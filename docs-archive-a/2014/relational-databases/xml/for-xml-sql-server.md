---
title: FOR XML(SQL Server) | Microsoft 문서
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: conceptual
helpviewer_keywords:
- FOR XML clause, about FOR XML clause
- PATH FOR XML mode, construction
- EXPLICIT FOR XML mode
- RAW FOR XML mode
- retrieving XML data
- XML [SQL Server], FOR XML clause
- AUTO FOR XML mode
- XML [SQL Server], construction
ms.assetid: 2b6b5c61-c5bd-49d2-8c0c-b7cf15857906
author: rothja
ms.author: jroth
ms.openlocfilehash: 6fe55186e89020f57ae1eb078625d1cdce262864
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87743099"
---
# <a name="for-xml-sql-server"></a><span data-ttu-id="1cc1a-102">FOR XML(SQL Server)</span><span class="sxs-lookup"><span data-stu-id="1cc1a-102">FOR XML (SQL Server)</span></span>
  <span data-ttu-id="1cc1a-103">SELECT 쿼리는 결과를 행 집합으로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-103">A SELECT query returns results as a rowset.</span></span> <span data-ttu-id="1cc1a-104">선택적으로 쿼리에서 FOR XML 절을 지정하면 SQL 쿼리의 서식 결과를 XML로 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-104">You can optionally retrieve formal results of a SQL query as XML by specifying the FOR XML clause in the query.</span></span> <span data-ttu-id="1cc1a-105">FOR XML 절은 최상위 쿼리 및 하위 쿼리에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-105">The FOR XML clause can be used in top-level queries and in sub queries.</span></span> <span data-ttu-id="1cc1a-106">최상위 FOR XML 절은 SELECT 문에서만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-106">The top-level FOR XML clause can be used only in the SELECT statement.</span></span> <span data-ttu-id="1cc1a-107">하위 쿼리에서는 INSERT, UPDATE 및 DELETE 문에서 FOR XML을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-107">In sub queries, FOR XML can be used in the INSERT, UPDATE, and DELETE statements.</span></span> <span data-ttu-id="1cc1a-108">또한 대입 문에서도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-108">It can also be used in assignment statements.</span></span>  
  
 <span data-ttu-id="1cc1a-109">FOR XML 절에서 다음 모드 중 하나를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-109">In a FOR XML clause, you specify one of these modes:</span></span>  
  
-   <span data-ttu-id="1cc1a-110">RAW</span><span class="sxs-lookup"><span data-stu-id="1cc1a-110">RAW</span></span>  
  
-   <span data-ttu-id="1cc1a-111">AUTO</span><span class="sxs-lookup"><span data-stu-id="1cc1a-111">AUTO</span></span>  
  
-   <span data-ttu-id="1cc1a-112">EXPLICIT</span><span class="sxs-lookup"><span data-stu-id="1cc1a-112">EXPLICIT</span></span>  
  
-   <span data-ttu-id="1cc1a-113">PATH</span><span class="sxs-lookup"><span data-stu-id="1cc1a-113">PATH</span></span>  
  
 <span data-ttu-id="1cc1a-114">RAW 모드는 행 집합의 각 행마다 SELECT 문으로 반환되는 단일 \<row> 요소를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-114">The RAW mode generates a single \<row> element per row in the rowset that is returned by the SELECT statement.</span></span> <span data-ttu-id="1cc1a-115">중첩된 FOR XML 쿼리를 작성하여 XML 계층을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-115">You can generate XML hierarchy by writing nested FOR XML queries.</span></span>  
  
 <span data-ttu-id="1cc1a-116">AUTO 모드는 SELECT 문이 지정된 방식에 따른 추론 방식을 사용하여 결과 XML에서 중첩 구조를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-116">The AUTO mode generates nesting in the resulting XML by using heuristics based on the way the SELECT statement is specified.</span></span> <span data-ttu-id="1cc1a-117">생성된 XML의 셰이프는 최소한으로만 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-117">You have minimal control over the shape of the XML generated.</span></span> <span data-ttu-id="1cc1a-118">AUTO 모드 추론 방식으로 생성된 XML 셰이프와는 달리 XML 계층을 생성하도록 중첩된 FOR XML 쿼리를 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-118">The nested FOR XML queries can be written to generate XML hierarchy beyond the XML shape that is generated by AUTO mode heuristics.</span></span>  
  
 <span data-ttu-id="1cc1a-119">EXPLICIT 모드는 XML 셰이프에 대해 더 많은 제어 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-119">The EXPLICIT mode allows more control over the shape of the XML.</span></span> <span data-ttu-id="1cc1a-120">사용자는 XML 셰이프를 결정할 때 자신의 의지대로 특성과 요소를 혼합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-120">You can mix attributes and elements at will in deciding the shape of the XML.</span></span> <span data-ttu-id="1cc1a-121">이를 위해서는 쿼리 실행에 따라 생성되는 결과 행 집합에 대한 특정 서식이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-121">It requires a specific format for the resulting rowset that is generated because of query execution.</span></span> <span data-ttu-id="1cc1a-122">그런 다음 이 행 집합 서식이 XML 셰이프로 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-122">This rowset format is then mapped into XML shape.</span></span> <span data-ttu-id="1cc1a-123">EXPLICIT 모드의 장점은 특성 및 요소를 자신의 의지대로 혼합하고, 래퍼 및 중첩된 복합 속성을 만들고, 공백으로 구분된 값(예: 주문 ID 값 목록이 포함된 OrderID 특성)과 혼합된 내용을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-123">The power of EXPLICIT mode is to mix attributes and elements at will, create wrappers and nested complex properties, create space-separated values (for example, OrderID attribute may have a list of order ID values), and mixed contents.</span></span>  
  
 <span data-ttu-id="1cc1a-124">하지만 EXPLICIT 모드 쿼리 작성은 복잡할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-124">However, writing EXPLICIT mode queries can be cumbersome.</span></span> <span data-ttu-id="1cc1a-125">중첩된 FOR XML RAW/AUTO/PATH 모드 쿼리 및 TYPE 지시어를 작성하여 EXPLICIT 모드를 사용하는 대신 새로운 FOR XML 기능 중 일부를 사용하여 계층을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-125">You can use some of the new FOR XML capabilities, such as writing nested FOR XML RAW/AUTO/PATH mode queries and the TYPE directive, instead of using EXPLICIT mode to generate the hierarchies.</span></span> <span data-ttu-id="1cc1a-126">중첩된 FOR XML 쿼리는 EXPLICIT 모드를 사용하여 생성할 수 있는 모든 XML을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-126">The nested FOR XML queries can produce any XML that you can generate by using the EXPLICIT mode.</span></span> <span data-ttu-id="1cc1a-127">자세한 내용은 [중첩 FOR XML 쿼리 사용](use-nested-for-xml-queries.md) 및 [FOR XML 쿼리의 TYPE 지시어](type-directive-in-for-xml-queries.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-127">For more information, see [Use Nested FOR XML Queries](use-nested-for-xml-queries.md) and [TYPE Directive in FOR XML Queries](type-directive-in-for-xml-queries.md).</span></span>  
  
 <span data-ttu-id="1cc1a-128">중첩된 FOR XML 쿼리 기능이 함께 포함된 PATH 경로는 EXPLICIT 모드를 보다 간단한 방식으로 사용할 수 있는 유연성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-128">The PATH mode together with the nested FOR XML query capability provides the flexibility of the EXPLICIT mode in a simpler manner.</span></span>  
  
 <span data-ttu-id="1cc1a-129">이러한 모드는 실제로 모드가 설정된 해당 쿼리 실행만을 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-129">These modes are in effect only for the execution of the query for which they are set.</span></span> <span data-ttu-id="1cc1a-130">다른 후속 쿼리의 결과에는 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-130">They do not affect the results of any subsequent queries.</span></span>  
  
 <span data-ttu-id="1cc1a-131">FOR XML은 FOR BROWSE 절과 함께 사용하는 모든 선택에 대해서는 유효하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-131">FOR XML is not valid for any selection that is used with a FOR BROWSE clause.</span></span>  
  
## <a name="example"></a><span data-ttu-id="1cc1a-132">예제</span><span class="sxs-lookup"><span data-stu-id="1cc1a-132">Example</span></span>  
 <span data-ttu-id="1cc1a-133">다음 `SELECT` 문은 `Sales.Customer` 데이터베이스의 `Sales.SalesOrderHeader` 및 `AdventureWorks2012` 테이블에서 정보를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-133">The following `SELECT` statement retrieves information from the `Sales.Customer` and `Sales.SalesOrderHeader` tables in the `AdventureWorks2012` database.</span></span> <span data-ttu-id="1cc1a-134">다음 쿼리는 `AUTO` 절에 `FOR XML` 모드를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-134">This query specifies the `AUTO` mode in the `FOR XML` clause:</span></span>  
  
```  
USE AdventureWorks2012  
GO  
SELECT Cust.CustomerID,   
       OrderHeader.CustomerID,  
       OrderHeader.SalesOrderID,   
       OrderHeader.Status  
FROM Sales.Customer Cust   
INNER JOIN Sales.SalesOrderHeader OrderHeader  
ON Cust.CustomerID = OrderHeader.CustomerID  
FOR XML AUTO  
```  
  
## <a name="the-for-xml-clause-and-server-names"></a><span data-ttu-id="1cc1a-135">FOR XML 절 및 서버 이름</span><span class="sxs-lookup"><span data-stu-id="1cc1a-135">The FOR XML Clause and Server Names</span></span>  
 <span data-ttu-id="1cc1a-136">FOR XML 절이 있는 SELECT 명령문이 쿼리에서 네 부분으로 된 이름을 지정할 경우, 로컬 컴퓨터에서 쿼리를 실행하면 서버 이름이 결과 XML 문서에 반환되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-136">When a SELECT statement with a FOR XML clause specifies a four-part name in the query, the server name is not returned in the resulting XML document when the query is executed on the local computer.</span></span> <span data-ttu-id="1cc1a-137">그러나 쿼리를 네트워크 서버에서 실행하면 서버 이름은 네 부분으로 된 이름으로 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-137">However, the server name is returned as the four-part name when the query is executed on a network server.</span></span>  
  
 <span data-ttu-id="1cc1a-138">예를 들어 다음과 같은 쿼리를 고려할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-138">For example, consider this query:</span></span>  
  
```  
SELECT TOP 1 LastName  
FROM ServerName.AdventureWorks2012.Person.Person  
FOR XML AUTO  
```  
  
 <span data-ttu-id="1cc1a-139">`ServerName` 이 로컬 서버면 쿼리는 다음을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-139">When `ServerName` is a local server, the query returns the following:</span></span>  
  
```  
<AdventureWorks2012.Person.Person LastName="Achong" />  
```  
  
 <span data-ttu-id="1cc1a-140">`ServerName` 이 네트워크 서버면 쿼리는 다음을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-140">When `ServerName` is a network server, the query returns the following:</span></span>  
  
```  
<ServerName.AdventureWorks2012.Person.Person LastName="Achong" />  
```  
  
 <span data-ttu-id="1cc1a-141">다음과 같이 별칭을 지정하면 이러한 잠재적 모호성을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-141">This potential ambiguity can be avoided by specifying this alias:</span></span>  
  
```  
SELECT TOP 1 LastName  
FROM ServerName.AdventureWorks2012.Person.Person x  
FOR XML AUTO   
```  
  
 <span data-ttu-id="1cc1a-142">이 쿼리는 다음과 같은 결과를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1cc1a-142">This query returns the following:</span></span>  
  
```  
<x LastName="Achong"/>  
```  
  
## <a name="see-also"></a><span data-ttu-id="1cc1a-143">참고 항목</span><span class="sxs-lookup"><span data-stu-id="1cc1a-143">See Also</span></span>  
 <span data-ttu-id="1cc1a-144">[FOR XML 절의 기본 구문](basic-syntax-of-the-for-xml-clause.md) </span><span class="sxs-lookup"><span data-stu-id="1cc1a-144">[Basic Syntax of the FOR XML Clause](basic-syntax-of-the-for-xml-clause.md) </span></span>  
 <span data-ttu-id="1cc1a-145">[FOR XML에서 RAW 모드 사용](use-raw-mode-with-for-xml.md) </span><span class="sxs-lookup"><span data-stu-id="1cc1a-145">[Use RAW Mode with FOR XML](use-raw-mode-with-for-xml.md) </span></span>  
 <span data-ttu-id="1cc1a-146">[FOR XML에서 AUTO 모드 사용](use-auto-mode-with-for-xml.md) </span><span class="sxs-lookup"><span data-stu-id="1cc1a-146">[Use AUTO Mode with FOR XML](use-auto-mode-with-for-xml.md) </span></span>  
 <span data-ttu-id="1cc1a-147">[FOR XML에서 EXPLICIT 모드 사용](use-explicit-mode-with-for-xml.md) </span><span class="sxs-lookup"><span data-stu-id="1cc1a-147">[Use EXPLICIT Mode with FOR XML](use-explicit-mode-with-for-xml.md) </span></span>  
 <span data-ttu-id="1cc1a-148">[FOR XML에서 PATH 모드 사용](use-path-mode-with-for-xml.md) </span><span class="sxs-lookup"><span data-stu-id="1cc1a-148">[Use PATH Mode with FOR XML](use-path-mode-with-for-xml.md) </span></span>  
 <span data-ttu-id="1cc1a-149">[OPENXML &#40;SQL Server&#41;](openxml-sql-server.md) </span><span class="sxs-lookup"><span data-stu-id="1cc1a-149">[OPENXML &#40;SQL Server&#41;](openxml-sql-server.md) </span></span>  
 [<span data-ttu-id="1cc1a-150">WITH XMLNAMESPACES를 사용하여 쿼리에 네임스페이스 추가</span><span class="sxs-lookup"><span data-stu-id="1cc1a-150">Add Namespaces to Queries with WITH XMLNAMESPACES</span></span>](add-namespaces-to-queries-with-with-xmlnamespaces.md)  
  
  
