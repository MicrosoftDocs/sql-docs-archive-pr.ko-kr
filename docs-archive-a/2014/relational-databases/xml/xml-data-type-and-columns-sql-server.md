---
title: XML 데이터 형식 및 열(SQL Server) | Microsoft 문서
ms.custom: ''
ms.date: 06/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: conceptual
ms.assetid: 00db8f21-7d4b-4347-ae43-3a7c314d2fa1
author: rothja
ms.author: jroth
ms.openlocfilehash: 575f8b8fc640ea5ff671a6b0cef4208e7447898f
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87741648"
---
# <a name="xml-data-type-and-columns-sql-server"></a><span data-ttu-id="232c9-102">XML 데이터 형식 및 열(SQL Server)</span><span class="sxs-lookup"><span data-stu-id="232c9-102">XML Data Type and Columns (SQL Server)</span></span>
  <span data-ttu-id="232c9-103">이 항목에서는의 데이터 형식에 대 한 장점과 제한 사항을 설명 하 `xml` [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 고 XML 데이터를 저장 하는 방법을 선택 하는 데 도움을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-103">This topic discusses the advantages and the limitations of the `xml` data type in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], and helps you to choose how to store XML data.</span></span>  
  
## <a name="relational-or-xml-data-model"></a><span data-ttu-id="232c9-104">관계형 데이터 모델 또는 XML 데이터 모델</span><span class="sxs-lookup"><span data-stu-id="232c9-104">Relational or XML Data Model</span></span>  
 <span data-ttu-id="232c9-105">데이터가 알려진 스키마로 복잡하게 구조화된 경우 관계형 모델이 데이터 스토리지에 가장 적합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-105">If your data is highly structured with known schema, the relational model is likely to work best for data storage.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="232c9-106">는 사용자에게 필요한 기능 및 도구를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-106">provides the required functionality and tools you may need.</span></span> <span data-ttu-id="232c9-107">반면에 반구조화되어 있거나 구조화되지 않았거나 구조화 상태를 알 수 없는 경우에는 이러한 데이터의 모델링을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-107">On the other hand, if the structure is semi-structured or unstructured, or unknown, you have to give consideration to modeling such data.</span></span>  
  
 <span data-ttu-id="232c9-108">구조적 및 의미적 태그를 사용하여 데이터의 이동성을 보장하기 위해 플랫폼 독립적인 모델이 필요한 경우에는 XML이 좋은 대안입니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-108">XML is a good choice if you want a platform-independent model in order to ensure portability of the data by using structural and semantic markup.</span></span> <span data-ttu-id="232c9-109">또한 XML은 다음과 같은 상황에서도 적절한 대안이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-109">Additionally, it is an appropriate option if some of the following properties are satisfied:</span></span>  
  
-   <span data-ttu-id="232c9-110">데이터가 산발적이거나 데이터 구조를 알 수 없거나 데이터 구조가 이후에 크게 변경될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-110">Your data is sparse or you do not know the structure of the data, or the structure of your data may change significantly in the future.</span></span>  
  
-   <span data-ttu-id="232c9-111">데이터가 엔터티 간 참조 대신 포함 계층을 나타내며 재귀적일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-111">Your data represents containment hierarchy, instead of references among entities, and may be recursive.</span></span>  
  
-   <span data-ttu-id="232c9-112">데이터에 정렬이 내재되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-112">Order is inherent in your data.</span></span>  
  
-   <span data-ttu-id="232c9-113">데이터 구조를 기반으로 데이터를 쿼리하거나 데이터 일부를 업데이트하고자 합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-113">You want to query into the data or update parts of it, based on its structure.</span></span>  
  
 <span data-ttu-id="232c9-114">이러한 상황에 하나도 해당되지 않으면 관계형 데이터 모델을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-114">If none of these conditions is met, you should use the relational data model.</span></span> <span data-ttu-id="232c9-115">예를 들어 데이터가 XML 형식으로 되어 있지만 애플리케이션에서 데이터의 저장 및 검색을 위해서만 데이터베이스를 사용하는 경우에는 `[n]varchar(max)` 열만 있으면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-115">For example, if your data is in XML format but your application just uses the database to store and retrieve the data, an `[n]varchar(max)` column is all you require.</span></span> <span data-ttu-id="232c9-116">XML 열에 데이터를 저장하면 추가 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-116">Storing the data in an XML column has additional benefits.</span></span> <span data-ttu-id="232c9-117">이러한 이점에 대한 예로, 엔진에서 데이터가 잘 작성되었거나 유효한지 여부를 확인할 수 있으며, XML 데이터의 세부적 쿼리 및 업데이트가 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-117">This includes having the engine determine that the data is well formed or valid, and also includes support for fine-grained query and updates into the XML data.</span></span>  
  
## <a name="reasons-for-storing-xml-data-in-sql-server"></a><span data-ttu-id="232c9-118">SQL Server에서 XML 데이터를 저장하는 이유</span><span class="sxs-lookup"><span data-stu-id="232c9-118">Reasons for Storing XML Data in SQL Server</span></span>  
 <span data-ttu-id="232c9-119">다음은 파일 시스템에서 XML 데이터를 관리하는 대신 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 에서 네이티브 XML 기능을 사용하는 몇 가지 이유입니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-119">Following are some of the reasons to use native XML features in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] instead of managing your XML data in the file system:</span></span>  
  
-   <span data-ttu-id="232c9-120">효율적이고 실용적인 방식으로 XML 데이터를 공유, 쿼리 및 수정하고자 합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-120">You want to share, query, and modify your XML data in an efficient and transacted way.</span></span> <span data-ttu-id="232c9-121">세부적 데이터 액세스는 애플리케이션에 중요한 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-121">Fine-grained data access is important to your application.</span></span> <span data-ttu-id="232c9-122">예를 들어 XML 문서 내에서 일부 섹션을 추출하거나 전체 문서를 바꾸지 않고 새 섹션을 삽입합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-122">For example, you may want to extract some of the sections within an XML document, or you may want to insert a new section without replacing your whole document.</span></span>  
  
-   <span data-ttu-id="232c9-123">관계형 데이터 및 XML 데이터가 있고 애플리케이션 내에서 관계형 데이터 및 XML 데이터 사이의 호환성이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-123">You have relational data and XML data and you want interoperability between both relational and XML data within your application.</span></span>  
  
-   <span data-ttu-id="232c9-124">도메인 간 애플리케이션에서 쿼리 및 데이터 수정을 위한 언어 지원이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-124">You need language support for query and data modification for cross-domain applications.</span></span>  
  
-   <span data-ttu-id="232c9-125">서버의 데이터가 잘 작성되도록 보장하고 선택적으로 XML 스키마에 따라 데이터의 유효성을 검사고자 합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-125">You want the server to guarantee that the data is well formed and also optionally validate your data according to XML schemas.</span></span>  
  
-   <span data-ttu-id="232c9-126">효율적인 쿼리 처리 및 확장성을 위해 XML 데이터를 인덱싱하고 최상의 쿼리 최적화 프로그램을 사용하고자 합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-126">You want indexing of XML data for efficient query processing and good scalability, and the use of a first-rate query optimizer.</span></span>  
  
-   <span data-ttu-id="232c9-127">XML 데이터에 대한 SOAP, ADO.NET 및 OLE DB 액세스가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-127">You want SOAP, ADO.NET, and OLE DB access to XML data.</span></span>  
  
-   <span data-ttu-id="232c9-128">XML 데이터 관리를 위해 데이터베이스 서버의 관리 기능을 사용하고자 합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-128">You want to use administrative functionality of the database server for managing your XML data.</span></span> <span data-ttu-id="232c9-129">예를 들어 이러한 기능에는 백업, 복구 및 복제가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-129">For example, this would be backup, recovery, and replication.</span></span>  
  
 <span data-ttu-id="232c9-130">이러한 상황에 하나도 해당되지 않으면 `[n]varchar(max)` 또는 `varbinary(max)`와 같은 비-XML의 큰 개체 형식으로 데이터를 저장하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-130">If none of these conditions is satisfied, it may be better to store your data as a non-XML, large object type, such as `[n]varchar(max)` or `varbinary(max)`.</span></span>  
  
## <a name="xml-storage-options"></a><span data-ttu-id="232c9-131">XML 스토리지 옵션</span><span class="sxs-lookup"><span data-stu-id="232c9-131">XML Storage Options</span></span>  
 <span data-ttu-id="232c9-132">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 의 XML 스토리지 옵션에는 다음이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-132">The storage options for XML in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] include the following:</span></span>  
  
-   <span data-ttu-id="232c9-133">`xml` 데이터 형식의 네이티브 스토리지</span><span class="sxs-lookup"><span data-stu-id="232c9-133">Native storage as `xml` data type</span></span>  
  
     <span data-ttu-id="232c9-134">데이터의 XML 내용을 보존하는 내부 표현으로 데이터가 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-134">The data is stored in an internal representation that preserves the XML content of the data.</span></span> <span data-ttu-id="232c9-135">이러한 내부 표현에는 포함 계층, 문서 순서, 요소 및 특성 값에 대한 정보가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-135">This internal representation includes information about the containment hierarchy, document order, and element and attribute values.</span></span> <span data-ttu-id="232c9-136">특히 XML 데이터의 InfoSet 내용이 보존됩니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-136">Specifically, the InfoSet content of the XML data is preserved.</span></span> <span data-ttu-id="232c9-137">InfoSet에 대한 자세한 내용을 보려면 [http://www.w3.org/TR/xml-infoset](https://go.microsoft.com/fwlink/?LinkId=48843)를 방문하세요.</span><span class="sxs-lookup"><span data-stu-id="232c9-137">For more information about InfoSet, visit [http://www.w3.org/TR/xml-infoset](https://go.microsoft.com/fwlink/?LinkId=48843).</span></span> <span data-ttu-id="232c9-138">InfoSet 내용은 다음 정보가 포함되지 않기 때문에 테스트 XML의 동일 복사본이 될 수 없습니다. 제외되는 정보는 중요하지 않은 공백, 특성 순서, 네임스페이스 접두사 및 XML 선언입니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-138">The InfoSet content may not be an identical copy of the text XML, because the following information is not retained: insignificant white spaces, order of attributes, namespace prefixes, and XML declaration.</span></span>  
  
     <span data-ttu-id="232c9-139">`xml`XML 스키마에 바인딩된 데이터 형식인 형식화 된 데이터 형식의 경우 `xml` PSVI (사후 스키마 유효성 검사 infoset)는 InfoSet에 유형 정보를 추가 하 고 내부 표현으로 인코딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-139">For typed `xml` data type, an `xml` data type bound to XML schemas, the post-schema validation InfoSet (PSVI) adds type information to the InfoSet and is encoded in the internal representation.</span></span> <span data-ttu-id="232c9-140">이렇게 하면 구문 분석 속도가 크게 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-140">This improves parsing speed significantly.</span></span> <span data-ttu-id="232c9-141">자세한 내용은 [http://www.w3.org/TR/xmlschema-1](https://go.microsoft.com/fwlink/?LinkId=48881) 및 [http://www.w3.org/TR/xmlschema-2](https://go.microsoft.com/fwlink/?LinkId=4871)에 있는 W3C XML 스키마 사양을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="232c9-141">For more information, see the W3C XML Schema specifications at [http://www.w3.org/TR/xmlschema-1](https://go.microsoft.com/fwlink/?LinkId=48881) and [http://www.w3.org/TR/xmlschema-2](https://go.microsoft.com/fwlink/?LinkId=4871).</span></span>  
  
-   <span data-ttu-id="232c9-142">XML 및 관계형 스토리지 간 매핑</span><span class="sxs-lookup"><span data-stu-id="232c9-142">Mapping between XML and relational storage</span></span>  
  
     <span data-ttu-id="232c9-143">XML은 AXSD(주석 지정 스키마)를 사용하여 하나 이상의 테이블에 있는 열로 분해됩니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-143">By using an annotated schema (AXSD), the XML is decomposed into columns in one or more tables.</span></span> <span data-ttu-id="232c9-144">이렇게 하면 관계형 수준에서 데이터의 정확성이 보존됩니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-144">This preserves fidelity of the data at the relational level.</span></span> <span data-ttu-id="232c9-145">그 결과 요소 간 순서가 무시되더라도 계층적 구조가 보존됩니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-145">As a result, the hierarchical structure is preserved although order among elements is ignored.</span></span> <span data-ttu-id="232c9-146">스키마는 재귀적일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-146">The schema cannot be recursive.</span></span>  
  
-   <span data-ttu-id="232c9-147">큰 개체 스토리지 `[n]varchar(max)` 및 `varbinary(max)`</span><span class="sxs-lookup"><span data-stu-id="232c9-147">Large object storage, `[n]varchar(max)` and `varbinary(max)`</span></span>  
  
     <span data-ttu-id="232c9-148">데이터의 동일 복사본이 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-148">An identical copy of the data is stored.</span></span> <span data-ttu-id="232c9-149">이 옵션은 법률 문서와 같은 특수한 용도의 애플리케이션에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-149">This is useful for special-purpose applications such as legal documents.</span></span> <span data-ttu-id="232c9-150">대부분의 애플리케이션에는 정확한 복사본이 필요하지 않으며 XML 내용만으로도 충분합니다(InfoSet 정확성).</span><span class="sxs-lookup"><span data-stu-id="232c9-150">Most applications do not require an exact copy and are satisfied with the XML content (InfoSet fidelity).</span></span>  
  
 <span data-ttu-id="232c9-151">일반적으로 이러한 접근 방식을 조합해서 사용해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-151">Generally, you may have to use a combination of these approaches.</span></span> <span data-ttu-id="232c9-152">예를 들어 `xml` 데이터 형식의 열에 XML 데이터를 저장하고 XML 열에서 관계형 열로 속성을 승격해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-152">For example, you may want to store your XML data in an `xml` data type column and promote properties from it into relational columns.</span></span> <span data-ttu-id="232c9-153">또는 매핑 기술을 사용 하 여 비 XML 열에 비재귀 부분을 저장 하 고 데이터 형식 열의 재귀 부분만 저장할 수 있습니다 `xml` .</span><span class="sxs-lookup"><span data-stu-id="232c9-153">Or, you may want to use mapping technology to store nonrecursive parts in non-XML columns and only the recursive parts in `xml` data type columns.</span></span>  
  
### <a name="choice-of-xml-technology"></a><span data-ttu-id="232c9-154">XML 기술 선택</span><span class="sxs-lookup"><span data-stu-id="232c9-154">Choice of XML Technology</span></span>  
 <span data-ttu-id="232c9-155">네이티브 XML과 XML 뷰 간의 XML 기술 선택은 일반적으로 다음 요소에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-155">The choice of XML technology, native XML versus XML view, generally depends upon the following factors:</span></span>  
  
-   <span data-ttu-id="232c9-156">스토리지 옵션</span><span class="sxs-lookup"><span data-stu-id="232c9-156">Storage options</span></span>  
  
     <span data-ttu-id="232c9-157">XML 데이터는 큰 개체 스토리지에 적합하거나(예: 제품 설명서) 관계형 열에 있는 스토리지에 더 적합할 수 있습니다(예: XML로 변환된 라인 항목).</span><span class="sxs-lookup"><span data-stu-id="232c9-157">Your XML data may be more appropriate for large object storage (for example, a product manual), or more amenable to storage in relational columns (for example, a line item converted to XML).</span></span> <span data-ttu-id="232c9-158">각 스토리지 옵션은 서로 다른 수준의 문서 정확성을 보존합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-158">Each storage option preserves document fidelity to a different extent.</span></span>  
  
-   <span data-ttu-id="232c9-159">쿼리 기능</span><span class="sxs-lookup"><span data-stu-id="232c9-159">Query capabilities</span></span>  
  
     <span data-ttu-id="232c9-160">쿼리의 특성과 XML 데이터를 쿼리하는 정도에 따라 적합한 스토리지 옵션을 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-160">You may find one storage option more appropriate than another, based on the nature of your queries and on the extent to which you query your XML data.</span></span> <span data-ttu-id="232c9-161">XML 노드에 대한 조건자 평가와 같은 세부적인 XML 데이터 쿼리는 두 개의 스토리지 옵션에서 서로 다르게 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-161">Fine-grained query of your XML data, for example, predicate evaluation on XML nodes, is supported to varying degrees in the two storage options.</span></span>  
  
-   <span data-ttu-id="232c9-162">XML 데이터 인덱싱</span><span class="sxs-lookup"><span data-stu-id="232c9-162">Indexing XML data</span></span>  
  
     <span data-ttu-id="232c9-163">XML 쿼리 성능의 속도를 높이기 위해 XML 데이터를 인덱싱할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-163">You may want to index the XML data to speed up XML query performance.</span></span> <span data-ttu-id="232c9-164">인덱싱 옵션은 스토리지 옵션별로 다르므로 작업을 최적화할 수 있는 적합한 옵션을 선택해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-164">Indexing options vary with the storage options; you have to make the appropriate choice to optimize your workload.</span></span>  
  
-   <span data-ttu-id="232c9-165">데이터 수정 기능</span><span class="sxs-lookup"><span data-stu-id="232c9-165">Data modification capabilities</span></span>  
  
     <span data-ttu-id="232c9-166">일부 작업에는 XML 데이터에 대한 세부적인 수정 작업이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-166">Some workloads involve fine-grained modification of XML data.</span></span> <span data-ttu-id="232c9-167">예를 들어 특정 작업에는 문서 내의 새 섹션 추가 작업이 포함되지만 웹 콘텐츠와 같은 다른 작업에는 이러한 작업이 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-167">For example, this can include adding a new section within a document, while other workloads, such as Web content, do not.</span></span> <span data-ttu-id="232c9-168">데이터 수정 언어 지원은 애플리케이션에 있어서 중요한 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-168">Data modification language support may be important for your application.</span></span>  
  
-   <span data-ttu-id="232c9-169">스키마 지원</span><span class="sxs-lookup"><span data-stu-id="232c9-169">Schema support</span></span>  
  
     <span data-ttu-id="232c9-170">XML 데이터를 스키마에 의해 기술할 수 있으며 이러한 스키마는 XML 스키마 문서일 수도 혹은 아닐 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-170">Your XML data may be described by a schema that may or may not be an XML schema document.</span></span> <span data-ttu-id="232c9-171">스키마 바인딩 XML 지원은 XML 기술에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-171">The support for schema-bound XML depends upon the XML technology.</span></span>  
  
 <span data-ttu-id="232c9-172">선택한 옵션에 따라 성능 특성이 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-172">Different choices also have different performance characteristics.</span></span>  
  
### <a name="native-xml-storage"></a><span data-ttu-id="232c9-173">네이티브 XML 스토리지</span><span class="sxs-lookup"><span data-stu-id="232c9-173">Native XML Storage</span></span>  
 <span data-ttu-id="232c9-174">서버에서 `xml` 데이터 형식의 열에 XML 데이터를 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-174">You can store your XML data in an `xml` data type column at the server.</span></span> <span data-ttu-id="232c9-175">이 옵션은 다음과 같은 상황에서 적절한 대안이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-175">This is an appropriate choice if the following applies:</span></span>  
  
-   <span data-ttu-id="232c9-176">서버에 XML 데이터를 저장하고 동시에 문서 순서 및 문서 구조를 보존할 수 있는 직관적인 방식이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-176">You want a straightforward way to store your XML data at the server and, at the same time, preserve document order and document structure.</span></span>  
  
-   <span data-ttu-id="232c9-177">XML 데이터에 대한 스키마가 있거나 없습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-177">You may or may not have a schema for your XML data.</span></span>  
  
-   <span data-ttu-id="232c9-178">XML 데이터를 쿼리하고 수정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-178">You want to query and modify your XML data.</span></span>  
  
-   <span data-ttu-id="232c9-179">신속한 쿼리 처리를 위해 XML 데이터를 인덱싱해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-179">You want to index the XML data for faster query processing.</span></span>  
  
-   <span data-ttu-id="232c9-180">XML 데이터 및 XML 스키마를 관리하려면 애플리케이션에 시스템 카탈로그 뷰가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-180">Your application needs system catalog views to administer your XML data and XML schemas.</span></span>  
  
 <span data-ttu-id="232c9-181">네이티브 XML 스토리지는 구조 범위가 포함된 XML 문서가 있거나 관계형 구조로 매핑하기 어려운 여러 스키마 또는 복잡한 스키마에 해당하는 XML 문서가 있는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-181">Native XML storage is useful when you have XML documents that have a range of structures, or you have XML documents that conform to different or complex schemas that are too hard to map to relational structures.</span></span>  
  
#### <a name="example-modeling-xml-data-using-the-xml-data-type"></a><span data-ttu-id="232c9-182">예제: XML 데이터 형식을 사용하여 XML 데이터 모델링</span><span class="sxs-lookup"><span data-stu-id="232c9-182">Example: Modeling XML Data Using the xml Data Type</span></span>  
 <span data-ttu-id="232c9-183">각 항목에 대한 별도의 장으로 구성되어 있고 각 장 내에 여러 섹션이 포함된 XML 형식의 제품 설명서를 가정해 보십시오.</span><span class="sxs-lookup"><span data-stu-id="232c9-183">Consider a product manual in XML format that is made up of a separate chapter for each topic and that has multiple sections within each chapter.</span></span> <span data-ttu-id="232c9-184">하나의 섹션에는 하위 섹션이 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-184">A section can contain subsections.</span></span> <span data-ttu-id="232c9-185">따라서 \<section>은 재귀적 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-185">As a result, \<section> is a recursive element.</span></span> <span data-ttu-id="232c9-186">제품 설명서에는 다량의 콘텐츠, 다이어그램 및 기술 자료가 혼합되어 있으며 데이터는 반구조적입니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-186">Product manuals contain a large amount of mixed content, diagrams, and technical material; the data is semi-structured.</span></span> <span data-ttu-id="232c9-187">사용자는 "인덱싱" 장에서 "클러스터형 인덱스" 섹션을 검색하는 것과 같이 원하는 항목을 문맥에 따라 검색하고 많은 기술 자료를 쿼리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-187">Users may want to perform a contextual search for topics of interest such as searching for the section on "clustered index" within the chapter on "indexing", and query technical quantities.</span></span>  
  
 <span data-ttu-id="232c9-188">XML 문서에 적합한 스토리지 모델은 `xml` 데이터 형식의 열입니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-188">An appropriate storage model for your XML documents is an `xml` data type column.</span></span> <span data-ttu-id="232c9-189">이 모델은 XML 데이터에 대한 InfoSet 내용을 보존합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-189">This preserves the InfoSet content of your XML data.</span></span> <span data-ttu-id="232c9-190">XML 열을 인덱싱하면 쿼리 성능이 높아집니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-190">Indexing the XML column benefits query performance.</span></span>  
  
#### <a name="example-retaining-exact-copies-of-xml-data"></a><span data-ttu-id="232c9-191">예제: XML 데이터에 대한 정확한 복사본 유지</span><span class="sxs-lookup"><span data-stu-id="232c9-191">Example: Retaining Exact Copies of XML Data</span></span>  
 <span data-ttu-id="232c9-192">이해를 돕기 위해 정부 규제에 따라 XML 문서에 대한 정확한 텍스트 복사본을 유지해야 한다고 가정해 보십시오.</span><span class="sxs-lookup"><span data-stu-id="232c9-192">For illustration, assume that government regulations require you to retain exact textual copies of your XML documents.</span></span> <span data-ttu-id="232c9-193">예를 들어 여기에는 서명된 문서, 법률 문서 또는 상품 거래 주문 내역 등이 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-193">For example, these could include signed documents, legal documents, or stock transaction orders.</span></span> <span data-ttu-id="232c9-194">문서를 `[n]varchar(max)` 열에 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-194">You may want to store your documents in a `[n]varchar(max)` column.</span></span>  
  
 <span data-ttu-id="232c9-195">쿼리를 위해서는 데이터를 런타임에 `xml` 데이터 형식으로 변환하고 여기에서 Xquery를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-195">For querying, convert the data to `xml` data type at run time and execute Xquery on it.</span></span> <span data-ttu-id="232c9-196">런타임 변환은 특히 문서가 큰 경우 비용이 많이 듭니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-196">The run-time conversion may be costly, especially when the document is large.</span></span> <span data-ttu-id="232c9-197">쿼리를 자주 수행하는 경우 `xml` 데이터 형식의 열에 문서를 중복해서 저장하고 `[n]varchar(max)` 열에서 정확한 문서 복사본을 반환하는 동안 이를 인덱싱할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-197">If you query frequently, you can redundantly store the documents in an `xml` data type column and index it while you return exact document copies from the `[n]varchar(max)` column.</span></span>  
  
 <span data-ttu-id="232c9-198">XML 열은 `[n]varchar(max)` 열을 기반으로 계산을 수행하는 계산 열일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-198">The XML column may be a computed column, based on the `[n]varchar(max)` column.</span></span> <span data-ttu-id="232c9-199">그러나 계산 된 XML 열에는 XML 인덱스를 만들 수 없으며 또는 열을 기반으로 XML 인덱스를 작성할 수도 `[n]varchar(max)` 없습니다 `varbinary(max)` .</span><span class="sxs-lookup"><span data-stu-id="232c9-199">However, you cannot create an XML index on a computed, XML column, nor can an XML index be built on `[n]varchar(max)` or `varbinary(max)` columns.</span></span>  
  
### <a name="xml-view-technology"></a><span data-ttu-id="232c9-200">XML 뷰 기술</span><span class="sxs-lookup"><span data-stu-id="232c9-200">XML View Technology</span></span>  
 <span data-ttu-id="232c9-201">데이터베이스에 있는 테이블과 XML 스키마 간의 매핑을 정의하면 영구적 데이터에 대한 "XML 뷰"를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-201">By defining a mapping between your XML schemas and the tables in a database, you create an "XML view" of your persistent data.</span></span> <span data-ttu-id="232c9-202">XML 대량 로드를 사용하면 XML 뷰를 사용하여 기본 테이블을 채울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-202">XML bulk load can be used to populate the underlying tables by using the XML view.</span></span> <span data-ttu-id="232c9-203">XML 뷰는 XPath 버전 1.0을 사용하여 쿼리할 수 있으며, 이 쿼리는 테이블에서 SQL 쿼리로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-203">You can query the XML view by using XPath version 1.0; the query is translated to SQL queries on the tables.</span></span> <span data-ttu-id="232c9-204">이와 마찬가지로 이들 테이블에 업데이트를 전파할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-204">Similarly, updates are also propagated to those tables.</span></span>  
  
 <span data-ttu-id="232c9-205">이 기술은 다음과 같은 경우 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-205">This technology is useful in the following situations:</span></span>  
  
-   <span data-ttu-id="232c9-206">기존 관계형 데이터에 대해 XML 뷰를 사용하는 XML 중심 프로그래밍 모델을 갖고자 합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-206">You want to have an XML-centric programming model using XML views over your existing relational data.</span></span>  
  
-   <span data-ttu-id="232c9-207">외부 파트너가 제공한 XML 데이터에 대한 스키마(XSD, XDR)가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-207">You have a schema (XSD, XDR) for your XML data that an external partner may have provided.</span></span>  
  
-   <span data-ttu-id="232c9-208">데이터에서 순서가 중요하지 않거나, 쿼리 테이블 데이터가 재귀적이지 않거나, 최대 재귀 깊이가 미리 알려져 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-208">Order is not important in your data, or your query table data is not recursive, or the maximal recursion depth is known in advance.</span></span>  
  
-   <span data-ttu-id="232c9-209">XPath 버전 1.0을 사용하여 XML 뷰를 통해 데이터를 쿼리 및 수정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-209">You want to query and modify the data through the XML view by using XPath version 1.0.</span></span>  
  
-   <span data-ttu-id="232c9-210">XML 데이터를 대량 로드하고 XML 뷰를 사용하여 기본 테이블로 분해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-210">You want to bulk load XML data and decompose them into the underlying tables by using the XML view.</span></span>  
  
 <span data-ttu-id="232c9-211">이러한 예로는 데이터 교환 및 웹 서비스에 대해 XML로 제공된 관계형 데이터와 고정 스키마가 포함된 XML 데이터가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-211">Examples include relational data exposed as XML for data exchange and Web services, and XML data with fixed schema.</span></span> <span data-ttu-id="232c9-212">자세한 내용은 [MSDN Online Library](https://go.microsoft.com/fwlink/?linkid=31174)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="232c9-212">For more information, see the [MSDN Online Library](https://go.microsoft.com/fwlink/?linkid=31174).</span></span>  
  
#### <a name="example-modeling-data-using-an-annotated-xml-schema-axsd"></a><span data-ttu-id="232c9-213">예제: AXSD(주석 지정 XML 스키마)를 사용하여 데이터 모델링</span><span class="sxs-lookup"><span data-stu-id="232c9-213">Example: Modeling Data Using an Annotated XML Schema (AXSD)</span></span>  
 <span data-ttu-id="232c9-214">이해를 돕기 위해 고객, 주문 및 라인 항목 등과 같은 기존 관계형 데이터가 있고 이를 XML로 처리하려는 경우를 가정해 보십시오.</span><span class="sxs-lookup"><span data-stu-id="232c9-214">For illustration, assume that you have existing relational data, such as customers, orders, and line items, that you want to handle as XML.</span></span> <span data-ttu-id="232c9-215">관계형 데이터에 대해 AXSD를 사용하여 XML 뷰를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-215">Define an XML view by using AXSD over the relational data.</span></span> <span data-ttu-id="232c9-216">XML 뷰를 사용하면 XML 데이터를 테이블에 대량 로드하고 XML 뷰를 사용하여 관계형 데이터를 쿼리 및 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-216">The XML view allows you to bulk load XML data into your tables and query and update the relational data by using the XML view.</span></span> <span data-ttu-id="232c9-217">이 모델은 XML 태그가 포함된 데이터를 다른 애플리케이션과 교환하고 SQL 애플리케이션을 방해 받지 않고 실행해야 하는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-217">This model is useful if you have to exchange data that contains XML markup with other applications while your SQL applications work uninterrupted.</span></span>  
  
### <a name="hybrid-model"></a><span data-ttu-id="232c9-218">하이브리드 모델</span><span class="sxs-lookup"><span data-stu-id="232c9-218">Hybrid Model</span></span>  
 <span data-ttu-id="232c9-219">관계형 및 `xml` 데이터 형식 열의 조합이 데이터 모델링에 적합 한 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-219">Frequently, a combination of relational and `xml` data type columns is appropriate for data modeling.</span></span> <span data-ttu-id="232c9-220">XML 데이터의 일부 값은 관계형 열에 저장하고 나머지 값이나 전체 XML 값은 XML 열에 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-220">Some of the values from your XML data can be stored in relational columns, and the rest, or the whole XML value stored in an XML column.</span></span> <span data-ttu-id="232c9-221">이렇게 하면 관계형 열에서 만든 인덱스와 잠금 특성을 더욱 자세히 제어할 수 있다는 점에서 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-221">This may yield better performance in that you have more control over the indexes created on the relational columns and locking characteristics.</span></span>  
  
 <span data-ttu-id="232c9-222">관계형 열에 저장하는 값은 작업에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-222">The values to store in relational columns depend on your workload.</span></span> <span data-ttu-id="232c9-223">예를 들어 경로 식 /Customer/@CustId에 따라 모든 XML 값을 검색하는 경우 **CustId** 특성의 값을 관계형 열로 승격하고 이를 인덱싱하면 쿼리 속도가 빨라집니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-223">For example, if you retrieve all the XML values based on the path expression, /Customer/@CustId, promoting the value of the **CustId** attribute into a relational column and indexing it may yield faster query performance.</span></span> <span data-ttu-id="232c9-224">반면에 XML 데이터가 관계형 열로 포괄적으로 중복되지 않게 분해된 경우 리어셈블리 비용이 상당히 높을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-224">On the other hand, if your XML data is extensively and nonredundantly decomposed into relational columns, the re-assembly cost may be significant.</span></span>  
  
 <span data-ttu-id="232c9-225">예를 들어 구조화 수준이 높은 XML 데이터의 경우 테이블의 내용이 XML로 변환되어 모든 값을 관계형 열로 매핑하고 XML 뷰 기술을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-225">For highly structured XML data, for example, the content of a table has been converted into XML; you can map all values to relational columns, and possibly use XML view technology.</span></span>  
  
## <a name="granularity-of-xml-data"></a><span data-ttu-id="232c9-226">XML 데이터의 세분성</span><span class="sxs-lookup"><span data-stu-id="232c9-226">Granularity of XML Data</span></span>  
 <span data-ttu-id="232c9-227">XML 열에 저장된 XML 데이터의 세분성은 잠금에 있어서 매우 중요하며, 업데이트에 대해서도 역시 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-227">The granularity of the XML data stored in an XML column is very important for locking and, to a lesser degree, it is also important for updates.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="232c9-228">는 XML 및 비-XML 데이터에 대해서 모두 같은 잠금 메커니즘을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-228">uses the same locking mechanism for both XML and non-XML data.</span></span> <span data-ttu-id="232c9-229">따라서 행 수준의 잠금으로 인해 행에 있는 모든 XML 인스턴스가 잠깁니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-229">Therefore, row-level locking causes all XML instances in the row to be locked.</span></span> <span data-ttu-id="232c9-230">세분성이 큰 경우 업데이트를 위해 큰 XML 인스턴스를 잠그면 다중 사용자 환경에서 처리량이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-230">When the granularity is large, locking large XML instances for updates causes throughput to decline in a multiuser scenario.</span></span> <span data-ttu-id="232c9-231">반면에 심각한 분해 작업을 수행하면 개체 캡슐화가 손실되며 리어셈블리 비용이 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-231">On the other hand, severe decomposition loses object encapsulation and increases reassembly cost.</span></span>  
  
 <span data-ttu-id="232c9-232">데이터 모델링 요구 사항과 잠금 및 업데이트 특성 간의 균형은 훌륭한 디자인을 위해 중요한 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-232">A balance between data modeling requirements and locking and update characteristics is important for good design.</span></span> <span data-ttu-id="232c9-233">하지만 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]에서 실제 저장된 XML 인스턴스의 크기는 그렇게 중요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-233">However, in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], the size of actual stored XML instances is not as critical.</span></span>  
  
 <span data-ttu-id="232c9-234">예를 들어 XML 인스턴스에 대한 업데이트는 저장된 기존 XML 인스턴스가 해당 업데이트된 버전과 비교되는 부분적 BLOB(Binary Large Object) 업데이트와 부분적 인덱스 업데이트에 대한 새로운 지원을 사용하여 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-234">For example, updates to an XML instance are performed by using new support for partial binary large object (BLOB) and partial index updates in which the existing stored XML instance is compared to its updated version.</span></span> <span data-ttu-id="232c9-235">부분적 BLOB(Binary Large Object) 업데이트는 두 개의 XML 인스턴스 간의 차등 비교를 수행하고 다른 점만 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-235">Partial binary large object (BLOB) update performs a differential comparison between the two XML instances and updates only the differences.</span></span> <span data-ttu-id="232c9-236">부분적 인덱스 업데이트는 XML 인덱스에서 변경되어야 하는 행만 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-236">Partial index updates modify only those rows that must be changed in the XML index.</span></span>  
  
## <a name="limitations-of-the-xml-data-type"></a><span data-ttu-id="232c9-237">xml 데이터 형식의 제한 사항</span><span class="sxs-lookup"><span data-stu-id="232c9-237">Limitations of the xml Data Type</span></span>  
 <span data-ttu-id="232c9-238">다음의 일반적인 제한 사항이 `xml` 데이터 형식에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-238">Note the following general limitations that apply to the `xml` data type:</span></span>  
  
-   <span data-ttu-id="232c9-239">저장된 `xml` 데이터 형식 인스턴스의 표현은 2GB를 초과할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-239">The stored representation of `xml` data type instances cannot exceed 2 GB.</span></span>  
  
-   <span data-ttu-id="232c9-240">**sql_variant** 인스턴스의 하위 유형으로 사용될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-240">It cannot be used as a subtype of a **sql_variant** instance.</span></span>  
  
-   <span data-ttu-id="232c9-241">`text` 또는 `ntext`로의 캐스트 또는 변환을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-241">It does not support casting or converting to either `text` or `ntext`.</span></span> <span data-ttu-id="232c9-242">대신 `varchar(max)` 또는 `nvarchar(max)`를 사용하십시오.</span><span class="sxs-lookup"><span data-stu-id="232c9-242">Use `varchar(max)` or `nvarchar(max)` instead.</span></span>  
  
-   <span data-ttu-id="232c9-243">비교 또는 정렬할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-243">It cannot be compared or sorted.</span></span> <span data-ttu-id="232c9-244">즉, `xml` 데이터 형식은 GROUP BY 문에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-244">This means an `xml` data type cannot be used in a GROUP BY statement.</span></span>  
  
-   <span data-ttu-id="232c9-245">ISNULL, COALESCE 및 DATALENGTH 이외의 기본 제공 스칼라 함수에 대한 매개 변수로 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-245">It cannot be used as a parameter to any scalar, built-in functions other than ISNULL, COALESCE, and DATALENGTH.</span></span>  
  
-   <span data-ttu-id="232c9-246">인덱스에서 키 열로 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-246">It cannot be used as a key column in an index.</span></span> <span data-ttu-id="232c9-247">하지만 클러스터형 인덱스의 데이터로 포함되거나 비클러스터형 인덱스를 만든 경우 INCLUDE 키워드를 사용하여 비클러스터형 인덱스에 명시적으로 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="232c9-247">However, it can be included as data in a clustered index or explicitly added to a nonclustered index by using the INCLUDE keyword when the nonclustered index is created.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="232c9-248">참고 항목</span><span class="sxs-lookup"><span data-stu-id="232c9-248">See Also</span></span>  
 [<span data-ttu-id="232c9-249">XML 문서 대량 가져오기 및 내보내기 예제&#40;SQL Server&#41;</span><span class="sxs-lookup"><span data-stu-id="232c9-249">Examples of Bulk Import and Export of XML Documents &#40;SQL Server&#41;</span></span>](../import-export/examples-of-bulk-import-and-export-of-xml-documents-sql-server.md)  
  
  
