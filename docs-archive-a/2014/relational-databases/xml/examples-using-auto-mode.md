---
title: '예제: AUTO 모드 사용 | Microsoft Docs'
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: conceptual
helpviewer_keywords:
- AUTO FOR XML mode, examples
ms.assetid: 11e8d0e4-df8a-46f8-aa21-9602d4f26cad
author: rothja
ms.author: jroth
ms.openlocfilehash: b457bca6b7c25b9822e3dab2eba5f5cdb04b83e6
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87639434"
---
# <a name="examples-using-auto-mode"></a><span data-ttu-id="b49c3-102">예제: AUTO 모드 사용</span><span class="sxs-lookup"><span data-stu-id="b49c3-102">Examples: Using AUTO Mode</span></span>
  <span data-ttu-id="b49c3-103">다음 예에서는 AUTO 모드를 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-103">The following examples illustrate the use of AUTO mode.</span></span> <span data-ttu-id="b49c3-104">이러한 쿼리는 대부분 [!INCLUDE[ssSampleDBnormal](../../includes/sssampledbnormal-md.md)] 예제 데이터베이스의 ProductModel 테이블에 있는 Instructions 열에 저장된 자전거 제조 지침 XML 문서에 대해 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-104">Many of these queries are specified against bicycle manufacturing instructions XML documents that are stored in the Instructions column of the ProductModel table in the [!INCLUDE[ssSampleDBnormal](../../includes/sssampledbnormal-md.md)] sample database.</span></span>  
  
## <a name="example-retrieving-customer-order-and-order-detail-information"></a><span data-ttu-id="b49c3-105">예제: 고객, 주문 및 주문 세부 정보 검색</span><span class="sxs-lookup"><span data-stu-id="b49c3-105">Example: Retrieving customer, order, and order detail information</span></span>  
 <span data-ttu-id="b49c3-106">이 쿼리는 특정 고객에 대한 고객, 주문 및 주문 세부 정보를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-106">This query retrieves customer, order, and order detail information for a specific customer.</span></span>  
  
```  
USE AdventureWorks2012;  
GO  
SELECT Cust.CustomerID,   
       OrderHeader.CustomerID,  
       OrderHeader.SalesOrderID,   
       Detail.SalesOrderID, Detail.LineTotal, Detail.ProductID,   
       Product.Name,  
       Detail.OrderQty  
FROM Sales.Customer AS Cust  
INNER JOIN Sales.SalesOrderHeader AS OrderHeader   
    ON Cust.CustomerID = OrderHeader.CustomerID  
INNER JOIN Sales.SalesOrderDetail AS Detail  
    ON OrderHeader.SalesOrderID = Detail.SalesOrderID  
INNER JOIN Production.Product AS Product  
    ON Product.ProductID = Detail.ProductID  
WHERE Cust.CustomerID IN (29672, 29734)  
ORDER BY OrderHeader.CustomerID,  
         OrderHeader.SalesOrderID  
FOR XML AUTO;  
```  
  
 <span data-ttu-id="b49c3-107">이 쿼리는 `Cust`, `OrderHeader`, `Detail`및 `Product` 테이블 별칭을 식별하기 때문에 해당 요소가 `AUTO` 모드에 의해 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-107">Because the query identifies, `Cust`, `OrderHeader`, `Detail`, and `Product` table aliases, corresponding elements are generated by the `AUTO` mode.</span></span> <span data-ttu-id="b49c3-108">다시 말해서 `SELECT` 절에 지정된 열에 의해 식별되는 테이블 순서에 따라 이러한 요소들의 계층이 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-108">Again, the order in which tables are identified by the columns specified in the `SELECT` clause determine the hierarchy of these elements.</span></span>  
  
 <span data-ttu-id="b49c3-109">다음은 결과의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-109">This is the partial result.</span></span>  
  
 `<Cust CustomerID="29672">`  
  
 `<OrderHeader CustomerID="29672" SalesOrderID="43660">`  
  
 `<Detail SalesOrderID="43660" LineTotal="874.794000" ProductID="758" OrderQty="1">`  
  
 `<Product Name="Road-450 Red, 52" />`  
  
 `</Detail>`  
  
 `<Detail SalesOrderID="43660" LineTotal="419.458900" ProductID="762" OrderQty="1">`  
  
 `<Product Name="Road-650 Red, 44" />`  
  
 `</Detail>`  
  
 `</OrderHeader>`  
  
 `<OrderHeader CustomerID="29672" SalesOrderID="47660">`  
  
 `<Detail SalesOrderID="47660" LineTotal="469.794000" ProductID="765" OrderQty="1">`  
  
 `<Product Name="Road-650 Black, 58" />`  
  
 `</Detail>`  
  
 `</OrderHeader>`  
  
 `<OrderHeader CustomerID="29672" SalesOrderID="49857">`  
  
 `<Detail SalesOrderID="49857" LineTotal="44.994000" ProductID="852" OrderQty="1">`  
  
 `<Product Name="Women's Tights, S" />`  
  
 `</Detail>`  
  
 `</OrderHeader>`  
  
 `...`  
  
 `</Cust>`  
  
## <a name="example-specifying-group-by-and-aggregate-functions"></a><span data-ttu-id="b49c3-110">예제: GROUP BY 및 집계 함수 지정</span><span class="sxs-lookup"><span data-stu-id="b49c3-110">Example: Specifying GROUP BY and aggregate functions</span></span>  
 <span data-ttu-id="b49c3-111">다음 쿼리는 개별 고객 ID와 고객이 요청한 주문 번호를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-111">The following query returns individual customer IDs and the number of orders that the customer has requested.</span></span>  
  
```  
USE AdventureWorks2012;  
GO  
SELECT C.CustomerID, COUNT(*) AS NoOfOrders  
FROM Sales.Customer AS C  
INNER JOIN Sales.SalesOrderHeader AS SOH  
On C.CustomerID = SOH.CustomerID  
GROUP BY C.CustomerID  
FOR XML AUTO;This is the partial result:  
```  
  
 `<I CustomerID="11000" NoOfOrders="3" />`  
  
 `<I CustomerID="11001" NoOfOrders="3" />`  
  
 `...`  
  
## <a name="example-specifying-computed-columns-in-auto-mode"></a><span data-ttu-id="b49c3-112">예제: AUTO 모드에서 계산 열 지정</span><span class="sxs-lookup"><span data-stu-id="b49c3-112">Example: Specifying computed columns in AUTO mode</span></span>  
 <span data-ttu-id="b49c3-113">이 쿼리는 연결된 개별 고객 이름 및 주문 정보를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-113">This query returns concatenated individual customer names and the order information.</span></span> <span data-ttu-id="b49c3-114">계산 열은 해당 시점에 발생하는 가장 안쪽 수준으로 할당됩니다(이 예에서는 <`SOH`> 요소).</span><span class="sxs-lookup"><span data-stu-id="b49c3-114">Because the computed column is assigned to the innermost level encountered at that point, the <`SOH`> element in this example.</span></span> <span data-ttu-id="b49c3-115">연결된 고객 이름은 결과에서 <`SOH`> 요소의 특성으로 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-115">The concatenated customer names are added as attributes of the <`SOH`> element in the result.</span></span>  
  
```  
USE AdventureWorks2012;  
GO  
SELECT P.FirstName + ' ' + P.LastName AS Name,  
       SOH.SalesOrderID  
FROM Sales.Customer AS C  
INNER JOIN Sales.SalesOrderHeader AS SOH  
    ON  C.CustomerID = SOH.CustomerID  
INNER JOIN Person.Person AS P  
    ON P.BusinessEntityID = C.PersonID  
FOR XML AUTO;  
```  
  
 <span data-ttu-id="b49c3-116">다음은 결과의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-116">This is the partial result:</span></span>  
  
```  
<SOH Name="Jon Yang" SalesOrderID="43793" />  
<SOH Name="Eugene Huang" SalesOrderID="43767" />  
```  
  
 <span data-ttu-id="b49c3-117">각 판매 주문 헤더 정보가 하위 요소로 들어 있는 `Name` 특성이 포함된 <`IndividualCustomer`> 요소를 검색하기 위해 하위 SELECT를 사용하여 쿼리가 다시 작성되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-117">To retrieve the <`IndividualCustomer`> elements having the `Name` attribute that contains each sales order header information as a subelement, the query is rewritten using a sub select.</span></span> <span data-ttu-id="b49c3-118">내부 SELECT는 개별 고객의 이름이 포함된 계산 열이 있는 임시 `IndividualCustomer` 테이블을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-118">The inner select creates a temporary `IndividualCustomer` table with the computed column that contains the names of the individual customers.</span></span> <span data-ttu-id="b49c3-119">그런 다음 이 테이블이 `SalesOrderHeader` 테이블에 조인되어 결과를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-119">This table is then joined to the `SalesOrderHeader` table to obtain the result.</span></span>  
  
 <span data-ttu-id="b49c3-120">`Sales.Customer` 테이블은 해당 고객에 대한 `PersonID` 값을 포함하여 개별 고객 정보를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-120">Note that the `Sales.Customer` table stores individual customer information, including the `PersonID` value for that customer.</span></span> <span data-ttu-id="b49c3-121">그런 다음 이 `PersonID` 는 `Person.Person` 테이블에서 연락처 이름을 찾는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-121">This `PersonID` is then used to find the contact name from the `Person.Person` table.</span></span>  
  
```  
SELECT IndividualCustomer.Name, SOH.SalesOrderID  
FROM (SELECT FirstName+ ' '+LastName AS Name, C.PersonID, C.CustomerID  
      FROM Sales.Customer AS C, Person.Person AS P  
      WHERE C.PersonID = P.BusinessEntityID) AS IndividualCustomer  
LEFT OUTER JOIN  Sales.SalesOrderHeader AS SOH  
   ON IndividualCustomer.CustomerID = SOH.CustomerID  
ORDER BY IndividualCustomer.CustomerID, SOH.CustomerIDFOR XML AUTO;  
```  
  
 <span data-ttu-id="b49c3-122">다음은 결과의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-122">This is the partial result:</span></span>  
  
 `<IndividualCustomer Name="Jon Yang">`  
  
 `<SOH SalesOrderID="43793" />`  
  
 `<SOH SalesOrderID="51522" />`  
  
 `<SOH SalesOrderID="57418" />`  
  
 `</IndividualCustomer>`  
  
 `...`  
  
 `...`  
  
## <a name="example-returning-binary-data"></a><span data-ttu-id="b49c3-123">예제: 이진 데이터 반환</span><span class="sxs-lookup"><span data-stu-id="b49c3-123">Example: Returning binary data</span></span>  
 <span data-ttu-id="b49c3-124">이 쿼리는 `ProductPhoto` 테이블에서 제품 사진을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-124">This query returns a product photo from the `ProductPhoto` table.</span></span> <span data-ttu-id="b49c3-125">`ThumbNailPhoto`는 `ProductPhoto` 테이블의 `varbinary(max)` 열입니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-125">`ThumbNailPhoto` is an `varbinary(max)` column in the `ProductPhoto` table.</span></span> <span data-ttu-id="b49c3-126">기본적으로 `AUTO` 모드는 이진 데이터에 대해 쿼리가 실행되는 데이터베이스의 가상 루트에 대한 상대 URL인 참조를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-126">By default, `AUTO` mode returns to the binary data a reference that is a relative URL to the virtual root of the database where the query is executed.</span></span> <span data-ttu-id="b49c3-127">이미지를 식별하기 위해서는 `ProductPhotoID` 키 특성을 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-127">The `ProductPhotoID` key attribute must be specified to identify the image.</span></span> <span data-ttu-id="b49c3-128">이 예에서 설명된 것과 같이 이미지 참조를 검색할 때 테이블의 기본 키도 행을 고유하게 식별할 수 있도록 `SELECT` 절에서 지정되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-128">In retrieving an image reference as illustrated in this example, the primary key of the table must also be specified in the `SELECT` clause to uniquely identify a row.</span></span>  
  
```  
SELECT ProductPhotoID, ThumbNailPhoto  
FROM   Production.ProductPhoto   
WHERE ProductPhotoID=70  
FOR XML AUTO;  
```  
  
 <span data-ttu-id="b49c3-129">다음은 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-129">This is the result:</span></span>  
  
 `-- result`  
  
 `<Production.ProductPhoto`  
  
 `ProductPhotoID="70"`  
  
 `ThumbNailPhoto= "dbobject/Production.ProductPhoto[@ProductPhotoID='70']/@ThumbNailPhoto" />`  
  
 <span data-ttu-id="b49c3-130">`BINARY BASE64` 옵션으로도 동일한 쿼리가 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-130">The same query is executed with the `BINARY BASE64` option.</span></span> <span data-ttu-id="b49c3-131">다음 쿼리는 이진 데이터를 base64 인코딩 형식으로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-131">The query returns the binary data in base64-encoded format.</span></span>  
  
```  
SELECT ProductPhotoID, ThumbNailPhoto  
FROM   Production.ProductPhoto   
WHERE ProductPhotoID=70  
FOR XML AUTO, BINARY BASE64;  
```  
  
 <span data-ttu-id="b49c3-132">다음은 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-132">This is the result:</span></span>  
  
 `-- result`  
  
 `<Production.ProductPhoto ProductPhotoID="70" ThumbNailPhoto="Base64 encoded photo" />`  
  
 <span data-ttu-id="b49c3-133">기본적으로 이진 데이터를 검색하기 위해 AUTO 모드를 사용하는 경우 쿼리가 실행되는 데이터베이스의 가상 루트에 대한 상대 URL 참조가 이진 데이터 대신 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-133">By default, when you use AUTO mode to retrieve binary data, a reference to a relative URL to the virtual root of the database where the query was executed will be returned instead of the binary data.</span></span> <span data-ttu-id="b49c3-134">이 경우는 BINARY BASE64 옵션이 지정되지 않은 경우에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-134">This will occur if the BINARY BASE64 option is not specified.</span></span>  
  
 <span data-ttu-id="b49c3-135">AUTO 모드가 쿼리에 지정된 테이블 또는 열 이름이 데이터베이스에 있는 테이블 또는 열 이름과 일치하지 않는 대/소문자를 구분하지 않는 데이터베이스에 있는 이진 데이터에 대한 URL 참조를 반환하는 경우 쿼리가 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-135">When AUTO mode returns a URL reference to the binary data in case-insensitive databases where a table or column name specified in the query does not match the table or column name in the database, the query executes.</span></span> <span data-ttu-id="b49c3-136">하지만 참조에 반환된 대/소문자가 일관적이지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-136">However, the case returned in the reference will not be consistent.</span></span> <span data-ttu-id="b49c3-137">예를 들면 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-137">For example:</span></span>  
  
```  
SELECT ProductPhotoID, ThumbnailPhoto  
FROM   Production.ProductPhoto   
WHERE  ProductPhotoID=70  
FOR XML AUTO;  
```  
  
 <span data-ttu-id="b49c3-138">다음은 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-138">This is the result:</span></span>  
  
 `<Production.PRODUCTPHOTO`  
  
 `PRODUCTPHOTOID="70"`  
  
 `THUMBNAILPHOTO= "dbobject/Production.PRODUCTPHOTO[@ProductPhotoID='70']/@ThumbNailPhoto" />`  
  
 <span data-ttu-id="b49c3-139">이는 특히 대/소문자를 구분하는 데이터베이스에 대해 dbobject 쿼리를 실행하는 경우에 문제가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-139">This can be a problem particularly when dbobject queries are executed against a case sensitive database.</span></span> <span data-ttu-id="b49c3-140">이러한 문제를 방지하려면 쿼리에 지정된 테이블 또는 열 이름의 대/소문자가 데이터베이스에 있는 테이블 또는 열 이름의 대/소문자와 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-140">To avoid this, the case of the table or column name that is specified in the queries should match the case of the table or column name in the database.</span></span>  
  
## <a name="example-understanding-the-encoding"></a><span data-ttu-id="b49c3-141">예제: 인코딩 이해</span><span class="sxs-lookup"><span data-stu-id="b49c3-141">Example: Understanding the encoding</span></span>  
 <span data-ttu-id="b49c3-142">다음 예에서는 결과에서 발생하는 여러 가지 인코딩을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-142">This example shows the various encoding that occurs in the result.</span></span>  
  
 <span data-ttu-id="b49c3-143">다음 테이블을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-143">Create this table:</span></span>  
  
```  
CREATE TABLE [Special Chars] (Col1 char(1) primary key, [Col#&2] varbinary(50));  
```  
  
 <span data-ttu-id="b49c3-144">테이블에 다음 데이터를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-144">Add the following data to the table:</span></span>  
  
```  
INSERT INTO [Special Chars] VALUES ('&', 0x20), ('#', 0x20);  
```  
  
 <span data-ttu-id="b49c3-145">다음 쿼리는 테이블에서 데이터를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-145">This query returns the data from the table.</span></span> <span data-ttu-id="b49c3-146">FOR XML AUTO 모드가 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-146">The FOR XML AUTO mode is specified.</span></span> <span data-ttu-id="b49c3-147">이진 데이터가 참조로 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-147">Binary data is returned as a reference.</span></span>  
  
```  
SELECT * FROM [Special Chars] FOR XML AUTO;  
```  
  
 <span data-ttu-id="b49c3-148">다음은 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-148">This is the result:</span></span>  
  
 `<Special_x0020_Chars`  
  
 `Col1="#"`  
  
 `Col_x0023__x0026_2="dbobject/Special_x0020_Chars[@Col1='#']/@Col_x0023__x0026_2"`  
  
 `/>`  
  
 `<Special_x0020_Chars`  
  
 `Col1="&"`  
  
 `Col_x0023__x0026_2="dbobject/Special_x0020_Chars[@Col1='&']/@Col_x0023__x0026_2"`  
  
 `/>`  
  
 <span data-ttu-id="b49c3-149">다음은 결과에서 특수 문자를 인코딩하는 처리 과정입니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-149">This is the process for encoding special characters in the result:</span></span>  
  
-   <span data-ttu-id="b49c3-150">쿼리 결과에서 반환된 요소와 특성 이름의 특수 XML 및 URL 문자는 그에 해당되는 유니코드 문자의 16진수 값을 사용하여 인코딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-150">In the query result, the special XML and URL characters in the element and attribute names that are returned are encoded by using the hexadecimal value of the corresponding Unicode character.</span></span> <span data-ttu-id="b49c3-151">이전 결과에서 요소 이름 <`Special Chars`>는 <`Special_x0020_Chars`>로 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-151">In the previous result, the element name <`Special Chars`> is returned as <`Special_x0020_Chars`>.</span></span> <span data-ttu-id="b49c3-152">특성 이름 <`Col#&2`>는 <`Col_x0023__x0026_2`>로 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-152">The attribute name <`Col#&2`> is returned as <`Col_x0023__x0026_2`>.</span></span> <span data-ttu-id="b49c3-153">XML 및 URL 특수 문자가 모두 인코딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-153">Both XML and URL special characters are encoded.</span></span>  
  
-   <span data-ttu-id="b49c3-154">요소나 특성의 값에 5개의 표준 XML 문자 엔터티(', "", \<, > 및 &)가 있는 경우 이 특수 XML 문자는 항상 XML 문자 인코딩을 사용하여 인코딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-154">If the values of the elements or attribute contain any of the five standard XML character entities (', "", \<, >, and &), these special XML characters are always encoded using XML character encoding.</span></span> <span data-ttu-id="b49c3-155">이전 결과에서 <`Col1`> 특성 값의 `&` 값은 `&`로 인코딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-155">In the previous result, the value `&` in the value of attribute <`Col1`> is encoded as `&`.</span></span> <span data-ttu-id="b49c3-156">그러나 # 문자는 유효한 XML 문자이고 특수 XML 문자가 아니기 때문에 #로 그대로 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-156">However, the # character remains #, because it is a valid XML character and not a special XML character.</span></span>  
  
-   <span data-ttu-id="b49c3-157">요소나 특성의 값에 URL에서 특수한 의미가 있는 특수 URL 문자가 있으면 이 문자는 DBOBJECT URL 값에서만 인코딩되고 특수 문자가 테이블이나 열 이름의 일부일 경우에만 인코딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-157">If the values of the elements or attributes contain any special URL characters that have special meaning in the URL, they are encoded only in the DBOBJECT URL value and are encoded only when the special character is part of a table or column name.</span></span> <span data-ttu-id="b49c3-158">결국 테이블 이름 `#` 의 일부인 문자 `Col#&2` 는 `_x0023_ in the DBOJBECT URL`으로 인코딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="b49c3-158">In the result, the character `#` that is part of table name `Col#&2` is encoded as `_x0023_ in the DBOJBECT URL`.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b49c3-159">참고 항목</span><span class="sxs-lookup"><span data-stu-id="b49c3-159">See Also</span></span>  
 [<span data-ttu-id="b49c3-160">FOR XML에서 AUTO 모드 사용</span><span class="sxs-lookup"><span data-stu-id="b49c3-160">Use AUTO Mode with FOR XML</span></span>](use-auto-mode-with-for-xml.md)  
  
  
