---
title: OPENXML(SQL Server) | Microsoft 문서
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: conceptual
helpviewer_keywords:
- ColPattern [XML in SQL Server]
- OPENXML statement, about OPENXML statement
- writing XML, OPENXML statement
- OPENXML statement, querying XML
- attribute-centric mapping
- SELECT statement [SQL Server], OPENXML keyword
- column patterns [XML in SQL Server]
- row patterns [XML in SQL Server]
- rowpattern [XML in SQL Server]
- queries [XML in SQL Server], OPENXML statement
- XML [SQL Server], OPENXML statement
- element-centric mapping [SQL Server]
ms.assetid: 060126fc-ed0f-478f-830a-08e418d410dc
author: rothja
ms.author: jroth
ms.openlocfilehash: 1849029e6654fcd629499cceeff9957e5389370f
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87743044"
---
# <a name="openxml-sql-server"></a><span data-ttu-id="21f04-102">OPENXML(SQL Server)</span><span class="sxs-lookup"><span data-stu-id="21f04-102">OPENXML (SQL Server)</span></span>
  <span data-ttu-id="21f04-103">[!INCLUDE[tsql](../../includes/tsql-md.md)] 키워드인 OPENXML은 테이블 또는 뷰와 비슷한 메모리 내 XML 문서에 대한 행 집합을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-103">OPENXML, a [!INCLUDE[tsql](../../includes/tsql-md.md)] keyword, provides a rowset over in-memory XML documents that is similar to a table or a view.</span></span> <span data-ttu-id="21f04-104">OPENXML은 관계형 행 집합인 것처럼 XML 데이터에 대한 액세스를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-104">OPENXML allows access to XML data as though it is a relational rowset.</span></span> <span data-ttu-id="21f04-105">이러한 기능은 XML 문서의 내부 표현에 대한 행 집합 뷰를 제공함으로써 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-105">It does this by providing a rowset view of the internal representation of an XML document.</span></span> <span data-ttu-id="21f04-106">행 집합의 레코드는 데이터베이스 테이블에 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-106">The records in the rowset can be stored in database tables.</span></span>

 <span data-ttu-id="21f04-107">OPENXML은 행 집합 공급자, 뷰 또는 OPENROWSET이 원본으로 표시될 수 있는 경우 SELECT 및 SELECT INTO에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-107">OPENXML can be used in SELECT and SELECT INTO statements wherever rowset providers, a view, or OPENROWSET can appear as the source.</span></span> <span data-ttu-id="21f04-108">OPENXML 구문에 대한 자세한 내용은 [OPENXML&#40;Transact-SQL&#41;](/sql/t-sql/functions/openxml-transact-sql)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="21f04-108">For information about the syntax of OPENXML, see [OPENXML &#40;Transact-SQL&#41;](/sql/t-sql/functions/openxml-transact-sql).</span></span>

 <span data-ttu-id="21f04-109">OPENXML을 사용 하 여 XML 문서에 대 한 쿼리를 작성 하려면 먼저를 호출 해야 `sp_xml_preparedocument` 합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-109">To write queries against an XML document by using OPENXML, you must first call `sp_xml_preparedocument`.</span></span> <span data-ttu-id="21f04-110">이 메서드는 XML 문서를 구문 분석하고 사용할 준비가 된 구문 분석된 문서에 핸들을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-110">This parses the XML document and returns a handle to the parsed document that is ready for consumption.</span></span> <span data-ttu-id="21f04-111">구문 분석된 문서는 XML 문서의 여러 노드를 DOM(문서 개체 모델) 트리로 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-111">The parsed document is a document object model (DOM) tree representation of various nodes in the XML document.</span></span> <span data-ttu-id="21f04-112">문서 핸들은 OPENXML에 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-112">The document handle is passed to OPENXML.</span></span> <span data-ttu-id="21f04-113">그런 다음 OPENXML은 전달된 매개 변수에 따라 문서의 행 집합 뷰를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-113">OPENXML then provides a rowset view of the document, based on the parameters passed to it.</span></span>

> [!NOTE]
>  <span data-ttu-id="21f04-114">`sp_xml_preparedocument`는 Msxmlsql.dll의 MSXML 파서의 SQL 업데이트 된 버전을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-114">`sp_xml_preparedocument` uses a SQL-updated version of the MSXML parser, Msxmlsql.dll.</span></span> <span data-ttu-id="21f04-115">이 버전의 MSXML 파서는 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 를 지원하고 MSXML 버전 2.6에 대한 이전 버전과의 호환성을 유지하도록 디자인되었습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-115">This version of the MSXML parser was designed to support [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] and remain backward compatible with MSXML version 2.6.</span></span>

 <span data-ttu-id="21f04-116">메모리를 확보하기 위해서는 **sp_xml_removedocument** 시스템 저장 프로시저를 호출하여 메모리에서 XML 문서의 내부 표현을 제거해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-116">The internal representation of an XML document must be removed from memory by calling the **sp_xml_removedocument** system stored procedure to free the memory.</span></span>

 <span data-ttu-id="21f04-117">다음 그림은 이 프로세스를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-117">The following illustration shows the process.</span></span>

 <span data-ttu-id="21f04-118">![OPENXML을 통한 XML 구문 분석](../../database-engine/media/xmlsp.gif "OPENXML을 통한 XML 구문 분석")</span><span class="sxs-lookup"><span data-stu-id="21f04-118">![Parsing XML with OPENXML](../../database-engine/media/xmlsp.gif "Parsing XML with OPENXML")</span></span>

 <span data-ttu-id="21f04-119">OPENXML을 이해하려면 XPath 쿼리에 익숙해야 하며 XML을 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-119">Note that to understand OPENXML, familiarity with XPath queries and an understanding of XML is required.</span></span> <span data-ttu-id="21f04-120">SQL Server의 XPath 지원에 대한 자세한 내용은 [SQLXML 4.0의 XPath 쿼리 사용](../sqlxml-annotated-xsd-schemas-xpath-queries/using-xpath-queries-in-sqlxml-4-0.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="21f04-120">For more information about XPath support in SQL Server, see [Using XPath Queries in SQLXML 4.0](../sqlxml-annotated-xsd-schemas-xpath-queries/using-xpath-queries-in-sqlxml-4-0.md).</span></span>

> [!NOTE]
>  <span data-ttu-id="21f04-121">OpenXML을 사용하면 행 및 열의 XPath 패턴을 변수로 매개 변수화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-121">OpenXML allows the row and column XPath patterns to be parameterized as variables.</span></span> <span data-ttu-id="21f04-122">프로그래머가 매개 변수화를 외부 사용자에게 제공하는 경우(예를 들어 외부적으로 호출된 저장 프로시저를 통해 매개 변수가 제공되는 경우) 이러한 매개 변수화를 수행하면 XPath 식이 삽입될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-122">Such parameterization could lead to XPath expression injections, if the programmer exposes the parameterization to outside users (for example, if the parameters are provided via an externally called stored procedure).</span></span> <span data-ttu-id="21f04-123">이러한 잠재적 보안 문제를 방지하려면 XPath 매개 변수를 외부 호출자에게 제공하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-123">To avoid such potential security issues, it is recommended that XPath parameters should never be exposed to external callers.</span></span>

## <a name="example"></a><span data-ttu-id="21f04-124">예제</span><span class="sxs-lookup"><span data-stu-id="21f04-124">Example</span></span>
 <span data-ttu-id="21f04-125">다음 예에서는 `OPENXML` 및 `INSERT` 문에서 `SELECT` 을 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-125">The following example shows the use of `OPENXML` in an `INSERT` statement and a `SELECT` statement.</span></span> <span data-ttu-id="21f04-126">예제 XML 문서에 `<Customers>` 및 `<Orders>` 요소가 들어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-126">The sample XML document contains `<Customers>` and `<Orders>` elements.</span></span>

 <span data-ttu-id="21f04-127">우선 `sp_xml_preparedocument` 저장 프로시저가 XML 문서를 구문 분석합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-127">First, the `sp_xml_preparedocument` stored procedure parses the XML document.</span></span> <span data-ttu-id="21f04-128">구문 분석된 문서는 XML 문서의 노드(요소, 특성, 텍스트 및 주석)를 트리로 나타낸 것입니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-128">The parsed document is a tree representation of the nodes (elements, attributes, text, and comments) in the XML document.</span></span> <span data-ttu-id="21f04-129">`OPENXML` 은 이 구문 분석된 XML 문서를 참조하여 해당 XML 문서의 일부 또는 전체에 대한 행 집합 뷰를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-129">`OPENXML` then refers to this parsed XML document and provides a rowset view of all or parts of this XML document.</span></span> <span data-ttu-id="21f04-130">`INSERT` 을 사용하는 `OPENXML` 문은 그러한 행 집합의 데이터를 데이터베이스 테이블에 삽입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-130">An `INSERT` statement using `OPENXML` can insert data from such a rowset into a database table.</span></span> <span data-ttu-id="21f04-131">`OPENXML` 을 여러 번 호출하면 XML 문서의 여러 부분에 대한 행 집합 뷰를 제공하고, XML 문서의 여러 부분을 다른 테이블에 삽입하는 등 다양하게 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-131">Several `OPENXML` calls can be used to provide a rowset view of various parts of the XML document and process them, for example, by inserting them into different tables.</span></span> <span data-ttu-id="21f04-132">이 프로세스는 XML을 테이블로 조각화한다라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-132">This process is also referred to as shredding XML into tables.</span></span>

 <span data-ttu-id="21f04-133">다음 예에서는 두 개의 `<Customers>` 문을 사용하여 `Customers` 요소를 `<Orders>` 테이블에 저장하고 `Orders` 요소를 `INSERT` 테이블에 저장하는 방식으로 XML 문서가 조각화됩니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-133">In the following example, an XML document is shredded in a way that `<Customers>` elements are stored in the `Customers` table and `<Orders>` elements are stored in the `Orders` table by using two `INSERT` statements.</span></span> <span data-ttu-id="21f04-134">또한 XML 문서에서 `SELECT` 및 `OPENXML` 를 검색하는 `CustomerID` 이 포함된 `OrderDate` 문을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-134">The example also shows a `SELECT` statement with `OPENXML` that retrieves `CustomerID` and `OrderDate` from the XML document.</span></span> <span data-ttu-id="21f04-135">이 과정의 마지막 단계에서 `sp_xml_removedocument`를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-135">The last step in the process is to call `sp_xml_removedocument`.</span></span> <span data-ttu-id="21f04-136">이 작업은 구문 분석 단계 중에 생성된 내부 XML 트리를 표시하는 데 할당된 메모리를 해제하기 위해 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-136">This is done in order to release the memory allocated to contain the internal XML tree representation that was created during the parse phase.</span></span>

```
-- Create tables for later population using OPENXML.
CREATE TABLE Customers (CustomerID varchar(20) primary key,
                ContactName varchar(20), 
                CompanyName varchar(20));
GO
CREATE TABLE Orders( CustomerID varchar(20), OrderDate datetime);
GO
DECLARE @docHandle int;
DECLARE @xmlDocument nvarchar(max); -- or xml type
SET @xmlDocument = N'<ROOT>
<Customers CustomerID="XYZAA" ContactName="Joe" CompanyName="Company1">
<Orders CustomerID="XYZAA" OrderDate="2000-08-25T00:00:00"/>
<Orders CustomerID="XYZAA" OrderDate="2000-10-03T00:00:00"/>
</Customers>
<Customers CustomerID="XYZBB" ContactName="Steve"
CompanyName="Company2">No Orders yet!
</Customers>
</ROOT>';
EXEC sp_xml_preparedocument @docHandle OUTPUT, @xmlDocument;
-- Use OPENXML to provide rowset consisting of customer data.
INSERT Customers 
SELECT * 
FROM OPENXML(@docHandle, N'/ROOT/Customers') 
  WITH Customers;
-- Use OPENXML to provide rowset consisting of order data.
INSERT Orders 
SELECT * 
FROM OPENXML(@docHandle, N'//Orders') 
  WITH Orders;
-- Using OPENXML in a SELECT statement.
SELECT * FROM OPENXML(@docHandle, N'/ROOT/Customers/Orders') WITH (CustomerID nchar(5) '../@CustomerID', OrderDate datetime);
-- Remove the internal representation of the XML document.
EXEC sp_xml_removedocument @docHandle; 
```

 <span data-ttu-id="21f04-137">다음 그림에서는 sp_xml_preparedocument에 의해 생성된 이전 XML 문서의 구문 분석된 XML 트리를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-137">The following illustration shows the parsed XML tree of the previous XML document that was created by using sp_xml_preparedocument.</span></span>

 <span data-ttu-id="21f04-138">![구문 분석된 XML 트리](../../database-engine/media/xmlparsedtree.gif "구문 분석된 XML 트리")</span><span class="sxs-lookup"><span data-stu-id="21f04-138">![Parsed XML tree](../../database-engine/media/xmlparsedtree.gif "Parsed XML tree")</span></span>

## <a name="openxml-parameters"></a><span data-ttu-id="21f04-139">OPENXML 매개 변수</span><span class="sxs-lookup"><span data-stu-id="21f04-139">OPENXML Parameters</span></span>
 <span data-ttu-id="21f04-140">OPENXML에 대한 매개 변수는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-140">The parameters to OPENXML include the following:</span></span>

-   <span data-ttu-id="21f04-141">XML 문서 핸들(*idoc*)</span><span class="sxs-lookup"><span data-stu-id="21f04-141">An XML document handle (*idoc*)</span></span>

-   <span data-ttu-id="21f04-142">행에 매핑될 노드를 식별하기 위한 XPath 식(*rowpattern*)</span><span class="sxs-lookup"><span data-stu-id="21f04-142">An XPath expression to identify the nodes to be mapped to rows (*rowpattern*)</span></span>

-   <span data-ttu-id="21f04-143">생성될 행 집합에 대한 설명</span><span class="sxs-lookup"><span data-stu-id="21f04-143">A description of the rowset to be generated</span></span>

-   <span data-ttu-id="21f04-144">행 집합 열과 XML 노드 간의 매핑</span><span class="sxs-lookup"><span data-stu-id="21f04-144">Mapping between the rowset columns and the XML nodes</span></span>

### <a name="xml-document-handle-idoc"></a><span data-ttu-id="21f04-145">XML 문서 핸들(idoc)</span><span class="sxs-lookup"><span data-stu-id="21f04-145">XML Document Handle (idoc)</span></span>
 <span data-ttu-id="21f04-146">문서 핸들은 저장 프로시저에 의해 반환 됩니다 `sp_xml_preparedocument` .</span><span class="sxs-lookup"><span data-stu-id="21f04-146">The document handle is returned by the `sp_xml_preparedocument` stored procedure.</span></span>

### <a name="xpath-expression-to-identify-the-nodes-to-be-processed-rowpattern"></a><span data-ttu-id="21f04-147">처리될 노드를 식별하는 XPath 식(rowpattern)</span><span class="sxs-lookup"><span data-stu-id="21f04-147">XPath Expression to Identify the Nodes to Be Processed (rowpattern)</span></span>
 <span data-ttu-id="21f04-148">*rowpattern* 으로 지정된 XPath 식은 XML 문서의 노드 집합을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-148">The XPath expression specified as *rowpattern* identifies a set of nodes in the XML document.</span></span> <span data-ttu-id="21f04-149">*rowpattern* 에 의해 식별되는 노드는 각각 OPENXML에 의해 생성되는 행 집합의 단일 행에 해당됩니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-149">Each node that is identified by *rowpattern* corresponds to a single row in the rowset that is generated by OPENXML.</span></span>

 <span data-ttu-id="21f04-150">XPath 식에 의해 식별되는 노드는 XML 문서의 모든 XML 노드일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-150">The nodes identified by the XPath expression can be any XML node in the XML document.</span></span> <span data-ttu-id="21f04-151">*rowpattern* 이 XML 문서의 요소 집합을 식별하는 경우 식별되는 각 요소 노드에 대한 행 집합에는 한 개의 행이 있게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-151">If *rowpattern* identifies a set of elements in the XML document, there is one row in the rowset for each element node identified.</span></span> <span data-ttu-id="21f04-152">예를 들어 *rowpattern* 이 특성으로 끝나면 *rowpattern*에 의해 선택되는 각 특성 노드에 대해 한 개의 행이 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-152">For example, if *rowpattern* ends in an attribute, a row is created for each attribute node selected by *rowpattern*.</span></span>

### <a name="description-of-the-rowset-to-be-generated"></a><span data-ttu-id="21f04-153">생성될 행 집합에 대한 설명</span><span class="sxs-lookup"><span data-stu-id="21f04-153">Description of the Rowset to Be Generated</span></span>
 <span data-ttu-id="21f04-154">행 집합 스키마는 결과 행 집합을 생성하기 위해 OPENXML에 의해 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-154">A rowset schema is used by OPENXML to generate the resulting rowset.</span></span> <span data-ttu-id="21f04-155">행 집합 스키마를 지정할 때 다음 옵션을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-155">You can use the following options when specifying a rowset schema.</span></span>

#### <a name="using-the-edge-table-format"></a><span data-ttu-id="21f04-156">Edge 테이블 형식 사용</span><span class="sxs-lookup"><span data-stu-id="21f04-156">Using the Edge Table Format</span></span>
 <span data-ttu-id="21f04-157">행 집합 스키마를 지정하려면 Edge 테이블 형식을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-157">You should use the edge table format to specify a rowset schema.</span></span> <span data-ttu-id="21f04-158">WITH 절을 사용하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="21f04-158">Do not use the WITH clause.</span></span>

 <span data-ttu-id="21f04-159">WITH 절을 사용하면 OPENXML이 행 집합을 Edge 테이블 형식으로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-159">When you do this, OPENXML returns a rowset in the edge table format.</span></span> <span data-ttu-id="21f04-160">이 테이블은 구문 분석된 XML 문서 트리의 가장 자리에 있는 모든 노드가 행 집합의 행으로 매핑되기 때문에 Edge 테이블이라고 부릅니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-160">This is referred to as an edge table, because every edge in the parsed XML document tree maps to a row in the rowset.</span></span>

 <span data-ttu-id="21f04-161">Edge 테이블은 단일 테이블 내에 세부적인 XML 문서 구조를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-161">Edge tables represent within a single table the fine-grained XML document structure.</span></span> <span data-ttu-id="21f04-162">이 구조에는 요소 및 특성 이름, 문서 계층, 네임스페이스 및 처리 명령이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-162">This structure includes the element and attribute names, the document hierarchy, the namespaces, and the processing instructions.</span></span> <span data-ttu-id="21f04-163">Edge 테이블 형식을 사용하면 메타 속성을 통해 제공되지 않은 정보를 추가로 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-163">The edge table format allows you to obtain additional information that is not exposed through the metaproperties.</span></span> <span data-ttu-id="21f04-164">메타 속성에 대한 자세한 내용은 [Specify Metaproperties in OPENXML](../xml/specify-metaproperties-in-openxml.md)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="21f04-164">For more information about metaproperties, see [Specify Metaproperties in OPENXML](../xml/specify-metaproperties-in-openxml.md).</span></span>

 <span data-ttu-id="21f04-165">Edge 테이블에서 제공되는 추가 정보를 사용하면 요소 및 특성의 데이터 형식과 노드 유형을 저장 및 쿼리할 수 있으며 XML 문서 구조에 대한 정보를 저장 및 쿼리할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-165">The additional information provided by an edge table allows you to store and query the data type of an element and attribute, and the node type, and also store and query information about the XML document structure.</span></span> <span data-ttu-id="21f04-166">이 추가 정보를 사용하면 자체 XML 문서 관리 시스템을 구축할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-166">With this additional information, it may also be possible to build your own XML document management system.</span></span>

 <span data-ttu-id="21f04-167">Edge 테이블을 사용하면 XML 문서를 BLOB(Binary Large Object) 입력으로 사용하고 Edge 테이블을 생성한 다음 보다 세부적인 수준에서 문서를 추출 및 분석하는 저장 프로시저를 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-167">By using an edge table, you can write stored procedures that take XML documents as binary large object (BLOB) input, produce the edge table, and then extract and analyze the document on a more detailed level.</span></span> <span data-ttu-id="21f04-168">이러한 세부적인 수준에는 문서 계층, 요소 및 특성 이름, 네임스페이스 및 처리 명령 검색이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-168">This detailed level could include finding the document hierarchy, the element and attribute names, the namespaces, and the processing instructions.</span></span>

 <span data-ttu-id="21f04-169">또한 Edge 테이블은 다른 관계형 형식에 대한 매핑이 논리적이지 않은 경우와 ntext 필드가 구조 정보를 충분히 제공하지 않는 경우, XML 문서에 대한 스토리지 형식으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-169">The edge table also can serve as a storage format for XML documents when mapping to other relational formats is not logical and an ntext field is not providing enough structural information.</span></span>

 <span data-ttu-id="21f04-170">XML 파서를 사용하여 XML 문서를 검사할 수 있는 경우 Edge 테이블을 대신 사용해도 동일한 정보를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-170">In situations where you can use an XML parser to examine an XML document, you can use an edge table instead to obtain the same information.</span></span>

 <span data-ttu-id="21f04-171">다음 표에서는 Edge 테이블의 구조에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-171">The following table describes the structure of the edge table.</span></span>

|<span data-ttu-id="21f04-172">열 이름</span><span class="sxs-lookup"><span data-stu-id="21f04-172">Column name</span></span>|<span data-ttu-id="21f04-173">데이터 형식</span><span class="sxs-lookup"><span data-stu-id="21f04-173">Data type</span></span>|<span data-ttu-id="21f04-174">Description</span><span class="sxs-lookup"><span data-stu-id="21f04-174">Description</span></span>|
|-----------------|---------------|-----------------|
|<span data-ttu-id="21f04-175">**id**</span><span class="sxs-lookup"><span data-stu-id="21f04-175">**id**</span></span>|<span data-ttu-id="21f04-176">**bigint**</span><span class="sxs-lookup"><span data-stu-id="21f04-176">**bigint**</span></span>|<span data-ttu-id="21f04-177">문서 노드의 고유 ID입니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-177">Is the unique ID of the document node.</span></span><br /><br /> <span data-ttu-id="21f04-178">루트 요소의 ID 값은 0입니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-178">The root element has an ID value of 0.</span></span> <span data-ttu-id="21f04-179">음수 ID 값은 예약된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-179">The negative ID values are reserved.</span></span>|
|<span data-ttu-id="21f04-180">**parentid**</span><span class="sxs-lookup"><span data-stu-id="21f04-180">**parentid**</span></span>|<span data-ttu-id="21f04-181">**bigint**</span><span class="sxs-lookup"><span data-stu-id="21f04-181">**bigint**</span></span>|<span data-ttu-id="21f04-182">노드의 부모를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-182">Identifies the parent of the node.</span></span> <span data-ttu-id="21f04-183">이 ID로 식별된 부모는 부모 요소가 아닐 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-183">The parent identified by this ID is not necessarily the parent element.</span></span> <span data-ttu-id="21f04-184">하지만 부모 요소인지 여부는 부모가 이 ID에 의해 식별되는 노드의 NodeType에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-184">However, this depends on the NodeType of the node whose parent is identified by this ID.</span></span> <span data-ttu-id="21f04-185">예를 들어 노드가 텍스트 노드인 경우 해당 부모는 특성 노드일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-185">For example, if the node is a text node, its parent may be an attribute node.</span></span><br /><br /> <span data-ttu-id="21f04-186">노드가 XML 문서의 최상위 수준에 있으면 해당 **ParentID** 는 NULL입니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-186">If the node is at the top level in the XML document, its **ParentID** is NULL.</span></span>|
|<span data-ttu-id="21f04-187">**node type**</span><span class="sxs-lookup"><span data-stu-id="21f04-187">**node type**</span></span>|<span data-ttu-id="21f04-188">**int**</span><span class="sxs-lookup"><span data-stu-id="21f04-188">**int**</span></span>|<span data-ttu-id="21f04-189">노드 유형을 식별하며 XML 개체 모델(DOM) 노드 유형의 지정 번호에 해당하는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-189">Identifies the node type and is an integer that corresponds to the XML object model (DOM) node type numbering.</span></span><br /><br /> <span data-ttu-id="21f04-190">다음은 이 열에 표시될 수 있는 노드 유형을 나타내는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-190">Following are the values that can appear in this column to indicate the node type:</span></span><br /><br /> <span data-ttu-id="21f04-191">**1** = 요소 노드</span><span class="sxs-lookup"><span data-stu-id="21f04-191">**1** = Element node</span></span><br /><br /> <span data-ttu-id="21f04-192">**2** = 특성 노드</span><span class="sxs-lookup"><span data-stu-id="21f04-192">**2** = Attribute node</span></span><br /><br /> <span data-ttu-id="21f04-193">**3** = 텍스트 노드</span><span class="sxs-lookup"><span data-stu-id="21f04-193">**3** = Text node</span></span><br /><br /> <span data-ttu-id="21f04-194">**4** = CDATA 섹션 노드</span><span class="sxs-lookup"><span data-stu-id="21f04-194">**4** = CDATA section node</span></span><br /><br /> <span data-ttu-id="21f04-195">**5** = 엔터티 참조 노드</span><span class="sxs-lookup"><span data-stu-id="21f04-195">**5** = Entity reference node</span></span><br /><br /> <span data-ttu-id="21f04-196">**6** = 엔터티 노드</span><span class="sxs-lookup"><span data-stu-id="21f04-196">**6** = Entity node</span></span><br /><br /> <span data-ttu-id="21f04-197">**7** = 처리 명령 노드</span><span class="sxs-lookup"><span data-stu-id="21f04-197">**7** = Processing instruction node</span></span><br /><br /> <span data-ttu-id="21f04-198">**8** = 주석 노드</span><span class="sxs-lookup"><span data-stu-id="21f04-198">**8** = Comment node</span></span><br /><br /> <span data-ttu-id="21f04-199">**9** = 문서 노드</span><span class="sxs-lookup"><span data-stu-id="21f04-199">**9** = Document node</span></span><br /><br /> <span data-ttu-id="21f04-200">**10** = 문서 유형 노드</span><span class="sxs-lookup"><span data-stu-id="21f04-200">**10** = Document Type node</span></span><br /><br /> <span data-ttu-id="21f04-201">**11** = 문서 조각 노드</span><span class="sxs-lookup"><span data-stu-id="21f04-201">**11** = Document Fragment node</span></span><br /><br /> <span data-ttu-id="21f04-202">**12** = 표기법 노드</span><span class="sxs-lookup"><span data-stu-id="21f04-202">**12** = Notation node</span></span><br /><br /> <span data-ttu-id="21f04-203">자세한 내용은 MSXML(Microsoft XML) SDK의 "nodeType Property" 항목을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="21f04-203">For more information, see the "nodeType Property" topic in the Microsoft XML (MSXML) SDK.</span></span>|
|<span data-ttu-id="21f04-204">**localname**</span><span class="sxs-lookup"><span data-stu-id="21f04-204">**localname**</span></span>|<span data-ttu-id="21f04-205">**nvarchar(max)**</span><span class="sxs-lookup"><span data-stu-id="21f04-205">**nvarchar(max)**</span></span>|<span data-ttu-id="21f04-206">요소 또는 특성의 로컬 이름을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-206">Gives the local name of the element or attribute.</span></span> <span data-ttu-id="21f04-207">DOM 개체에 이름이 없는 경우에는 NULL입니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-207">Is NULL if the DOM object does not have a name.</span></span>|
|<span data-ttu-id="21f04-208">**prefix**</span><span class="sxs-lookup"><span data-stu-id="21f04-208">**prefix**</span></span>|<span data-ttu-id="21f04-209">**nvarchar(max)**</span><span class="sxs-lookup"><span data-stu-id="21f04-209">**nvarchar(max)**</span></span>|<span data-ttu-id="21f04-210">노드 이름의 네임스페이스 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-210">Is the namespace prefix of the node name.</span></span>|
|<span data-ttu-id="21f04-211">**namespaceuri**</span><span class="sxs-lookup"><span data-stu-id="21f04-211">**namespaceuri**</span></span>|<span data-ttu-id="21f04-212">**nvarchar(max)**</span><span class="sxs-lookup"><span data-stu-id="21f04-212">**nvarchar(max)**</span></span>|<span data-ttu-id="21f04-213">노드의 네임스페이스 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-213">Is the namespace URI of the node.</span></span> <span data-ttu-id="21f04-214">값이 NULL이면 네임스페이스가 없는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-214">If the value is NULL, no namespace is present.</span></span>|
|<span data-ttu-id="21f04-215">**datatype**</span><span class="sxs-lookup"><span data-stu-id="21f04-215">**datatype**</span></span>|<span data-ttu-id="21f04-216">**nvarchar(max)**</span><span class="sxs-lookup"><span data-stu-id="21f04-216">**nvarchar(max)**</span></span>|<span data-ttu-id="21f04-217">요소 또는 특성 행의 실제 데이터 형식이며, 그렇지 않은 경우에는 NULL입니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-217">Is the actual data type of the element or attribute row and is otherwise NULL.</span></span> <span data-ttu-id="21f04-218">데이터 형식은 인라인 DTD 또는 인라인 스키마로부터 추정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-218">The data type is inferred from the inline DTD or from the inline schema.</span></span>|
|<span data-ttu-id="21f04-219">**prev**</span><span class="sxs-lookup"><span data-stu-id="21f04-219">**prev**</span></span>|<span data-ttu-id="21f04-220">**bigint**</span><span class="sxs-lookup"><span data-stu-id="21f04-220">**bigint**</span></span>|<span data-ttu-id="21f04-221">이전의 형제 요소에 대한 XML ID입니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-221">Is the XML ID of the previous sibling element.</span></span> <span data-ttu-id="21f04-222">바로 이전의 형제가 없으면 NULL입니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-222">Is NULL if there is no direct previous sibling.</span></span>|
|<span data-ttu-id="21f04-223">**text**</span><span class="sxs-lookup"><span data-stu-id="21f04-223">**text**</span></span>|<span data-ttu-id="21f04-224">**ntext**</span><span class="sxs-lookup"><span data-stu-id="21f04-224">**ntext**</span></span>|<span data-ttu-id="21f04-225">특성 값 또는 텍스트 형식의 요소 내용이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-225">Contains the attribute value or the element content in text form.</span></span> <span data-ttu-id="21f04-226">또는 Edge 테이블 항목에 값이 필요하지 않은 경우 NULL입니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-226">Or is NULL, if the edge table entry does not need a value.</span></span>|

#### <a name="using-the-with-clause-to-specify-an-existing-table"></a><span data-ttu-id="21f04-227">WITH 절을 사용하여 기존 테이블 지정</span><span class="sxs-lookup"><span data-stu-id="21f04-227">Using the WITH Clause to Specify an Existing Table</span></span>
 <span data-ttu-id="21f04-228">WITH 절을 사용하여 기존 테이블의 이름을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-228">You can use the WITH clause to specify the name of an existing table.</span></span> <span data-ttu-id="21f04-229">이렇게 하려면 행 집합을 생성하기 위해 OPENXML이 사용할 수 있는 스키마의 기존 테이블 이름만 지정하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-229">To do this, just specify an existing table name whose schema can be used by OPENXML to generate the rowset.</span></span>

#### <a name="using-the-with-clause-to-specify-a-schema"></a><span data-ttu-id="21f04-230">WITH 절을 사용하여 스키마 지정</span><span class="sxs-lookup"><span data-stu-id="21f04-230">Using the WITH Clause to Specify a Schema</span></span>
 <span data-ttu-id="21f04-231">WITH 절을 사용하여 완전한 스키마를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-231">You can use the WITH Clause to specify a complete schema.</span></span> <span data-ttu-id="21f04-232">행 집합 스키마를 지정할 때 열 이름과 그에 해당되는 데이터 형식 및 XML 문서에 대한 매핑을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-232">In specifying the rowset schema, you specify the column names, their data types, and their mapping to the XML document.</span></span>

 <span data-ttu-id="21f04-233">SchemaDeclaration에서 ColPattern 매개 변수를 사용하여 열 패턴을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-233">You can specify the column pattern by using the ColPattern parameter in the SchemaDeclaration.</span></span> <span data-ttu-id="21f04-234">지정된 열 패턴은 행 집합 열을 rowpattern에 의해 식별되는 XML 노드에 매핑할 뿐 아니라 매핑 유형을 결정하기 위해서도 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-234">The specified column pattern is used to map a rowset column to the XML node that is identified by rowpattern and is also used to determine the type of mapping.</span></span>

 <span data-ttu-id="21f04-235">열에 대해 ColPattern이 지정되지 않은 경우에는 *flags* 매개 변수로 지정된 매핑을 기준으로 동일한 이름을 갖는 XML 노드에 행 집합 열이 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-235">If ColPattern is not specified for a column, the rowset column maps to the XML node with the same name, based on the mapping specified by the *flags* parameter.</span></span> <span data-ttu-id="21f04-236">그러나 ColPattern이 WITH 절에서 스키마 지정의 일부로 지정된 경우에는 *flags* 매개 변수에 지정된 매핑을 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-236">However, if ColPattern is specified as part of the schema specification in the WITH clause, it overwrites the mapping that is specified in the *flags* parameter.</span></span>

### <a name="mapping-between-the-rowset-columns-and-the-xml-nodes"></a><span data-ttu-id="21f04-237">행 집합 열과 XML 노드 간의 매핑</span><span class="sxs-lookup"><span data-stu-id="21f04-237">Mapping Between the Rowset Columns and the XML Nodes</span></span>
 <span data-ttu-id="21f04-238">OPENXML 문에서는 행 집합 열과 *rowpattern*에 의해 식별된 XML 노드 간에 매핑 유형(특성 중심, 요소 중심)을 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-238">In the OPENXML statement, you can optionally specify the type of mapping, such as attribute-centric or element-centric, between the rowset columns and the XML nodes that are identified by the *rowpattern*.</span></span> <span data-ttu-id="21f04-239">이 정보는 XML 노드와 행 집합 열 간의 변환에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-239">This information is used in the transformation between the XML nodes and the rowset columns.</span></span>

 <span data-ttu-id="21f04-240">매핑은 다음 두 가지 방식으로 지정할 수 있으며 두 방식을 모두 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-240">You can specify the mapping in two ways, and you can also specify both:</span></span>

-   <span data-ttu-id="21f04-241">*flags* 매개 변수 사용</span><span class="sxs-lookup"><span data-stu-id="21f04-241">By using the *flags* parameter</span></span>

     <span data-ttu-id="21f04-242">*flags* 매개 변수로 지정되는 매핑은 XML 노드가 동일한 이름을 가진 해당 행 집합 열에 매핑되는 이름 일치를 전제로 합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-242">The mapping that is specified by the *flags* parameter assumes name correspondence in which the XML nodes map to the corresponding rowset columns with same name.</span></span>

-   <span data-ttu-id="21f04-243">*ColPattern* 매개 변수 사용</span><span class="sxs-lookup"><span data-stu-id="21f04-243">By using the *ColPattern* parameter</span></span>

     <span data-ttu-id="21f04-244">XPath 식인*ColPattern*은 WITH 절에서 *SchemaDeclaration* 의 일부로 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-244">*ColPattern*, an XPath expression, is specified as part of *SchemaDeclaration* in the WITH clause.</span></span> <span data-ttu-id="21f04-245">*ColPattern* 에 지정된 매핑은 *flags* 매개 변수로 지정된 매핑에 우선합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-245">The mapping specified in *ColPattern* overwrites the mapping specified by the *flags* parameter.</span></span>

     <span data-ttu-id="21f04-246">*ColPattern* 을 사용하면 *flags*로 표시된 기본 매핑을 덮어쓰거나 향상시키는 특성 중심이나 요소 중심과 같은 매핑 유형을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-246">*ColPattern* can be used to specify the type of mapping, such as attribute-centric or element-centric, that overwrites or enhances the default mapping indicated by the *flags*.</span></span>

     <span data-ttu-id="21f04-247">*ColPattern* 은 다음 상황에서 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-247">*ColPattern* is specified under the following circumstances:</span></span>

    -   <span data-ttu-id="21f04-248">행 집합의 열 이름이 매핑될 요소 또는 특성 이름과 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-248">The column name in the rowset is different from the element or attribute name to which it is mapped.</span></span> <span data-ttu-id="21f04-249">이 경우 *ColPattern* 을 사용하여 행 집합 열이 매핑될 XML 요소와 특성 이름을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-249">In this case, *ColPattern* is used to identify the XML element and attribute name to which the rowset column maps.</span></span>

    -   <span data-ttu-id="21f04-250">메타 속성 특성을 열에 매핑하려는 경우</span><span class="sxs-lookup"><span data-stu-id="21f04-250">You want to map a metaproperty attribute to the column.</span></span> <span data-ttu-id="21f04-251">이 경우 *ColPattern* 을 사용하여 행 집합 열이 매핑될 메타 속성을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-251">In this case, *ColPattern* is used to identify the metaproperty to which the rowset column maps.</span></span> <span data-ttu-id="21f04-252">메타 속성을 사용하는 방법에 대한 자세한 내용은 [OPENXML에 메타 속성 지정](../xml/specify-metaproperties-in-openxml.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="21f04-252">For more information about how to use metaproperties, see [Specify Metaproperties in OPENXML](../xml/specify-metaproperties-in-openxml.md).</span></span>

 <span data-ttu-id="21f04-253">*flags* 와 *ColPattern* 매개 변수는 모두 선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-253">Both the *flags* and *ColPattern* parameters are optional.</span></span> <span data-ttu-id="21f04-254">매핑을 지정하지 않으면 특성 중심 매핑으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-254">If no mapping is specified, attribute-centric mapping is assumed.</span></span> <span data-ttu-id="21f04-255">특성 중심 매핑은 *flags* 매개 변수의 기본값입니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-255">Attribute-centric mapping is the default value of the *flags* parameter.</span></span>

#### <a name="attribute-centric-mapping"></a><span data-ttu-id="21f04-256">특성 중심 매핑</span><span class="sxs-lookup"><span data-stu-id="21f04-256">Attribute-centric Mapping</span></span>
 <span data-ttu-id="21f04-257">OPENXML의 *flags* 매개 변수를 1(XML_ATTRIBUTES)로 설정하면 **특성 중심** 매핑이 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-257">Setting the *flags* parameter in OPENXML to 1 (XML_ATTRIBUTES) specifies **attribute-centric** mapping.</span></span> <span data-ttu-id="21f04-258">*flags* 에 XML_ATTRIBUTES가 포함된 경우 제공된 행 집합은 각 XML 요소가 하나의 행으로 표시되는 행을 제공하거나 소비합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-258">If *flags* contains XML_ ATTRIBUTES, the exposed rowset provides or consumes rows where each XML element is represented as a row.</span></span> <span data-ttu-id="21f04-259">XML 특성은 이름 일치 여부에 따라 SchemaDeclaration에 정의되어 있거나 WITH 절의 Tablename으로 제공되는 특성에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-259">The XML attributes are mapped to the attributes that are defined in the SchemaDeclaration or that are provided by the Tablename of the WITH clause, based on name correspondence.</span></span> <span data-ttu-id="21f04-260">이름 일치란 특정 이름의 XML 특성이 동일한 이름의 행 집합의 열로 저장되는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-260">Name correspondence means that the XML attributes of a particular name are stored in a column in the rowset with the same name.</span></span>

 <span data-ttu-id="21f04-261">열 이름이 매핑될 특성 이름과 다른 경우에는 *ColPattern* 을 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-261">If the column name is different from the attribute name that it maps to, *ColPattern* must be specified.</span></span>

 <span data-ttu-id="21f04-262">XML 특성에 네임스페이스 한정자가 있으면 행 집합의 열 이름에도 한정자가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-262">If the XML attribute has a namespace qualifier, the column name in the rowset must also have the qualifier.</span></span>

#### <a name="element-centric-mapping"></a><span data-ttu-id="21f04-263">요소 중심 매핑</span><span class="sxs-lookup"><span data-stu-id="21f04-263">Element-centric Mapping</span></span>
 <span data-ttu-id="21f04-264">OPENXML의 *flags* 매개 변수를 2(XML_ELEMENTS)로 설정하면 **요소 중심** 매핑이 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-264">Setting the *flags* parameter in OPENXML to 2 (XML_ELEMENTS) specifies **element-centric** mapping.</span></span> <span data-ttu-id="21f04-265">요소 중심 매핑은 다음 사항을 제외하고 **특성 중심** 매핑과 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-265">It is similar to **attribute-centric** mapping, except for the following differences:</span></span>

-   <span data-ttu-id="21f04-266">열 수준 패턴이 지정되지 않은 경우, 매핑 예의 이름 일치(동일한 이름의 XML 요소에 대한 열 매핑)는 복잡하지 않은 하위 요소를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-266">The name correspondence of the mapping example, a column mapping to an XML element with the same name chooses the noncomplex subelements, unless a column-level pattern is specified.</span></span> <span data-ttu-id="21f04-267">검색 프로세스에서 하위 요소가 복잡하면(하위 요소가 더 있는 경우) 해당 열이 NULL로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-267">In the retrieval process, if the subelement is complex because it contains additional subelements, the column is set to NULL.</span></span> <span data-ttu-id="21f04-268">하위 요소의 특성 값은 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-268">Attribute values of the subelements are then ignored.</span></span>

-   <span data-ttu-id="21f04-269">동일 이름의 하위 요소가 여러 개 있는 경우 첫 번째 노드가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="21f04-269">For multiple subelements that have the same name, the first node is returned.</span></span>

## <a name="see-also"></a><span data-ttu-id="21f04-270">참고 항목</span><span class="sxs-lookup"><span data-stu-id="21f04-270">See Also</span></span>
 <span data-ttu-id="21f04-271">transact-sql &#40;[OPENXML](/sql/t-sql/functions/openxml-transact-sql)&#41;Transact-sql &#40;[xml 데이터](../xml/xml-data-sql-server.md)&#41;&#40;SQL Server [&#40;transact-sql&#41;](/sql/relational-databases/system-stored-procedures/sp-xml-preparedocument-transact-sql) [sp_xml_removedocument&#41;](/sql/relational-databases/system-stored-procedures/sp-xml-removedocument-transact-sql) sp_xml_preparedocument</span><span class="sxs-lookup"><span data-stu-id="21f04-271">[sp_xml_preparedocument &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-xml-preparedocument-transact-sql) [sp_xml_removedocument &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-xml-removedocument-transact-sql) [OPENXML &#40;Transact-SQL&#41;](/sql/t-sql/functions/openxml-transact-sql) [XML Data &#40;SQL Server&#41;](../xml/xml-data-sql-server.md)</span></span>


