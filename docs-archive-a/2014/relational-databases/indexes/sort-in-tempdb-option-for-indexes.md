---
title: 인덱스에 대한 SORT_IN_TEMPDB 옵션 | Microsoft 문서
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: table-view-index
ms.topic: conceptual
helpviewer_keywords:
- SORT_IN_TEMPDB option
- disk space [SQL Server], indexes
- space [SQL Server], indexes
- tempdb database [SQL Server], indexes
- indexes [SQL Server], tempdb database
- index creation [SQL Server], tempdb database
ms.assetid: 754a003f-fe51-4d10-975a-f6b8c04ebd35
author: MikeRayMSFT
ms.author: mikeray
ms.openlocfilehash: 8feccc5b1d29617193f481569e10648c6ed77242
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87739934"
---
# <a name="sort_in_tempdb-option-for-indexes"></a><span data-ttu-id="d9802-102">인덱스에 대한 SORT_IN_TEMPDB 옵션</span><span class="sxs-lookup"><span data-stu-id="d9802-102">SORT_IN_TEMPDB Option For Indexes</span></span>
  <span data-ttu-id="d9802-103">인덱스를 만들거나 다시 만들 때 SORT_IN_TEMPDB 옵션을 ON으로 설정하면 [!INCLUDE[ssDEnoversion](../../includes/ssdenoversion-md.md)] 에서 **tempdb** 를 사용하여 인덱스를 만드는 데 사용되는 중간 정렬 결과를 저장하도록 지시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-103">When you create or rebuild an index, by setting the SORT_IN_TEMPDB option to ON you can direct the [!INCLUDE[ssDEnoversion](../../includes/ssdenoversion-md.md)] to use **tempdb** to store the intermediate sort results that are used to build the index.</span></span> <span data-ttu-id="d9802-104">이 옵션을 사용하면 인덱스를 만드는 데 사용되는 임시 디스크 공간이 늘어나지만 **tempdb** 가 사용자 데이터베이스와 다른 디스크 집합에 있을 때 인덱스를 만들거나 다시 만드는 데 필요한 시간이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-104">Although this option increases the amount of temporary disk space that is used to create an index, the option could reduce the time that is required to create or rebuild an index when **tempdb** is on a set of disks different from that of the user database.</span></span> <span data-ttu-id="d9802-105">**tempdb**에 대한 자세한 내용은 [인덱스 생성 메모리 서버 구성 옵션 구성](../../database-engine/configure-windows/configure-the-index-create-memory-server-configuration-option.md)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="d9802-105">For more information about **tempdb**, see [Configure the index create memory Server Configuration Option](../../database-engine/configure-windows/configure-the-index-create-memory-server-configuration-option.md).</span></span>  
  
## <a name="phases-of-index-building"></a><span data-ttu-id="d9802-106">인덱스를 만드는 단계</span><span class="sxs-lookup"><span data-stu-id="d9802-106">Phases of Index Building</span></span>  
 <span data-ttu-id="d9802-107">[!INCLUDE[ssDE](../../includes/ssde-md.md)] 에서 인덱스를 만들 때 다음 단계가 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-107">As the [!INCLUDE[ssDE](../../includes/ssde-md.md)] builds an index, it goes through the following phases:</span></span>  
  
-   <span data-ttu-id="d9802-108">먼저 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 은 기본 테이블의 데이터 페이지를 검색하여 키 값을 찾고 각 데이터 행의 인덱스 리프 행을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-108">The [!INCLUDE[ssDE](../../includes/ssde-md.md)] first scans the data pages of the base table to retrieve key values and builds an index leaf row for each data row.</span></span> <span data-ttu-id="d9802-109">내부 정렬 버퍼가 리프 인덱스 항목으로 채워지면 항목이 정렬되고 중간 정렬 실행으로 디스크에 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-109">When the internal sort buffers have been filled with leaf index entries, the entries are sorted and written to disk as an intermediate sort run.</span></span> <span data-ttu-id="d9802-110">그러면 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 은 정렬 버퍼가 다시 채워질 때까지 데이터 페이지 검색을 계속합니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-110">The [!INCLUDE[ssDE](../../includes/ssde-md.md)] then resumes the data page scan until the sort buffers are again filled.</span></span> <span data-ttu-id="d9802-111">기본 테이블의 모든 행이 처리될 때까지 이러한 여러 데이터 페이지의 검색 패턴에 따라 정렬이 수행되고 정렬 실행 쓰기가 계속됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-111">This pattern of scanning multiple data pages followed by sorting and writing a sort run continues until all the rows of the base table have been processed.</span></span>  
  
     <span data-ttu-id="d9802-112">클러스터형 인덱스에서 인덱스의 리프 행은 테이블의 데이터 행이므로 중간 정렬 실행은 모든 데이터 행을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-112">In a clustered index, the leaf rows of the index are the data rows of the table; therefore, the intermediate sort runs contain all the data rows.</span></span> <span data-ttu-id="d9802-113">비클러스터형 인덱스에서 리프 행은 키가 아닌 열을 포함할 수 있지만 일반적으로 클러스터형 인덱스보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-113">In a nonclustered index, the leaf rows may contain nonkey columns, but are generally smaller than a clustered index.</span></span> <span data-ttu-id="d9802-114">인덱스 키가 클 경우 또는 인덱스에 키가 아닌 열이 여러 개 포함된 경우 비클러스터형 정렬 실행이 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-114">If the index keys are large, or there are several nonkey columns included in the index, a nonclustered sort run can be large.</span></span> <span data-ttu-id="d9802-115">키가 아닌 열 포함에 대한 자세한 내용은 [Create Indexes with Included Columns](create-indexes-with-included-columns.md)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="d9802-115">For more information about including nonkey columns, see [Create Indexes with Included Columns](create-indexes-with-included-columns.md).</span></span>  
  
-   <span data-ttu-id="d9802-116">[!INCLUDE[ssDE](../../includes/ssde-md.md)] 은 정렬된 단일 스트림으로 인덱스 리프 행의 정렬된 실행을 병합합니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-116">The [!INCLUDE[ssDE](../../includes/ssde-md.md)] merges the sorted runs of index leaf rows into a single, sorted stream.</span></span> <span data-ttu-id="d9802-117">[!INCLUDE[ssDE](../../includes/ssde-md.md)] 의 정렬 병합 구성 요소는 각 정렬 실행의 첫 페이지에서 시작하여 모든 페이지에서 가장 낮은 키를 찾은 다음 인덱스 만들기 구성 요소에 리프 행을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-117">The sort merge component of the [!INCLUDE[ssDE](../../includes/ssde-md.md)] starts with the first page of each sort run, finds the lowest key in all the pages, and passes that leaf row to the index create component.</span></span> <span data-ttu-id="d9802-118">다음으로 가장 낮은 키를 처리하는 식으로 이 과정이 계속됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-118">The next lowest key is processed, and then the next, and so on.</span></span> <span data-ttu-id="d9802-119">마지막 리프 인덱스 행이 정렬 실행 페이지에서 추출되면 프로세스는 해당 정렬 실행에서 다음 페이지로 전환됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-119">When the last leaf index row is extracted from a sort run page, the process shifts to the next page from that sort run.</span></span> <span data-ttu-id="d9802-120">정렬 실행 익스텐트의 모든 페이지가 처리되면 익스텐트가 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-120">When all the pages in a sort run extent have been processed, the extent is freed.</span></span> <span data-ttu-id="d9802-121">각 리프 인덱스 행이 인덱스 만들기 구성 요소에 전달되면 버퍼의 리프 인덱스 페이지에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-121">As each leaf index row is passed to the index create component, it is included in a leaf index page in the buffer.</span></span> <span data-ttu-id="d9802-122">각 리프 페이지는 채워진 후에 쓰여집니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-122">Each leaf page is written as it is filled.</span></span> <span data-ttu-id="d9802-123">리프 페이지가 쓰여지면 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 도 인덱스의 상위 수준을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-123">As leaf pages are written, the [!INCLUDE[ssDE](../../includes/ssde-md.md)] also builds the upper levels of the index.</span></span> <span data-ttu-id="d9802-124">각 상위 수준 인덱스 페이지는 채워진 후에 쓰여집니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-124">Each upper level index page is written when it is filled.</span></span>  
  
## <a name="sort_in_tempdb-option"></a><span data-ttu-id="d9802-125">SORT_IN_TEMPDB 옵션</span><span class="sxs-lookup"><span data-stu-id="d9802-125">SORT_IN_TEMPDB Option</span></span>  
 <span data-ttu-id="d9802-126">SORT_IN_TEMPDB를 기본값인 OFF로 설정한 경우 기본적으로 정렬 실행은 대상 파일 그룹에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-126">When SORT_IN_TEMPDB is set to OFF, the default, the sort runs are stored in the destination filegroup.</span></span> <span data-ttu-id="d9802-127">인덱스를 만드는 첫째 단계 동안 기본 테이블 페이지의 읽기와 정렬 실행의 쓰기가 번갈아 수행되어 디스크의 한 영역에서 다른 영역으로 디스크 읽기/쓰기 헤드가 이동됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-127">During the first phase of creating the index, the alternating reads of the base table pages and writes of the sort runs move the disk read/write heads from one area of the disk to another.</span></span> <span data-ttu-id="d9802-128">이 헤드는 데이터 페이지가 검색될 때 데이터 페이지 영역에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-128">The heads are in the data page area as the data pages are scanned.</span></span> <span data-ttu-id="d9802-129">정렬 버퍼가 채워지고 현재 정렬 실행이 디스크에 쓰여져야 할 때 이러한 헤드는 빈 영역으로 이동했다가 테이블 페이지 검색이 다시 시작될 때 데이터 페이지 영역으로 다시 돌아갑니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-129">They move to an area of free space when the sort buffers fill and the current sort run has to be written to disk, and then move back to the data page area as the table page scan is resumed.</span></span> <span data-ttu-id="d9802-130">읽기/쓰기 헤드 이동은 둘째 단계에서 더 많이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-130">The read/write head movement is greater in the second phase.</span></span> <span data-ttu-id="d9802-131">이 단계에서 정렬 프로세스는 일반적으로 각 정렬 실행 영역을 번갈아 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-131">At that time the sort process is typically alternating reads from each sort run area.</span></span> <span data-ttu-id="d9802-132">대상 파일 그룹에 정렬 실행과 새 인덱스 페이지가 작성되는데</span><span class="sxs-lookup"><span data-stu-id="d9802-132">Both the sort runs and the new index pages are built in the destination filegroup.</span></span> <span data-ttu-id="d9802-133">이는 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 이 각 정렬 실행을 번갈아 읽으면서 동시에 주기적으로 인덱스 익스텐트로 점프하여 채워질 때 새 인덱스 페이지를 써야 함을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-133">This means that at the same time the [!INCLUDE[ssDE](../../includes/ssde-md.md)] is spreading reads across the sort runs, it has to periodically jump to the index extents to write new index pages as they are filled.</span></span>  
  
 <span data-ttu-id="d9802-134">SORT_IN_TEMPDB 옵션을 ON으로 설정하고 **tempdb** 가 대상 파일 그룹의 개별 디스크 집합에 있으면 첫째 단계 중에 데이터 페이지의 읽기는 **tempdb**의 정렬 작업 영역에 대한 쓰기와는 다른 디스크에서 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-134">If the SORT_IN_TEMPDB option is set to ON and **tempdb** is on a separate set of disks from the destination filegroup, during the first phase, the reads of the data pages occur on a different disk from the writes to the sort work area in **tempdb**.</span></span> <span data-ttu-id="d9802-135">그러므로 마지막 인덱스를 작성하기 위한 쓰기를 수행할 때 일반적으로 데이터 키의 디스크 읽기가 디스크에서 좀 더 연속적으로 진행되며 일반적으로 **tempdb** 디스크에 대한 쓰기 역시 연속적으로 진행됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-135">This means the disk reads of the data keys generally continue more serially across the disk, and the writes to the **tempdb** disk also are generally serial, as do the writes to build the final index.</span></span> <span data-ttu-id="d9802-136">다른 사용자가 해당 데이터베이스를 사용하고 별도의 디스크 주소를 액세스하는 경우에도 읽기 및 쓰기의 전반적인 패턴은 SORT_IN_TEMPDB가 지정되는 것이 지정되지 않을 때보다 좀 더 효율적으로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-136">Even if other users are using the database and accessing separate disk addresses, the overall pattern of reads and writes are more efficient when SORT_IN_TEMPDB is specified than when it is not.</span></span>  
  
 <span data-ttu-id="d9802-137">SORT_IN_TEMPDB 옵션은 특히 CREATE INDEX 작업이 병렬로 처리되지 않은 경우 인덱스 익스텐트의 근접성을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-137">The SORT_IN_TEMPDB option may improve the contiguity of index extents, especially if the CREATE INDEX operation is not being processed in parallel.</span></span> <span data-ttu-id="d9802-138">정렬 작업 영역 익스텐트는 데이터베이스에서 이 익스텐트가 차지하는 위치에 관계없이 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-138">The sort work area extents are freed on a somewhat random basis with regard to their location in the database.</span></span> <span data-ttu-id="d9802-139">정렬 작업 영역이 대상 파일 그룹에 포함된 경우 정렬 작업 익스텐트가 해제되면 익스텐트 구조가 작성될 때 인덱스 구조를 보유하기 위한 익스텐트 요청에 의해 정렬 작업 익스텐트가 확보될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-139">If the sort work areas are contained in the destination filegroup, as the sort work extents are freed, they can be acquired by the requests for extents to hold the index structure as it is built.</span></span> <span data-ttu-id="d9802-140">이로 인해 어느 수준까지 인덱스 익스텐트의 위치가 무작위로 지정될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-140">This can randomize the locations of the index extents to a degree.</span></span> <span data-ttu-id="d9802-141">정렬 익스텐트가 **tempdb**에 별도로 보관되는 경우 해제되는 순서는 인덱스 익스텐트의 위치에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-141">If the sort extents are held separately in **tempdb**, the sequence in which they are freed has no effect on the location of the index extents.</span></span> <span data-ttu-id="d9802-142">또한 중간 정렬 실행이 대상 파일 그룹 대신 **tempdb** 에 저장되면 대상 파일 그룹에 사용 가능한 공간이 더 많아지므로</span><span class="sxs-lookup"><span data-stu-id="d9802-142">Also, when the intermediate sort runs are stored in **tempdb** instead of the destination filegroup, there is more space available in the destination filegroup.</span></span> <span data-ttu-id="d9802-143">인덱스 익스텐트가 근접하게 될 확률이 높아집니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-143">This increases the chances that index extents will be contiguous.</span></span>  
  
 <span data-ttu-id="d9802-144">SORT_IN_TEMPDB 옵션은 현재 문에만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-144">The SORT_IN_TEMPDB option affects only the current statement.</span></span> <span data-ttu-id="d9802-145">인덱스가 **tempdb**에서 정렬되어 있는지 여부를 기록하는 메타데이터는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-145">No metadata records that the index was or was not sorted in **tempdb**.</span></span> <span data-ttu-id="d9802-146">예를 들어 SORT_IN_TEMPDB 옵션을 사용하여 비클러스터형 인덱스를 만들고 이후에 이 옵션을 지정하지 않고 클러스터형 인덱스를 만드는 경우 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 은 비클러스터형 인덱스를 다시 만들 때 이 옵션을 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-146">For example, if you create a nonclustered index using the SORT_IN_TEMPDB option, and at a later time create a clustered index without specifying the option, the [!INCLUDE[ssDE](../../includes/ssde-md.md)] does not use the option when it re-creates the nonclustered index.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="d9802-147">정렬 작업이 필요하지 않거나 메모리에서 정렬을 수행할 수 있으면 SORT_IN_TEMPDB 옵션이 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-147">If a sort operation is not required or if the sort can be performed in memory, the SORT_IN_TEMPDB option is ignored.</span></span>  
  
## <a name="disk-space-requirements"></a><span data-ttu-id="d9802-148">디스크 공간 요구 사항</span><span class="sxs-lookup"><span data-stu-id="d9802-148">Disk Space Requirements</span></span>  
 <span data-ttu-id="d9802-149">SORT_IN_TEMPDB 옵션을 ON으로 설정하면 **tempdb** 에는 중간 정렬 실행을 보관하기 위한 충분한 빈 디스크 공간이 있어야 하며 대상 파일 그룹에는 새 인덱스를 보관하기 위한 충분한 빈 디스크 공간이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-149">When you set the SORT_IN_TEMPDB option to ON, you must have sufficient free disk space available in **tempdb** to hold the intermediate sort runs, and enough free disk space in the destination filegroup to hold the new index.</span></span> <span data-ttu-id="d9802-150">빈 공간이 충분하지 않고, 디스크에 공간이 없거나 자동 증가 옵션이 해제된 경우처럼 데이터베이스가 자동 증가되어 더 많은 공간을 확보하지 못하는 경우 CREATE INDEX 문은 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-150">The CREATE INDEX statement fails if there is insufficient free space and there is some reason the databases cannot autogrow to acquire more space, such as no space on the disk or autogrow is set to off.</span></span>  
  
 <span data-ttu-id="d9802-151">SORT_IN_TEMPDB를 OFF로 설정한 경우 대상 파일 그룹의 빈 디스크 공간은 최종 인덱스의 크기와 거의 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-151">If SORT_IN_TEMPDB is set to OFF, the available free disk space in the destination filegroup must be roughly the size of the final index.</span></span> <span data-ttu-id="d9802-152">첫째 단계에서 정렬 실행이 작성되고 최종 인덱스와 거의 같은 양의 공간이 요구됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-152">During the first phase, the sort runs are built and require about the same amount of space as the final index.</span></span> <span data-ttu-id="d9802-153">둘째 단계에서 각 정렬 실행 익스텐트는 처리된 후 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-153">During the second phase, each sort run extent is freed after it has been processed.</span></span> <span data-ttu-id="d9802-154">따라서 정렬 실행 익스텐트가 최종 인덱스 페이지를 보유하기 위해 익스텐트가 확보되는 비율과 거의 동일한 비율로 해제되므로 전반적인 공간 요구 사항은 최종 인덱스의 크기를 많이 초과하지 않게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-154">This means that sort run extents are freed at about the same rate at which extents are acquired to hold the final index pages; therefore, the overall space requirements do not greatly exceed the size of the final index.</span></span> <span data-ttu-id="d9802-155">이로 인해 발생하는 한 가지 부작용은 빈 공간의 양이 최종 인덱스의 크기와 아주 근접할 경우 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 은 일반적으로 정렬 실행 익스텐트가 해제되자마자 이 정렬 실행 익스텐트를 다시 사용한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-155">One side effect of this is that if the amount of free space is very close to the size of the final index, the [!INCLUDE[ssDE](../../includes/ssde-md.md)] will generally reuse the sort run extents very quickly after they are freed.</span></span> <span data-ttu-id="d9802-156">정렬 실행 익스텐트는 무작위로 해제되므로 이 시나리오에 해당하는 인덱스 익스텐트의 근접성을 감소시킵니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-156">Because the sort run extents are freed in a somewhat random manner, this reduces the continuity of the index extents in this scenario.</span></span> <span data-ttu-id="d9802-157">SORT_IN_TEMPDB를 OFF로 설정하면 새롭게 할당 취소된 정렬 실행 익스텐트가 아니라 연속된 풀에서 인덱스 익스텐트를 할당할 수 있도록 대상 파일 그룹에 충분한 빈 공간이 있을 경우 인덱스 익스텐트의 근접성이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-157">If SORT_IN_TEMPDB is set to OFF, the continuity of the index extents is improved if there is sufficient free space available in the destination filegroup that the index extents can be allocated from a contiguous pool instead of from the freshly deallocated sort run extents.</span></span>  
  
 <span data-ttu-id="d9802-158">비클러스터형 인덱스를 만들 때 다음과 같이 사용 가능한 공간이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-158">When you create a nonclustered index, you must have available as free space:</span></span>  
  
-   <span data-ttu-id="d9802-159">SORT_IN_TEMPDB를 ON으로 설정한 경우 **tempdb** 에는 정렬 실행을 저장하기 위한 충분한 사용 가능한 공간이 있어야 하며 대상 파일 그룹에는 최종 인덱스 구조를 저장하기 위한 충분한 빈 공간이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-159">If SORT_IN_TEMPDB is set to ON, there must be sufficient free space in **tempdb** to store the sort runs, and sufficient free space in the destination filegroup to store the final index structure.</span></span> <span data-ttu-id="d9802-160">정렬 실행은 인덱스의 리프 행을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-160">The sort runs contain the leaf rows of the index.</span></span>  
  
-   <span data-ttu-id="d9802-161">SORT_IN_TEMPDB를 OFF로 설정한 경우 대상 파일 그룹에는 최종 인덱스 구조를 저장하기 위한 빈 공간이 충분히 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-161">If SORT_IN_TEMPDB is set to OFF, the free space in the destination filegroup must be large enough to store the final index structure.</span></span> <span data-ttu-id="d9802-162">인덱스 익스텐트의 근접성은 사용 가능한 빈 공간이 늘어날 때 향상될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-162">The continuity of the index extends may be improved if more free space is available.</span></span>  
  
 <span data-ttu-id="d9802-163">비클러스터형 인덱스가 없는 테이블에 클러스터형 인덱스를 만드는 경우 다음과 같이 사용 가능한 공간이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-163">When you create a clustered index on a table that does not have nonclustered indexes, you must have available as free space:</span></span>  
  
-   <span data-ttu-id="d9802-164">SORT_IN_TEMPDB를 ON으로 설정한 경우 **tempdb** 에는 정렬 실행을 저장하기 위한 사용 가능한 공간이 충분히 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-164">If SORT_IN_TEMPDB is set to ON, there must be sufficient free space in **tempdb** to store the sort runs.</span></span> <span data-ttu-id="d9802-165">여기에는 테이블의 데이터 행이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-165">These include the data rows of the table.</span></span> <span data-ttu-id="d9802-166">대상 파일 그룹에는 최종 인덱스 구조를 저장하기 위한 충분한 빈 공간이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-166">There must be sufficient free space in the destination filegroup to store the final index structure.</span></span> <span data-ttu-id="d9802-167">여기에는 테이블의 데이터 행과 인덱스 B-트리가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-167">This includes the data rows of the table and the index B-tree.</span></span> <span data-ttu-id="d9802-168">키 크기를 크게 사용하거나 채우기 비율을 낮은 값으로 설정하는 등 예상 계수를 조정해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-168">You may have to adjust the estimate for factors such as having a large key size or a fill factor with a low value.</span></span>  
  
-   <span data-ttu-id="d9802-169">SORT_IN_TEMPDB를 OFF로 설정한 경우 대상 파일 그룹에는 최종 테이블을 저장하기 위한 빈 공간이 충분히 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-169">If SORT_IN_TEMPDB is set to OFF, the free space in the destination filegroup must be large enough to store the final table.</span></span> <span data-ttu-id="d9802-170">여기에는 인덱스 구조가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-170">This includes the index structure.</span></span> <span data-ttu-id="d9802-171">테이블 및 인덱스 익스텐트의 근접성은 사용 가능한 빈 공간이 늘어날 때 향상될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-171">The continuity of the table and index extents may be improved if more free space is available.</span></span>  
  
 <span data-ttu-id="d9802-172">비클러스터형 인덱스가 있는 테이블에 클러스터형 인덱스를 만드는 경우 사용 가능한 공간이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-172">When you create a clustered index on a table that has nonclustered indexes, you must have available as free space:</span></span>  
  
-   <span data-ttu-id="d9802-173">SORT_IN_TEMPDB를 ON으로 설정한 경우 **tempdb** 에는 가장 큰 인덱스(일반적으로 클러스터형 인덱스)의 정렬 실행 집합을 저장하기 위한 충분한 빈 공간이 있어야 하며 대상 파일 그룹에는 모든 인덱스의 최종 구조를 저장하기 위한 충분한 빈 공간이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-173">If SORT_IN_TEMPDB is set to ON, there must be sufficient free space in **tempdb** to store the collection of sort runs for the largest index, typically the clustered index, and sufficient free space in the destination filegroup to store the final structures of all the indexes.</span></span> <span data-ttu-id="d9802-174">여기에는 테이블의 데이터 행이 있는 클러스터형 인덱스가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-174">This includes the clustered index that contains the data rows of the table.</span></span>  
  
-   <span data-ttu-id="d9802-175">SORT_IN_TEMPDB를 OFF로 설정한 경우 대상 파일 그룹에는 최종 테이블을 저장하기 위한 빈 공간이 충분히 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-175">If SORT_IN_TEMPDB is set to OFF, the free space in the destination filegroup must be large enough to store the final table.</span></span> <span data-ttu-id="d9802-176">여기에는 모든 인덱스의 구조가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-176">This includes the structures of all the indexes.</span></span> <span data-ttu-id="d9802-177">테이블 및 인덱스 익스텐트의 근접성은 사용 가능한 빈 공간이 늘어날 때 향상될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d9802-177">The continuity of the table and index extents may be improved if more free space is available.</span></span>  
  
## <a name="related-tasks"></a><span data-ttu-id="d9802-178">관련 작업</span><span class="sxs-lookup"><span data-stu-id="d9802-178">Related Tasks</span></span>  
 [<span data-ttu-id="d9802-179">CREATE INDEX&#40;Transact-SQL&#41;</span><span class="sxs-lookup"><span data-stu-id="d9802-179">CREATE INDEX &#40;Transact-SQL&#41;</span></span>](/sql/t-sql/statements/create-index-transact-sql)  
  
 [<span data-ttu-id="d9802-180">인덱스 다시 구성 및 다시 작성</span><span class="sxs-lookup"><span data-stu-id="d9802-180">Reorganize and Rebuild Indexes</span></span>](indexes.md)  
  
## <a name="related-content"></a><span data-ttu-id="d9802-181">관련 내용</span><span class="sxs-lookup"><span data-stu-id="d9802-181">Related Content</span></span>  
 [<span data-ttu-id="d9802-182">ALTER INDEX&#40;Transact-SQL&#41;</span><span class="sxs-lookup"><span data-stu-id="d9802-182">ALTER INDEX &#40;Transact-SQL&#41;</span></span>](/sql/t-sql/statements/alter-index-transact-sql)  
  
 [<span data-ttu-id="d9802-183">인덱스 생성 메모리 서버 구성 옵션 구성</span><span class="sxs-lookup"><span data-stu-id="d9802-183">Configure the index create memory Server Configuration Option</span></span>](../../database-engine/configure-windows/configure-the-index-create-memory-server-configuration-option.md)  
  
 [<span data-ttu-id="d9802-184">인덱스 DDL 작업의 디스크 공간 요구 사항</span><span class="sxs-lookup"><span data-stu-id="d9802-184">Disk Space Requirements for Index DDL Operations</span></span>](disk-space-requirements-for-index-ddl-operations.md)  
  
  
