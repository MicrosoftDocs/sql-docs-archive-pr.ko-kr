---
title: 클러스터형 및 비클러스터형 인덱스 소개 | Microsoft 문서
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: table-view-index
ms.topic: conceptual
helpviewer_keywords:
- query optimizer [SQL Server], index usage
- index concepts [SQL Server]
ms.assetid: b7d6b323-728d-4763-a987-92e6292f6f7a
author: MikeRayMSFT
ms.author: mikeray
ms.openlocfilehash: c9eb51a24000b8af4a466fe4330644a722ad325b
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87740968"
---
# <a name="clustered-and-nonclustered-indexes-described"></a><span data-ttu-id="3b33a-102">클러스터형 및 비클러스터형 인덱스 소개</span><span class="sxs-lookup"><span data-stu-id="3b33a-102">Clustered and Nonclustered Indexes Described</span></span>
  <span data-ttu-id="3b33a-103">인덱스는 테이블이나 뷰와 관련된 디스크상 구조로서 테이블이나 뷰의 행 검색 속도를 향상시킵니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-103">An index is an on-disk structure associated with a table or view that speeds retrieval of rows from the table or view.</span></span> <span data-ttu-id="3b33a-104">인덱스에는 테이블이나 뷰에 있는 하나 이상의 열로 작성되는 키가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-104">An index contains keys built from one or more columns in the table or view.</span></span> <span data-ttu-id="3b33a-105">이러한 키는 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 에서 키 값과 연결된 행을 빠르고 효율적으로 찾을 수 있는 구조(B-트리)에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-105">These keys are stored in a structure (B-tree) that enables [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] to find the row or rows associated with the key values quickly and efficiently.</span></span>  
  
 <span data-ttu-id="3b33a-106">테이블이나 뷰에 포함할 수 있는 인덱스 유형은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-106">A table or view can contain the following types of indexes:</span></span>  
  
-   <span data-ttu-id="3b33a-107">클러스터형</span><span class="sxs-lookup"><span data-stu-id="3b33a-107">Clustered</span></span>  
  
    -   <span data-ttu-id="3b33a-108">클러스터형 인덱스는 해당 키 값을 기반으로 테이블이나 뷰의 데이터 행을 정렬하고 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-108">Clustered indexes sort and store the data rows in the table or view based on their key values.</span></span> <span data-ttu-id="3b33a-109">인덱스 정의에 여러 열이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-109">These are the columns included in the index definition.</span></span> <span data-ttu-id="3b33a-110">데이터 행 자체는 한 가지 순서로만 정렬될 수 있으므로 테이블당 클러스터형 인덱스는 하나만 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-110">There can be only one clustered index per table, because the data rows themselves can be sorted in only one order.</span></span>  
  
    -   <span data-ttu-id="3b33a-111">테이블의 데이터 행이 정렬된 순서로 저장될 때만 테이블에 클러스터형 인덱스가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-111">The only time the data rows in a table are stored in sorted order is when the table contains a clustered index.</span></span> <span data-ttu-id="3b33a-112">클러스터형 인덱스가 포함된 테이블을 클러스터형 테이블이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-112">When a table has a clustered index, the table is called a clustered table.</span></span> <span data-ttu-id="3b33a-113">테이블에 클러스터형 인덱스가 없으면 해당 데이터 행은 힙이라는 정렬되지 않은 _구조로 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-113">If a table has no clustered index, its data rows are stored in an unordered structure called a heap.</span></span>  
  
-   <span data-ttu-id="3b33a-114">비클러스터형 인덱스</span><span class="sxs-lookup"><span data-stu-id="3b33a-114">Nonclustered</span></span>  
  
    -   <span data-ttu-id="3b33a-115">비클러스터형 인덱스의 구조는 데이터 행으로부터 독립적입니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-115">Nonclustered indexes have a structure separate from the data rows.</span></span> <span data-ttu-id="3b33a-116">비클러스터형 인덱스에는 비클러스터형 인덱스 키 값이 있으며 각 키 값 항목에는 해당 키 값이 포함된 데이터 행에 대한 포인터가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-116">A nonclustered index contains the nonclustered index key values and each key value entry has a pointer to the data row that contains the key value.</span></span>  
  
    -   <span data-ttu-id="3b33a-117">비클러스터형 인덱스의 인덱스 행에서 데이터 행으로의 포인터를 행 로케이터라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-117">The pointer from an index row in a nonclustered index to a data row is called a row locator.</span></span> <span data-ttu-id="3b33a-118">행 로케이터의 구조는 데이터 페이지가 힙에 저장되는지 아니면 클러스터형 테이블에 저장되는지에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-118">The structure of the row locator depends on whether the data pages are stored in a heap or a clustered table.</span></span> <span data-ttu-id="3b33a-119">힙의 경우 행 로케이터는 행에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-119">For a heap, a row locator is a pointer to the row.</span></span> <span data-ttu-id="3b33a-120">클러스터형 테이블의 경우 행 로케이터는 클러스터형 인덱스 키입니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-120">For a clustered table, the row locator is the clustered index key.</span></span>  
  
    -   <span data-ttu-id="3b33a-121">클러스터형 인덱스의 리프 수준에 키가 아닌 열을 추가하여 기존 키 제한(900바이트 및 16개 키 열)을 무시하고 완전히 포괄되는 인덱싱된 쿼리를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-121">You can add nonkey columns to the leaf level of the nonclustered index to by-pass existing index key limits, 900 bytes and 16 key columns, and execute fully covered, indexed, queries.</span></span> <span data-ttu-id="3b33a-122">자세한 내용은 [Create Indexes with Included Columns](create-indexes-with-included-columns.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3b33a-122">For more information, see [Create Indexes with Included Columns](create-indexes-with-included-columns.md).</span></span>  
  
 <span data-ttu-id="3b33a-123">클러스터형 인덱스와 비클러스터형 인덱스 모두 고유 인덱스가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-123">Both clustered and nonclustered indexes can be unique.</span></span> <span data-ttu-id="3b33a-124">이 경우 두 행에 인덱스 키에 대한 동일한 값이 있을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-124">This means no two rows can have the same value for the index key.</span></span> <span data-ttu-id="3b33a-125">동일한 값이 있다면 인덱스는 고유하지 않으며 여러 행에서 동일한 키 값을 공유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-125">Otherwise, the index is not unique and multiple rows can share the same key value.</span></span> <span data-ttu-id="3b33a-126">자세한 내용은 [고유 인덱스 만들기](create-unique-indexes.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3b33a-126">For more information, see [Create Unique Indexes](create-unique-indexes.md).</span></span>  
  
 <span data-ttu-id="3b33a-127">테이블 데이터가 수정될 때마다 테이블이나 뷰에 대한 인덱스가 자동으로 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-127">Indexes are automatically maintained for a table or view whenever the table data is modified.</span></span>  
  
 <span data-ttu-id="3b33a-128">다른 유형의 특수 목적 인덱스에 대한 자세한 내용은 [Indexes](indexes.md) 를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="3b33a-128">See [Indexes](indexes.md) for additional types of special purpose indexes.</span></span>  
  
## <a name="indexes-and-constraints"></a><span data-ttu-id="3b33a-129">인덱스 및 제약 조건</span><span class="sxs-lookup"><span data-stu-id="3b33a-129">Indexes and Constraints</span></span>  
 <span data-ttu-id="3b33a-130">테이블 열에 PRIMARY KEY 및 UNIQUE 제약 조건을 정의하면 인덱스가 자동으로 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-130">Indexes are automatically created when PRIMARY KEY and UNIQUE constraints are defined on table columns.</span></span> <span data-ttu-id="3b33a-131">예를 들어 테이블을 만들고 특정 열을 기본 키로 지정하면 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 에서 자동으로 해당 열에 대한 인덱스와 PRIMARY KEY 제약 조건이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-131">For example, when you create a table and identify a particular column to be the primary key, the [!INCLUDE[ssDE](../../includes/ssde-md.md)] automatically creates a PRIMARY KEY constraint and index on that column.</span></span> <span data-ttu-id="3b33a-132">자세한 내용은 [Create Primary Keys](../tables/create-primary-keys.md) 및 [Create Unique Constraints](../tables/create-unique-constraints.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3b33a-132">For more information, see [Create Primary Keys](../tables/create-primary-keys.md) and [Create Unique Constraints](../tables/create-unique-constraints.md).</span></span>  
  
## <a name="how-indexes-are-used-by-the-query-optimizer"></a><span data-ttu-id="3b33a-133">쿼리 최적화 프로그램의 인덱스 사용 방법</span><span class="sxs-lookup"><span data-stu-id="3b33a-133">How Indexes Are Used by the Query Optimizer</span></span>  
 <span data-ttu-id="3b33a-134">인덱스를 잘 디자인하면 디스크 I/O 작업과 시스템 리소스 사용을 줄일 수 있으므로 쿼리 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-134">Well-designed indexes can reduce disk I/O operations and consume fewer system resources therefore improving query performance.</span></span> <span data-ttu-id="3b33a-135">인덱스는 SELECT, UPDATE, DELETE 또는 MERGE 문을 포함하는 다양한 쿼리에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-135">Indexes can be helpful for a variety of queries that contain SELECT, UPDATE, DELETE, or MERGE statements.</span></span> <span data-ttu-id="3b33a-136">`SELECT Title, HireDate FROM HumanResources.Employee WHERE EmployeeID = 250` 데이터베이스의 [!INCLUDE[ssSampleDBobject](../../includes/sssampledbobject-md.md)] 을 예로 들어 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-136">Consider the query `SELECT Title, HireDate FROM HumanResources.Employee WHERE EmployeeID = 250` in the [!INCLUDE[ssSampleDBobject](../../includes/sssampledbobject-md.md)] database.</span></span> <span data-ttu-id="3b33a-137">이 쿼리가 실행될 때 쿼리 최적화 프로그램은 데이터 검색에 사용할 수 있는 각 방법을 평가하고 가장 효율적인 방법을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-137">When this query is executed, the query optimizer evaluates each available method for retrieving the data and selects the most efficient method.</span></span> <span data-ttu-id="3b33a-138">이때 테이블 검색이 선택될 수 있습니다. 가능한 경우 하나 이상의 인덱스 검색이 선택될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-138">The method may be a table scan, or may be scanning one or more indexes if they exist.</span></span>  
  
 <span data-ttu-id="3b33a-139">테이블 검색을 수행할 때 쿼리 최적화 프로그램은 테이블의 모든 행을 읽고 쿼리 조건에 맞는 행을 추출합니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-139">When performing a table scan, the query optimizer reads all the rows in the table, and extracts the rows that meet the criteria of the query.</span></span> <span data-ttu-id="3b33a-140">테이블 검색은 많은 디스크 I/O 작업을 생성하고 리소스를 많이 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-140">A table scan generates many disk I/O operations and can be resource intensive.</span></span> <span data-ttu-id="3b33a-141">그러나 예를 들어 쿼리 결과 집합의 행이 테이블에서 높은 비율을 차지할 경우 테이블 검색이 가장 효율적인 방법일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-141">However, a table scan could be the most efficient method if, for example, the result set of the query is a high percentage of rows from the table.</span></span>  
  
 <span data-ttu-id="3b33a-142">쿼리 최적화 프로그램은 인덱스 키 열을 검색하고 쿼리에 필요한 행의 스토리지 위치를 찾은 후 해당 위치에서 일치하는 행을 추출하는 방식으로 인덱스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-142">When the query optimizer uses an index, it searches the index key columns, finds the storage location of the rows needed by the query and extracts the matching rows from that location.</span></span> <span data-ttu-id="3b33a-143">일반적으로 인덱스 검색이 테이블 검색보다 훨씬 빠릅니다. 이는 테이블과 달리 인덱스는 행당 열 수가 매우 적고 행이 정렬되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-143">Generally, searching the index is much faster than searching the table because unlike a table, an index frequently contains very few columns per row and the rows are in sorted order.</span></span>  
  
 <span data-ttu-id="3b33a-144">쿼리 최적화 프로그램은 일반적으로 쿼리 실행 시 가장 효율적인 방법을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-144">The query optimizer typically selects the most efficient method when executing queries.</span></span> <span data-ttu-id="3b33a-145">그러나 사용 가능한 인덱스가 없을 경우 쿼리 최적화 프로그램은 테이블 검색을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-145">However, if no indexes are available, the query optimizer must use a table scan.</span></span> <span data-ttu-id="3b33a-146">쿼리 최적화 프로그램에서 선택할 수 있는 효율적인 인덱스가 충분하도록 하려면 환경에 가장 적합한 인덱스를 여러 개 디자인하고 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-146">Your task is to design and create indexes that are best suited to your environment so that the query optimizer has a selection of efficient indexes from which to select.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="3b33a-147">제공하는 [데이터베이스 엔진 튜닝 관리자](../performance/database-engine-tuning-advisor.md) 를 사용하면 데이터베이스 환경을 분석하고 적절한 인덱스를 선택하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3b33a-147">provides the [Database Engine Tuning Advisor](../performance/database-engine-tuning-advisor.md) to help with the analysis of your database environment and in the selection of appropriate indexes.</span></span>  
  
## <a name="related-tasks"></a><span data-ttu-id="3b33a-148">관련 작업</span><span class="sxs-lookup"><span data-stu-id="3b33a-148">Related Tasks</span></span>  
 [<span data-ttu-id="3b33a-149">클러스터형 인덱스 만들기</span><span class="sxs-lookup"><span data-stu-id="3b33a-149">Create Clustered Indexes</span></span>](create-clustered-indexes.md)  
  
 [<span data-ttu-id="3b33a-150">비클러스터형 인덱스 만들기</span><span class="sxs-lookup"><span data-stu-id="3b33a-150">Create Nonclustered Indexes</span></span>](create-nonclustered-indexes.md)  
  
  
