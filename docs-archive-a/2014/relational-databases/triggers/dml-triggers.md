---
title: DML 트리거 | Microsoft 문서
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
helpviewer_keywords:
- triggers [SQL Server], about triggers
- DML triggers, about DML triggers
- triggers [SQL Server]
ms.assetid: 298eafca-e01f-4707-8c29-c75546fcd6b0
author: rothja
ms.author: jroth
ms.openlocfilehash: 7fb2e5e85c9479726fe38e02721186a0723a2ec8
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87660401"
---
# <a name="dml-triggers"></a><span data-ttu-id="5546a-102">DML 트리거</span><span class="sxs-lookup"><span data-stu-id="5546a-102">DML Triggers</span></span>
  <span data-ttu-id="5546a-103">DML 트리거는 트리거에 정의된 테이블 또는 뷰에 영향을 주는 DML(데이터 조작 언어) 이벤트가 실행될 때 자동으로 적용되는 특별한 유형의 저장 프로시저입니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-103">DML triggers is a special type of stored procedure that automatically takes effect when a data manipulation language (DML) event takes place that affects the table or view defined in the trigger.</span></span> <span data-ttu-id="5546a-104">DML 이벤트에는 INSERT, UPDATE 또는 DELETE 문이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-104">DML events include INSERT, UPDATE, or DELETE statements.</span></span> <span data-ttu-id="5546a-105">DML 트리거를 사용하여 비즈니스 규칙과 데이터 무결성을 적용하고, 다른 테이블을 쿼리하고, 복잡한 [!INCLUDE[tsql](../../includes/tsql-md.md)] 문을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-105">DML triggers can be used to enforce business rules and data integrity, query other tables, and include complex [!INCLUDE[tsql](../../includes/tsql-md.md)] statements.</span></span> <span data-ttu-id="5546a-106">트리거 및 트리거를 시작하는 문은 트리거 내에서 롤백할 수 있는 단일 트랜잭션으로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-106">The trigger and the statement that fires it are treated as a single transaction, which can be rolled back from within the trigger.</span></span> <span data-ttu-id="5546a-107">디스크 공간 부족 등의 심각한 오류가 발견되면 전체 트랜잭션이 자동으로 롤백됩니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-107">If a severe error is detected (for example, insufficient disk space), the entire transaction automatically rolls back.</span></span>  
  
## <a name="dml-trigger-benefits"></a><span data-ttu-id="5546a-108">DML 트리거의 이점</span><span class="sxs-lookup"><span data-stu-id="5546a-108">DML Trigger Benefits</span></span>  
 <span data-ttu-id="5546a-109">DML 트리거는 엔터티 무결성 또는 도메인 무결성을 적용할 수 있다는 점에서 제약 조건과 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-109">DML triggers are similar to constraints in that they can enforce entity integrity or domain integrity.</span></span> <span data-ttu-id="5546a-110">일반적으로 PRIMARY KEY 및 UNIQUE 제약 조건의 일부가 되거나 제약 조건과 상관없이 생성되는 인덱스는 가장 낮은 수준에서 항상 엔터티 무결성이 강제 적용되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-110">In general, entity integrity should always be enforced at the lowest level by indexes that are part of PRIMARY KEY and UNIQUE constraints or are created independently of constraints.</span></span> <span data-ttu-id="5546a-111">도메인 무결성은 CHECK 제약 조건을 통해 강제 적용되어야 하고, 참조 무결성(RI)은 FOREIGN KEY 제약 조건을 통해 강제 적용되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-111">Domain integrity should be enforced through CHECK constraints, and referential integrity (RI) should be enforced through FOREIGN KEY constraints.</span></span> <span data-ttu-id="5546a-112">DML 트리거는 제약 조건에서 지원하는 기능이 애플리케이션에서 필요한 기능을 수행하지 못할 때 가장 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-112">DML triggers are most useful when the features supported by constraints cannot meet the functional needs of the application.</span></span>  
  
 <span data-ttu-id="5546a-113">다음 목록에서는 DML 트리거를 제약 조건과 비교하고 DML 트리거의 이점을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-113">The following list compares DML triggers with constraints and identifies when DML triggers have benefits over .</span></span>  
  
-   <span data-ttu-id="5546a-114">DML 트리거는 데이터베이스의 관련 테이블을 통해 변경 내용을 연계할 수 있습니다. 그러나 연계 참조 무결성 제약 조건을 사용하면 더 효율적으로 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-114">DML triggers can cascade changes through related tables in the database; however, these changes can be executed more efficiently using cascading referential integrity constraints.</span></span> <span data-ttu-id="5546a-115">REFERENCES 절이 연계 참조 동작을 정의하지 않으면 FOREIGN KEY 제약 조건은 다른 열의 값과 정확히 일치하는 열 값에 대해서만 유효성을 검사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-115">FOREIGN KEY constraints can validate a column value only with an exact match to a value in another column, unless the REFERENCES clause defines a cascading referential action.</span></span>  
  
-   <span data-ttu-id="5546a-116">DML 트리거는 악의적이거나 잘못된 INSERT, UPDATE 및 DELETE 작업으로부터 보호하며 CHECK 제약 조건으로 정의하는 것보다 복잡한 다른 제약 조건을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-116">They can guard against malicious or incorrect INSERT, UPDATE, and DELETE operations and enforce other restrictions that are more complex than those defined with CHECK constraints.</span></span>  
  
     <span data-ttu-id="5546a-117">CHECK 제약 조건과 달리 DML 트리거는 다른 테이블의 열을 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-117">Unlike CHECK constraints, DML triggers can reference columns in other tables.</span></span> <span data-ttu-id="5546a-118">예를 들어 트리거는 다른 테이블에서 SELECT 문을 사용하여 삽입되거나 업데이트된 데이터와 비교하고 데이터 수정 또는 사용자 정의 오류 메시지 표시 등의 추가 동작을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-118">For example, a trigger can use a SELECT from another table to compare to the inserted or updated data and to perform additional actions, such as modify the data or display a user-defined error message.</span></span>  
  
-   <span data-ttu-id="5546a-119">데이터 수정 전후의 테이블 상태를 평가하고 이 차이점에 따라 동작을 수행할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-119">They can evaluate the state of a table before and after a data modification and take actions based on that difference.</span></span>  
  
-   <span data-ttu-id="5546a-120">테이블에 같은 유형(INSERT, UPDATE 또는 DELETE)의 DML 트리거를 여러 개 만들면 같은 수정 문이 실행될 때 여러 다른 동작을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-120">Multiple DML triggers of the same type (INSERT, UPDATE, or DELETE) on a table allow multiple, different actions to take place in response to the same modification statement.</span></span>  
  
-   <span data-ttu-id="5546a-121">제약 조건은 표준화된 시스템 오류 메시지를 통해서만 오류를 알립니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-121">Constraints can communicate about errors only through standardized system error messages.</span></span> <span data-ttu-id="5546a-122">애플리케이션에서 사용자 지정 메시지와 더 복잡한 오류 처리가 필요하면 트리거를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-122">If your application requires, or can benefit from, customized messages and more complex error handling, you must use a trigger.</span></span>  
  
-   <span data-ttu-id="5546a-123">DML 트리거는 참조 무결성을 위반하는 변경 내용을 적용하지 않거나 롤백하여 데이터 수정을 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-123">DML triggers can disallow or roll back changes that violate referential integrity, thereby canceling the attempted data modification.</span></span> <span data-ttu-id="5546a-124">이 트리거는 외래 키를 변경했는데 새 값이 기본 키와 일치하지 않을 때 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-124">Such a trigger might go into effect when you change a foreign key and the new value does not match its primary key.</span></span> <span data-ttu-id="5546a-125">그러나 이 작업에는 일반적으로 FOREIGN KEY 제약 조건을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-125">However, FOREIGN KEY constraints are usually used for this purpose.</span></span>  
  
-   <span data-ttu-id="5546a-126">트리거 테이블에 제약 조건이 있으면 INSTEAD OF 트리거가 실행된 후 AFTER 트리거가 실행되기 전에 제약 조건이 확인됩니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-126">If constraints exist on the trigger table, they are checked after the INSTEAD OF trigger execution but prior to the AFTER trigger execution.</span></span> <span data-ttu-id="5546a-127">제약 조건을 위반하면 INSTEAD OF 트리거 동작이 롤백되고 AFTER 트리거가 실행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-127">If the constraints are violated, the INSTEAD OF trigger actions are rolled back and the AFTER trigger is not executed.</span></span>  
  
## <a name="types-of-dml-triggers"></a><span data-ttu-id="5546a-128">DML 트리거 유형</span><span class="sxs-lookup"><span data-stu-id="5546a-128">Types of DML Triggers</span></span>  
 <span data-ttu-id="5546a-129">AFTER 트리거</span><span class="sxs-lookup"><span data-stu-id="5546a-129">AFTER trigger</span></span>  
 <span data-ttu-id="5546a-130">INSERT, UPDATE, MERGE 또는 DELETE 문의 동작을 수행한 후에 AFTER 트리거를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-130">AFTER triggers are executed after the action of the INSERT, UPDATE, MERGE, or DELETE statement is performed.</span></span> <span data-ttu-id="5546a-131">제약 조건을 위반하면 AFTER 트리거가 절대로 실행되지 않습니다. 따라서 제약 조건 위반이 발생할 수 있는 처리에 대해서는 이 트리거를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-131">AFTER triggers are never executed if a constraint violation occurs; therefore, these triggers cannot be used for any processing that might prevent constraint violations.</span></span> <span data-ttu-id="5546a-132">MERGE 문에 지정된 INSERT, UPDATE 또는 DELETE 동작이 발생할 때마다 각 DML 동작에 대해 해당 트리거가 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-132">For every INSERT, UPDATE, or DELETE action specified in a MERGE statement, the corresponding trigger is fired for each DML operation.</span></span>  
  
 <span data-ttu-id="5546a-133">INSTEAD OF 트리거</span><span class="sxs-lookup"><span data-stu-id="5546a-133">INSTEAD OF trigger</span></span>  
 <span data-ttu-id="5546a-134">INSTEAD OF 트리거는 트리거 문의 표준 동작을 무시합니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-134">INSTEAD OF triggers override the standard actions of the triggering statement.</span></span> <span data-ttu-id="5546a-135">따라서 이 트리거를 사용하여 하나 이상의 열에서 오류나 값을 확인하고 행을 삽입, 업데이트 또는 삭제하기 전에 추가 동작을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-135">Therefore, they can be used to perform error or value checking on one or more columns and the perform additional actions before insert, updating or deleting the row or rows.</span></span> <span data-ttu-id="5546a-136">예를 들어 임금 대장 테이블의 시간별 임금 열에서 업데이트되는 값이 지정된 값을 초과할 때 오류 메시지를 생성하거나 트랜잭션을 롤백하도록 트리거를 정의할 수 있습니다. 또는 임금 대장 테이블에 레코드를 삽입하기 전에 감사 내역에 새 레코드를 삽입하도록 트리거를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-136">For example, when the value being updated in an hourly wage column in a payroll table exceeds a specified value, a trigger can be defined to either produce an error message and roll back the transaction, or insert a new record into an audit trail before inserting the record into the payroll table.</span></span> <span data-ttu-id="5546a-137">INSTEAD OF 트리거의 주된 이점은 업데이트할 수 없는 뷰에 대해 업데이트를 지원한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-137">The primary advantage of INSTEAD OF triggers is that they enable views that would not be updatable to support updates.</span></span> <span data-ttu-id="5546a-138">예를 들어 여러 개의 기본 테이블로 구성된 뷰는 INSTEAD OF 트리거를 사용하여 여러 테이블의 데이터를 참조하는 삽입, 업데이트 및 삭제를 지원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-138">For example, a view based on multiple base tables must use an INSTEAD OF trigger to support inserts, updates, and deletes that reference data in more than one table.</span></span> <span data-ttu-id="5546a-139">INSTEAD OF 트리거의 또 다른 이점은 일괄 처리의 일부는 계속 처리하고 다른 일부는 처리하지 않도록 하는 논리를 코드화할 수 있게 한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-139">Another advantage of INSTEAD OF triggers is that they enable you to code logic that can reject parts of a batch while letting other parts of a batch to succeed.</span></span>  
  
 <span data-ttu-id="5546a-140">이 표에서는 AFTER 트리거와 INSTEAD OF 트리거의 기능을 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-140">This table compares the functionality of the AFTER and INSTEAD OF triggers.</span></span>  
  
|<span data-ttu-id="5546a-141">함수</span><span class="sxs-lookup"><span data-stu-id="5546a-141">Function</span></span>|<span data-ttu-id="5546a-142">AFTER 트리거</span><span class="sxs-lookup"><span data-stu-id="5546a-142">AFTER trigger</span></span>|<span data-ttu-id="5546a-143">INSTEAD OF 트리거</span><span class="sxs-lookup"><span data-stu-id="5546a-143">INSTEAD OF trigger</span></span>|  
|--------------|-------------------|------------------------|  
|<span data-ttu-id="5546a-144">적용 대상</span><span class="sxs-lookup"><span data-stu-id="5546a-144">Applicability</span></span>|<span data-ttu-id="5546a-145">테이블</span><span class="sxs-lookup"><span data-stu-id="5546a-145">Tables</span></span>|<span data-ttu-id="5546a-146">테이블 및 뷰</span><span class="sxs-lookup"><span data-stu-id="5546a-146">Tables and views</span></span>|  
|<span data-ttu-id="5546a-147">각 테이블이나 뷰에서 가능한 트리거 수</span><span class="sxs-lookup"><span data-stu-id="5546a-147">Quantity per table or view</span></span>|<span data-ttu-id="5546a-148">각 트리거 동작(UPDATE, DELETE 및 INSERT)에 대해 여러 개 사용 가능</span><span class="sxs-lookup"><span data-stu-id="5546a-148">Multiple per triggering action (UPDATE, DELETE, and INSERT)</span></span>|<span data-ttu-id="5546a-149">각 트리거 동작(UPDATE, DELETE 및 INSERT)에 대해 한 개만 사용 가능</span><span class="sxs-lookup"><span data-stu-id="5546a-149">One per triggering action (UPDATE, DELETE, and INSERT)</span></span>|  
|<span data-ttu-id="5546a-150">연계 참조</span><span class="sxs-lookup"><span data-stu-id="5546a-150">Cascading references</span></span>|<span data-ttu-id="5546a-151">적용되는 제한 없음</span><span class="sxs-lookup"><span data-stu-id="5546a-151">No restrictions apply</span></span>|<span data-ttu-id="5546a-152">연계 참조 무결성 제약 조건이 적용되는 테이블에는 INSTEAD OF UPDATE 트리거와 DELETE 트리거가 허용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-152">INSTEAD OF UPDATE and DELETE triggers are not allowed on tables that are targets of cascaded referential integrity constraints.</span></span>|  
|<span data-ttu-id="5546a-153">실행</span><span class="sxs-lookup"><span data-stu-id="5546a-153">Execution</span></span>|<span data-ttu-id="5546a-154">이후:</span><span class="sxs-lookup"><span data-stu-id="5546a-154">After:</span></span><br /><br /> <span data-ttu-id="5546a-155">제약 조건 처리</span><span class="sxs-lookup"><span data-stu-id="5546a-155">Constraint processing</span></span><br /><span data-ttu-id="5546a-156">선언적 참조 동작</span><span class="sxs-lookup"><span data-stu-id="5546a-156">Declarative referential actions</span></span><br /><span data-ttu-id="5546a-157">**inserted** 및 **deleted** 테이블 만들기</span><span class="sxs-lookup"><span data-stu-id="5546a-157">**inserted** and **deleted** tables creation</span></span><br /><span data-ttu-id="5546a-158">트리거 동작</span><span class="sxs-lookup"><span data-stu-id="5546a-158">The triggering action</span></span>|<span data-ttu-id="5546a-159">이전: 제약 조건 처리</span><span class="sxs-lookup"><span data-stu-id="5546a-159">Before: Constraint processing</span></span><br /><br /> <span data-ttu-id="5546a-160">대신: 트리거 동작</span><span class="sxs-lookup"><span data-stu-id="5546a-160">In place of:  The triggering action</span></span><br /><br /> <span data-ttu-id="5546a-161">이후:  **inserted** 및 **deleted** 테이블 만들기</span><span class="sxs-lookup"><span data-stu-id="5546a-161">After:  **inserted** and **deleted** tables creation</span></span>|  
|<span data-ttu-id="5546a-162">실행 순서</span><span class="sxs-lookup"><span data-stu-id="5546a-162">Order of execution</span></span>|<span data-ttu-id="5546a-163">첫 실행과 마지막 실행을 지정할 수 있음</span><span class="sxs-lookup"><span data-stu-id="5546a-163">First and last execution may be specified</span></span>|<span data-ttu-id="5546a-164">해당 없음</span><span class="sxs-lookup"><span data-stu-id="5546a-164">Not applicable</span></span>|  
|<span data-ttu-id="5546a-165">`varchar(max)``nvarchar(max)` `varbinary(max)` **inserted** 및 **deleted** 테이블의, 및 열 참조</span><span class="sxs-lookup"><span data-stu-id="5546a-165">`varchar(max)`, `nvarchar(max)`, and `varbinary(max)` column references in **inserted** and **deleted** tables</span></span>|<span data-ttu-id="5546a-166">허용됨</span><span class="sxs-lookup"><span data-stu-id="5546a-166">Allowed</span></span>|<span data-ttu-id="5546a-167">허용됨</span><span class="sxs-lookup"><span data-stu-id="5546a-167">Allowed</span></span>|  
|<span data-ttu-id="5546a-168">`text``ntext` `image` **inserted** 및 **deleted** 테이블의, 및 열 참조</span><span class="sxs-lookup"><span data-stu-id="5546a-168">`text`, `ntext`, and `image` column references in **inserted** and **deleted** tables</span></span>|<span data-ttu-id="5546a-169">허용되지 않음</span><span class="sxs-lookup"><span data-stu-id="5546a-169">Not allowed</span></span>|<span data-ttu-id="5546a-170">허용됨</span><span class="sxs-lookup"><span data-stu-id="5546a-170">Allowed</span></span>|  
  
 <span data-ttu-id="5546a-171">CLR 트리거</span><span class="sxs-lookup"><span data-stu-id="5546a-171">CLR Triggers</span></span>  
 <span data-ttu-id="5546a-172">CLR 트리거는 AFTER 또는 INSTEAD OF 트리거일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-172">A CLR Trigger can be either an AFTER or INSTEAD OF trigger.</span></span> <span data-ttu-id="5546a-173">또한 CLR 트리거는 DDL 트리거일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-173">A CLR trigger can also be a DDL trigger.</span></span> <span data-ttu-id="5546a-174">CLR 트리거는 [!INCLUDE[tsql](../../includes/tsql-md.md)] 저장 프로시저를 실행하는 대신 .NET Framework에서 생성되고 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]에서 업로드되는 어셈블리 멤버인 관리 코드로 작성된 하나 이상의 메서드를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-174">Instead of executing a [!INCLUDE[tsql](../../includes/tsql-md.md)] stored procedure, a CLR trigger executes one or more methods written in managed code that are members of an assembly created in the .NET Framework and uploaded in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span>  
  
## <a name="related-tasks"></a><span data-ttu-id="5546a-175">관련 작업</span><span class="sxs-lookup"><span data-stu-id="5546a-175">Related Tasks</span></span>  
  
|<span data-ttu-id="5546a-176">Task</span><span class="sxs-lookup"><span data-stu-id="5546a-176">Task</span></span>|<span data-ttu-id="5546a-177">항목</span><span class="sxs-lookup"><span data-stu-id="5546a-177">Topic</span></span>|  
|----------|-----------|  
|<span data-ttu-id="5546a-178">DML 트리거를 만드는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-178">Describes how to create a DML trigger.</span></span>|[<span data-ttu-id="5546a-179">DML 트리거 만들기</span><span class="sxs-lookup"><span data-stu-id="5546a-179">Create DML Triggers</span></span>](create-dml-triggers.md)|  
|<span data-ttu-id="5546a-180">CLR 트리거를 만드는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-180">Describes how to create a CLR trigger.</span></span>|[<span data-ttu-id="5546a-181">CLR 트리거 만들기</span><span class="sxs-lookup"><span data-stu-id="5546a-181">Create CLR Triggers</span></span>](create-clr-triggers.md)|  
|<span data-ttu-id="5546a-182">단일 행 데이터 수정과 다중 행 데이터 수정을 모두 처리하는 DML 트리거를 만드는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-182">Describes how to create a DML trigger to handle both single-row and multi-row data modifications.</span></span>|[<span data-ttu-id="5546a-183">여러 행의 데이터를 처리하기 위한 DML 트리거 만들기</span><span class="sxs-lookup"><span data-stu-id="5546a-183">Create DML Triggers to Handle Multiple Rows of Data</span></span>](create-dml-triggers-to-handle-multiple-rows-of-data.md)|  
|<span data-ttu-id="5546a-184">트리거를 중첩하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-184">Describes how to nest triggers.</span></span>|[<span data-ttu-id="5546a-185">중첩 트리거 만들기</span><span class="sxs-lookup"><span data-stu-id="5546a-185">Create Nested Triggers</span></span>](create-nested-triggers.md)|  
|<span data-ttu-id="5546a-186">AFTER 트리거가 발생되는 순서를 지정하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-186">Describes how to specify the order in which AFTER triggers are fired.</span></span>|[<span data-ttu-id="5546a-187">첫 번째 및 마지막 트리거 지정</span><span class="sxs-lookup"><span data-stu-id="5546a-187">Specify First and Last Triggers</span></span>](specify-first-and-last-triggers.md)|  
|<span data-ttu-id="5546a-188">트리거 코드에서 특수 inserted 및 delete 테이블을 사용하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-188">Describes how to use the special inserted and delete tables in trigger code.</span></span>|[<span data-ttu-id="5546a-189">inserted 및 deleted 테이블 사용</span><span class="sxs-lookup"><span data-stu-id="5546a-189">Use the inserted and deleted Tables</span></span>](use-the-inserted-and-deleted-tables.md)|  
|<span data-ttu-id="5546a-190">DML 트리거를 수정하거나 이름을 변경하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-190">Describes how to modify or rename a DML trigger.</span></span>|[<span data-ttu-id="5546a-191">DML 트리거 수정 또는 이름 바꾸기</span><span class="sxs-lookup"><span data-stu-id="5546a-191">Modify or Rename DML Triggers</span></span>](modify-or-rename-dml-triggers.md)|  
|<span data-ttu-id="5546a-192">DML 트리거에 대한 정보를 보는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-192">Describes how to view information about DML triggers.</span></span>|[<span data-ttu-id="5546a-193">DML 트리거에 대한 정보 가져오기</span><span class="sxs-lookup"><span data-stu-id="5546a-193">Get Information About DML Triggers</span></span>](get-information-about-dml-triggers.md)|  
|<span data-ttu-id="5546a-194">DML 트리거 삭제하거나 사용하지 않도록 설정하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-194">Describes how to delete or disable DML triggers.</span></span>|[<span data-ttu-id="5546a-195">DML 트리거 삭제 또는 해제</span><span class="sxs-lookup"><span data-stu-id="5546a-195">Delete or Disable DML Triggers</span></span>](delete-or-disable-dml-triggers.md)|  
|<span data-ttu-id="5546a-196">트리거 보안을 관리하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="5546a-196">Describes how to manage trigger security.</span></span>|[<span data-ttu-id="5546a-197">트리거 보안 관리</span><span class="sxs-lookup"><span data-stu-id="5546a-197">Manage Trigger Security</span></span>](manage-trigger-security.md)|  
  
## <a name="see-also"></a><span data-ttu-id="5546a-198">참고 항목</span><span class="sxs-lookup"><span data-stu-id="5546a-198">See Also</span></span>  
 <span data-ttu-id="5546a-199">[CREATE TRIGGER&#40;Transact-SQL&#41;](/sql/t-sql/statements/create-trigger-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="5546a-199">[CREATE TRIGGER &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-trigger-transact-sql) </span></span>  
 <span data-ttu-id="5546a-200">[ALTER TRIGGER&#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-trigger-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="5546a-200">[ALTER TRIGGER &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-trigger-transact-sql) </span></span>  
 <span data-ttu-id="5546a-201">[DROP TRIGGER&#40;Transact-SQL&#41;](/sql/t-sql/statements/drop-trigger-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="5546a-201">[DROP TRIGGER &#40;Transact-SQL&#41;](/sql/t-sql/statements/drop-trigger-transact-sql) </span></span>  
 <span data-ttu-id="5546a-202">[DISABLE TRIGGER&#40;Transact-SQL&#41;](/sql/t-sql/statements/disable-trigger-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="5546a-202">[DISABLE TRIGGER &#40;Transact-SQL&#41;](/sql/t-sql/statements/disable-trigger-transact-sql) </span></span>  
 [<span data-ttu-id="5546a-203">트리거 함수&#40;Transact-SQL&#41;</span><span class="sxs-lookup"><span data-stu-id="5546a-203">Trigger Functions &#40;Transact-SQL&#41;</span></span>](/sql/t-sql/functions/trigger-functions-transact-sql)  
  
  
