---
title: 핵심 SQLXML 보안 고려 사항 | Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: reference
helpviewer_keywords:
- security [SQLXML], about security
ms.assetid: 330cd2ff-d5d5-4c8e-8f93-0869c977be94
author: rothja
ms.author: jroth
ms.openlocfilehash: eceaa28ff4d1a7b998a51b07df3b1076cf524e81
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87661635"
---
# <a name="core-sqlxml-security-considerations"></a><span data-ttu-id="cf56b-102">핵심 SQLXML 보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="cf56b-102">Core SQLXML Security Considerations</span></span>
  <span data-ttu-id="cf56b-103">다음은 데이터 액세스에 SQLXML을 사용하는 경우에 대한 보안 지침입니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-103">The following are security guidelines for using SQLXML for data access.</span></span>  
  
-   <span data-ttu-id="cf56b-104">SQLXMLOLEDB 공급자는 각 특정 인스턴스에 대해 사용하거나 사용하지 않도록 설정할 SQLXML 기능을 나타내는 플래그를 설정할 수 있는 `StreamFlags` 속성을 노출합니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-104">The SQLXMLOLEDB provider exposes a `StreamFlags` property which allows you to set flags indicating what SQLXML functionality should be enabled or disabled for each specific instance.</span></span> <span data-ttu-id="cf56b-105">이 속성을 사용하여 SQLXML 사용을 사용자 지정하고 원하는 구성 요소만 사용되도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-105">You can use this property to customize your use of SQLXML and to make sure that only the components you want are enabled.</span></span> <span data-ttu-id="cf56b-106">자세한 내용은 [SQLXMLOLEDB Provider &#40;SQLXML 4.0&#41;](../../../database-engine/dev-guide/sqlxmloledb-provider-sqlxml-4-0.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="cf56b-106">For more information, see [SQLXMLOLEDB Provider &#40;SQLXML 4.0&#41;](../../../database-engine/dev-guide/sqlxmloledb-provider-sqlxml-4-0.md).</span></span>  
  
-   <span data-ttu-id="cf56b-107">SQLXML 오류가 발생하고 반환되는 경우 테이블 이름, 열 이름 또는 유형 정보와 같은 데이터베이스 스키마 정보가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-107">When SQLXML errors occur and are returned, they can include information about the database schema such as table names, column names or type information.</span></span> <span data-ttu-id="cf56b-108">의도되지 않았거나 필요하지 않은 경우 사용자가 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 설치에 대한 정보를 쉽게 검색할 수 없도록 이러한 오류를 처리할 때는 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-108">You should use care when handling these errors so that information about your [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] installation is not easily discoverable by users where it is not intended or needed.</span></span>  
  
-   <span data-ttu-id="cf56b-109">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]를 쿼리하거나 업데이트를 보내기 위해 사용하는 경우 SQLXML은 교환할 수 있는 데이터 양에 제한을 설정하지 않으며, 처리 전에 SQLXML 페이로드의 데이터 크기를 확인하지도 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-109">When used to either query or send updates to [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], SQLXML sets no limit on the amount of data that can be exchanged and does not do any checking on the size of data in a SQLXML payload before attempting to process it.</span></span> <span data-ttu-id="cf56b-110">SQLXML을 사용하여 애플리케이션을 개발하는 경우 시스템에 데이터를 처리할 충분한 메모리가 있는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-110">When you develop your application using SQLXML, it is your responsibility to ensure there is enough memory on the system to process the data.</span></span> <span data-ttu-id="cf56b-111">예를 들어 서버의 데이터를 쿼리하는 경우 클라이언트 메모리에 해당 데이터를 받아들일 충분한 공간이 있는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-111">For example, when querying data from the server, you should verify there is enough room in memory on the client to receive it.</span></span> <span data-ttu-id="cf56b-112">마찬가지로, 데이터를 서버로 로드하는 경우 해당 데이터를 처리하는 데 필요한 메모리를 서버에서 사용할 수 있는지, 그리고 서버에서 사용 가능한 디스크 저장 공간이 데이터를 저장하기에 충분한지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-112">Likewise, if you are loading data to the server, you need to verify there is enough available memory on the server to process it and enough available disk storage space on the server to store the data.</span></span>  
  
-   <span data-ttu-id="cf56b-113">SQLXML은 동적으로 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 쿼리 및 업데이트 명령을 생성하여 실행을 위해 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]로 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-113">SQLXML dynamically generates [!INCLUDE[tsql](../../../includes/tsql-md.md)] queries and update commands and sends them to [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] for execution.</span></span> <span data-ttu-id="cf56b-114">SQLXML은 이런 방식으로만 서버를 쿼리하고 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-114">This is the only way in which SQLXML queries and updates the server.</span></span> <span data-ttu-id="cf56b-115">결과는 XML 스트림이나 행 집합으로 수신됩니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-115">Results will be received either as a stream (of XML) or as a rowset.</span></span>  
  
-   <span data-ttu-id="cf56b-116">쿼리 결과를 받을 때 SQLXML은 수신된 데이터의 내용을 기반으로 어떠한 동작도 수행하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-116">When receiving query results, SQLXML takes no actions based on the content of the data that it receives.</span></span> <span data-ttu-id="cf56b-117">데이터 형식이나 내용을 기반으로 추가 처리가 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-117">No additional processing is done based on the type or contents of the data.</span></span> <span data-ttu-id="cf56b-118">데이터는 동작을 실행할 코드로 처리되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-118">The data is never treated as code with which to execute actions.</span></span>  
  
-   <span data-ttu-id="cf56b-119">XML 템플릿을 실행하는 경우 SQLXML은 제출된 템플릿 내에 포함된 XPath 및 DBObject 쿼리를 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 명령으로 변환합니다. 이 명령은 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]에 대해 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-119">When executing XML Templates, SQLXML translates the XPath and DBObject queries contained within the submitted template into [!INCLUDE[tsql](../../../includes/tsql-md.md)] commands that are then executed against [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="cf56b-120">이 명령은 기존 데이터에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-120">These commands only ever affect existing data.</span></span> <span data-ttu-id="cf56b-121">SQLXML에서 생성된 명령은 데이터베이스 구조를 변경하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-121">Commands generated by SQLXML will never alter the structure of the database.</span></span> <span data-ttu-id="cf56b-122">데이터베이스 구조를 변경하려면 사용자는 명시적인 명령을 실행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-122">Users must issue explicit commands to alter the database structure.</span></span> <span data-ttu-id="cf56b-123">예를 들어 명령을 템플릿의 `sql:query` 블록에 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-123">For example, by including them in a `sql:query` block of a template.</span></span>  
  
-   <span data-ttu-id="cf56b-124">매핑 파일을 통해 DBObject 쿼리와 XPath 문을 실행하는 경우 SQLXML은 어떤 방식으로든 데이터베이스의 데이터를 변경하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-124">When executing DBObject queries and XPath statements over mapping files, SQLXML will not alter the data in the database in any way.</span></span>  
  
-   <span data-ttu-id="cf56b-125">SQLXML에서 XML과 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 데이터 모델 사이의 차이를 기반으로 지정된 데이터 형식을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-125">SQLXML may make formatting changes to the given data based on differences between the XML and [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] data models.</span></span> <span data-ttu-id="cf56b-126">예를 들어 시간을 지정하는 형식이 다를 경우</span><span class="sxs-lookup"><span data-stu-id="cf56b-126">For example, the format for specifying a time is different.</span></span> <span data-ttu-id="cf56b-127">SQLXML에서 이러한 차이를 해결하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-127">SQLXML will attempt to resolve these differences.</span></span> <span data-ttu-id="cf56b-128">따라서 일부 전체 자릿수 정보가 손실될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-128">As a result, some precision information may be lost.</span></span>  
  
-   <span data-ttu-id="cf56b-129">SQLXML은 데이터를 처리하는 데 걸리는 시간에 제한을 설정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-129">SQLXML sets no limit on the amount of time it takes to process the data.</span></span> <span data-ttu-id="cf56b-130">오류가 발생하거나 처리가 완료될 때까지 처리 작업이 계속됩니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-130">Processing will continue until an error occurs or processing is complete.</span></span>  
  
-   <span data-ttu-id="cf56b-131">SQLXML은 파일 시스템에 쓰지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-131">SQLXML does not write to the file system.</span></span> <span data-ttu-id="cf56b-132">사용자가 데이터베이스에서 검색한 데이터를 저장하려는 경우 해당 코드에서 이 작업을 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-132">If users wish to save the data they retrieve from the database, they must do this in their code.</span></span>  
  
-   <span data-ttu-id="cf56b-133">SQLXML을 통해 사용자는 원하는 모든 SQL 쿼리를 데이터베이스에 대해 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-133">SQLXML allows users to execute any SQL query they like against the database.</span></span> <span data-ttu-id="cf56b-134">보안되지 않은 원본이나 제어되지 않은 원본에는 이 기능을 노출하면 안 됩니다. 그렇지 않으면 프로비전 없이 SQL 데이터베이스가 모든 사용자에게 열리게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-134">This functionality should never be exposed to an unsecure or uncontrolled source, as this is essentially opening up the SQL database without provision to any users.</span></span>  
  
-   <span data-ttu-id="cf56b-135">Updategram을 실행하는 경우 SQLXML은 `updg:sync` 블록을 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 인스턴스에 대한 DELETE, UPDATE 및 INSERT 명령으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-135">When executing Updategrams, SQLXML translates the `updg:sync` blocks into DELETE, UPDATE, and INSERT commands against the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] instance.</span></span> <span data-ttu-id="cf56b-136">이 명령은 기존 데이터에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-136">These commands only ever affect existing data.</span></span> <span data-ttu-id="cf56b-137">SQLXML에서 생성된 명령은 데이터베이스를 변경하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-137">Commands generated by SQLXML will never alter the database.</span></span> <span data-ttu-id="cf56b-138">데이터베이스 구조를 변경하려면 사용자는 명시적인 명령을 실행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-138">Users must issue explicit commands to alter the database structure.</span></span> <span data-ttu-id="cf56b-139">예를 들어 명령을 템플릿의 `sql:query` 블록에 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-139">For example, by including them in a `sql:query` block of a template.</span></span>  
  
-   <span data-ttu-id="cf56b-140">DiffGram을 실행하는 경우 SQLXML은 DiffGram을 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 인스턴스에 대한 DELETE, UPDATE 및 INSERT 명령으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-140">When executing DiffGrams, SQLXML translates the DiffGram into DELETE, UPDATE, and INSERT commands against the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] instance.</span></span> <span data-ttu-id="cf56b-141">이 명령은 기존 데이터에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-141">These commands only ever affect existing data.</span></span> <span data-ttu-id="cf56b-142">SQLXML에서 생성된 명령은 데이터베이스를 변경하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-142">Commands generated by SQLXML will never alter the database.</span></span> <span data-ttu-id="cf56b-143">데이터베이스 구조를 변경하려면 사용자는 명시적인 명령을 실행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-143">Users must issue explicit commands to alter the database structure.</span></span> <span data-ttu-id="cf56b-144">예를 들어 명령을 템플릿의 `sql:query` 블록에 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cf56b-144">For example, by including them in a `sql:query` block of a template.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="cf56b-145">참고 항목</span><span class="sxs-lookup"><span data-stu-id="cf56b-145">See Also</span></span>  
 [<span data-ttu-id="cf56b-146">SQLXML 4.0 보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="cf56b-146">SQLXML 4.0 Security Considerations</span></span>](sqlxml-4-0-security-considerations.md)  
  
  
