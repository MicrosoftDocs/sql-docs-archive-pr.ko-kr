---
title: 분할된 테이블 및 인덱스 | Microsoft 문서
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
helpviewer_keywords:
- partitioned tables [SQL Server], about partitioned tables
- partitioned indexes [SQL Server], architecture
- partitioned tables [SQL Server], architecture
- partitioned indexes [SQL Server], about partitioned indexes
ms.assetid: cc5bf181-18a0-44d5-8bd7-8060d227c927
author: MikeRayMSFT
ms.author: mikeray
ms.openlocfilehash: e8d041abcfe491f311e38bc8dab4be4ea253e37c
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87739765"
---
# <a name="partitioned-tables-and-indexes"></a><span data-ttu-id="e0530-102">Partitioned Tables and Indexes</span><span class="sxs-lookup"><span data-stu-id="e0530-102">Partitioned Tables and Indexes</span></span>
  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="e0530-103">에서는 테이블 및 인덱스 분할을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-103">supports table and index partitioning.</span></span> <span data-ttu-id="e0530-104">분할 테이블 및 인덱스의 데이터는 데이터베이스에서 두 개 이상의 파일 그룹으로 분할될 수 있는 단위로 나뉩니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-104">The data of partitioned tables and indexes is divided into units that can be spread across more than one filegroup in a database.</span></span> <span data-ttu-id="e0530-105">행 그룹이 개별 파티션에 매핑되도록 데이터는 수평적으로 분할됩니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-105">The data is partitioned horizontally, so that groups of rows are mapped into individual partitions.</span></span> <span data-ttu-id="e0530-106">단일 인덱스나 테이블의 모든 파티션은 동일 데이터베이스에 상주해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-106">All partitions of a single index or table must reside in the same database.</span></span> <span data-ttu-id="e0530-107">데이터에서 쿼리나 업데이트가 수행되면 테이블이나 인덱스는 단일 논리적 엔터티로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-107">The table or index is treated as a single logical entity when queries or updates are performed on the data.</span></span> <span data-ttu-id="e0530-108">분할된 테이블 및 인덱스는 일부 [!INCLUDE[msCoName](../../includes/msconame-md.md)][!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 버전에서만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-108">Partitioned tables and indexes are not available in every edition of [!INCLUDE[msCoName](../../includes/msconame-md.md)][!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="e0530-109">버전에서 지원 되는 기능 목록은 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] [SQL Server 2014 버전에서 지 원하는 기능](../../getting-started/features-supported-by-the-editions-of-sql-server-2014.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="e0530-109">For a list of features that are supported by the editions of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], see [Features Supported by the Editions of SQL Server 2014](../../getting-started/features-supported-by-the-editions-of-sql-server-2014.md).</span></span>  
  
> [!IMPORTANT]  
>  [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] <span data-ttu-id="e0530-110">는 기본적으로 최대 15,000개의 파티션을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-110">supports up to 15,000 partitions by default.</span></span> <span data-ttu-id="e0530-111">[!INCLUDE[ssSQL11](../../includes/sssql11-md.md)]이전 버전에서는 파티션 수가 기본적으로 1,000개로 제한되었습니다. x86 기반 시스템에서는 파티션 수가 1,000개를 초과하는 테이블 또는 인덱스를 만들 수 있지만 해당 테이블 또는 인덱스는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-111">In versions earlier than [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], the number of partitions was limited to 1,000 by default.On x86-based systems, creating a table or index with more than 1000 partitions is possible, but is not supported.</span></span>  
  
## <a name="benefits-of-partitioning"></a><span data-ttu-id="e0530-112">분할의 이점</span><span class="sxs-lookup"><span data-stu-id="e0530-112">Benefits of Partitioning</span></span>  
 <span data-ttu-id="e0530-113">큰 테이블 또는 인덱스를 분할하면 관리 효율성과 성능 면에서 다음과 같은 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-113">Partitioning large tables or indexes can have the following manageability and performance benefits.</span></span>  
  
-   <span data-ttu-id="e0530-114">데이터 하위 집합을 빠르고 효율적으로 전송하거나 액세스할 수 있을 뿐만 아니라 데이터 컬렉션의 무결성을 유지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-114">You can transfer or access subsets of data quickly and efficiently, while maintaining the integrity of a data collection.</span></span> <span data-ttu-id="e0530-115">예를 들어 데이터를 분할하지 않은 상태에서 몇 분 내지 몇 시간이 걸렸던 작업(예: OLTP에서 OLAP 시스템으로 데이터 로드)이 몇 초 안에 끝납니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-115">For example, an operation such as loading data from an OLTP to an OLAP system takes only seconds, instead of the minutes and hours the operation takes when the data is not partitioned.</span></span>  
  
-   <span data-ttu-id="e0530-116">하나 이상의 파티션에서 유지 관리 작업을 더 빠르게 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-116">You can perform maintenance operations on one or more partitions more quickly.</span></span> <span data-ttu-id="e0530-117">전체 테이블 대신 이 데이터 하위 집합만 대상으로 하기 때문에 작업이 더 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-117">The operations are more efficient because they target only these data subsets, instead of the whole table.</span></span> <span data-ttu-id="e0530-118">예를 들어 하나 이상의 파티션에서 데이터를 압축하거나 인덱스의 파티션 중 하나 이상을 다시 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-118">For example, you can choose to compress data in one or more partitions or rebuild one or more partitions of an index.</span></span>  
  
-   <span data-ttu-id="e0530-119">자주 실행하는 쿼리 유형과 사용 중인 하드웨어 구성에 따라 쿼리 성능이 향상될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-119">You may improve query performance, based on the types of queries you frequently run and on your hardware configuration.</span></span> <span data-ttu-id="e0530-120">예를 들어 쿼리 최적화 프로그램에서는 파티션 자체를 조인할 수 있으므로 테이블의 분할 열이 동일한 경우 두 개 이상의 분할된 테이블 간의 동등 조인 쿼리를 더 빠르게 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-120">For example, the query optimizer can process equi-join queries between two or more partitioned tables faster when the partitioning columns in the tables are the same, because the partitions themselves can be joined.</span></span>  
  
     <span data-ttu-id="e0530-121">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 가 I/O 작업을 위해 데이터를 정렬할 때 먼저 파티션을 기준으로 데이터가 정렬됩니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-121">When [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] performs data sorting for I/O operations, it sorts the data first by partition.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="e0530-122">가 한 번에 한 드라이브에 액세스하므로 성능이 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-122">accesses one drive at a time, and this might reduce performance.</span></span> <span data-ttu-id="e0530-123">데이터 저장 성능을 향상시키려면 RAID를 설정하여 두 개 이상의 디스크 간에 파티션의 데이터 파일을 스트라이프합니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-123">To improve data sorting performance, stripe the data files of your partitions across more than one disk by setting up a RAID.</span></span> <span data-ttu-id="e0530-124">이렇게 하면 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 가 여전히 파티션을 기준으로 데이터를 정렬하지만 동시에 각 파티션의 모든 드라이브에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-124">In this way, although [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] still sorts data by partition, it can access all the drives of each partition at the same time.</span></span>  
  
     <span data-ttu-id="e0530-125">또한 전체 테이블이 아니라 파티션 수준에서 잠금 에스컬레이션을 설정하여 성능을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-125">In addition, you can improve performance by enabling lock escalation at the partition level instead of a whole table.</span></span> <span data-ttu-id="e0530-126">따라서 테이블의 잠금 경합을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-126">This can reduce lock contention on the table.</span></span>  
  
## <a name="components-and-concepts"></a><span data-ttu-id="e0530-127">구성 요소 및 개념</span><span class="sxs-lookup"><span data-stu-id="e0530-127">Components and Concepts</span></span>  
 <span data-ttu-id="e0530-128">테이블 및 인덱스 분할에 적용되는 용어는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-128">The following terms are applicable to table and index partitioning.</span></span>  
  
 <span data-ttu-id="e0530-129">파티션 함수</span><span class="sxs-lookup"><span data-stu-id="e0530-129">Partition function</span></span>  
 <span data-ttu-id="e0530-130">분할 열이라고 하는 특정 열의 값을 기반으로 파티션 집합에 테이블이나 인덱스의 행을 매핑하는 방식을 정의하는 데이터베이스 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-130">A database object that defines how the rows of a table or index are mapped to a set of partitions based on the values of certain column, called a partitioning column.</span></span> <span data-ttu-id="e0530-131">즉, 파티션 함수는 테이블이 포함할 파티션 수를 정의하고 파티션 경계의 정의 방법을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-131">That is, the partition function defines the number of partitions that the table will have and how the boundaries of the partitions are defined.</span></span> <span data-ttu-id="e0530-132">예를 들어 매출 주문 데이터가 포함된 테이블이 있다고 가정할 경우 매출 날짜와 같은 `datetime` 열을 기준으로 테이블을 12개(월별) 파티션으로 분할해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-132">For example, given a table that contains sales order data, you may want to partition the table into twelve (monthly) partitions based on a `datetime` column such as a sales date.</span></span>  
  
 <span data-ttu-id="e0530-133">파티션 구성표</span><span class="sxs-lookup"><span data-stu-id="e0530-133">Partition scheme</span></span>  
 <span data-ttu-id="e0530-134">파티션 함수의 파티션을 파일 그룹 집합으로 매핑하는 데이터베이스 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-134">A database object that maps the partitions of a partition function to a set of filegroups.</span></span> <span data-ttu-id="e0530-135">별개의 파일 그룹에 파티션을 넣는 주된 이유는 파티션 백업 작업을 독립적으로 수행하기 위해서입니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-135">The primary reason for placing your partitions on separate filegroups is to make sure that you can independently perform backup operations on partitions.</span></span> <span data-ttu-id="e0530-136">이는 개별 파일 그룹에 대해 백업을 수행할 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-136">This is because you can perform backups on individual filegroups.</span></span>  
  
 <span data-ttu-id="e0530-137">분할 열</span><span class="sxs-lookup"><span data-stu-id="e0530-137">Partitioning column</span></span>  
 <span data-ttu-id="e0530-138">파티션 함수가 테이블이나 인덱스를 분할하는 데 사용하는 테이블 또는 인덱스의 열입니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-138">The column of a table or index that a partition function uses to partition the table or index.</span></span> <span data-ttu-id="e0530-139">파티션 함수에 참여하는 계산 열은 명시적으로 PERSISTED로 표시되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-139">Computed columns that participate in a partition function must be explicitly marked PERSISTED.</span></span> <span data-ttu-id="e0530-140">`timestamp`를 제외하고 인덱스 열로 사용할 수 있는 모든 데이터 형식을 분할 열로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-140">All data types that are valid for use as index columns can be used as a partitioning column, except `timestamp`.</span></span> <span data-ttu-id="e0530-141">`ntext`, `text`, `image`, `xml`, `varchar(max)`, `nvarchar(max)` 또는 `varbinary(max)` 데이터 형식은 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-141">The `ntext`, `text`, `image`, `xml`, `varchar(max)`, `nvarchar(max)`, or `varbinary(max)` data types cannot be specified.</span></span> <span data-ttu-id="e0530-142">또한 Microsoft .NET Framework CLR(공용 언어 런타임) 사용자 정의 유형 및 별칭 데이터 형식 열은 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-142">Also, Microsoft .NET Framework common language runtime (CLR) user-defined type and alias data type columns cannot be specified.</span></span>  
  
 <span data-ttu-id="e0530-143">정렬된 인덱스</span><span class="sxs-lookup"><span data-stu-id="e0530-143">Aligned index</span></span>  
 <span data-ttu-id="e0530-144">해당 테이블과 동일한 파티션 구성표를 기반으로 작성되는 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-144">An index that is built on the same partition scheme as its corresponding table.</span></span> <span data-ttu-id="e0530-145">테이블과 인덱스가 정렬되면 SQL Server에서 테이블과 인덱스의 파티션 구조를 유지하면서 신속하고 효율적으로 파티션을 전환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-145">When a table and its indexes are in alignment, SQL Server can switch partitions quickly and efficiently while maintaining the partition structure of both the table and its indexes.</span></span> <span data-ttu-id="e0530-146">인덱스가 기본 테이블에 맞게 정렬되기 위해 반드시 같은 이름의 파티션 함수를 사용할 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-146">An index does not have to participate in the same named partition function to be aligned with its base table.</span></span> <span data-ttu-id="e0530-147">그러나 인덱스와 기본 테이블의 파티션 함수는 1) 파티션 함수의 인수가 동일한 데이터 형식이어야 하고 2) 정의되는 파티션 수가 같아야 하고 3) 동일한 파티션 경계 값이 정의되어야 한다는 점에서 기본적으로 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-147">However, the partition function of the index and the base table must be essentially the same, in that 1) the arguments of the partition functions have the same data type, 2) they define the same number of partitions, and 3) they define the same boundary values for partitions.</span></span>  
  
 <span data-ttu-id="e0530-148">정렬되지 않은 인덱스</span><span class="sxs-lookup"><span data-stu-id="e0530-148">Nonaligned index</span></span>  
 <span data-ttu-id="e0530-149">해당 테이블과 독립적으로 분할된 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-149">An index partitioned independently from its corresponding table.</span></span> <span data-ttu-id="e0530-150">즉, 인덱스의 파티션 구성표가 다르거나 인덱스가 기본 테이블과 다른 파일 그룹에 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-150">That is, the index has a different partition scheme or is placed on a separate filegroup from the base table.</span></span> <span data-ttu-id="e0530-151">다음과 같은 경우에는 정렬되지 않은 분할된 인덱스를 디자인하는 것이 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-151">Designing an nonaligned partitioned index can be useful in the following cases:</span></span>  
  
-   <span data-ttu-id="e0530-152">기본 테이블이 분할되지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="e0530-152">The base table has not been partitioned.</span></span>  
  
-   <span data-ttu-id="e0530-153">인덱스 키가 고유하고 테이블의 분할 열을 포함하고 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="e0530-153">The index key is unique and it does not contain the partitioning column of the table.</span></span>  
  
-   <span data-ttu-id="e0530-154">기본 테이블이 다른 조인 열을 사용하여 추가 테이블과의 배치된 조인에 참여하도록 하려는 경우</span><span class="sxs-lookup"><span data-stu-id="e0530-154">You want the base table to participate in collocated joins with more tables using different join columns.</span></span>  
  
 <span data-ttu-id="e0530-155">파티션 제거</span><span class="sxs-lookup"><span data-stu-id="e0530-155">Partition elimination</span></span>  
 <span data-ttu-id="e0530-156">쿼리 최적화 프로그램에서 관련 파티션만 액세스하여 쿼리의 필터 조건을 충족하기 위해 사용되는 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-156">The process by which the query optimizer accesses only the relevant partitions to satisfy the filter criteria of the query.</span></span>  
  
## <a name="performance-guidelines"></a><span data-ttu-id="e0530-157">성능 지침</span><span class="sxs-lookup"><span data-stu-id="e0530-157">Performance Guidelines</span></span>  
 <span data-ttu-id="e0530-158">파티션 수 제한이 15,000개로 늘어나서 메모리, 분할된 인덱스 작업, DBCC 명령 및 쿼리에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-158">The new, higher limit of 15,000 partitions affects memory, partitioned index operations, DBCC commands, and queries.</span></span> <span data-ttu-id="e0530-159">이 섹션에서는 파티션 수를 1,000개 이상으로 늘리는 경우의 성능 영향에 대해 설명하고 필요한 경우 해결 방법을 제시합니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-159">This section describes the performance implications of increasing the number of partitions above 1,000 and provides workarounds as needed.</span></span> <span data-ttu-id="e0530-160">최대 파티션 수 제한을 15,000개로 늘리면 데이터를 더 오래 동안 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-160">With the limit on the maximum number of partitions being increased to 15,000, you can store data for a longer time.</span></span> <span data-ttu-id="e0530-161">하지만 데이터를 필요한 기간 동안만 저장하고 성능과 파티션 수를 균형되게 조정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-161">However, you should retain data only for as long as it is needed and maintain a balance between performance and number of partitions.</span></span>  
  
### <a name="memory-usage-and-guidelines"></a><span data-ttu-id="e0530-162">메모리 사용량 및 지침</span><span class="sxs-lookup"><span data-stu-id="e0530-162">Memory Usage and Guidelines</span></span>  
 <span data-ttu-id="e0530-163">많은 수의 파티션을 사용할 경우 16GB 이상의 RAM을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-163">We recommend that you use at least 16 GB of RAM if a large number of partitions are in use.</span></span> <span data-ttu-id="e0530-164">시스템의 메모리가 부족할 경우 DML(데이터 정의 언어), DDL(데이터 조작 언어) 문 및 기타 작업이 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-164">If the system does not have enough memory, Data Manipulation Language (DML) statements, Data Definition Language (DDL) statements and other operations can fail due to insufficient memory.</span></span> <span data-ttu-id="e0530-165">메모리를 많이 사용하는 프로세스를 실행하는 16GB RAM이 장착된 시스템에서 많은 수의 파티션에서 실행되는 작업을 수행하면 메모리가 부족해질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-165">Systems with 16 GB of RAM that run many memory-intensive processes may run out of memory on operations that run on a large number of partitions.</span></span> <span data-ttu-id="e0530-166">따라서 메모리(16GB 이상)가 많을수록 성능 및 메모리 문제가 발생할 가능성이 더 낮아집니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-166">Therefore, the more memory you have over 16 GB, the less likely you are to encounter performance and memory issues.</span></span>  
  
 <span data-ttu-id="e0530-167">메모리 제한 사항은 분할된 인덱스를 작성하는 SQL Server의 성능 또는 기능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-167">Memory limitations can affect the performance or ability of SQL Server to build a partitioned index.</span></span> <span data-ttu-id="e0530-168">이러한 제한 사항은 이미 테이블에 정렬된 클러스터형 인덱스가 있고 인덱스가 기본 테이블 또는 클러스터형 인덱스에 맞게 정렬되지 않은 경우에 크게 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-168">This is especially the case when the index is not aligned with its base table or is not aligned with its clustered index, if the table already has a clustered index applied to it.</span></span>  
  
### <a name="partitioned-index-operations"></a><span data-ttu-id="e0530-169">분할된 인덱스 작업</span><span class="sxs-lookup"><span data-stu-id="e0530-169">Partitioned Index Operations</span></span>  
 <span data-ttu-id="e0530-170">메모리 제한 사항은 분할된 인덱스를 작성하는 SQL Server의 성능 또는 기능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-170">Memory limitations can affect the performance or ability of SQL Server to build a partitioned index.</span></span> <span data-ttu-id="e0530-171">특히 정렬되지 않은 인덱스를 사용하는 경우에 큰 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-171">This is especially the case with nonaligned indexes.</span></span> <span data-ttu-id="e0530-172">파티션 수가 1,000개를 초과하는 테이블에서 정렬되지 않은 인덱스를 만들거나 다시 작성할 수 있지만 해당 인덱스는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-172">Creating and rebuilding nonaligned indexes on a table with more than 1,000 partitions is possible, but is not supported.</span></span> <span data-ttu-id="e0530-173">그러면 작업 중에 성능이 저하되거나 메모리가 과도하게 소비될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-173">Doing so may cause degraded performance or excessive memory consumption during these operations.</span></span>  
  
 <span data-ttu-id="e0530-174">파티션 수가 늘어날수록 정렬된 인덱스를 만들거나 다시 작성하는 데 더 많은 시간이 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-174">Creating and rebuilding aligned indexes could take longer to execute as the number of partitions increases.</span></span> <span data-ttu-id="e0530-175">인덱스 만들기 및 다시 작성 명령을 한 번에 여러 개씩 실행하지 않는 것이 좋습니다. 그러면 성능 및 메모리 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-175">We recommend that you do not run multiple create and rebuild index commands at the same time as you may run into performance and memory issues.</span></span>  
  
 <span data-ttu-id="e0530-176">SQL Server에서 정렬을 수행하여 분할된 인덱스를 작성할 때는 먼저 파티션마다 하나씩 정렬 테이블을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-176">When SQL Server performs sorting to build partitioned indexes, it first builds one sort table for each partition.</span></span> <span data-ttu-id="e0530-177">그런 다음 각 파티션에 있는 각각의 파일 그룹에 정렬 테이블을 만들거나 SORT_IN_TEMPDB 인덱스 옵션이 지정된 경우 `tempdb`에 정렬 테이블을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-177">It then builds the sort tables either in the respective filegroup of each partition or in `tempdb`, if the SORT_IN_TEMPDB index option is specified.</span></span> <span data-ttu-id="e0530-178">각 정렬 테이블을 만드는 데는 최소 메모리 크기가 요구됩니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-178">Each sort table requires a minimum amount of memory to build.</span></span> <span data-ttu-id="e0530-179">기본 테이블에 맞게 정렬된 분할된 인덱스를 작성할 때는 정렬 테이블이 한 번에 하나씩 만들어지므로 메모리가 적게 소모됩니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-179">When you are building a partitioned index that is aligned with its base table, sort tables are built one at a time, using less memory.</span></span> <span data-ttu-id="e0530-180">그러나 정렬되지 않은 분할된 인덱스를 작성할 때는 모든 정렬 테이블이 동시에 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-180">However, when you are building a nonaligned partitioned index, the sort tables are built at the same time.</span></span> <span data-ttu-id="e0530-181">따라서 이러한 동시 정렬을 처리하기에 충분한 메모리 양이 필요하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-181">As a result, there must be sufficient memory to handle these concurrent sorts.</span></span> <span data-ttu-id="e0530-182">파티션의 수가 많을수록 필요한 메모리 양은 늘어납니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-182">The larger the number of partitions, the more memory required.</span></span> <span data-ttu-id="e0530-183">파티션별 각 정렬 테이블의 최소 크기는 40페이지이며 페이지당 8KB의 용량이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-183">The minimum size for each sort table, for each partition, is 40 pages, with 8 kilobytes per page.</span></span> <span data-ttu-id="e0530-184">예를 들어 정렬되지 않은 분할된 인덱스의 파티션 수가 100개이면 4,000(40\*100)페이지를 동시에 연속적으로 정렬하기에 충분한 메모리 양이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-184">For example, a nonaligned partitioned index with 100 partitions requires sufficient memory to serially sort 4,000 (40 \* 100) pages at the same time.</span></span> <span data-ttu-id="e0530-185">메모리가 충분하면 인덱스 작성 작업을 수행할 수 있지만 성능이 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-185">If this memory is available, the build operation will succeed, but performance may suffer.</span></span> <span data-ttu-id="e0530-186">메모리가 충분하지 않으면 작성 작업을 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-186">If this memory is not available, the build operation will fail.</span></span> <span data-ttu-id="e0530-187">반면 정렬된 분할된 인덱스의 경우 파티션 수가 100개라도 정렬 작업이 동시에 수행되지 않으므로 40페이지를 정렬하기에 충분한 메모리만 있으면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-187">Alternatively, an aligned partitioned index with 100 partitions requires only sufficient memory to sort 40 pages, because the sorts are not performed at the same time.</span></span>  
  
 <span data-ttu-id="e0530-188">SQL Server가 다중 프로세서 컴퓨터에서 작성 작업을 수행할 때 병렬 처리 수준을 적용하면 정렬된 인덱스와 정렬되지 않은 인덱스 모두 메모리 요구 사항이 더 커질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-188">For both aligned and nonaligned indexes, the memory requirement can be greater if SQL Server is applying degrees of parallelism to the build operation on a multiprocessor computer.</span></span> <span data-ttu-id="e0530-189">이는 병렬 처리 수준이 높을수록 메모리 요구 사항이 커지기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-189">This is because the greater the degrees of parallelism, the greater the memory requirement.</span></span> <span data-ttu-id="e0530-190">예를 들어 SQL Server에서 병렬 처리 수준을 4로 설정하면 파티션 수가 100개인 정렬되지 않은 분할된 인덱스의 경우 4개의 프로세서에서 4,000페이지(16,000페이지)를 동시에 정렬하는 데 충분한 메모리 크기가 필요하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-190">For example, if SQL Server sets degrees of parallelism to 4, a nonaligned partitioned index with 100 partitions requires sufficient memory for four processors to sort 4,000 pages at the same time, or 16,000 pages.</span></span> <span data-ttu-id="e0530-191">분할된 인덱스가 정렬되어 있는 경우에는 4개의 프로세서에서 40페이지, 즉 160페이지(4\*40)를 정렬할 수 있는 메모리 크기만 있으면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-191">If the partitioned index is aligned, the memory requirement is reduced to four processors sorting 40 pages, or 160 (4 \* 40) pages.</span></span> <span data-ttu-id="e0530-192">병렬 처리 수준은 MAXDOP 인덱스 옵션을 사용하여 수동으로 낮출 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-192">You can use the MAXDOP index option to manually reduce the degrees of parallelism.</span></span>  
  
### <a name="dbcc-commands"></a><span data-ttu-id="e0530-193">DBCC 명령</span><span class="sxs-lookup"><span data-stu-id="e0530-193">DBCC Commands</span></span>  
 <span data-ttu-id="e0530-194">파티션 수가 늘어날수록 DBCC 명령을 실행하는 데 더 많은 시간이 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-194">With a larger number of partitions, DBCC commands could take longer to execute as the number of partitions increases.</span></span>  
  
### <a name="queries"></a><span data-ttu-id="e0530-195">쿼리</span><span class="sxs-lookup"><span data-stu-id="e0530-195">Queries</span></span>  
 <span data-ttu-id="e0530-196">파티션 제거를 사용하는 쿼리는 파티션 수가 많을 경우 향상된 성능을 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-196">Queries that use partition elimination could have comparable or improved performance with larger number of partitions.</span></span> <span data-ttu-id="e0530-197">파티션 제거를 사용하지 않는 쿼리는 파티션 수가 늘어나면 실행하는 데 더 많은 시간이 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-197">Queries that do not use partition elimination could take longer to execute as the number of partitions increases.</span></span>  
  
 <span data-ttu-id="e0530-198">예를 들어 테이블에 1억 개의 행과 `A`, `B`및 `C`열이 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-198">For example, assume a table has 100 million rows and columns `A`, `B`, and `C`.</span></span> <span data-ttu-id="e0530-199">시나리오 1에서는 테이블의 `A`열이 1,000개의 파티션으로 분할됩니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-199">In scenario 1, the table is divided into 1000 partitions on column `A`.</span></span> <span data-ttu-id="e0530-200">시나리오 2에서는 테이블의 `A`열이 10,000개의 파티션으로 분할됩니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-200">In scenario 2, the table is divided into 10,000 partitions on column `A`.</span></span> <span data-ttu-id="e0530-201">`A` 열에서 필터링하는 WHERE 절이 있는 테이블에 대한 쿼리는 파티션 제거를 수행하고 파티션 하나를 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-201">A query on the table that has a WHERE clause filtering on column `A` will perform partition elimination and scan one partition.</span></span> <span data-ttu-id="e0530-202">시나리오 2에서는 파티션에 검사할 행이 더 적기 때문에 동일한 쿼리가 더 빠르게 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-202">That same query may run faster in scenario 2 as there are fewer rows to scan in a partition.</span></span> <span data-ttu-id="e0530-203">B 열에서 필터링하는 WHERE 절이 있는 쿼리는 모든 파티션을 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-203">A query that has a WHERE clause filtering on column B will scan all partitions.</span></span> <span data-ttu-id="e0530-204">시나리오 1에서는 시나리오 2보다 검사할 파티션 수가 더 적기 때문에 쿼리가 더 빠르게 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-204">The query may run faster in scenario 1 than in scenario 2 as there are fewer partitions to scan.</span></span>  
  
 <span data-ttu-id="e0530-205">분할 열이 아닌 열에서 TOP 또는 MAX/MIN과 같은 연산자를 사용하는 쿼리에서는 모든 파티션이 평가되어야 하므로 분할 성능이 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-205">Queries that use operators such as TOP or MAX/MIN on columns other than the partitioning column may experience reduced performance with partitioning because all partitions must be evaluated.</span></span>  
  
## <a name="behavior-changes-in-statistics-computation-during-partitioned-index-operations"></a><span data-ttu-id="e0530-206">분할된 인덱스 작업 중 통계 계산의 동작 변경 내용</span><span class="sxs-lookup"><span data-stu-id="e0530-206">Behavior Changes in Statistics Computation During Partitioned Index Operations</span></span>  
 <span data-ttu-id="e0530-207">[!INCLUDE[ssSQL11](../../includes/sssql11-md.md)]부터 분할된 인덱스를 만들거나 다시 작성할 때 테이블의 모든 행을 검사하여 통계를 작성하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-207">Beginning with [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], statistics are not created by scanning all the rows in the table when a partitioned index is created or rebuilt.</span></span> <span data-ttu-id="e0530-208">대신 쿼리 최적화 프로그램에서 기본 샘플링 알고리즘을 사용하여 통계를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-208">Instead, the query optimizer uses the default sampling algorithm to generate statistics.</span></span> <span data-ttu-id="e0530-209">분할된 인덱스로 데이터베이스를 업그레이드한 후 인덱스에 대한 히스토그램 데이터가 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-209">After upgrading a database with partitioned indexes, you may notice a difference in the histogram data for these indexes.</span></span> <span data-ttu-id="e0530-210">이 동작 변경이 쿼리 성능에는 영향을 주지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-210">This change in behavior may not affect query performance.</span></span> <span data-ttu-id="e0530-211">테이블의 모든 행을 검사하여 분할된 인덱스에 대한 통계를 얻으려면 FULLSCAN 절에서 CREATE STATISTICS 또는 UPDATE STATISTICS를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-211">To obtain statistics on partitioned indexes by scanning all the rows in the table, use CREATE STATISTICS or UPDATE STATISTICS with the FULLSCAN clause.</span></span>  
  
## <a name="related-tasks"></a><span data-ttu-id="e0530-212">관련 작업</span><span class="sxs-lookup"><span data-stu-id="e0530-212">Related Tasks</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e0530-213">**작업**</span><span class="sxs-lookup"><span data-stu-id="e0530-213">**Tasks**</span></span>|<span data-ttu-id="e0530-214">**항목**</span><span class="sxs-lookup"><span data-stu-id="e0530-214">**Topic**</span></span>|  
|<span data-ttu-id="e0530-215">파티션 함수와 파티션 구성표를 만든 다음 테이블 및 인덱스에 적용하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="e0530-215">Describes how to create partition functions and partition schemes and then apply these to a table and index.</span></span>|[<span data-ttu-id="e0530-216">분할된 테이블 및 인덱스 만들기</span><span class="sxs-lookup"><span data-stu-id="e0530-216">Create Partitioned Tables and Indexes</span></span>](create-partitioned-tables-and-indexes.md)|  
|||  
  
## <a name="related-content"></a><span data-ttu-id="e0530-217">관련 내용</span><span class="sxs-lookup"><span data-stu-id="e0530-217">Related Content</span></span>  
 <span data-ttu-id="e0530-218">분할된 테이블 및 인덱스 전략과 구현에 대한 자세한 내용은 다음 백서를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="e0530-218">You may find the following white papers on partitioned table and index strategies and implementations useful.</span></span>  
  
-   <span data-ttu-id="e0530-219">[SQL Server 2008을 사용할 경우의 분할된 테이블 및 인덱스 전략](https://msdn.microsoft.com/library/dd578580\(SQL.100\).aspx)</span><span class="sxs-lookup"><span data-stu-id="e0530-219">[Partitioned Table and Index Strategies Using SQL Server 2008](https://msdn.microsoft.com/library/dd578580\(SQL.100\).aspx)</span></span>  
  
-   <span data-ttu-id="e0530-220">[자동 슬라이딩 윈도우를 구현하는 방법](https://msdn.microsoft.com/library/aa964122\(SQL.90\).aspx)</span><span class="sxs-lookup"><span data-stu-id="e0530-220">[How to Implement an Automatic Sliding Window](https://msdn.microsoft.com/library/aa964122\(SQL.90\).aspx)</span></span>  
  
-   [<span data-ttu-id="e0530-221">분할된 테이블로 대량 로드</span><span class="sxs-lookup"><span data-stu-id="e0530-221">Bulk Loading into a Partitioned Table</span></span>](https://msdn.microsoft.com/library/cc966380.aspx)  
  
-   [<span data-ttu-id="e0530-222">분할된 테이블 및 인덱스에서의 향상된 쿼리 처리</span><span class="sxs-lookup"><span data-stu-id="e0530-222">Query Processing Enhancements on Partitioned Tables and Indexes</span></span>](https://msdn.microsoft.com/library/ms345599.aspx)  
  
-   [<span data-ttu-id="e0530-223">대규모 관계형 데이터 웨어하우스를 구축하기 위한 상위 10가지 최선의 방법</span><span class="sxs-lookup"><span data-stu-id="e0530-223">Top 10 Best Practices for Building a Large Scale Relational Data Warehouse</span></span>](http://sqlcat.com/top10lists/archive/2008/02/06/top-10-best-practices-for-building-a-large-scale-relational-data-warehouse.aspx)  
  
  
