---
title: 병합 복제 성능 향상 | Microsoft 문서
ms.custom: ''
ms.date: 03/08/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: replication
ms.topic: conceptual
helpviewer_keywords:
- publications [SQL Server replication], design and performance
- designing databases [SQL Server], replication performance
- Merge Agent, performance
- snapshots [SQL Server replication], performance considerations
- merge replication performance [SQL Server replication]
- subscriptions [SQL Server replication], performance considerations
- performance [SQL Server replication], merge replication
- agents [SQL Server replication], performance
ms.assetid: f929226f-b83d-4900-a07c-a62f64527c7f
author: MashaMSFT
ms.author: mathoma
ms.openlocfilehash: 41dc258e9b45e9839ad142e73cb145999d02986c
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87741880"
---
# <a name="enhance-merge-replication-performance"></a><span data-ttu-id="240e1-102">병합 복제 성능 향상</span><span class="sxs-lookup"><span data-stu-id="240e1-102">Enhance Merge Replication Performance</span></span>
  <span data-ttu-id="240e1-103">[일반적인 복제 성능 향상](enhance-general-replication-performance.md)에서 설명하는 일반적인 성능 팁을 고려한 후 병합 복제에 대한 다음 영역을 추가로 고려해 보십시오.</span><span class="sxs-lookup"><span data-stu-id="240e1-103">After considering the general performance tips described in [Enhancing General Replication Performance](enhance-general-replication-performance.md), consider these additional areas specific to merge replication.</span></span>  
  
## <a name="database-design"></a><span data-ttu-id="240e1-104">데이터베이스 디자인</span><span class="sxs-lookup"><span data-stu-id="240e1-104">Database Design</span></span>  
  
-   <span data-ttu-id="240e1-105">행 필터 및 조인 필터에 사용된 열을 인덱싱합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-105">Index columns used in row filters and join filters.</span></span>  
  
     <span data-ttu-id="240e1-106">게시된 아티클에 행 필터를 사용하는 경우 필터의 WHERE 절에 사용되는 각 열에 인덱스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-106">When you use a row filter on a published article, create an index on each of the columns that is used in the filter's WHERE clause.</span></span> <span data-ttu-id="240e1-107">인덱스가 없으면 [!INCLUDE[msCoName](../../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]에서는 테이블의 각 행을 읽은 후 해당 행을 파티션에 포함할 것인지 아닌지를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-107">Without an index, [!INCLUDE[msCoName](../../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] has to read each row in the table to determine whether the row should be included in the partition.</span></span> <span data-ttu-id="240e1-108">인덱스가 있다면 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 는 어떤 행을 포함해야 하는지를 빨리 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-108">With an index, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can quickly locate which rows should be included.</span></span> <span data-ttu-id="240e1-109">복제가 인덱스에서만 필터의 WHERE 절을 모두 확인하면 가장 빠른 처리가 이루어집니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-109">The fastest processing takes place if replication can fully resolve the WHERE clause of the filter from the index alone.</span></span>  
  
     <span data-ttu-id="240e1-110">조인 필터에 사용되는 모든 열에 인덱스를 만드는 것도 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-110">Indexing all the columns used in join filters is also important.</span></span> <span data-ttu-id="240e1-111">병합 에이전트는 실행될 때마다 기본 테이블의 어떤 열과 관련 테이블의 어떤 열을 파티션에 포함할 것인지를 결정하기 위해 부모 테이블을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-111">Each time the Merge Agent runs, it searches the base table to determine which rows in a parent table and which rows in related tables are included in a partition.</span></span> <span data-ttu-id="240e1-112">조인된 열에 인덱스를 만들면 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 에서는 병합 에이전트가 실행될 때마다 테이블의 각 행을 읽지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-112">Creating an index on the joined columns avoids having [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] read each row in the table every time the Merge Agent runs.</span></span>  
  
     <span data-ttu-id="240e1-113">필터링에 대한 자세한 내용은 [병합 복제의 게시된 데이터 필터링](../merge/filter-published-data-for-merge-replication.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="240e1-113">For more information on filtering, see [Filter Published Data for Merge Replication](../merge/filter-published-data-for-merge-replication.md).</span></span>  
  
-   <span data-ttu-id="240e1-114">LOB(Large Object) 데이터 형식을 포함하는 테이블을 너무 많이 정규화한 경우를 고려해 보십시오.</span><span class="sxs-lookup"><span data-stu-id="240e1-114">Consider overnormalizing tables that include Large Object (LOB) data types.</span></span>  
  
     <span data-ttu-id="240e1-115">동기화가 발생할 때 병합 에이전트는 게시자 또는 구독자에서 전체 데이터 행을 읽고 전송해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-115">When synchronization occurs, the Merge Agent might need to read and transfer the entire data row from a Publisher or Subscriber.</span></span> <span data-ttu-id="240e1-116">이 행에 LOB를 사용하는 열이 있다면 추가 메모리 할당이 필요하고 이러한 열이 업데이트되지 않았어도 성능에 부정적 영향을 미칠 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-116">If the row contains columns that use LOBs, this process can require additional memory allocation and negatively impact performance even though these columns may not have been updated.</span></span> <span data-ttu-id="240e1-117">이렇게 성능에 미칠 영향을 줄이려면 나머지 행 데이터에 대해 일 대 일 관계를 사용하여 LOB 열을 별개의 테이블에 두도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-117">To reduce the likelihood that this performance impact occurs, consider putting LOB columns in a separate table using a one-to-one relationship to the rest of the row data.</span></span> <span data-ttu-id="240e1-118">`text`, `ntext` 및 `image` 데이터 형식은 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-118">The data types `text`, `ntext`, and `image` are deprecated.</span></span> <span data-ttu-id="240e1-119">LOB를 포함시킬 경우 데이터 형식 `varchar(max)`, `nvarchar(max)`, `varbinary(max)`를 각각 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-119">If you do include LOBs, we recommend that you use the data types `varchar(max)`, `nvarchar(max)`, `varbinary(max)`, respectively.</span></span>  
  
## <a name="publication-design"></a><span data-ttu-id="240e1-120">게시 디자인</span><span class="sxs-lookup"><span data-stu-id="240e1-120">Publication Design</span></span>  
  
-   <span data-ttu-id="240e1-121">90RTM([!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)] 이상 버전)의 게시 호환성 수준을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-121">Use a publication compatibility level of 90RTM ([!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)] or a later version).</span></span>  
  
     <span data-ttu-id="240e1-122">하나 이상의 구독자가 동일한 버전의 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]를 사용하면 게시에서 [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)] 이상 버전만 지원하도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-122">Unless one or more Subscribers use a different version of [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], specify that the publication must support only [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)] or a later version.</span></span> <span data-ttu-id="240e1-123">이렇게 하면 게시에서 새로운 기능과 성능 최적화를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-123">This allows the publication to take advantage of new features and performance optimizations.</span></span>  
  
-   <span data-ttu-id="240e1-124">적절한 게시 보존 설정을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-124">Use appropriate publication retention settings.</span></span>  
  
     <span data-ttu-id="240e1-125">구독이 동기화되기 전까지의 최대 시간을 나타내는 게시 보존 기간은 추적 메타데이터가 저장되는 기간을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-125">The publication retention period, which is the maximum amount of time before a subscription must be synchronized, determines how long tracking metadata is stored.</span></span> <span data-ttu-id="240e1-126">값이 높으면 스토리지 및 처리 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-126">A high value can affect storage and processing performance.</span></span> <span data-ttu-id="240e1-127">게시 보존 기간을 설정하는 방법은 [Subscription Expiration and Deactivation](../subscription-expiration-and-deactivation.md)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="240e1-127">For more information about setting the publication retention period, see [Subscription Expiration and Deactivation](../subscription-expiration-and-deactivation.md).</span></span>  
  
-   <span data-ttu-id="240e1-128">게시자에서만 변경되는 테이블의 다운로드 전용 아티클을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-128">Use download-only articles on those tables that are only changed at the Publisher.</span></span> <span data-ttu-id="240e1-129">자세한 내용은 [다운로드 전용 아티클로 병합 복제 성능 최적화](../merge/optimize-merge-replication-performance-with-download-only-articles.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="240e1-129">For more information, see [Optimize Merge Replication Performance with Download-Only Articles](../merge/optimize-merge-replication-performance-with-download-only-articles.md).</span></span>  
  
### <a name="filter-design-and-use"></a><span data-ttu-id="240e1-130">필터 디자인 및 사용</span><span class="sxs-lookup"><span data-stu-id="240e1-130">Filter Design and Use</span></span>  
  
-   <span data-ttu-id="240e1-131">행 필터 절의 복잡도를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-131">Limit the complexity of row filter clauses.</span></span>  
  
     <span data-ttu-id="240e1-132">필터링 조건의 복잡도를 제한하면 병합 에이전트가 구독자로 보낼 행 변경 내용을 평가할 때 성능을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-132">Limiting the complexity of the filtering criteria helps improve performance when the Merge Agent is evaluating row changes to send to Subscribers.</span></span> <span data-ttu-id="240e1-133">병합 행 필터 절에 하위 선택을 사용하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-133">Avoid using sub-selects within merge row filter clauses.</span></span> <span data-ttu-id="240e1-134">대신 다른 테이블의 행 필터 절을 기반으로 하는 한 테이블에서 데이터를 보다 효율적으로 분할할 수 있는 조인 필터의 사용을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-134">Instead, consider using join filters, which are generally more efficient when used to partition data in one table based on the row filter clause in another table.</span></span> <span data-ttu-id="240e1-135">필터링에 대한 자세한 내용은 [병합 복제의 게시된 데이터 필터링](../merge/filter-published-data-for-merge-replication.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="240e1-135">For more information about filtering, see [Filter Published Data for Merge Replication](../merge/filter-published-data-for-merge-replication.md).</span></span>  
  
-   <span data-ttu-id="240e1-136">매개 변수가 있는 필터와 함께 사전 계산 파티션을 사용합니다. 이 기능은 기본적으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-136">Use precomputed partitions with parameterized filters (this feature is used by default).</span></span> <span data-ttu-id="240e1-137">자세한 내용은 [사전 계산 파티션으로 매개 변수가 있는 필터 성능 최적화](../merge/parameterized-filters-optimize-for-precomputed-partitions.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="240e1-137">For more information, see [Optimize Parameterized Filter Performance with Precomputed Partitions](../merge/parameterized-filters-optimize-for-precomputed-partitions.md).</span></span>  
  
     <span data-ttu-id="240e1-138">사전 계산 파티션은 여러 가지 필터링 동작을 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-138">Precomputed partitions impose a number of limits on filtering behavior.</span></span> <span data-ttu-id="240e1-139">애플리케이션이 이러한 제한 사항을 따를 수 없는 경우 **keep_partition_changes** 옵션을 **True**로 설정하면 성능상 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-139">If your application cannot adhere to these limitations, set the **keep_partition_changes** option to **True**, which provides a performance benefit.</span></span> <span data-ttu-id="240e1-140">자세한 내용은 [매개 변수가 있는 행 필터](../merge/parameterized-filters-parameterized-row-filters.md)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="240e1-140">For more information, see [Parameterized Row Filters](../merge/parameterized-filters-parameterized-row-filters.md).</span></span>  
  
-   <span data-ttu-id="240e1-141">데이터가 필터링되었지만 사용자 간에 공유되지 않으면 겹치지 않는 파티션을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-141">Use nonoverlapping partitions if data is filtered but not shared among users.</span></span>  
  
     <span data-ttu-id="240e1-142">복제에서는 파티션 또는 구독 간에 공유되지 않는 데이터의 성능을 최적화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-142">Replication can optimize performance for data that is not shared between partitions or subscriptions.</span></span> <span data-ttu-id="240e1-143">자세한 내용은 [매개 변수가 있는 행 필터](../merge/parameterized-filters-parameterized-row-filters.md)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="240e1-143">For more information, see [Parameterized Row Filters](../merge/parameterized-filters-parameterized-row-filters.md).</span></span>  
  
-   <span data-ttu-id="240e1-144">복잡한 조인 필터 계층을 만들지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-144">Do not create complex join filter hierarchies.</span></span>  
  
     <span data-ttu-id="240e1-145">5개 이상의 테이블을 가진 조인 필터는 병합 처리 중 성능에 크게 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-145">Join filters with five or more tables can significantly impact performance during merge processing.</span></span> <span data-ttu-id="240e1-146">5개 이상의 테이블을 가진 조인 필터를 생성하는 경우 다른 해결책을 고려하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-146">We recommend that if you are generating join filters of five or more tables that you consider other solutions:</span></span>  
  
    -   <span data-ttu-id="240e1-147">주로 조회 테이블, 작은 테이블 및 변경이 필요하지 않은 테이블로 구성된 테이블은 필터링하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-147">Avoid filtering tables that are primarily lookup tables, smaller tables, and tables that are not subject to change.</span></span> <span data-ttu-id="240e1-148">이러한 테이블을 전체적으로 게시의 일부로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-148">Make those tables part of the publication in their entirety.</span></span> <span data-ttu-id="240e1-149">구독자 간에 분할되어야 하는 테이블 사이에만 조인 필터를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-149">We recommend that you use join filters only between tables that must be partitioned among Subscribers.</span></span> <span data-ttu-id="240e1-150">자세한 내용은 [Join Filters](../merge/join-filters.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="240e1-150">For more information, see [Join Filters](../merge/join-filters.md).</span></span>  
  
    -   <span data-ttu-id="240e1-151">조인에 테이블이 많은 경우 데이터베이스 디자인을 비정규화하거나 매핑 테이블을 사용할 것을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-151">Consider denormalizing the database design or using a mapping table if there are a large number of tables in a join.</span></span> <span data-ttu-id="240e1-152">예를 들어 영업 사원은 자신의 고객에 대한 데이터만 필요한 경우 고객을 영업 사원과 연결하기 위해 6개의 조인이 필요하다면 영업 사원을 식별하는 customer 테이블에 열을 추가할 것을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-152">For example, if a sales person needs only the data for her customers, but it requires six joins to associate a customer with a sales person, consider adding a column to the customer table that identifies the sales person.</span></span> <span data-ttu-id="240e1-153">영업 사원 데이터는 중복되지만 복제를 분할하는 것이 해당 테이블을 비정규화하는 것보다 성능상 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-153">The sales person data is redundant, but the costs of denormalizing the tables somewhat might be outweighed by the performance benefits for replication partitioning.</span></span>  
  
    -   <span data-ttu-id="240e1-154">일괄 처리에 많은 데이터 변경 사항이 있을 때 사전 계산 파티션의 성능을 향상시키기 위해 신중하게 애플리케이션을 디자인합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-154">To improve the performance of precomputed partitions when batches contain lots of data changes, design your application with care.</span></span> <span data-ttu-id="240e1-155">조인 필터에서 부모 테이블의 데이터 변경은 자식 테이블의 해당 데이터 변경보다 먼저 수행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-155">Make sure that changes to data in the parent table in a join filter are made before corresponding changes in the child tables.</span></span>  
  
-   <span data-ttu-id="240e1-156">논리에 맞는 경우 **join_unique_key** 옵션을 **1** 로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-156">Set the **join_unique_key** option to **1** if logic allows.</span></span>  
  
     <span data-ttu-id="240e1-157">이 매개 변수를 **1** 로 설정하면 조인 필터에서 자식 테이블과 부모 테이블 사이의 관계가 일 대 일 또는 일 대 다가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-157">Setting this parameter to **1** indicates that the relationship between the child and parent tables in a join filter is one to one or one to many.</span></span> <span data-ttu-id="240e1-158">자식 테이블의 조인 열에 고유성을 보장하는 제약 조건이 있는 경우에만 이 매개 변수를 **1** 로 설정하십시오.</span><span class="sxs-lookup"><span data-stu-id="240e1-158">Only set this parameter to **1** if you have a constraint on the joining column in the child table that guarantees uniqueness.</span></span> <span data-ttu-id="240e1-159">그렇지 않은 경우에 이 매개 변수를 **1** 로 설정하면 데이터가 일치하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-159">If the parameter is set to **1** incorrectly, non-convergence of data can occur.</span></span> <span data-ttu-id="240e1-160">자세한 내용은 [Join Filters](../merge/join-filters.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="240e1-160">For more information, see [Join Filters](../merge/join-filters.md).</span></span>  
  
-   <span data-ttu-id="240e1-161">사전 계산 파티션을 사용하는 경우 많은 변경 사항이 있는 일괄 처리를 실행하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-161">Avoid executing batches with lots of changes when you use precomputed partitions.</span></span>  
  
     <span data-ttu-id="240e1-162">많은 데이터 변경 사항이 있는 일괄 처리를 실행한 후 병합 에이전트를 실행하면 이 에이전트에서 큰 일괄 처리를 여러 개의 작은 일괄 처리로 나눕니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-162">When the Merge Agent is run after you run a batch that contains lots of data changes, the agent tries to divide the large batch into smaller batches.</span></span> <span data-ttu-id="240e1-163">이 시간 동안 다른 병합 에이전트 프로세스는 차단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-163">During this time, other Merge Agent processes may be blocked.</span></span> <span data-ttu-id="240e1-164">일괄 처리의 변경 사항 수를 줄이고 일괄 처리 사이에 병합 에이전트를 실행하십시오.</span><span class="sxs-lookup"><span data-stu-id="240e1-164">Consider reducing the number of changes in a batch and run the Merge Agent between batches.</span></span> <span data-ttu-id="240e1-165">이렇게 할 수 없으면 게시에 대한 **generation_leveling_threshold** 값을 늘립니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-165">If this cannot be done, increase the value of **generation_leveling_threshold** for the publication.</span></span>  
  
## <a name="subscription-considerations"></a><span data-ttu-id="240e1-166">구독 고려 사항</span><span class="sxs-lookup"><span data-stu-id="240e1-166">Subscription Considerations</span></span>  
  
-   <span data-ttu-id="240e1-167">구독 동기화 일정은 엇갈리게 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-167">Stagger subscription synchronization schedules.</span></span>  
  
     <span data-ttu-id="240e1-168">많은 구독자가 게시자와 동기화하는 경우 각각의 병합 에이전트가 서로 다른 시간에 실행되도록 일정을 엇갈리게 설정해 봅니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-168">If a large number of Subscribers synchronize with a Publisher, consider staggering the schedules so that Merge Agents run at different times.</span></span> <span data-ttu-id="240e1-169">자세한 내용은 [Specify Synchronization Schedules](../specify-synchronization-schedules.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="240e1-169">For more information, see [Specify Synchronization Schedules](../specify-synchronization-schedules.md).</span></span>  
  
## <a name="merge-agent-parameters"></a><span data-ttu-id="240e1-170">병합 에이전트 매개 변수</span><span class="sxs-lookup"><span data-stu-id="240e1-170">Merge Agent Parameters</span></span>  
 <span data-ttu-id="240e1-171">병합 에이전트와 해당 매개 변수에 대한 자세한 내용은 [Replication Merge Agent](../agents/replication-merge-agent.md)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="240e1-171">For information about the Merge Agent and its parameters, see [Replication Merge Agent](../agents/replication-merge-agent.md).</span></span>  
  
-   <span data-ttu-id="240e1-172">끌어오기 구독에 대한 모든 구독자를 [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)] 이상 버전으로 업그레이드합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-172">Upgrade all Subscribers for pull subscriptions to [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)] or a later version.</span></span>  
  
     <span data-ttu-id="240e1-173">구독자를 [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)] 이상 버전으로 업그레이드하면 해당 구독자의 구독에서 사용한 병합 에이전트가 업그레이드됩니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-173">Upgrading the Subscriber to [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)] or a later version upgrades the Merge Agent used by the subscriptions at that Subscriber.</span></span> <span data-ttu-id="240e1-174">여러 가지 새로운 기능과 성능 최적화를 사용하려면 [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)] 이상 버전의 병합 에이전트가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-174">To take advantage of many of the new features and performance optimizations, the Merge Agent from [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)] or a later version is required.</span></span>  
  
-   <span data-ttu-id="240e1-175">구독이 빠른 연결을 통해 동기화되고 게시자에서 구독자로 변경 내용이 전송되면 병합 에이전트에 대해 **–ParallelUploadDownload** 매개 변수를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-175">If a subscription is synchronized over a fast connection and changes are sent from the Publisher and Subscriber, use the **-ParallelUploadDownload** parameter for the Merge Agent.</span></span>  
  
     [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)]<span data-ttu-id="240e1-176">에는 새로운 병합 에이전트 매개 변수인 **–ParallelUploadDownload**가 도입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-176">introduced a new Merge Agent parameter: **-ParallelUploadDownload**.</span></span> <span data-ttu-id="240e1-177">이 매개 변수를 설정하면 병합 에이전트가 게시자로 업로드되는 변경 내용과 구독자로 다운로드되는 변경 내용을 병렬로 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-177">Setting this parameter allows the Merge Agent to process in parallel the changes uploaded to the Publisher and those downloaded to the Subscriber.</span></span> <span data-ttu-id="240e1-178">이것은 네트워크 대역폭이 높은 대규모 환경에서 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-178">This is useful in high volume environments with high network bandwidth.</span></span> <span data-ttu-id="240e1-179">에이전트 프로필 및 명령줄에서 에이전트 매개 변수를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-179">Agent parameters can be specified in agent profiles and on the command line.</span></span> <span data-ttu-id="240e1-180">자세한 내용은 다음을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="240e1-180">For more information, see:</span></span>  
  
    -   [<span data-ttu-id="240e1-181">복제 에이전트 프로필 작업</span><span class="sxs-lookup"><span data-stu-id="240e1-181">Work with Replication Agent Profiles</span></span>](../agents/replication-agent-profiles.md)  
  
    -   [<span data-ttu-id="240e1-182">복제 에이전트의 명령 프롬프트 매개 변수 보기 및 수정&#40;SQL Server Management Studio&#41;</span><span class="sxs-lookup"><span data-stu-id="240e1-182">View and Modify Replication Agent Command Prompt Parameters &#40;SQL Server Management Studio&#41;</span></span>](../agents/view-and-modify-replication-agent-command-prompt-parameters.md)  
  
    -   [<span data-ttu-id="240e1-183">Replication Agent Executables Concepts</span><span class="sxs-lookup"><span data-stu-id="240e1-183">Replication Agent Executables Concepts</span></span>](../concepts/replication-agent-executables-concepts.md)  
  
-   <span data-ttu-id="240e1-184">특히 동기화할 때 구독자로부터의 업로드와 구독자로의 다운로드가 더 많이 필요한 경우 **-MakeGenerationInterval** 매개 변수의 값을 늘릴 것을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-184">Consider increasing the value of the **-MakeGenerationInterval** parameter, especially if synchronization involves more uploads from Subscribers than downloads to Subscribers.</span></span>  
  
-   <span data-ttu-id="240e1-185">LOB 열이 있는 행처럼 많은 양의 데이터가 있는 데이터 행을 동기화할 때는 웹 동기화에 추가 메모리 할당이 필요하고 성능이 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-185">When you synchronize data rows with a large amount of data, such as rows with LOB columns, Web synchronization can require additional memory allocation and hurt performance.</span></span> <span data-ttu-id="240e1-186">병합 에이전트에서 대량의 데이터가 있는 데이터 행을 너무 많이 포함한 XML 메시지를 생성하는 경우 이러한 현상이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-186">This occurs when the Merge Agent generates an XML message that contains too many data rows with large amounts of data.</span></span> <span data-ttu-id="240e1-187">병합 에이전트가 웹 동기화 중에 너무 많은 리소스를 소비하는 경우 다음 중 한 가지 방법으로 단일 메시지에 보내는 행 수를 줄이십시오.</span><span class="sxs-lookup"><span data-stu-id="240e1-187">If the Merge Agent is consuming too many resources during Web synchronization, reduce the number of rows sent in a single message in one of the following ways:</span></span>  
  
    -   <span data-ttu-id="240e1-188">병합 에이전트에 느린 연결 에이전트 프로필을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-188">Use the slow link agent profile for the Merge Agent.</span></span> <span data-ttu-id="240e1-189">자세한 내용은 [Replication Agent Profiles](../agents/replication-agent-profiles.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="240e1-189">For more information, see [Replication Agent Profiles](../agents/replication-agent-profiles.md).</span></span>  
  
    -   <span data-ttu-id="240e1-190">병합 에이전트의 경우 **-DownloadGenerationsPerBatch** 및 **-UploadGenerationsPerBatch** 매개 변수를 10 이하의 값으로 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-190">Decrease the **-DownloadGenerationsPerBatch** and **-UploadGenerationsPerBatch** parameters for the Merge Agent to a value of 10 or less.</span></span> <span data-ttu-id="240e1-191">이들 매개 변수의 기본값은 50입니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-191">The default value of these parameters is 50.</span></span>  
  
## <a name="snapshot-considerations"></a><span data-ttu-id="240e1-192">스냅샷 고려 사항</span><span class="sxs-lookup"><span data-stu-id="240e1-192">Snapshot Considerations</span></span>  
  
-   <span data-ttu-id="240e1-193">초기 스냅샷을 생성하기 전에 대형 테이블에 ROWGUIDCOL 열을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-193">Create a ROWGUIDCOL column on large tables prior to generating the initial snapshot.</span></span>  
  
     <span data-ttu-id="240e1-194">병합 복제에서 게시된 각 테이블은 ROWGUIDCOL 열을 가져야 합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-194">Merge replication requires that each published table have a ROWGUIDCOL column.</span></span> <span data-ttu-id="240e1-195">스냅샷 에이전트가 초기 스냅샷 파일을 만들기 전에 ROWGUIDCOL 열이 테이블에 없다면 에이전트는 우선 ROWGUIDCOL 열을 추가하고 채워야 합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-195">If a ROWGUIDCOL column does not exist in the table before the Snapshot Agent creates the initial snapshot files, the agent must first add and populate the ROWGUIDCOL column.</span></span> <span data-ttu-id="240e1-196">병합 복제 중 스냅샷을 생성할 때 성능을 향상시키려면 게시하기 전 각 테이블에 ROWGUIDCOL 열을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-196">To gain a performance advantage when generating snapshots during merge replication, create the ROWGUIDCOL column on each table before publishing.</span></span> <span data-ttu-id="240e1-197">이 열은 어떤 이름도 가질 수 있지만(기본적으로 스냅샷 에이전트는**rowguid** 를 사용) 다음 데이터 형식 특징이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-197">The column can have any name (**rowguid** is used by the Snapshot Agent by default), but must have the following data type characteristics:</span></span>  
  
    -   <span data-ttu-id="240e1-198">UNIQUEIDENTIFIER 데이터 형식</span><span class="sxs-lookup"><span data-stu-id="240e1-198">A data type of UNIQUEIDENTIFIER.</span></span>  
  
    -   <span data-ttu-id="240e1-199">NEWSEQUENTIALID() 또는 NEWID()의 기본값.</span><span class="sxs-lookup"><span data-stu-id="240e1-199">A default of NEWSEQUENTIALID() or NEWID().</span></span> <span data-ttu-id="240e1-200">NEWSEQUENTIALID()는 변경을 수행하고 추적할 때 성능을 향상시킬 수 있으므로 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-200">NEWSEQUENTIALID() is recommended because it can provide increased performance when making and tracking changes.</span></span>  
  
    -   <span data-ttu-id="240e1-201">ROWGUIDCOL 속성 집합</span><span class="sxs-lookup"><span data-stu-id="240e1-201">The ROWGUIDCOL property set.</span></span>  
  
    -   <span data-ttu-id="240e1-202">열에 있는 고유 인덱스</span><span class="sxs-lookup"><span data-stu-id="240e1-202">A unique index on the column.</span></span>  
  
-   <span data-ttu-id="240e1-203">스냅샷을 미리 생성하거나 구독자가 처음 동기화될 때 스냅샷의 생성과 적용을 요청하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-203">Pre-generate snapshots and/or allow Subscribers to request snapshot generation and application the first time they synchronize.</span></span>  
  
     <span data-ttu-id="240e1-204">이러한 옵션 중 하나 또는 둘 모두를 사용하여 매개 변수가 있는 필터를 사용하는 게시에 대한 스냅샷을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-204">Use one or both of these options to provide snapshots for publications that use parameterized filters.</span></span> <span data-ttu-id="240e1-205">이러한 옵션을 하나도 지정하지 않으면 **bcp** 유틸리티를 사용하지 않고 일련의 SELECT 및 INSERT 문을 사용하여 구독을 초기화하게 되는데 이 경우 프로세스의 속도가 훨씬 느립니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-205">If you do not specify one of these options, subscriptions are initialized using a series of SELECT and INSERT statements, rather than using the **bcp** utility; this process is much slower.</span></span> <span data-ttu-id="240e1-206">자세한 내용은 [Snapshots for Merge Publications with Parameterized Filters](../snapshots-for-merge-publications-with-parameterized-filters.md)을(를) 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="240e1-206">For more information, see [Snapshots for Merge Publications with Parameterized Filters](../snapshots-for-merge-publications-with-parameterized-filters.md).</span></span>  
  
## <a name="maintenance-and-monitoring-considerations"></a><span data-ttu-id="240e1-207">유지 관리 및 모니터링 고려 사항</span><span class="sxs-lookup"><span data-stu-id="240e1-207">Maintenance and Monitoring Considerations</span></span>  
  
-   <span data-ttu-id="240e1-208">병합 복제 시스템 테이블의 인덱스를 가끔씩 다시 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-208">Occasionally re-index merge replication system tables.</span></span>  
  
     <span data-ttu-id="240e1-209">병합 복제 유지 관리의 한 부분으로 병합 복제와 연결된 **MSmerge_contents**, **MSmerge_genhistory**및 **MSmerge_tombstone**, **MSmerge_current_partition_mappings**및 **MSmerge_past_partition_mappings**시스템 테이블의 증가를 확인하십시오.</span><span class="sxs-lookup"><span data-stu-id="240e1-209">As part of maintenance for merge replication, occasionally check the growth of the system tables associated with merge replication: **MSmerge_contents**, **MSmerge_genhistory**, and **MSmerge_tombstone**, **MSmerge_current_partition_mappings**, and **MSmerge_past_partition_mappings**.</span></span> <span data-ttu-id="240e1-210">이러한 테이블의 인덱스를 주기적으로 다시 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-210">Periodically re-index these tables.</span></span> <span data-ttu-id="240e1-211">자세한 내용은 [인덱스 다시 구성 및 다시 작성](../../indexes/reorganize-and-rebuild-indexes.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="240e1-211">For more information, see [Reorganize and Rebuild Indexes](../../indexes/reorganize-and-rebuild-indexes.md).</span></span>  
  
-   <span data-ttu-id="240e1-212">복제 모니터의 **동기화 기록** 탭을 사용하여 동기화 성능을 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-212">Monitor synchronization performance using the **Synchronization History** tab in Replication Monitor.</span></span>  
  
     <span data-ttu-id="240e1-213">병합 복제의 경우 복제 모니터는 각 처리 단계(변경 내용 업로드, 변경 내용 다운로드 등)에 소요된 시간을 포함하여 동기화 중에 처리된 각 아티클에 대한 자세한 통계를 **동기화 기록** 탭에 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-213">For merge replication, Replication Monitor displays detailed statistics in the **Synchronization History** tab for each article processed during synchronization, including the amount of time spent in each processing phase (uploading changes, downloading changes, and so on).</span></span> <span data-ttu-id="240e1-214">이 통계는 속도 저하의 원인이 되고 병합 구독의 성능 문제를 해결하기에 가장 적합한 특정 테이블을 정확히 찾아내는 데 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="240e1-214">It can help pinpoint specific tables that are causing slow downs and is the best place to troubleshoot performance issues with merge subscriptions.</span></span> <span data-ttu-id="240e1-215">자세한 통계 보기에 대한 자세한 내용은 [복제 모니터를 사용하여 정보 보기 및 태스크 수행](../monitor/view-information-and-perform-tasks-replication-monitor.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="240e1-215">For more information on viewing detailed statistics, see [View Information and Perform Tasks using Replication Monitor](../monitor/view-information-and-perform-tasks-replication-monitor.md).</span></span>  
  
  
