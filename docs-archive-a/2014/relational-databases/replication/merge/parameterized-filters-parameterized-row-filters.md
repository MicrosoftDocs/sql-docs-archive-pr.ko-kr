---
title: 매개 변수가 있는 행 필터 | Microsoft 문서
ms.custom: ''
ms.date: 06/02/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: replication
ms.topic: conceptual
helpviewer_keywords:
- publications [SQL Server replication], dynamic filters
- merge replication [SQL Server replication], dynamic filters
- parameterized filters [SQL Server replication]
- filters [SQL Server replication], dynamic
- merge replication parameterized filters [SQL Server replication]
- publications [SQL Server replication], parameterized filters
- parameterized filters [SQL Server replication], about parameterized filters
- filters [SQL Server replication], parameterized
- dynamic filters [SQL Server replication]
ms.assetid: b48a6825-068f-47c8-afdc-c83540da4639
author: MashaMSFT
ms.author: mathoma
ms.openlocfilehash: a293d5dfc6bfbdf66afb680f0604117e2cc02b2d
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87646367"
---
# <a name="parameterized-row-filters"></a><span data-ttu-id="cb3c9-102">매개 변수가 있는 행 필터</span><span class="sxs-lookup"><span data-stu-id="cb3c9-102">Parameterized Row Filters</span></span>
  <span data-ttu-id="cb3c9-103">매개 변수가 있는 행 필터를 사용하면 여러 게시를 만들지 않고도 데이터의 여러 파티션을 서로 다른 구독자로 보낼 수 있습니다. 이전 버전의 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]에서는 매개 변수가 있는 행 필터를 동적 필터라고 불렀습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-103">Parameterized row filters allow different partitions of data to be sent to different Subscribers without requiring multiple publications to be created (parameterized filters were referred to as dynamic filters in previous versions of [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]).</span></span> <span data-ttu-id="cb3c9-104">파티션은 테이블에 있는 행의 하위 집합입니다. 게시된 테이블의 각 행은 매개 변수가 있는 필터를 만들 때 선택한 설정에 따라 하나의 파티션에만 속하거나(겹치지 않는 파티션 생성) 두 개 이상의 파티션에 속할 수 있습니다(겹치는 파티션 생성).</span><span class="sxs-lookup"><span data-stu-id="cb3c9-104">A partition is a subset of the rows in a table; depending on the settings chosen when creating a parameterized row filter, each row in a published table can belong to one partition only (which produces nonoverlapping partitions) or to two or more partitions (which produces overlapping partitions).</span></span>  
  
 <span data-ttu-id="cb3c9-105">겹치지 않는 파티션을 구독 간에 공유하게 하거나 지정된 파티션을 한 구독에서만 받도록 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-105">Nonoverlapping partitions can be shared among subscriptions or they can be restricted so that only one subscription receives a given partition.</span></span> <span data-ttu-id="cb3c9-106">파티션의 동작을 제어하는 설정은 나중에 이 항목의 "적절한 필터링 옵션 사용"에서 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-106">The settings that control partition behavior are described in "Using the Appropriate Filtering Options" later in this topic.</span></span> <span data-ttu-id="cb3c9-107">이 설정을 사용하면 매개 변수가 있는 필터링을 애플리케이션 및 성능 요구 사항에 알맞게 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-107">Using these settings you can tailor parameterized filtering according to application and performance requirements.</span></span> <span data-ttu-id="cb3c9-108">일반적으로 겹치는 파티션은 유연성이 뛰어나고, 단일 구독으로 복제되는 겹치지 않는 파티션은 성능이 뛰어납니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-108">In general, overlapping partitions allow for greater flexibility, and nonoverlapping partitions replicated to a single subscription provide better performance.</span></span>  
  
 <span data-ttu-id="cb3c9-109">매개 변수가 있는 필터는 단일 테이블에서 사용되며 일반적으로 조인 필터와 함께 사용하여 관련 테이블로 필터링을 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-109">Parameterized filters are used on a single table and are typically combined with join filters to extend filtering to related tables.</span></span> <span data-ttu-id="cb3c9-110">자세한 내용은 [Join Filters](join-filters.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-110">For more information, see [Join Filters](join-filters.md).</span></span>  
  
 <span data-ttu-id="cb3c9-111">매개 변수가 있는 행 필터를 정의하거나 수정하려면 [병합 아티클에 대한 매개 변수가 있는 행 필터 정의 및 수정](../publish/define-and-modify-a-parameterized-row-filter-for-a-merge-article.md)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-111">To define or modify a parameterized row filter, see [Define and Modify a Parameterized Row Filter for a Merge Article](../publish/define-and-modify-a-parameterized-row-filter-for-a-merge-article.md).</span></span>  
  
## <a name="how-parameterized-filters-work"></a><span data-ttu-id="cb3c9-112">매개 변수가 있는 필터의 동작 방식</span><span class="sxs-lookup"><span data-stu-id="cb3c9-112">How Parameterized Filters Work</span></span>  
 <span data-ttu-id="cb3c9-113">매개 변수가 있는 행 필터는 WHERE 절을 사용하여 게시할 데이터를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-113">A parameterized row filter uses a WHERE clause to select the appropriate data to be published.</span></span> <span data-ttu-id="cb3c9-114">정적 행 필터와는 달리 해당 절에 리터럴 값을 지정하는 대신 SUSER_SNAME() 및 HOST_NAME() 시스템 함수를 하나 또는 둘 모두 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-114">Rather than specifying a literal value in the clause (as you do with a static row filter), you specify one or both of the following system functions: SUSER_SNAME() and HOST_NAME().</span></span> <span data-ttu-id="cb3c9-115">사용자 정의 함수를 사용할 수도 있지만 사용자 정의 함수는 함수 본문에 SUSER_SNAME() 또는 HOST_NAME()을 포함해야 하거나 `MyUDF(SUSER_SNAME()`과 같은 시스템 함수 중 하나를 평가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-115">User-defined functions can also be used, but they must include SUSER_SNAME() or HOST_NAME() in the body of the function, or evaluate one of these system functions (such as `MyUDF(SUSER_SNAME()`).</span></span> <span data-ttu-id="cb3c9-116">사용자 정의 함수의 본문에 SUSER_SNAME() 또는 HOST_NAME()이 포함되어 있는 경우 함수에 매개 변수를 전달할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-116">If a user-defined function includes SUSER_SNAME() or HOST_NAME() in the body of the function, you cannot pass parameters to the function.</span></span>  
  
 <span data-ttu-id="cb3c9-117">SUSER_SNAME() 및 HOST_NAME() 시스템 함수는 병합 복제에 사용하는 것이 아니라 병합 복제에서 매개 변수가 있는 필터링용으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-117">The system functions SUSER_SNAME() and HOST_NAME() are not specific to merge replication, but they are used by merge replication for parameterized filtering:</span></span>  
  
-   <span data-ttu-id="cb3c9-118">SUSER_SNAME()은 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]인스턴스 연결에 대한 로그인 정보를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-118">SUSER_SNAME() returns login information for connections made to an instance of [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="cb3c9-119">매개 변수가 있는 필터에서 사용하면 병합 에이전트가 게시자로 연결할 때 사용한 로그인을 반환합니다. 로그인은 구독을 만들 때 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-119">When used in a parameterized filter, it returns the login used by the Merge Agent to connect to the Publisher (you specify a login when you create a subscription).</span></span>  
  
-   <span data-ttu-id="cb3c9-120">HOST_NAME()은 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]인스턴스에 연결한 컴퓨터의 이름을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-120">HOST_NAME() returns the name of the computer that is connecting to an instance of [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="cb3c9-121">이 시스템 함수를 매개 변수가 있는 필터에 사용하면 기본적으로 병합 에이전트가 실행 중인 컴퓨터의 이름이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-121">When used in a parameterized filter, by default it returns the name of the computer on which the Merge Agent is running.</span></span> <span data-ttu-id="cb3c9-122">끌어오기 구독의 경우 구독자의 이름을 반환하고 밀어넣기 구독의 경우 배포자의 이름을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-122">For pull subscriptions it is the name of the Subscriber; for push subscriptions it is the name of the Distributor.</span></span>  
  
     <span data-ttu-id="cb3c9-123">구독자 또는 배포자 이름 대신 다른 값으로 이 함수를 재정의할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-123">It is also possible to override this function with a value other than the name of the Subscriber or Distributor.</span></span> <span data-ttu-id="cb3c9-124">일반적으로 애플리케이션에서는 판매 직원 이름 또는 판매 직원 ID와 같은 의미 있는 값으로 이 함수를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-124">Typically applications override this function with more meaningful values, such as a salesperson name or salesperson ID.</span></span> <span data-ttu-id="cb3c9-125">자세한 내용은 이 항목의 "HOST_NAME() 값 재정의"를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-125">For more information, see the section "Overriding the HOST_NAME() Value" in this topic.</span></span>  
  
 <span data-ttu-id="cb3c9-126">시스템 함수에서 반환된 값을 사용자가 필터링하는 테이블에서 지정한 열과 비교한 다음 해당 데이터가 구독자로 다운로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-126">The value returned by the system function is compared to a column you specify in the table you are filtering, and the appropriate data is downloaded to the Subscriber.</span></span> <span data-ttu-id="cb3c9-127">구독이 초기화되어 초기 스냅샷에 해당 데이터만 들어 있을 경우와 구독이 동기화될 때마다 이 비교를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-127">This comparison is made when the subscription is initialized (so only the appropriate data is contained in the initial snapshot) and every time the subscription is synchronized.</span></span> <span data-ttu-id="cb3c9-128">기본적으로 게시자의 변경으로 인해 행이 파티션에서 이동 되는 경우 해당 행은 구독자에서 삭제 됩니다 .이 동작은 **@allow_partition_realignment** [transact-sql&#41;&#40;sp_addmergepublication ](/sql/relational-databases/system-stored-procedures/sp-addmergepublication-transact-sql)매개 변수를 사용 하 여 제어 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-128">By default, if a change at the Publisher results in a row being moved out of a partition, the row is deleted at the Subscriber (this behavior is controlled using the **@allow_partition_realignment** parameter of [sp_addmergepublication &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-addmergepublication-transact-sql)).</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="cb3c9-129">매개 변수가 있는 필터에 대해 비교가 수행될 경우 항상 데이터베이스 데이터 정렬을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-129">When comparisons are made for parameterized filters, the database collation is always used.</span></span> <span data-ttu-id="cb3c9-130">예를 들어 데이터베이스 데이터 정렬에서는 대/소문자를 구분하지 않지만 테이블 또는 열 데이터 정렬에서는 대/소문자를 구분할 경우 비교 시 대/소문자를 구분하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-130">For example, if the database collation is case insensitive, but the table or column collation is case sensitive, the comparison will be case insensitive.</span></span>  
  
### <a name="filtering-with-suser_sname"></a><span data-ttu-id="cb3c9-131">SUSER_SNAME()으로 필터링</span><span class="sxs-lookup"><span data-stu-id="cb3c9-131">Filtering with SUSER_SNAME()</span></span>  
 <span data-ttu-id="cb3c9-132">**예제 데이터베이스의** Employee 테이블 [!INCLUDE[ssSampleDBCoShort](../../../includes/sssampledbcoshort-md.md)] 을 고려해 봅니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-132">Consider the **Employee Table** in the [!INCLUDE[ssSampleDBCoShort](../../../includes/sssampledbcoshort-md.md)] sample database.</span></span> <span data-ttu-id="cb3c9-133">이 테이블의 **LoginID**열에는 각 직원에 대한 로그인이 '*domain\login*' 형식으로 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-133">This table includes the column **LoginID**, which contains the login for each employee in the form '*domain\login*'.</span></span> <span data-ttu-id="cb3c9-134">직원이 자신에게 관련된 데이터만 받을 수 있도록 이 테이블을 필터링하려면 다음과 같은 필터 절을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-134">To filter this table so that employees receive only the data related to them, specify a filter clause of:</span></span>  
  
```  
LoginID = SUSER_SNAME()  
```  
  
 <span data-ttu-id="cb3c9-135">예를 들어 값이 'adventure-works\john5'인 직원이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-135">For example, the value for one of the employees is 'adventure-works\john5'.</span></span> <span data-ttu-id="cb3c9-136">병합 에이전트가 게시자로 연결할 경우 구독을 만들 때 사용자가 지정한 로그인(이 경우 'adventure-works\john5')을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-136">When the Merge Agent connects to the Publisher, it uses the login you specified when creating the subscription (in this case 'adventure-works\john5').</span></span> <span data-ttu-id="cb3c9-137">그러면 병합 에이전트는 SUSER_SNAME()에서 반환된 값을 해당 테이블의 값과 비교한 다음 **LoginID** 열에 'adventure-works\john5'라는 값이 포함된 행만 다운로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-137">The Merge Agent then compares the value returned by SUSER_SNAME() to the values in the table and downloads only the row that contains a value of 'adventure-works\john5' in the **LoginID** column.</span></span>  
  
### <a name="filtering-with-host_name"></a><span data-ttu-id="cb3c9-138">HOST_NAME()으로 필터링</span><span class="sxs-lookup"><span data-stu-id="cb3c9-138">Filtering with HOST_NAME()</span></span>  
 <span data-ttu-id="cb3c9-139">**HumanResources.Employee** 테이블을 고려해 봅니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-139">Consider the **HumanResources.Employee** table.</span></span> <span data-ttu-id="cb3c9-140">이 테이블의 **ComputerName** 과 같은 열에 각 직원의 컴퓨터 이름이 '*name_computertype*' 형식으로 포함되어 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-140">Suppose this table contained a column such as **ComputerName** with the name of each employee's computer in the form '*name_computertype*'.</span></span> <span data-ttu-id="cb3c9-141">직원이 자신에게 관련된 데이터만 받을 수 있도록 이 테이블을 필터링하려면 다음과 같은 필터 절을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-141">To filter this table so that employees receive only the data related to them, specify a filter clause of:</span></span>  
  
```  
ComputerName = HOST_NAME()  
```  
  
 <span data-ttu-id="cb3c9-142">예를 들어 값이 'john5_laptop'인 직원이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-142">For example, the value for one of the employees could be 'john5_laptop'.</span></span> <span data-ttu-id="cb3c9-143">병합 에이전트가 게시자로 연결하면 HOST_NAME()에서 반환된 값을 해당 테이블의 값과 비교한 다음 **ComputerName** 열에 'john5_laptop'이라는 값이 포함된 행만 다운로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-143">When the Merge Agent connects to the Publisher, it compares the value returned by HOST_NAME() to the values in the table and downloads only the row that contains a value of 'john5_laptop' in the **ComputerName** column.</span></span>  
  
 <span data-ttu-id="cb3c9-144">함수를 필터에서 함께 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-144">It is also possible to combine the functions in a filter.</span></span> <span data-ttu-id="cb3c9-145">예를 들어 직원이 자신의 컴퓨터에서 자신의 로그인을 사용할 때만 데이터를 받도록 하려면 필터 절을 다음과 같이 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-145">For example, if you wanted to ensure that an employee received data only if they used their login on their computer, the filter clause could be:</span></span>  
  
```  
LoginID = SUSER_SNAME() AND ComputerName = HOST_NAME()  
```  
  
 <span data-ttu-id="cb3c9-146">HOST_NAME() 값을 재정의하지 않을 경우 HOST_NAME()으로 필터링하는 방법은 일반적으로 끌어오기 구독에만 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-146">Unless you are overriding the HOST_NAME() value, filtering with HOST_NAME() is typically used only with pull subscriptions.</span></span> <span data-ttu-id="cb3c9-147">함수에서 반환되는 값은 병합 에이전트가 실행 중인 컴퓨터의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-147">The value returned by the function is the name of the computer on which the Merge Agent is running.</span></span> <span data-ttu-id="cb3c9-148">끌어오기 구독의 경우 각 구독마다 값이 다르지만 밀어넣기 구독의 경우 값이 동일합니다. 밀어넣기 구독의 경우 병합 에이전트는 모두 배포자에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-148">For pull subscriptions, the value is different for each subscription, but for push subscriptions, the value is the same (all Merge Agents run at the Distributor for push subscriptions).</span></span>  
  
> [!IMPORTANT]  
>  <span data-ttu-id="cb3c9-149">HOST_NAME() 함수의 값을 재정의할 수 있으므로 HOST_NAME()이 포함된 필터를 사용하여 데이터 파티션에 대한 액세스를 제어할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-149">The value for the HOST_NAME() function can be overridden; therefore it is not possible to use filters that include HOST_NAME() to control access to partitions of data.</span></span> <span data-ttu-id="cb3c9-150">데이터 파티션에 대한 액세스를 제어하려면 SUSER_SNAME()을 사용하거나 SUSER_SNAME()을 HOST_NAME()과 함께 사용합니다. 또는 정적 행 필터를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-150">To control access to partitions of data, use SUSER_SNAME(), SUSER_SNAME() in combination with HOST_NAME(), or use static row filters.</span></span>  
  
#### <a name="overriding-the-host_name-value"></a><span data-ttu-id="cb3c9-151">HOST_NAME() 값 재정의</span><span class="sxs-lookup"><span data-stu-id="cb3c9-151">Overriding the HOST_NAME() Value</span></span>  
 <span data-ttu-id="cb3c9-152">위에서 설명한 것처럼 HOST_NAME()은 기본적으로 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]인스턴스에 연결된 컴퓨터의 이름을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-152">As noted earlier, HOST_NAME() by default returns the name of the computer that is connecting to an instance of [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="cb3c9-153">매개 변수가 있는 필터를 사용할 경우 구독을 만들 때 값을 입력하여 이 값을 재정의하는 것이 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-153">When using parameterized filters, it is common to override this value by supplying a value when you create a subscription.</span></span> <span data-ttu-id="cb3c9-154">그러면 HOST_NAME() 함수는 컴퓨터 이름 대신 사용자가 지정한 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-154">The HOST_NAME() function then returns the value you specify rather than the name of the computer.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="cb3c9-155">HOST_NAME()을 재정의할 경우 HOST_NAME() 함수에 대한 모든 호출은 사용자가 지정한 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-155">If you override HOST_NAME(), all calls to the HOST_NAME() function will return the value you specify.</span></span> <span data-ttu-id="cb3c9-156">다른 애플리케이션이 컴퓨터 이름을 반환하는 HOST_NAME()에 종속되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-156">Ensure that other applications are not depending on HOST_NAME() returning the computer name.</span></span>  
  
 <span data-ttu-id="cb3c9-157">**HumanResources.Employee** 테이블을 고려해 봅니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-157">Consider the **HumanResources.Employee** table.</span></span> <span data-ttu-id="cb3c9-158">이 테이블에는 **EmployeeID**열이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-158">This table includes the column **EmployeeID**.</span></span> <span data-ttu-id="cb3c9-159">각 직원이 자신에게 관련된 데이터만 받을 수 있도록 이 테이블을 필터링하려면 다음과 같은 필터 절을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-159">To filter this table so that each employee receives only the data related to them, specify a filter clause of:</span></span>  
  
 `EmployeeID = CONVERT(int,HOST_NAME())`  
  
 <span data-ttu-id="cb3c9-160">예를 들어 직원 Pamela Ansman-Wolfe에게 직원 ID로 280을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-160">For example, employee Pamela Ansman-Wolfe has been assigned an employee ID of 280.</span></span> <span data-ttu-id="cb3c9-161">이 직원에 대한 구독을 만들 때 HOST_NAME() 값에 직원 ID 값(이 경우 280)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-161">Specify the value of the employee ID (280 in our example) for the HOST_NAME() value when creating a subscription for this employee.</span></span> <span data-ttu-id="cb3c9-162">병합 에이전트가 게시자로 연결하면 HOST_NAME()에서 반환된 값을 해당 테이블의 값과 비교한 다음 **EmployeeID** 열에 280이라는 값이 포함된 행만 다운로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-162">When the Merge Agent connects to the Publisher, it compares the value returned by HOST_NAME() to the values in the table and downloads only the row that contains a value of 280 in the **EmployeeID** column.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="cb3c9-163">HOST_NAME() 함수는 `nchar` 값을 반환하므로 위의 예처럼 필터 절의 열이 숫자 데이터 형식인 경우 CONVERT를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-163">The HOST_NAME() function returns an `nchar` value, so you must use CONVERT if the column in the filter clause is of a numeric data type, as it is in the example above.</span></span> <span data-ttu-id="cb3c9-164">성능상의 이유로 `CONVERT(nchar,EmployeeID) = HOST_NAME()`과 같은 매개 변수가 있는 행 필터 절의 열 이름에는 함수를 적용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-164">For performance reasons, we recommended that you do not apply functions to column names in parameterized row filter clauses, such as `CONVERT(nchar,EmployeeID) = HOST_NAME()`.</span></span> <span data-ttu-id="cb3c9-165">대신 `EmployeeID = CONVERT(int,HOST_NAME())`예제에서 보여준 방식을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-165">Instead, we recommend using the approach shown in the example: `EmployeeID = CONVERT(int,HOST_NAME())`.</span></span> <span data-ttu-id="cb3c9-166">이 절은 **@subset_filterclause** [sp_addmergearticle](/sql/relational-databases/system-stored-procedures/sp-addmergearticle-transact-sql)매개 변수에 사용할 수 있지만 일반적으로 새 게시 마법사에서는 사용할 수 없습니다. 마법사는 필터 절을 실행 하 여 유효성을 검사 하며 컴퓨터 이름을로 변환할 수 없기 때문에 실패 합니다 `int` .</span><span class="sxs-lookup"><span data-stu-id="cb3c9-166">This clause can be used for the **@subset_filterclause** parameter of [sp_addmergearticle](/sql/relational-databases/system-stored-procedures/sp-addmergearticle-transact-sql), but it typically cannot be used in the New Publication Wizard (the wizard executes the filter clause to validate it, which fails because the computer name cannot be converted to an `int`).</span></span> <span data-ttu-id="cb3c9-167">새 게시 마법사를 사용할 경우 게시에 대한 스냅샷을 만들기 전에 마법사에서 `CONVERT(nchar,EmployeeID) = HOST_NAME()` 을 지정한 다음 [sp_changemergearticle](/sql/relational-databases/system-stored-procedures/sp-changemergearticle-transact-sql) 을 사용하여 해당 절을 `EmployeeID = CONVERT(int,HOST_NAME())` 로 변경하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-167">If you use the New Publication Wizard, we recommend specifying `CONVERT(nchar,EmployeeID) = HOST_NAME()` in the wizard and then use [sp_changemergearticle](/sql/relational-databases/system-stored-procedures/sp-changemergearticle-transact-sql) to change the clause to `EmployeeID = CONVERT(int,HOST_NAME())` before creating a snapshot for the publication.</span></span>  
  
 <span data-ttu-id="cb3c9-168">**HOST_NAME() 값을 재정의하려면**</span><span class="sxs-lookup"><span data-stu-id="cb3c9-168">**To override the HOST_NAME() value**</span></span>  
  
 <span data-ttu-id="cb3c9-169">다음 방법 중 하나를 사용하여 HOST_NAME() 값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-169">Use one of the following methods to override the HOST_NAME() value:</span></span>  
  
-   [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)]<span data-ttu-id="cb3c9-170">: 새 구독 마법사의 **HOST\_NAME\(\) 값** 페이지에서 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-170">: specify a value on the **HOST\_NAME\(\) Values** page of the New Subscription Wizard.</span></span> <span data-ttu-id="cb3c9-171">구독 만들기에 대한 자세한 내용은 [게시 구독](../subscribe-to-publications.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-171">For more information about creating subscriptions, see [Subscribe to Publications](../subscribe-to-publications.md).</span></span>  
  
-   <span data-ttu-id="cb3c9-172">복제 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 프로그래밍: **@hostname** [sp_addmergesubscription &#40;transact-sql&#41;](/sql/relational-databases/system-stored-procedures/sp-addmergesubscription-transact-sql) (밀어넣기 구독의 경우) 또는 [sp_addmergepullsubscription_agent &#40;transact-sql&#41;](/sql/relational-databases/system-stored-procedures/sp-addmergepullsubscription-agent-transact-sql) (끌어오기 구독의 경우)의 매개 변수에 대 한 값을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-172">Replication [!INCLUDE[tsql](../../../includes/tsql-md.md)] programming: specify a value for the **@hostname** parameter of [sp_addmergesubscription &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-addmergesubscription-transact-sql) (for push subscriptions) or [sp_addmergepullsubscription_agent &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-addmergepullsubscription-agent-transact-sql) (for pull subscriptions).</span></span>  
  
-   <span data-ttu-id="cb3c9-173">병합 에이전트: 명령줄 또는 에이전트 프로필을 통해 **-Hostname** 매개 변수의 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-173">Merge Agent: specify a value for the **-Hostname** parameter at the command line or through an agent profile.</span></span> <span data-ttu-id="cb3c9-174">병합 에이전트에 대한 자세한 내용은 [Replication Merge Agent](../agents/replication-merge-agent.md)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-174">For more information about the Merge Agent, see [Replication Merge Agent](../agents/replication-merge-agent.md).</span></span> <span data-ttu-id="cb3c9-175">에이전트 프로필에 대한 자세한 내용은 [Replication Agent Profiles](../agents/replication-agent-profiles.md)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-175">For more information about agent profiles, see [Replication Agent Profiles](../agents/replication-agent-profiles.md).</span></span>  
  
## <a name="initializing-a-subscription-to-a-publication-with-parameterized-filters"></a><span data-ttu-id="cb3c9-176">매개 변수가 있는 필터로 게시에 대한 구독 초기화</span><span class="sxs-lookup"><span data-stu-id="cb3c9-176">Initializing a Subscription to a Publication with Parameterized Filters</span></span>  
 <span data-ttu-id="cb3c9-177">병합 게시에서 매개 변수가 있는 행 필터를 사용하면 복제 시 각 구독이 두 부분으로 구성된 스냅샷으로 초기화됩니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-177">When parameterized row filters are used in merge publications, replication initializes each subscription with a two-part snapshot.</span></span> <span data-ttu-id="cb3c9-178">자세한 내용은 [Snapshots for Merge Publications with Parameterized Filters](../snapshots-for-merge-publications-with-parameterized-filters.md)을(를) 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-178">For more information, see [Snapshots for Merge Publications with Parameterized Filters](../snapshots-for-merge-publications-with-parameterized-filters.md).</span></span>  
  
## <a name="using-the-appropriate-filtering-options"></a><span data-ttu-id="cb3c9-179">적절한 필터링 옵션 사용</span><span class="sxs-lookup"><span data-stu-id="cb3c9-179">Using the Appropriate Filtering Options</span></span>  
 <span data-ttu-id="cb3c9-180">매개 변수가 있는 필터를 사용할 경우 사용자가 제어하는 두 가지 중요한 영역이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-180">There are two key areas over which you have control when using parameterized filters:</span></span>  
  
-   <span data-ttu-id="cb3c9-181">병합 복제에서 필터를 처리하는 방법은 **use partition groups** 및 **keep partition changes**게시 설정 중 하나를 통해 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-181">How the filters are processed by merge replication, which is controlled by one of two publication settings: **use partition groups** and **keep partition changes**.</span></span>  
  
-   <span data-ttu-id="cb3c9-182">구독자 간에 데이터를 공유하는 방법은 아티클 설정 **partition options**에 반영해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-182">How the data is shared among Subscribers, which must be reflected by the article setting **partition options**.</span></span>  
  
 <span data-ttu-id="cb3c9-183">필터링 옵션을 설정하려면 [Optimize Parameterized Row Filters](../publish/optimize-parameterized-row-filters.md)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-183">To set filtering options, see [Optimize Parameterized Row Filters](../publish/optimize-parameterized-row-filters.md).</span></span>  
  
### <a name="setting-use-partition-groups-and-keep-partition-changes"></a><span data-ttu-id="cb3c9-184">'use partition groups' 및 'keep partition changes' 설정</span><span class="sxs-lookup"><span data-stu-id="cb3c9-184">Setting 'use partition groups' and 'keep partition changes'</span></span>  
 <span data-ttu-id="cb3c9-185">**use partition groups** 및 **keep partition changes** 옵션은 모두 게시 데이터베이스에 추가 메타데이터를 저장하여 필터링된 아티클이 있는 게시에 대한 동기화 성능을 향상시킵니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-185">Both the **use partition groups** and **keep partition changes** options improve the synchronization performance for publications with filtered articles by storing additional metadata in the publication database.</span></span> <span data-ttu-id="cb3c9-186">**use partition groups** 옵션은 사전 계산 파티션 기능을 사용하여 더욱 향상된 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-186">The **use partition groups** option provides greater performance improvement through the use of the precomputed partitions feature.</span></span> <span data-ttu-id="cb3c9-187">게시의 아티클이 일련의 요구 사항을 충족하는 경우 이 옵션은 기본적으로 `true`로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-187">This option is set to `true` by default if the articles in your publication adhere to a set of requirements.</span></span> <span data-ttu-id="cb3c9-188">이러한 요구 사항에 대한 자세한 내용은 [사전 계산 파티션으로 매개 변수가 있는 필터 성능 최적화](parameterized-filters-optimize-for-precomputed-partitions.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-188">For more information about these requirements, see [Optimize Parameterized Filter Performance with Precomputed Partitions](parameterized-filters-optimize-for-precomputed-partitions.md).</span></span> <span data-ttu-id="cb3c9-189">아티클이 사전 계산 파티션을 사용 하기 위한 요구 사항을 충족 하지 않는 경우에는 **파티션 변경 내용 유지** 옵션이로 설정 됩니다 `true` .</span><span class="sxs-lookup"><span data-stu-id="cb3c9-189">If your articles do not meet the requirements for using precomputed partitions, the **keep partition changes** option to is set to `true`.</span></span>  
  
### <a name="setting-partition-options"></a><span data-ttu-id="cb3c9-190">'partition options' 설정</span><span class="sxs-lookup"><span data-stu-id="cb3c9-190">Setting 'partition options'</span></span>  
 <span data-ttu-id="cb3c9-191">아티클을 만들 때 필터링된 테이블의 데이터를 구독자에서 공유하는 방식에 따라 **partition options** 속성의 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-191">You specify a value for the **partition options** property when creating an article, according to the way in which data in the filtered table will be shared by Subscribers.</span></span> <span data-ttu-id="cb3c9-192">속성은 [sp_addmergearticle](/sql/relational-databases/system-stored-procedures/sp-addmergearticle-transact-sql), [sp_changemergearticle](/sql/relational-databases/system-stored-procedures/sp-changemergearticle-transact-sql)및 **Article Properties** 대화 상자를 사용하여 네 값 중 하나로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-192">The property can be set to one of four values using [sp_addmergearticle](/sql/relational-databases/system-stored-procedures/sp-addmergearticle-transact-sql), [sp_changemergearticle](/sql/relational-databases/system-stored-procedures/sp-changemergearticle-transact-sql), and the **Article Properties** dialog box.</span></span> <span data-ttu-id="cb3c9-193">새 게시 마법사와 **게시 속성** 대화 상자의 **필터 추가** 또는 **필터 편집** 대화 상자를 사용하여 이 속성을 두 개의 값 중 하나로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-193">The property can be set to one of two values using the **Add Filter** or **Edit Filter** dialog boxes, which are available from the New Publication Wizard and the **Publication Properties** dialog box.</span></span> <span data-ttu-id="cb3c9-194">다음 표에서는 사용할 수 있는 값을 요약합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-194">The following table summarizes the available values:</span></span>  
  
|<span data-ttu-id="cb3c9-195">Description</span><span class="sxs-lookup"><span data-stu-id="cb3c9-195">Description</span></span>|<span data-ttu-id="cb3c9-196">필터 추가 및 필터 편집에 있는 값</span><span class="sxs-lookup"><span data-stu-id="cb3c9-196">Value in Add Filter and Edit Filter</span></span>|<span data-ttu-id="cb3c9-197">아티클 속성에 있는 값</span><span class="sxs-lookup"><span data-stu-id="cb3c9-197">Value in Article Properties</span></span>|<span data-ttu-id="cb3c9-198">저장 프로시저에 있는 값</span><span class="sxs-lookup"><span data-stu-id="cb3c9-198">Value in stored procedures</span></span>|  
|-----------------|-----------------------------------------|---------------------------------|--------------------------------|  
|<span data-ttu-id="cb3c9-199">파티션에 있는 데이터는 겹치며 구독자는 매개 변수가 있는 필터에서 참조된 열은 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-199">Data in the partitions is overlapping, and the Subscriber can update columns referenced in a parameterized filter.</span></span>|<span data-ttu-id="cb3c9-200">**이 테이블의 행을 여러 구독으로 이동**</span><span class="sxs-lookup"><span data-stu-id="cb3c9-200">**A row from this table will go to multiple subscriptions**</span></span>|<span data-ttu-id="cb3c9-201">**겹침**</span><span class="sxs-lookup"><span data-stu-id="cb3c9-201">**Overlapping**</span></span>|<span data-ttu-id="cb3c9-202">**0**</span><span class="sxs-lookup"><span data-stu-id="cb3c9-202">**0**</span></span>|  
|<span data-ttu-id="cb3c9-203">파티션에 있는 데이터는 겹치며 구독자는 매개 변수가 있는 필터에서 참조된 열은 업데이트할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-203">Data in the partitions is overlapping, and the Subscriber cannot update columns referenced in a parameterized filter.</span></span>|<span data-ttu-id="cb3c9-204">해당 없음<sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="cb3c9-204">N/A<sup>1</sup></span></span>|<span data-ttu-id="cb3c9-205">**겹침, 파티션 외부 데이터 변경 내용 허용 안 함**</span><span class="sxs-lookup"><span data-stu-id="cb3c9-205">**Overlapping, disallow out-of-partition data changes**</span></span>|<span data-ttu-id="cb3c9-206">**1**</span><span class="sxs-lookup"><span data-stu-id="cb3c9-206">**1**</span></span>|  
|<span data-ttu-id="cb3c9-207">파티션에 있는 데이터가 겹치지 않으며 데이터는 구독자 간에 공유됩니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-207">Data in the partitions is not overlapping, and the data is shared between subscriptions.</span></span> <span data-ttu-id="cb3c9-208">구독자는 매개 변수가 있는 필터에서 참조된 열은 업데이트할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-208">The Subscriber cannot update columns referenced in a parameterized filter.</span></span>|<span data-ttu-id="cb3c9-209">해당 없음<sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="cb3c9-209">N/A<sup>1</sup></span></span>|<span data-ttu-id="cb3c9-210">**겹치지 않음, 구독 간 공유**</span><span class="sxs-lookup"><span data-stu-id="cb3c9-210">**Nonoverlapping, shared between subscriptions**</span></span>|<span data-ttu-id="cb3c9-211">**2**</span><span class="sxs-lookup"><span data-stu-id="cb3c9-211">**2**</span></span>|  
|<span data-ttu-id="cb3c9-212">파티션에 있는 데이터는 겹치지 않으며 파티션당 하나의 구독이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-212">Data in the partitions is not overlapping, and there is a single subscription per partition.</span></span> <span data-ttu-id="cb3c9-213">구독자는 매개 변수가 있는 필터에서 참조 된 열은 업데이트할 수 없습니다. <sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="cb3c9-213">The Subscriber cannot update columns referenced in a parameterized filter.<sup>2</sup></span></span>|<span data-ttu-id="cb3c9-214">**이 테이블의 행을 단일 구독으로 이동**</span><span class="sxs-lookup"><span data-stu-id="cb3c9-214">**A row from this table will go to only one subscription**</span></span>|<span data-ttu-id="cb3c9-215">**겹치지 않음, 단일 구독**</span><span class="sxs-lookup"><span data-stu-id="cb3c9-215">**Nonoverlapping, single subscription**</span></span>|<span data-ttu-id="cb3c9-216">**3**</span><span class="sxs-lookup"><span data-stu-id="cb3c9-216">**3**</span></span>|  
  
 <span data-ttu-id="cb3c9-217"><sup>1</sup> 기본 필터링 옵션이 **0**, **1**또는 **2**로 설정 된 경우 **필터 추가** 및 **필터 편집** 대화 상자에 **이 테이블의 행을 여러 구독으로 이동이**표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-217"><sup>1</sup> If the underlying filtering option is set to **0**, or **1**, or **2**, the **Add Filter** and **Edit Filter** dialog boxes will display **A row from this table will go to multiple subscriptions**.</span></span>  
  
 <span data-ttu-id="cb3c9-218"><sup>2</sup> 이 옵션을 지정 하면 해당 아티클의 각 데이터 파티션에 대해 구독이 하나만 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-218"><sup>2</sup> If you specify this option, there can only be a single subscription for each partition of data in that article.</span></span> <span data-ttu-id="cb3c9-219">새 구독의 필터링 조건이 기존 구독과 동일한 파티션을 사용하도록 하여 두 번째 구독이 생성될 경우 기존 구독이 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-219">If a second subscription is created in which the filtering criterion of the new subscription resolves to the same partition as the existing subscription, the existing subscription is dropped.</span></span>  
  
> [!IMPORTANT]  
>  <span data-ttu-id="cb3c9-220">구독자가 데이터를 공유하는 방식에 따라 **partition options** 값을 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-220">The **partition options** value must be set according to how data is shared by Subscribers.</span></span> <span data-ttu-id="cb3c9-221">예를 들어 파티션당 구독이 하나 있는 겹치지 않는 파티션을 지정했지만 데이터가 다른 구독자에서 업데이트되는 경우 병합 에이전트가 동기화 중에 실패하고 데이터가 일치하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-221">If, for example, you specify that a partition is nonoverlapping with a single subscription per partition, but data is then updated at another Subscriber, the Merge Agent can fail during synchronization and non-convergence can occur.</span></span>  
  
#### <a name="selecting-the-appropriate-partition-option"></a><span data-ttu-id="cb3c9-222">적절한 파티션 옵션 선택</span><span class="sxs-lookup"><span data-stu-id="cb3c9-222">Selecting the Appropriate Partition Option</span></span>  
 <span data-ttu-id="cb3c9-223">겹치지 않는 파티션을 사전 계산 파티션과 함께 사용하여 일부 기능 제한이 허용되는 상황에서 성능을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-223">Nonoverlapping partitions work in conjunction with precomputed partitions to improve performance in situations where some functional limitations are acceptable.</span></span> <span data-ttu-id="cb3c9-224">사전 계산 파티션을 사용하면 구독자로 다운로드하는 속도는 빨라지지만 업로드 속도는 느려집니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-224">Precomputed partitions quicken downloads to Subscribers, but slow uploads.</span></span> <span data-ttu-id="cb3c9-225">겹치지 않는 파티션을 사용하면 사전 계산 파티션으로 인한 업로드 작업 손실을 최소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-225">Nonoverlapping partitions minimize the upload cost associated with precomputed partitions.</span></span> <span data-ttu-id="cb3c9-226">사용하는 매개 변수가 있는 필터와 조인 필터가 복잡할수록 겹치지 않는 파티션의 성능상 이점이 더욱 분명하게 드러납니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-226">The performance benefit of nonoverlapping partitions is more noticeable when the parameterized filters and join filters used are more complex.</span></span>  
  
 <span data-ttu-id="cb3c9-227">게시에서 사용할 파티션 옵션을 결정할 경우 다음 시나리오를 고려하십시오.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-227">Consider the following scenarios when deciding which partition options to use in a publication.</span></span>  
  
-   [!INCLUDE[ssSampleDBCoShort](../../../includes/sssampledbcoshort-md.md)] <span data-ttu-id="cb3c9-228">에는 지정된 우편 번호에 해당하는 고객을 담당하는 판매원으로 구성된 이동 영업팀이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-228">has a mobile sales force with each sales person responsible for customers in a given zip code.</span></span> <span data-ttu-id="cb3c9-229">고객이 한 판매 지역에서 다른 판매 지역으로 이동할 경우 고객이 다른 판매원에게 할당되도록 애플리케이션에서 우편 변호를 업데이트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-229">The application requires that  the zip code be updated if a customer moves from one sales territory to another, so that the customer is assigned to a different sales person.</span></span> <span data-ttu-id="cb3c9-230">매개 변수가 있는 필터는 고객의 우편 번호를 기준으로 하며 업데이트가 발생하면 한 판매원의 파티션에서 우편 번호가 제거되어 다른 판매원의 파티션으로 삽입됩니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-230">The parameterized filter is based on the customer's zip code, and the update removes the zip code from one sales person's partition and inserts it into another sales person's partition.</span></span> <span data-ttu-id="cb3c9-231">이 작업에는 매개 변수가 있는 필터에서 참조되는 열을 업데이트하는 기능이 있는 겹치는 파티션이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-231">This requires overlapping partitions with the ability to update columns referenced in a parameterized filter.</span></span> <span data-ttu-id="cb3c9-232">이 옵션을 사용하면 융통성을 최대로 높일 수 있지만 겹치지 않는 파티션보다 성능이 떨어질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-232">This option maximizes flexibility but might not perform as well as nonoverlapping partitions.</span></span>  
  
-   <span data-ttu-id="cb3c9-233">직업 소개소에는 각 지방의 지역 사무실로 전달할 데이터가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-233">An employment agency has data that is supplied to regional offices in each county of the state.</span></span> <span data-ttu-id="cb3c9-234">데이터는 겹치지 않습니다. 본사의 테이블에 있는 각 행은 하나의 파티션에만 포함되지만 이러한 행을 포함하는 파티션은 해당 지방의 여러 지역 사무실로 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-234">The data does not overlap; each row in the table at the agency's headquarters is included in only one partition, but that partition is sent to multiple offices in the same county.</span></span> <span data-ttu-id="cb3c9-235">이 작업에는 구독 간에 파티션을 공유하는 겹치지 않는 파티션 옵션이 적합합니다. 이 옵션을 사용하면 겹치는 파티션에 비해 보다 뛰어난 성능을 제공하면서 애플리케이션 요구 사항도 만족시킵니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-235">The nonoverlapping partition option with partitions shared between subscriptions is appropriate, providing a performance improvement over overlapping partitions while satisfying the application requirements.</span></span>  
  
-   <span data-ttu-id="cb3c9-236">겹치지 않는 파티션이 있고 하나의 구독만이 파티션에서 데이터를 받고 업데이트할 경우 더 많은 성능상의 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-236">If you have nonoverlapping partitions and only one subscription receives and updates the data in a partition, further performance benefits can be realized.</span></span> <span data-ttu-id="cb3c9-237">이 시나리오는 POS(Point of Sale) 시스템 및 구독자에서 주로 데이터를 수집하여 게시자로 업로드하는 FF(Field Force) 애플리케이션에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-237">This scenario is common for point of sale systems, and field force applications in which data is primarily collected at the Subscriber and uploaded to the Publisher.</span></span> <span data-ttu-id="cb3c9-238">배달 애플리케이션의 **Package** 테이블을 고려해 보십시오. 각 패키지가 트럭에 실리면서 **Package** 테이블에서 패키지의 상태가 변경되고 해당 변경 내용은 다시 본사로 복제됩니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-238">Consider a **Package** table in a delivery application: as each package is loaded onto a truck, the status of the package is changed in the **Package** table, and the change is replicated back to headquarters.</span></span> <span data-ttu-id="cb3c9-239">운전 기사는 두 대의 서로 다른 트럭에 실린 같은 패키지의 상태를 업데이트하지 않으므로 **Package** 테이블을 파티션당 하나의 구독이 있는 겹치지 않는 파티션으로 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-239">Drivers would not update the status of the same package on two different trucks, so the **Package** table is a good candidate for a nonoverlapping partition with a single subscription per partition.</span></span>  
  
#### <a name="considerations-for-nonoverlapping-partitions"></a><span data-ttu-id="cb3c9-240">겹치지 않는 파티션에 대한 고려 사항</span><span class="sxs-lookup"><span data-stu-id="cb3c9-240">Considerations for Nonoverlapping Partitions</span></span>  
 <span data-ttu-id="cb3c9-241">겹치지 않는 파티션 사용 시 다음 사항을 고려하십시오.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-241">Keep the following considerations in mind when using nonoverlapping partitions.</span></span>  
  
##### <a name="general-considerations"></a><span data-ttu-id="cb3c9-242">일반적인 고려 사항</span><span class="sxs-lookup"><span data-stu-id="cb3c9-242">General Considerations</span></span>  
  
-   <span data-ttu-id="cb3c9-243">게시에서는 사전 계산 파티션을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-243">The publication must use precomputed partitions.</span></span>  
  
-   <span data-ttu-id="cb3c9-244">행은 하나의 파티션에만 속해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-244">A row must belong to only one partition.</span></span>  
  
-   <span data-ttu-id="cb3c9-245">아티클은 논리적 레코드의 일부일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-245">Articles cannot be part of a logical record.</span></span>  
  
-   <span data-ttu-id="cb3c9-246">대체 동기화 파트너는 지원되지 않습니다(이 기능은 사용되지 않음).</span><span class="sxs-lookup"><span data-stu-id="cb3c9-246">Alternate synchronization partners are not supported (this feature is deprecated).</span></span>  
  
-   <span data-ttu-id="cb3c9-247">구독자는 매개 변수가 있는 필터에서 참조된 열은 업데이트할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-247">The Subscriber cannot update columns referenced in a parameterized filter.</span></span>  
  
-   <span data-ttu-id="cb3c9-248">파티션에 속하지 않는 구독자에서의 삽입은 삭제되지 않지만</span><span class="sxs-lookup"><span data-stu-id="cb3c9-248">If an insert at a Subscriber does not belong to the partition, it is not deleted.</span></span> <span data-ttu-id="cb3c9-249">다른 구독자로 복제되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-249">However, it will not be replicated to other Subscribers.</span></span>  
  
-   <span data-ttu-id="cb3c9-250">겹치는 파티션을 사용하는 일부 환경에서 병합 에이전트가 데이터를 삽입하면 ID 범위가 조정됩니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-250">In some circumstances with overlapping partitions, identity ranges are adjusted when the Merge Agent inserts data.</span></span> <span data-ttu-id="cb3c9-251">겹치지 않는 파티션을 사용할 경우 구독 데이터베이스에서 ID 범위를 조정할 권한이 있는 사용자가 삽입할 때에만 범위가 조정됩니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-251">With nonoverlapping partitions, ranges can only be adjusted during inserts by a user who has permission to adjust identity ranges in the subscription database.</span></span> <span data-ttu-id="cb3c9-252">사용자는 테이블의 소유자이거나 **sysadmin** 고정 서버 역할, **db_owner** 고정 데이터베이스 역할 또는 **db_ddladmin** 고정 데이터베이스 역할의 멤버여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-252">The user must either own the table, or be a member of the **sysadmin** fixed server role, the **db_owner** fixed database role, or the **db_ddladmin** fixed database role.</span></span>  
  
##### <a name="additional-considerations-for-nonoverlapping-partitions-with-a-single-subscription-per-partition"></a><span data-ttu-id="cb3c9-253">파티션당 하나의 구독이 있는 겹치지 않는 파티션에 대한 추가 고려 사항</span><span class="sxs-lookup"><span data-stu-id="cb3c9-253">Additional Considerations for Nonoverlapping Partitions with a Single Subscription per Partition</span></span>  
  
-   <span data-ttu-id="cb3c9-254">아티클은 하나의 게시에만 존재할 수 있으며 다시 게시할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-254">Articles can exist in only one publication; articles cannot be republished.</span></span>  
  
-   <span data-ttu-id="cb3c9-255">게시에서 구독자가 스냅샷 프로세스를 시작할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-255">The publication must allow Subscribers to initiate the snapshot process.</span></span> <span data-ttu-id="cb3c9-256">자세한 내용은 [Snapshots for Merge Publications with Parameterized Filters](../snapshots-for-merge-publications-with-parameterized-filters.md)을(를) 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-256">For more information, see [Snapshots for Merge Publications with Parameterized Filters](../snapshots-for-merge-publications-with-parameterized-filters.md).</span></span>  
  
##### <a name="additional-considerations-for-join-filters"></a><span data-ttu-id="cb3c9-257">조인 필터에 대한 추가 고려 사항</span><span class="sxs-lookup"><span data-stu-id="cb3c9-257">Additional Considerations for Join Filters</span></span>  
  
-   <span data-ttu-id="cb3c9-258">조인 필터 계층에서 겹치는 파티션이 있는 아티클은 겹치지 않는 파티션이 있는 아티클 위에 표시될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-258">In a join filter hierarchy, an article with an overlapping partition cannot appear above an article with a nonoverlapping partition.</span></span> <span data-ttu-id="cb3c9-259">즉 자식 아티클이 겹치지 않는 파티션을 사용하면 부모 아티클도 겹치지 않는 파티션을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-259">In other words, a parent article must use nonoverlapping partitions if the child article does.</span></span> <span data-ttu-id="cb3c9-260">조인 필터에 대한 자세한 내용은 [Join Filters](join-filters.md)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-260">For information about join filters, see [Join Filters](join-filters.md).</span></span>  
  
-   <span data-ttu-id="cb3c9-261">겹치지 않는 파티션이 자식인 조인 필터에서는 **join unique key** 속성을 1로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-261">A join filter in which the nonoverlapping partition is a child must have the **join unique key** property set to 1.</span></span> <span data-ttu-id="cb3c9-262">자세한 내용은 [Join Filters](join-filters.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-262">For more information, see [Join Filters](join-filters.md).</span></span>  
  
-   <span data-ttu-id="cb3c9-263">아티클에는 매개 변수가 있는 필터 또는 조인 필터가 하나만 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-263">The article should only have one parameterized filter or join filter.</span></span> <span data-ttu-id="cb3c9-264">매개 변수가 있는 필터가 있으면서 조인 필터에서 부모일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-264">Having a parameterized filter and being the parent in a join filter is allowed.</span></span> <span data-ttu-id="cb3c9-265">매개 변수가 있는 필터가 있으면서 조인 필터에서 자식일 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-265">Having a parameterized filter and being the child in a join filter is not allowed.</span></span> <span data-ttu-id="cb3c9-266">조인 필터가 두 개 이상일 수도 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-266">Having more than one join filter is also not allowed.</span></span>  
  
-   <span data-ttu-id="cb3c9-267">게시자의 두 테이블에 조인 필터 관계가 있고 자식 테이블에는 부모 테이블에 없는 행이 있을 경우 부모 테이블에 없는 행을 삽입해도 관련된 행이 구독자로 다운로드되지 않습니다(겹치는 파티션의 경우 다운로드됨).</span><span class="sxs-lookup"><span data-stu-id="cb3c9-267">If two tables at the Publisher have a join filter relationship and the child table has rows that have no corresponding row in the parent table, an insert of the missing parent row will not result in the related rows being downloaded to the Subscriber (the rows would be downloaded with overlapping partitions).</span></span> <span data-ttu-id="cb3c9-268">예를 들어 **SalesOrderHeader** 테이블에는 없는 행이 **SalesOrderDetail** 테이블에 있고 이 행을 **SalesOrderHeader**에 삽입하면 해당 행은 구독자로 다운로드되지만 **SalesOrderDetail** 의 행은 다운로드되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cb3c9-268">For example, if the **SalesOrderDetail** table has rows with no corresponding row in the **SalesOrderHeader** table, and you insert the missing row in **SalesOrderHeader**, the row is downloaded to the Subscriber, but the corresponding rows in **SalesOrderDetail** are not.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="cb3c9-269">참고 항목</span><span class="sxs-lookup"><span data-stu-id="cb3c9-269">See Also</span></span>  
 <span data-ttu-id="cb3c9-270">[시간 기반 행 필터에 대한 최상의 구현 방법](best-practices-for-time-based-row-filters.md) </span><span class="sxs-lookup"><span data-stu-id="cb3c9-270">[Best Practices for Time-Based Row Filters](best-practices-for-time-based-row-filters.md) </span></span>  
 <span data-ttu-id="cb3c9-271">[게시된 데이터 필터링](../publish/filter-published-data.md) </span><span class="sxs-lookup"><span data-stu-id="cb3c9-271">[Filter Published Data](../publish/filter-published-data.md) </span></span>  
 [<span data-ttu-id="cb3c9-272">병합 복제의 게시된 데이터 필터링</span><span class="sxs-lookup"><span data-stu-id="cb3c9-272">Filter Published Data for Merge Replication</span></span>](filter-published-data-for-merge-replication.md)  
  
  
