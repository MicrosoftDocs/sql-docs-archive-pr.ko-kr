---
title: 사용자 정의 형식 요구 사항 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: clr
ms.topic: reference
helpviewer_keywords:
- UDTs [CLR integration], requirements
- serialization
- Native serialization format [CLR integration]
- attributes [CLR integration]
- XML serialization [CLR integration]
- user-defined types [CLR integration], requirements
- user-defined serialization [CLR integration]
- user-defined types [CLR integration], Native serialization
- UDTs [CLR integration], Native serialization
ms.assetid: bedc3372-50eb-40f2-bcf2-d6db6a63b7e6
author: rothja
ms.author: jroth
ms.openlocfilehash: d4e692a4523829713cd95daf62374f84a74b6584
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87647713"
---
# <a name="user-defined-type-requirements"></a><span data-ttu-id="b6086-102">사용자 정의 형식 요구 사항</span><span class="sxs-lookup"><span data-stu-id="b6086-102">User-Defined Type Requirements</span></span>
  <span data-ttu-id="b6086-103">에 설치할 UDT (사용자 정의 형식)를 만들 때 몇 가지 중요 한 디자인 결정을 내려야 합니다 [!INCLUDE[msCoName](../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="b6086-103">You must make several important design decisions when creating a user-defined type (UDT) to be installed in [!INCLUDE[msCoName](../../includes/msconame-md.md)][!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="b6086-104">대부분의 UDT는 구조로 만드는 것이 좋지만 클래스로 만드는 방법도 고려해 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-104">For most UDTs, creating the UDT as a structure is recommended, although creating it as a class is also an option.</span></span> <span data-ttu-id="b6086-105">UDT 정의가 UDT 생성 사양에 맞아야만 UDT 정의를 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]에 등록할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-105">The UDT definition must conform to the specifications for creating UDTs in order for it to be registered with [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span>  
  
## <a name="requirements-for-implementing-udts"></a><span data-ttu-id="b6086-106">UDT 구현을 위한 요구 사항</span><span class="sxs-lookup"><span data-stu-id="b6086-106">Requirements for Implementing UDTs</span></span>  
 <span data-ttu-id="b6086-107">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]에서 UDT를 실행하려면 UDT 정의에서 다음 요구 사항을 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-107">To run in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], your UDT must implement the following requirements in the UDT definition:</span></span>  
  
 <span data-ttu-id="b6086-108">UDT에서 `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute`를 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-108">The UDT must specify the `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute`.</span></span> <span data-ttu-id="b6086-109">`System.SerializableAttribute`의 사용은 옵션이지만 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-109">The use of the `System.SerializableAttribute` is optional, but recommended.</span></span>  
  
-   <span data-ttu-id="b6086-110">UDT에서 공용 `System.Data.SqlTypes.INullable`([!INCLUDE[msCoName](../../includes/msconame-md.md)] Visual Basic의 경우 `static`) `Shared` 메서드를 만들어 클래스나 구조체에서 `Null` 인터페이스를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-110">The UDT must implement the `System.Data.SqlTypes.INullable` interface in the class or structure by creating a public `static` (`Shared` in [!INCLUDE[msCoName](../../includes/msconame-md.md)] Visual Basic) `Null` method.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]<span data-ttu-id="b6086-111">에서는 기본적으로 Null을 인식합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-111">is null-aware by default.</span></span> <span data-ttu-id="b6086-112">이 작업은 UDT를 실행하는 코드에서 Null 값을 인식할 수 있도록 하는 데 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-112">This is necessary for code executing in the UDT to be able to recognize a null value.</span></span>  
  
-   <span data-ttu-id="b6086-113">UDT가 개체의 문자열 표현으로부터의 구문 분석을 지원하는 공용 `static`(또는 `Shared`) `Parse` 메서드와 개체의 문자열 표현으로의 변환을 위한 공용 `ToString` 메서드를 포함해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-113">The UDT must contain a public `static` (or `Shared`) `Parse` method that supports parsing from, and a public `ToString` method for converting to a string representation of the object.</span></span>  
  
-   <span data-ttu-id="b6086-114">사용자 정의 직렬화 형식이 포함된 UDT는 `System.Data.IBinarySerialize` 인터페이스를 구현하고 `Read` 및 `Write` 메서드를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-114">A UDT with a user-defined serialization format must implement the `System.Data.IBinarySerialize` interface and provide a `Read` and a `Write` method.</span></span>  
  
-   <span data-ttu-id="b6086-115">UDT에서 `System.Xml.Serialization.IXmlSerializable`을 구현해야 합니다. 또는 표준 직렬화 재정의가 필요한 경우 모든 공용 필드 및 속성이 XML로 직렬화할 수 있는 형식이거나 `XmlIgnore` 특성으로 데코레이팅되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-115">The UDT must implement `System.Xml.Serialization.IXmlSerializable`, or all public fields and properties must be of types that are XML serializable or decorated with the `XmlIgnore` attribute if overriding standard serialization is required.</span></span>  
  
-   <span data-ttu-id="b6086-116">UDT 개체의 직렬화가 하나만 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-116">There must be only one serialization of a UDT object.</span></span> <span data-ttu-id="b6086-117">직렬화 또는 역직렬화 루틴에서 특정 개체의 표현을 두 개 이상 인식하면 유효성 검사가 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-117">Validation fails if the serialize or deserialize routines recognize more than one representation of a particular object.</span></span>  
  
-   <span data-ttu-id="b6086-118">바이트 순서로 데이터를 비교하려면 `SqlUserDefinedTypeAttribute.IsByteOrdered`가 `true`여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-118">`SqlUserDefinedTypeAttribute.IsByteOrdered` must be `true` to compare data in byte order.</span></span> <span data-ttu-id="b6086-119">IComparable 인터페이스가 구현되지 않으며 `SqlUserDefinedTypeAttribute.IsByteOrdered`가 `false`인 경우 바이트 순서 비교가 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-119">If the IComparable interface is not implemented and `SqlUserDefinedTypeAttribute.IsByteOrdered` is `false`, byte order comparisons will fail.</span></span>  
  
-   <span data-ttu-id="b6086-120">클래스에 정의된 UDT에는 인수를 사용하지 않는 공용 생성자가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-120">A UDT defined in a class must have a public constructor that takes no arguments.</span></span> <span data-ttu-id="b6086-121">오버로드된 추가 클래스 생성자를 만들 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-121">You can optionally create additional overloaded class constructors.</span></span>  
  
-   <span data-ttu-id="b6086-122">UDT가 데이터 요소를 공용 필드나 속성 프로시저로 표시해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-122">The UDT must expose data elements as public fields or property procedures.</span></span>  
  
-   <span data-ttu-id="b6086-123">공개 이름은 128 자 보다 길 수 없으며 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] [데이터베이스 식별자](../databases/database-identifiers.md)에 정의 된 식별자의 명명 규칙을 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-123">Public names cannot be longer than 128 characters, and must conform to the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] naming rules for identifiers as defined in [Database Identifiers](../databases/database-identifiers.md).</span></span>  
  
-   <span data-ttu-id="b6086-124">`sql_variant` 열에는 UDT의 인스턴스를 포함할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-124">`sql_variant` columns cannot contain instances of a UDT.</span></span>  
  
-   <span data-ttu-id="b6086-125">상속된 멤버는 [!INCLUDE[tsql](../../includes/tsql-md.md)]에서 액세스할 수 없습니다. 그 이유는 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 유형 시스템에서 UDT 간의 상속 계층을 인식하지 못하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-125">Inherited members are not accessible from [!INCLUDE[tsql](../../includes/tsql-md.md)] because the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] type system is not aware of the inheritance hierarchy among UDTs.</span></span> <span data-ttu-id="b6086-126">그러나 클래스를 구성할 때는 상속을 사용할 수 있으며 관리 코드를 사용한 형식 구현에서 이러한 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-126">However, you can use inheritance when you structure your classes and you can call such methods in the managed code implementation of the type.</span></span>  
  
-   <span data-ttu-id="b6086-127">클래스 생성자를 제외하고는 멤버를 오버로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-127">Members cannot be overloaded, except for the class constructor.</span></span> <span data-ttu-id="b6086-128">오버로드된 메서드를 만드는 경우 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]에서 어셈블리를 등록하거나 형식을 만들 때는 오류가 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-128">If you do create an overloaded method, no error is raised when you register the assembly or create the type in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="b6086-129">오버로드된 메서드는 형식이 만들어질 때가 아니라 런타임에 검색됩니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-129">Detection of the overloaded method occurs at run time, not when the type is created.</span></span> <span data-ttu-id="b6086-130">오버로드된 메서드를 호출하지 않는 한 오버로드된 메서드가 클래스 내에 존재할 수 있으며,</span><span class="sxs-lookup"><span data-stu-id="b6086-130">Overloaded methods can exist in the class as long as they are never invoked.</span></span> <span data-ttu-id="b6086-131">오버로드된 메서드를 호출하면 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-131">Once you invoke the overloaded method, an error is raised.</span></span>  
  
-   <span data-ttu-id="b6086-132">`static`(또는 `Shared`) 멤버는 상수나 읽기 전용으로 선언해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-132">Any `static` (or `Shared`) members must be declared as constants or as read-only.</span></span> <span data-ttu-id="b6086-133">정적 멤버는 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-133">Static members cannot be mutable.</span></span>  
  
-   <span data-ttu-id="b6086-134">`SqlUserDefinedTypeAttribute.MaxByteSize` 필드를 -1로 설정하면 직렬화된 UDT의 크기가 LOB(Large Object) 크기 제한(현재는 2GB)까지 커질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-134">If the `SqlUserDefinedTypeAttribute.MaxByteSize` field is set to -1, the serialized UDT can be as large as the large object (LOB) size limit (currently 2 GB).</span></span> <span data-ttu-id="b6086-135">UDT 크기는 `MaxByteSized` 필드에 지정된 값을 초과할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-135">The size of the UDT cannot exceed the value specified in the `MaxByteSized` field.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="b6086-136">서버에서 비교 작업에 사용하지는 않지만 단일 메서드 `System.IComparable`를 노출하는 `CompareTo` 인터페이스를 구현할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-136">Although it is not used by the server for performing comparisons, you can optionally implement the `System.IComparable` interface, which exposes a single method, `CompareTo`.</span></span> <span data-ttu-id="b6086-137">이 인터페이스는 UDT 값을 정확하게 비교하거나 정렬해야 하는 경우에 클라이언트 쪽에서 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-137">This is used on the client side in situations in which it is desirable to accurately compare or order UDT values.</span></span>  
  
## <a name="native-serialization"></a><span data-ttu-id="b6086-138">네이티브 직렬화</span><span class="sxs-lookup"><span data-stu-id="b6086-138">Native Serialization</span></span>  
 <span data-ttu-id="b6086-139">만들려는 UDT의 종류에 따라 UDT에 적합한 직렬화 특성을 선택해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-139">Choosing the right serialization attributes for your UDT depends on the type of UDT you are trying to create.</span></span> <span data-ttu-id="b6086-140">`Native` 직렬화 형식은 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]에서 UDT에 대한 효율적인 네이티브 표현을 디스크에 저장할 수 있게 하는 매우 간단한 구조를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-140">The `Native` serialization format utilizes a very simple structure that enables [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] to store an efficient native representation of the UDT on disk.</span></span> <span data-ttu-id="b6086-141">`Native` 형식은 UDT가 간단하며 다음 유형의 필드만 포함하는 경우에 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-141">The `Native` format is recommended if the UDT is simple and only contains fields of the following types:</span></span>  
  
 <span data-ttu-id="b6086-142">**bool**, **byte**, **sbyte**, **short**, **ushort**, **int**, **uint**, **long**, **ulong**, **float**, **double**, **SqlByte**, **SqlInt16**, **SqlInt32**, **SqlInt64**, **SqlDateTime**, **SqlSingle**, **SqlDouble**, **SqlMoney**, **SqlBoolean**</span><span class="sxs-lookup"><span data-stu-id="b6086-142">**bool**, **byte**, **sbyte**, **short**, **ushort**, **int**, **uint**, **long**, **ulong**, **float**, **double**, **SqlByte**, **SqlInt16**, **SqlInt32**, **SqlInt64**, **SqlDateTime**, **SqlSingle**, **SqlDouble**, **SqlMoney**, **SqlBoolean**</span></span>  
  
 <span data-ttu-id="b6086-143">위 형식의 필드로 구성 되는 값 형식은 형식에 적합 `Native` `structs` 합니다 (예: Visual c #의 경우 또는 `Structures` Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b6086-143">Value types that are composed of fields of the above types are good candidates for `Native` format, such as `structs` in Visual C#, (or `Structures` as they are known in Visual Basic).</span></span> <span data-ttu-id="b6086-144">예를 들어 `Native` 직렬화 형식을 사용하여 지정한 UDT에 마찬가지로 `Native` 형식을 사용하여 지정한 다른 UDT 필드가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-144">For example, a UDT specified with the `Native` serialization format may contain a field of another UDT that was also specified with the `Native` format.</span></span> <span data-ttu-id="b6086-145">UDT 정의가 이보다 복잡하며 위 목록에 없는 데이터 형식을 포함할 경우 대신 `UserDefined` 직렬화 형식을 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-145">If the UDT definition is more complex and contains data types not on the above list, you must specify the `UserDefined` serialization format instead.</span></span>  
  
 <span data-ttu-id="b6086-146">`Native` 형식은 다음 요구 사항을 충족해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-146">The `Native` format has the following requirements:</span></span>  
  
-   <span data-ttu-id="b6086-147">형식에서 `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute.MaxByteSize` 값을 지정하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-147">The type must not specify a value for `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute.MaxByteSize`.</span></span>  
  
-   <span data-ttu-id="b6086-148">모든 필드를 직렬화할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-148">All fields must be serializable.</span></span>  
  
-   <span data-ttu-id="b6086-149">UDT가 구조체가 아니라 클래스에 정의되어 있으면 `System.Runtime.InteropServices.StructLayoutAttribute`는 `StructLayout.LayoutKindSequential`로 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-149">The `System.Runtime.InteropServices.StructLayoutAttribute` must be specified as `StructLayout.LayoutKindSequential` if the UDT is defined in a class and not a structure.</span></span> <span data-ttu-id="b6086-150">이 특성은 데이터 필드의 물리적 레이아웃을 제어하며 멤버를 멤버가 실제로 나타나는 순서대로 배치하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-150">This attribute controls the physical layout of the data fields and is used to force the members to be laid out in the order in which they appear.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]<span data-ttu-id="b6086-151">에서는 이 특성을 사용하여 값이 여러 개 포함된 UDT의 필드 순서를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-151">uses this attribute to determine the field order for UDTs with multiple values.</span></span>  
  
 <span data-ttu-id="b6086-152">Serialization을 사용 하 여 정의 된 UDT의 예는 `Native` [사용자 정의 형식 코딩](creating-user-defined-types-coding.md)의 Point UDT를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="b6086-152">For an example of a UDT defined with `Native` serialization, see the Point UDT in [Coding User-Defined Types](creating-user-defined-types-coding.md).</span></span>  
  
## <a name="userdefined-serialization"></a><span data-ttu-id="b6086-153">UserDefined 직렬화</span><span class="sxs-lookup"><span data-stu-id="b6086-153">UserDefined Serialization</span></span>  
 <span data-ttu-id="b6086-154">`UserDefined` 특성에 대한 `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute` 형식 설정을 통해 개발자는 이진 형식을 완전히 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-154">The `UserDefined` format setting for the `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute` attribute gives the developer full control over the binary format.</span></span> <span data-ttu-id="b6086-155">`Format` 특성의 속성을 `UserDefined`로 지정할 경우 코드에서 다음 작업을 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-155">When specifying the `Format` attribute property as `UserDefined`, you must do the following in your code:</span></span>  
  
-   <span data-ttu-id="b6086-156">선택적 요소인 `IsByteOrdered` 특성의 속성을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-156">Specify the optional `IsByteOrdered` attribute property.</span></span> <span data-ttu-id="b6086-157">기본값은 `false`입니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-157">The default value is `false`.</span></span>  
  
-   <span data-ttu-id="b6086-158">`MaxByteSize`의 `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute` 속성을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-158">Specify the `MaxByteSize` property of the `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute`.</span></span>  
  
-   <span data-ttu-id="b6086-159">`Read` 인터페이스를 구현하여 UDT에 대한 `Write` 및 `System.Data.Sql.IBinarySerialize` 메서드를 구현하는 코드를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-159">Write code to implement `Read` and `Write` methods for the UDT by implementing the `System.Data.Sql.IBinarySerialize` interface.</span></span>  
  
 <span data-ttu-id="b6086-160">Serialization을 사용 하 여 정의 된 UDT의 예는 `UserDefined` [사용자 정의 형식 코딩](creating-user-defined-types-coding.md)의 통화 UDT를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="b6086-160">For an example of a UDT defined with `UserDefined` serialization, see the Currency UDT in [Coding User-Defined Types](creating-user-defined-types-coding.md).</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="b6086-161">UDT 필드를 인덱싱하려면 UDT 필드에 네이티브 직렬화를 사용하거나 필드를 지속형 필드로 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-161">UDT fields must use native serialization or be persisted in order to be indexed.</span></span>  
  
## <a name="serialization-attributes"></a><span data-ttu-id="b6086-162">직렬화 특성</span><span class="sxs-lookup"><span data-stu-id="b6086-162">Serialization Attributes</span></span>  
 <span data-ttu-id="b6086-163">특성은 직렬화를 사용하여 UDT의 스토리지 표현을 생성하고 UDT를 값으로 클라이언트에 전송하는 방법을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-163">Attributes determine how serialization is used to construct the storage representation of UDTs and to transmit UDTs by value to the client.</span></span> <span data-ttu-id="b6086-164">UDT를 만들 때 `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute`를 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-164">You are required to specify the `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute` when creating the UDT.</span></span> <span data-ttu-id="b6086-165">`Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute` 특성은 클래스가 UDT임을 나타내며 UDT에 대한 스토리지를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-165">The `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute` attribute indicates that the class is a UDT and specifies the storage for the UDT.</span></span> <span data-ttu-id="b6086-166">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]에서 요구 사항은 아니지만 `Serializable` 특성을 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-166">You can optionally specify the `Serializable` attribute, although [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] does not require this.</span></span>  
  
 <span data-ttu-id="b6086-167">`Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute`에는 다음 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-167">The `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute` has the following properties.</span></span>  
  
 `Format`  
 <span data-ttu-id="b6086-168">직렬화 형식을 지정합니다. 직렬화 형식은 UDT의 데이터 형식에 따라 `Native` 또는 `UserDefined`가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-168">Specifies the serialization format, which can be `Native` or `UserDefined`, depending on the data types of the UDT.</span></span>  
  
 `IsByteOrdered`  
 <span data-ttu-id="b6086-169">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]에서 UDT에 대한 이진 비교를 수행하는 방법을 결정하는 `Boolean` 값입니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-169">A `Boolean` value that determines how [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] performs binary comparisons on the UDT.</span></span>  
  
 `IsFixedLength`  
 <span data-ttu-id="b6086-170">이 UDT의 모든 인스턴스 길이가 같은지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-170">Indicates whether all instances of this UDT are the same length.</span></span>  
  
 `MaxByteSize`  
 <span data-ttu-id="b6086-171">인스턴스의 최대 크기(바이트)입니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-171">The maximum size of the instance, in bytes.</span></span> <span data-ttu-id="b6086-172">`MaxByteSize` 직렬화 형식과 함께 `UserDefined`를 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-172">You must specify `MaxByteSize` with the `UserDefined` serialization format.</span></span> <span data-ttu-id="b6086-173">사용자 정의 직렬화가 지정된 UDT의 경우 `MaxByteSize`는 사용자가 정의한 대로 직렬화된 형식의 전체 UDT 크기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-173">For a UDT with user-defined serialization specified, `MaxByteSize` refers to the total size of the UDT in its serialized form as defined by the user.</span></span> <span data-ttu-id="b6086-174">`MaxByteSize` 값은 1에서 8000 사이의 값이어야 합니다. UDT가 8000바이트보다 크다는 것을 나타내려면 이 값을 -1로 설정해야 하며 총 크기는 최대 LOB 크기를 초과할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-174">The value of `MaxByteSize` must be in the range of 1 to 8000, or set to -1 to indicate that the UDT is greater than 8000 bytes (the total size cannot exceed the maximum LOB size).</span></span> <span data-ttu-id="b6086-175">10개의 문자(`System.Char`)로 구성된 문자열 속성이 있는 UDT가 있다고 가정해 보십시오.</span><span class="sxs-lookup"><span data-stu-id="b6086-175">Consider a UDT with a property of a string of 10 characters (`System.Char`).</span></span> <span data-ttu-id="b6086-176">BinaryWriter를 사용 하 여 UDT를 serialize 하는 경우 직렬화 된 문자열의 총 크기는 22 바이트 (유니코드 UTF-16 문자인 경우 2 바이트, 최대 문자 수로 곱하고, 이진 스트림을 serialize 하 여 발생 하는 2 개의 제어 바이트)입니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-176">When the UDT is serialized by using a BinaryWriter, the total size of the serialized string is 22 bytes: 2 bytes per Unicode UTF-16 character, multiplied by the maximum number of characters, plus 2 control bytes of overhead incurred from serializing a binary stream.</span></span> <span data-ttu-id="b6086-177">따라서 `MaxByteSize`의 값을 결정할 때 직렬화된 UDT의 전체 크기를 고려해야 합니다. 이 크기는 이진 형식으로 직렬화된 데이터의 크기와 직렬화로 인해 발생한 오버헤드를 합한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-177">Therefore, when determining the value of `MaxByteSize`, the total size of the serialized UDT must be considered: the size of the data serialized in binary form plus the overhead incurred by serialization.</span></span>  
  
 `ValidationMethodName`  
 <span data-ttu-id="b6086-178">UDT의 인스턴스가 유효한지 여부를 검사하는 데 사용되는 메서드의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-178">The name of the method used to validate instances of the UDT.</span></span>  
  
### <a name="setting-isbyteordered"></a><span data-ttu-id="b6086-179">IsByteOrdered 설정</span><span class="sxs-lookup"><span data-stu-id="b6086-179">Setting IsByteOrdered</span></span>  
 <span data-ttu-id="b6086-180">`Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute.IsByteOrdered` 속성을 `true`로 설정하면 이는 직렬화된 이진 데이터가 정보의 의미 정렬(semantic ordering)에 사용될 수 있도록 보장하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-180">When the `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute.IsByteOrdered` property is set to `true`, you are in effect guaranteeing that the serialized binary data can be used for semantic ordering of the information.</span></span> <span data-ttu-id="b6086-181">따라서 바이트 정렬된 UDT 개체의 각 인스턴스에는 직렬화된 표현이 하나만 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-181">Thus, each instance of a byte-ordered UDT object can only have one serialized representation.</span></span> <span data-ttu-id="b6086-182">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]에서 직렬화된 바이트에 대한 비교 작업이 수행되면 그 결과는 동일한 비교 작업이 관리 코드에서 수행된 결과와 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-182">When a comparison operation is performed in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] on the serialized bytes, its results should be the same as if the same comparison operation had taken place in managed code.</span></span> <span data-ttu-id="b6086-183">`IsByteOrdered`가 `true`로 설정된 경우 다음 기능도 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-183">The following features are also supported when `IsByteOrdered` is set to `true`:</span></span>  
  
-   <span data-ttu-id="b6086-184">이 형식의 열에 인덱스를 만드는 기능</span><span class="sxs-lookup"><span data-stu-id="b6086-184">The ability to create indexes on columns of this type.</span></span>  
  
-   <span data-ttu-id="b6086-185">이 형식의 열에 CHECK 및 UNIQUE 제약 조건과 기본 키 및 외래 키를 만드는 기능</span><span class="sxs-lookup"><span data-stu-id="b6086-185">The ability to create primary and foreign keys as well as CHECK and UNIQUE constraints on columns of this type.</span></span>  
  
-   <span data-ttu-id="b6086-186">[!INCLUDE[tsql](../../includes/tsql-md.md)] ORDER BY, GROUP BY 및 PARTITION BY 절을 사용하는 기능.</span><span class="sxs-lookup"><span data-stu-id="b6086-186">The ability to use [!INCLUDE[tsql](../../includes/tsql-md.md)] ORDER BY, GROUP BY, and PARTITION BY clauses.</span></span> <span data-ttu-id="b6086-187">이 경우 형식의 이진 표현이 순서를 결정하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-187">In these cases, the binary representation of the type is used to determine the order.</span></span>  
  
-   <span data-ttu-id="b6086-188">[!INCLUDE[tsql](../../includes/tsql-md.md)] 문에서 비교 연산자를 사용하는 기능</span><span class="sxs-lookup"><span data-stu-id="b6086-188">The ability to use comparison operators in [!INCLUDE[tsql](../../includes/tsql-md.md)] statements.</span></span>  
  
-   <span data-ttu-id="b6086-189">이 형식의 계산 열을 유지하는 기능</span><span class="sxs-lookup"><span data-stu-id="b6086-189">The ability to persist computed columns of this type.</span></span>  
  
 <span data-ttu-id="b6086-190">`Native`가 `UserDefined`로 설정된 경우 `IsByteOrdered` 및 `true` 직렬화 형식은 다음 비교 연산자를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-190">Note that both the `Native` and `UserDefined` serialization formats support the following comparison operators when `IsByteOrdered` is set to `true`:</span></span>  
  
-   <span data-ttu-id="b6086-191">같음(=)</span><span class="sxs-lookup"><span data-stu-id="b6086-191">Equal to (=)</span></span>  
  
-   <span data-ttu-id="b6086-192">같지 않음(!=)</span><span class="sxs-lookup"><span data-stu-id="b6086-192">Not equal to (!=)</span></span>  
  
-   <span data-ttu-id="b6086-193">보다 큼(>)</span><span class="sxs-lookup"><span data-stu-id="b6086-193">Greater than (>)</span></span>  
  
-   <span data-ttu-id="b6086-194">보다 작음(\<)</span><span class="sxs-lookup"><span data-stu-id="b6086-194">Less than (\<)</span></span>  
  
-   <span data-ttu-id="b6086-195">크거나 같음(>=)</span><span class="sxs-lookup"><span data-stu-id="b6086-195">Greater than or equal to (>=)</span></span>  
  
-   <span data-ttu-id="b6086-196">작거나 같음(<=)</span><span class="sxs-lookup"><span data-stu-id="b6086-196">Less than or equal to (<=)</span></span>  
  
### <a name="implementing-nullability"></a><span data-ttu-id="b6086-197">Null 허용 여부 구현</span><span class="sxs-lookup"><span data-stu-id="b6086-197">Implementing Nullability</span></span>  
 <span data-ttu-id="b6086-198">어셈블리의 특성을 올바르게 지정하는 것 외에도 클래스는 Null 허용 여부를 지원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-198">In addition to specifying the attributes for your assemblies correctly, your class must also support nullability.</span></span> <span data-ttu-id="b6086-199">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]에 로드된 UDT는 Null을 인식하지만 UDT에서 Null 값을 인식하려면 클래스에서 `INullable` 인터페이스를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-199">UDTs loaded into [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] are null-aware, but in order for the UDT to recognize a null value, the class must implement the `INullable` interface.</span></span> <span data-ttu-id="b6086-200">UDT에서 null 허용 여부를 구현 하는 방법에 대 한 자세한 내용 및 예제는 [사용자 정의 형식 코딩](creating-user-defined-types-coding.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="b6086-200">For more information and an example of how to implement nullability in a UDT, see [Coding User-Defined Types](creating-user-defined-types-coding.md).</span></span>  
  
### <a name="string-conversions"></a><span data-ttu-id="b6086-201">문자열 변환</span><span class="sxs-lookup"><span data-stu-id="b6086-201">String Conversions</span></span>  
 <span data-ttu-id="b6086-202">UDT에서 문자열로의 변환 또는 문자열에서 UDT로의 변환을 지원하려면 클래스에서 `Parse` 메서드와 `ToString` 메서드를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-202">To support string conversion to and from the UDT, you must provide a `Parse` method and a `ToString` method in your class.</span></span> <span data-ttu-id="b6086-203">`Parse` 메서드는 문자열을 UDT로 변환할 수 있게 하며,</span><span class="sxs-lookup"><span data-stu-id="b6086-203">The `Parse` method allows a string to be converted into a UDT.</span></span> <span data-ttu-id="b6086-204">`static`(Visual Basic의 경우 `Shared`)으로 선언되고 `System.Data.SqlTypes.SqlString` 유형의 매개 변수를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-204">It must be declared as `static` (or `Shared` in Visual Basic), and take a parameter of type `System.Data.SqlTypes.SqlString`.</span></span> <span data-ttu-id="b6086-205">및 메서드를 구현 하는 방법에 대 한 자세한 내용 및 예제는 `Parse` `ToString` [사용자 정의 형식 코딩](creating-user-defined-types-coding.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="b6086-205">For more information and an example of how to implement the `Parse` and `ToString` methods, see [Coding User-Defined Types](creating-user-defined-types-coding.md).</span></span>  
  
## <a name="xml-serialization"></a><span data-ttu-id="b6086-206">XML Serialization</span><span class="sxs-lookup"><span data-stu-id="b6086-206">XML Serialization</span></span>  
 <span data-ttu-id="b6086-207">UDT는 XML 직렬화 계약에 따라 UDT에서 `xml` 데이터 형식으로의 변환 또는 xml 데이터 형식에서 UDT로의 변환을 지원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-207">UDTs must support conversion to and from the `xml` data type by conforming to the contract for XML serialization.</span></span> <span data-ttu-id="b6086-208">`System.Xml.Serialization` 네임스페이스는 개체를 XML 형식 문서나 스트림으로 serialize하는 데 사용되는 클래스를 포함하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-208">The `System.Xml.Serialization` namespace contains classes that are used to serialize objects into XML format documents or streams.</span></span> <span data-ttu-id="b6086-209">XML 직렬화 및 역직렬화를 위한 사용자 지정 형식을 제공하는 `xml` 인터페이스를 사용하여 `IXmlSerializable` 직렬화를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-209">You can choose to implement `xml` serialization by using the `IXmlSerializable` interface, which provides custom formatting for XML serialization and deserialization.</span></span>  
  
 <span data-ttu-id="b6086-210">XML 직렬화를 사용하면 UDT에서 `xml`로의 명시적 변환 외에도 다음과 같은 작업이 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-210">In addition to performing explicit conversions from UDT to `xml`, XML serialization enables you to:</span></span>  
  
-   <span data-ttu-id="b6086-211">`Xquery` 데이터 형식으로의 변환 후 UDT 인스턴스 값에 대해 `xml`를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-211">Use `Xquery` over values of UDT instances after conversion to the `xml` data type.</span></span>  
  
-   <span data-ttu-id="b6086-212">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]의 네이티브 XML 웹 서비스를 사용하여 매개 변수가 있는 쿼리 및 웹 메서드에서 UDT를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-212">Use UDTs in parameterized queries and Web methods with Native XML Web Services in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span>  
  
-   <span data-ttu-id="b6086-213">UDT를 사용하여 대량 로드된 XML 데이터를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-213">Use UDTs to receive a bulk load of XML data.</span></span>  
  
-   <span data-ttu-id="b6086-214">UDT 열이 있는 테이블이 포함된 데이터 세트을 직렬화합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-214">Serialize DataSets that contain tables with UDT columns.</span></span>  
  
 <span data-ttu-id="b6086-215">FOR XML 쿼리에서는 UDT가 직렬화되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-215">UDTs are not serialized in FOR XML queries.</span></span> <span data-ttu-id="b6086-216">UDT에 대한 XML 직렬화를 표시하는 FOR XML 쿼리를 실행하려면 SELECT 문에서 각 UDT 열을 `xml` 데이터 형식으로 명시적으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-216">To execute a FOR XML query that displays the XML serialization of UDTs, explicitly convert each UDT column to the `xml` data type in the SELECT statement.</span></span> <span data-ttu-id="b6086-217">UDT 열을 `varbinary`, `varchar` 또는 `nvarchar`로 명시적으로 변환할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b6086-217">You can also explicitly convert the columns to `varbinary`, `varchar`, or `nvarchar`.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b6086-218">참고 항목</span><span class="sxs-lookup"><span data-stu-id="b6086-218">See Also</span></span>  
 [<span data-ttu-id="b6086-219">사용자 정의 형식 만들기</span><span class="sxs-lookup"><span data-stu-id="b6086-219">Creating a User-Defined Type</span></span>](creating-user-defined-types.md)  
  
  
