---
title: CLR 호스팅 환경 | Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: clr
ms.topic: reference
helpviewer_keywords:
- type-safe code [CLR integration]
- UNSAFE permission set
- run-time environments [CLR integration]
- common language runtime [SQL Server], about CLR integration
- application domains [CLR integration]
- host protection attributes [CLR integration]
- managed code [SQL Server], common language runtime
- permission sets [CLR integration]
- reliability [CLR integration]
- SAFE permission set
- code access security [CLR integration]
- EXTERNAL_ACCESS permission set
- verifying type safety
- scalability [CLR integration]
- hosted environments [CLR integration]
- HPAs [CLR integration]
ms.assetid: d280d359-08f0-47b5-a07e-67dd2a58ad73
author: rothja
ms.author: jroth
ms.openlocfilehash: bd04536d1dfb8a4657fbe116cdfd38a6639a6327
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87735327"
---
# <a name="clr-hosted-environment"></a><span data-ttu-id="2d29b-102">CLR 호스팅 환경</span><span class="sxs-lookup"><span data-stu-id="2d29b-102">CLR Hosted Environment</span></span>
  <span data-ttu-id="2d29b-103">[!INCLUDE[msCoName](../../../includes/msconame-md.md)] .NET Framework CLR(공용 언어 런타임)은 [!INCLUDE[msCoName](../../../includes/msconame-md.md)] Visual C#, [!INCLUDE[msCoName](../../../includes/msconame-md.md)] Visual Basic 및 [!INCLUDE[msCoName](../../../includes/msconame-md.md)] Visual C++와 같은 여러 최신 프로그래밍 언어를 실행하는 환경입니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-103">The [!INCLUDE[msCoName](../../../includes/msconame-md.md)] .NET Framework common language runtime (CLR) is an environment that executes many modern programming languages, including [!INCLUDE[msCoName](../../../includes/msconame-md.md)] Visual C#, [!INCLUDE[msCoName](../../../includes/msconame-md.md)] Visual Basic, and [!INCLUDE[msCoName](../../../includes/msconame-md.md)] Visual C++.</span></span> <span data-ttu-id="2d29b-104">CLR에는 가비지 수집되는 메모리, 선점형 스레딩, 메타데이터 서비스(형식 리플렉션), 코드 안정성, 코드 액세스 보안 등의 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-104">The CLR features garbage-collected memory, pre-emptive threading, metadata services (type reflection), code verifiability, and code access security.</span></span> <span data-ttu-id="2d29b-105">CLR에서는 메타데이터를 사용하여 클래스를 찾아 로드하고, 메모리에 인스턴스를 배치하고, 메서드 호출을 확인하고, 네이티브 코드를 생성하고, 보안을 강화하며, 런타임 컨텍스트 경계를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-105">The CLR uses metadata to locate and load classes, lay out instances in memory, resolve method invocations, generate native code, enforce security, and set run-time context boundaries.</span></span>  
  
 <span data-ttu-id="2d29b-106">CLR과 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]는 모두 런타임 환경이지만 메모리, 스레드 및 동기화를 처리하는 방식에 있어서 서로 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-106">The CLR and [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] differ as run-time environments in the way they handle memory, threads, and synchronization.</span></span> <span data-ttu-id="2d29b-107">이 항목에서는 모든 시스템 리소스가 균일하게 관리되도록 이 두 런타임이 어떻게 통합되는지에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-107">This topic describes the way in which these two run times are integrated so that all system resources are managed uniformly.</span></span> <span data-ttu-id="2d29b-108">또한 안정적이고 안전한 사용자 코드 실행 환경을 제공하기 위해 CLR CAS(코드 액세스 보안)와 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 보안이 통합되는 방법에 대해서도 다룹니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-108">This topic also covers the way in which CLR code access security (CAS) and [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] security are integrated to provide a reliable and secure execution environment for user code.</span></span>  
  
## <a name="basic-concepts-of-clr-architecture"></a><span data-ttu-id="2d29b-109">CLR 아키텍처의 기본 개념</span><span class="sxs-lookup"><span data-stu-id="2d29b-109">Basic Concepts of CLR Architecture</span></span>  
 <span data-ttu-id="2d29b-110">.NET Framework에서 프로그래머는 클래스의 구조(예: 클래스의 필드나 속성)와 메서드를 정의하여 클래스를 구현하는 고급 언어로 코드를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-110">In the .NET Framework, a programmer writes in a high-level language that implements a class defining its structure (for example, the fields or properties of the class) and methods.</span></span> <span data-ttu-id="2d29b-111">이러한 메서드 일부는 정적 함수일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-111">Some of these methods can be static functions.</span></span> <span data-ttu-id="2d29b-112">프로그램을 컴파일하면 어셈블리라는 파일이 생성되는데 이 어셈블리 파일에는 MSIL([!INCLUDE[msCoName](../../../includes/msconame-md.md)] Intermediate Language)로 컴파일된 코드 및 종속 어셈블리에 대한 모든 참조가 포함된 매니페스트가 들어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-112">The compilation of the program produces a file called an assembly that contains the compiled code in the [!INCLUDE[msCoName](../../../includes/msconame-md.md)] intermediate language (MSIL), and a manifest that contains all references to dependent assemblies.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="2d29b-113">어셈블리는 CLR 아키텍처의 필수 요소로,</span><span class="sxs-lookup"><span data-stu-id="2d29b-113">Assemblies are a vital element in the architecture of the CLR.</span></span> <span data-ttu-id="2d29b-114">.NET Framework에서 애플리케이션 코드를 패키징, 배포 및 버전 관리하는 단위입니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-114">They are the units of packaging, deployment, and versioning of application code in the .NET Framework.</span></span> <span data-ttu-id="2d29b-115">어셈블리를 사용하면 데이터베이스 안에 애플리케이션 코드를 배포하고 완전한 데이터베이스 애플리케이션을 일관된 방법으로 관리, 백업 및 복원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-115">Using assemblies, you can deploy application code inside the database and provide a uniform way to administer, back up, and restore complete database applications.</span></span>  
  
 <span data-ttu-id="2d29b-116">어셈블리 매니페스트에는 프로그램에 정의되어 있는 모든 구조, 필드, 속성, 클래스, 상속 관계, 함수 및 메서드를 설명하는 어셈블리 메타데이터가 들어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-116">The assembly manifest contains metadata about the assembly, describing all of the structures, fields, properties, classes, inheritance relationships, functions, and methods defined in the program.</span></span> <span data-ttu-id="2d29b-117">어셈블리 매니페스트는 어셈블리의 ID를 설정하고, 어셈블리 구현을 구성하는 파일을 지정하고, 어셈블리를 구성하는 형식 및 리소스를 지정하며, 컴파일 타임의 다른 어셈블리에 대한 종속성을 항목별로 요약하고, 어셈블리가 제대로 실행되는 데 필요한 권한 집합을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-117">The manifest establishes the assembly identity, specifies the files that make up the assembly implementation, specifies the types and resources that make up the assembly, itemizes the compile-time dependencies on other assemblies, and specifies the set of permissions required for the assembly to run properly.</span></span> <span data-ttu-id="2d29b-118">이 정보는 런타임에 참조를 확인하고, 버전 바인딩 정책을 적용하고, 로드된 어셈블리의 무결성을 확인하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-118">This information is used at run time to resolve references, enforce version binding policy, and validate the integrity of loaded assemblies.</span></span>  
  
 <span data-ttu-id="2d29b-119">.NET Framework에서는 애플리케이션에서 메타데이터에 캡처할 수 있는 추가적인 정보를 클래스, 속성, 함수 및 메서드에 주석으로 추가할 수 있는 사용자 지정 특성을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-119">The .NET Framework supports custom attributes for annotating classes, properties, functions, and methods with additional information the application may capture in metadata.</span></span> <span data-ttu-id="2d29b-120">모든 .NET Framework 컴파일러는 이러한 주석을 해석 없이 사용하고 어셈블리 메타데이터로 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-120">All .NET Framework compilers consume these annotations without interpretation and store them as assembly metadata.</span></span> <span data-ttu-id="2d29b-121">이러한 주석은 다른 메타데이터와 같은 방식으로 검사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-121">These annotations can be examined in the same way as any other metadata.</span></span>  
  
 <span data-ttu-id="2d29b-122">관리 코드는 운영 체제에서 직접 실행되는 대신 CLR에서 실행되는 MSIL입니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-122">Managed code is MSIL executed in the CLR, rather than directly by the operating system.</span></span> <span data-ttu-id="2d29b-123">관리 코드 애플리케이션은 자동 가비지 수집, 런타임 형식 확인, 보안 지원 등과 같은 CLR 서비스를 얻습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-123">Managed code applications acquire CLR services, such as automatic garbage collection, run-time type checking, and security support.</span></span> <span data-ttu-id="2d29b-124">이러한 서비스는 관리 코드 애플리케이션의 일관된 플랫폼 및 언어 독립적인 동작을 제공하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-124">These services help provide uniform platform- and language-independent behavior of managed code applications.</span></span>  
  
## <a name="design-goals-of-clr-integration"></a><span data-ttu-id="2d29b-125">CLR 통합의 디자인 목표</span><span class="sxs-lookup"><span data-stu-id="2d29b-125">Design Goals of CLR Integration</span></span>  
 <span data-ttu-id="2d29b-126">CLR 통합은 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]의 CLR 호스팅 환경에서 사용자 코드를 실행하는 것을 의미하며 여기에는 다음과 같은 디자인 목표가 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-126">When user code runs inside the CLR-hosted environment in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] (called CLR integration), the following design goals apply:</span></span>  
  
###### <a name="reliability-safety"></a><span data-ttu-id="2d29b-127">안정성(보안)</span><span class="sxs-lookup"><span data-stu-id="2d29b-127">Reliability (Safety)</span></span>  
 <span data-ttu-id="2d29b-128">사용자 코드는 사용자 응답을 요청하는 메시지 상자를 표시하거나 프로세스를 종료하는 것과 같이 데이터베이스 엔진 프로세스의 무결성을 손상시키는 작업을 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-128">User code should not be allowed to perform operations that compromise the integrity of the Database Engine process, such as popping a message box requesting a user response or exiting the process.</span></span> <span data-ttu-id="2d29b-129">또한 사용자 코드는 데이터베이스 엔진 메모리 버퍼 또는 내부 데이터 구조를 덮어쓸 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-129">User code should not be able to overwrite Database Engine memory buffers or internal data structures.</span></span>  
  
###### <a name="scalability"></a><span data-ttu-id="2d29b-130">확장성</span><span class="sxs-lookup"><span data-stu-id="2d29b-130">Scalability</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]<span data-ttu-id="2d29b-131">와 CLR은 일정 예약 및 메모리 관리를 위한 내부 모델이 서로 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-131">and the CLR have different internal models for scheduling and memory management.</span></span> [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]<span data-ttu-id="2d29b-132">는 스레드가 정기적으로 또는 잠금이나 I/O 대기 중일 때 자동으로 실행이 해제되는 공동의 비선점형 스레딩 모델을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-132">supports a cooperative, non-preemptive threading model in which the threads voluntarily yield execution periodically, or when they are waiting on locks or I/O.</span></span> <span data-ttu-id="2d29b-133">반면 CLR은 선점형 스레딩 모델을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-133">The CLR supports a preemptive threading model.</span></span> <span data-ttu-id="2d29b-134">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 내에서 실행되는 사용자 코드에서 운영 체제 스레딩 기본 형식을 직접 호출할 수 있으면 사용자 코드가 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 태스크 스케줄러에 제대로 통합되지 않고 시스템의 확장성을 떨어뜨릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-134">If user code running inside [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can directly call the operating system threading primitives, then it does not integrate well into the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] task scheduler and can degrade the scalability of the system.</span></span> <span data-ttu-id="2d29b-135">CLR은 가상 메모리와 실제 메모리를 구분하지 않지만 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]는 실제 메모리를 직접 관리하고 구성 가능한 한도 내에서만 실제 메모리를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-135">The CLR does not distinguish between virtual and physical memory, but [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] directly manages physical memory and is required to use physical memory within a configurable limit.</span></span>  
  
 <span data-ttu-id="2d29b-136">수천 개의 동시 사용자 세션을 지원하도록 확장 가능한 RDBMS(관계형 데이터베이스 관리 시스템)의 경우에는 스레딩, 일정 예약 및 메모리 관리 모델이 다르기 때문에 통합하기 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-136">The different models for threading, scheduling, and memory management present an integration challenge for a relational database management system (RDBMS) that scales to support thousands of concurrent user sessions.</span></span> <span data-ttu-id="2d29b-137">아키텍처에서는 스레딩, 메모리 및 동기화 기본 형식을 위한 API(응용 프로그래밍 인터페이스)를 직접 호출하는 사용자 코드로 인해 시스템의 확장성에 문제가 발생하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-137">The architecture should ensure that the scalability of the system is not compromised by user code calling application programming interfaces (APIs) for threading, memory, and synchronization primitives directly.</span></span>  
  
###### <a name="security"></a><span data-ttu-id="2d29b-138">보안</span><span class="sxs-lookup"><span data-stu-id="2d29b-138">Security</span></span>  
 <span data-ttu-id="2d29b-139">데이터베이스에서 실행되는 사용자 코드는 테이블과 열 같은 데이터베이스 개체에 액세스할 때 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 인증 및 권한 부여 규칙을 준수해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-139">User code running in the database must follow [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] authentication and authorization rules when accessing database objects such as tables and columns.</span></span> <span data-ttu-id="2d29b-140">또한 데이터베이스 관리자는 데이터베이스에서 실행되는 사용자 코드를 통해 파일 같은 운영 체제 리소스에 대한 액세스 및 네트워크 액세스를 제어할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-140">In addition, database administrators should be able to control access to operating system resources, such as files and network access, from user code running in the database.</span></span> <span data-ttu-id="2d29b-141">Transact-SQL과 같이 관리되지 않는 언어와 달리 관리되는 프로그래밍 언어는 이와 같은 리소스에 액세스하기 위한 API를 제공하기 때문에 액세스 제어가 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-141">This becomes important as managed programming languages (unlike non-managed languages such as Transact-SQL) provide APIs to access such resources.</span></span> <span data-ttu-id="2d29b-142">시스템에서는 사용자 코드가 [!INCLUDE[ssDE](../../../includes/ssde-md.md)] 프로세스 외부에서 컴퓨터 리소스에 액세스할 수 있는 안전한 방법을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-142">The system must provide a secure way for user code to access machine resources outside the [!INCLUDE[ssDE](../../../includes/ssde-md.md)] process.</span></span> <span data-ttu-id="2d29b-143">자세한 내용은 [CLR Integration Security](security/clr-integration-security.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2d29b-143">For more information, see [CLR Integration Security](security/clr-integration-security.md).</span></span>  
  
###### <a name="performance"></a><span data-ttu-id="2d29b-144">성능</span><span class="sxs-lookup"><span data-stu-id="2d29b-144">Performance</span></span>  
 <span data-ttu-id="2d29b-145">[!INCLUDE[ssDE](../../../includes/ssde-md.md)]에서 실행되는 관리되는 사용자 코드는 서버 외부에서 실행되는 동일한 코드와 비교할 수 있을 정도의 계산 성능을 가지고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-145">Managed user code running in the [!INCLUDE[ssDE](../../../includes/ssde-md.md)] should have computational performance comparable to the same code run outside the server.</span></span> <span data-ttu-id="2d29b-146">관리되는 사용자 코드에서 데이터베이스에 액세스하면 네이티브 [!INCLUDE[tsql](../../../includes/tsql-md.md)]을 사용할 때보다 속도가 느립니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-146">Database access from managed user code is not as fast as native [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="2d29b-147">자세한 내용은 [CLR 통합의 성능](clr-integration-architecture-performance.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2d29b-147">For more information, see [Performance of CLR Integration](clr-integration-architecture-performance.md).</span></span>  
  
## <a name="clr-services"></a><span data-ttu-id="2d29b-148">CLR Services</span><span class="sxs-lookup"><span data-stu-id="2d29b-148">CLR Services</span></span>  
 <span data-ttu-id="2d29b-149">CLR은 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]와의 CLR 통합에 대한 디자인 목표를 달성하는 데 도움이 되는 여러 가지 서비스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-149">The CLR provides a number of services to help achieve the design goals of CLR integration with [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span>  
  
###### <a name="type-safety-verification"></a><span data-ttu-id="2d29b-150">형식 안전성 확인</span><span class="sxs-lookup"><span data-stu-id="2d29b-150">Type safety verification</span></span>  
 <span data-ttu-id="2d29b-151">형식 안전 코드는 명확하게 정의된 방법으로만 메모리 구조에 액세스하는 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-151">Type-safe code is code that accesses memory structures only in well-defined ways.</span></span> <span data-ttu-id="2d29b-152">예를 들어 올바른 개체 참조에 대해 형식 안전 코드는 실제 필드 멤버에 대응하는 고정 오프셋에서 메모리에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-152">For example, given a valid object reference, type-safe code can access memory at fixed offsets corresponding to actual field members.</span></span> <span data-ttu-id="2d29b-153">그러나 개체에 속하는 메모리 범위 안이나 밖의 임의의 오프셋에서 메모리에 액세스하는 코드는 형식 안전 코드가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-153">However, if the code accesses memory at arbitrary offsets inside or outside the range of memory that belongs to the object, then it is not type-safe.</span></span> <span data-ttu-id="2d29b-154">어셈블리가 CLR에 로드되고 JIT(Just-In-Time) 컴파일을 사용하여 MSIL을 컴파일되기 전에 런타임에서는 코드의 형식 안전성을 검사하는 확인 단계를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-154">When assemblies are loaded in the CLR, prior to the MSIL being compiled using just-in-time (JIT) compilation, the runtime performs a verification phase that examines code to determine its type-safety.</span></span> <span data-ttu-id="2d29b-155">이 확인 과정을 통과한 코드는 형식 안전 코드라고 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-155">Code that successfully passes this verification is called verifiably type-safe code.</span></span>  
  
###### <a name="application-domains"></a><span data-ttu-id="2d29b-156">애플리케이션 도메인</span><span class="sxs-lookup"><span data-stu-id="2d29b-156">Application domains</span></span>  
 <span data-ttu-id="2d29b-157">CLR은 호스트 프로세스에서 관리 코드 어셈블리를 로드하고 실행할 수 있는 실행 영역이라는 개념으로 애플리케이션 도메인을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-157">The CLR supports the notion of application domains as execution zones within a host process where managed code assemblies can be loaded and executed.</span></span> <span data-ttu-id="2d29b-158">애플리케이션 도메인 경계는 어셈블리 사이를 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-158">The application domain boundary provides isolation between assemblies.</span></span> <span data-ttu-id="2d29b-159">어셈블리는 정적 변수와 데이터 멤버의 표시 유형 및 코드를 동적으로 호출할 수 있는지 여부를 기준으로 격리됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-159">The assemblies are isolated in terms of visibility of static variables and data members and the ability to call code dynamically.</span></span> <span data-ttu-id="2d29b-160">애플리케이션 도메인은 코드를 로드하고 언로드하는 메커니즘이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-160">Application domains are also the mechanism for loading and unloading code.</span></span> <span data-ttu-id="2d29b-161">메모리에서 코드를 언로드하는 유일한 방법은 애플리케이션 도메인을 언로드하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-161">Code can be unloaded from memory only by unloading the application domain.</span></span> <span data-ttu-id="2d29b-162">자세한 내용은 [응용 프로그램 도메인 및 CLR 통합 보안](../../database-engine/dev-guide/application-domains-and-clr-integration-security.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2d29b-162">For more information, see [Application Domains and CLR Integration Security](../../database-engine/dev-guide/application-domains-and-clr-integration-security.md).</span></span>  
  
###### <a name="code-access-security-cas"></a><span data-ttu-id="2d29b-163">CAS(코드 액세스 보안)</span><span class="sxs-lookup"><span data-stu-id="2d29b-163">Code Access Security (CAS)</span></span>  
 <span data-ttu-id="2d29b-164">CLR 보안 시스템을 사용하면 코드에 사용 권한을 할당하여 관리 코드로 수행할 수 있는 작업의 유형을 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-164">The CLR security system provides a way to control what kinds of operations managed code can perform by assigning permissions to code.</span></span> <span data-ttu-id="2d29b-165">코드 액세스 권한은 코드 ID(예: 어셈블리의 서명 또는 코드 원본)를 기준으로 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-165">Code access permissions are assigned based on code identity (for example, the signature of the assembly or the origin of the code).</span></span>  
  
 <span data-ttu-id="2d29b-166">CLR에는 컴퓨터 관리자가 설정할 수 있는 컴퓨터 차원의 정책이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-166">The CLR provides for a computer-wide policy that can be set by the computer administrator.</span></span> <span data-ttu-id="2d29b-167">이 정책은 컴퓨터에서 실행되는 모든 관리 코드에 대한 권한 부여를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-167">This policy defines the permission grants for any managed code running on the machine.</span></span> <span data-ttu-id="2d29b-168">컴퓨터 차원의 정책 외에 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 같은 호스트에서 관리 코드에 대한 추가적인 제한을 지정하는 데 사용할 수 있는 호스트 수준의 보안 정책도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-168">In addition, there is a host-level security policy that can be used by hosts such as [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to specify additional restrictions on managed code.</span></span>  
  
 <span data-ttu-id="2d29b-169">.NET Framework의 관리되는 API가 코드 액세스 권한으로 보호되는 리소스에 대한 작업을 노출할 경우, API는 리소스에 액세스하기 전에 해당 사용 권한을 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-169">If a managed API in the .NET Framework exposes operations on resources that are protected by a code access permission, the API will demand that permission before accessing the resource.</span></span> <span data-ttu-id="2d29b-170">이 요청이 발생하면 CLR 보안 시스템에서는 호출 스택에 포함된 모든 코드 단위(어셈블리)에 대한 포괄적인 검사를 트리거합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-170">This demand causes the CLR security system to trigger a comprehensive check of every unit of code (assembly) in the call stack.</span></span> <span data-ttu-id="2d29b-171">전체 호출 체인에 사용 권한이 있는 경우에만 리소스에 대한 액세스가 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-171">Only if the entire call chain has permission will access to the resource be granted.</span></span>  
  
 <span data-ttu-id="2d29b-172">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]의 CLR 호스팅 환경 내에서는 Reflection.Emit API를 사용하여 관리 코드를 동적으로 생성할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-172">Note that the ability to generate managed code dynamically, using the Reflection.Emit API, is not supported inside the CLR-hosted environment in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="2d29b-173">이러한 코드는 적절한 CAS 권한을 가지고 있지 않기 때문에 런타임에 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-173">Such code would not have the CAS permissions to run and would therefore fail at run time.</span></span> <span data-ttu-id="2d29b-174">자세한 내용은 [CLR 통합 코드 액세스 보안](security/clr-integration-code-access-security.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2d29b-174">For more information, see [CLR Integration Code Access Security](security/clr-integration-code-access-security.md).</span></span>  
  
###### <a name="host-protection-attributes-hpas"></a><span data-ttu-id="2d29b-175">HPA(호스트 보호 특성)</span><span class="sxs-lookup"><span data-stu-id="2d29b-175">Host Protection Attributes (HPAs)</span></span>  
 <span data-ttu-id="2d29b-176">CLR은 .NET Framework의 일부인 관리되는 API에 대해 CLR 호스트에서 유용할 수 있는 특성으로 주석을 지정하기 위한 메커니즘을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-176">The CLR provides a mechanism to annotate managed APIs that are part of the .NET Framework with certain attributes that may be of interest to a host of the CLR.</span></span> <span data-ttu-id="2d29b-177">이러한 특성의 예를 들면 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-177">Examples of such attributes include:</span></span>  
  
-   <span data-ttu-id="2d29b-178">SharedState: API가 공유 상태(예: 정적 클래스 필드)를 만들거나 관리하는 기능을 노출하는지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-178">SharedState, which indicates whether the API exposes the ability to create or manage shared state (for example, static class fields).</span></span>  
  
-   <span data-ttu-id="2d29b-179">Synchronization: API가 스레드 간 동기화 기능을 노출하는지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-179">Synchronization, which indicates whether the API exposes the ability to perform synchronization between threads.</span></span>  
  
-   <span data-ttu-id="2d29b-180">ExternalProcessMgmt: API가 호스트 프로세스 제어 기능을 노출하는지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-180">ExternalProcessMgmt, which indicates whether the API exposes a way to control the host process.</span></span>  
  
 <span data-ttu-id="2d29b-181">이러한 특성을 사용하면 호스트에서는 호스팅 환경에서 허용하지 않는 HPA 목록(예: SharedState 특성)을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-181">Given these attributes, the host can specify a list of HPAs, such as the SharedState attribute, that should be disallowed in the hosted environment.</span></span> <span data-ttu-id="2d29b-182">이렇게 하면 CLR에서는 금지 목록에 포함된 HPA로 주석이 지정된 API를 호출하는 사용자 코드를 거부합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-182">In this case, the CLR denies attempts by user code to call APIs that are annotated by the HPAs in the prohibited list.</span></span> <span data-ttu-id="2d29b-183">자세한 내용은 [호스트 보호 특성 및 CLR 통합 프로그래밍](../clr-integration-security-host-protection-attributes/host-protection-attributes-and-clr-integration-programming.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2d29b-183">For more information, see [Host Protection Attributes and CLR Integration Programming](../clr-integration-security-host-protection-attributes/host-protection-attributes-and-clr-integration-programming.md).</span></span>  
  
## <a name="how-sql-server-and-the-clr-work-together"></a><span data-ttu-id="2d29b-184">SQL Server와 CLR이 함께 작동하는 방법</span><span class="sxs-lookup"><span data-stu-id="2d29b-184">How SQL Server and the CLR Work Together</span></span>  
 <span data-ttu-id="2d29b-185">이 섹션에서는 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]에서 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]와 CLR의 스레딩, 일정 관리, 동기화 및 메모리 관리 모델을 통합하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-185">This section discusses how [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] integrates the threading, scheduling, synchronization, and memory management models of [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and the CLR.</span></span> <span data-ttu-id="2d29b-186">특히 이 섹션에서는 확장성, 안정성 및 보안 목표 측면에서의 통합을 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-186">In particular, this section examines the integration in light of scalability, reliability, and security goals.</span></span> [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="2d29b-187">내에서 CLR을 호스팅하면 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]는 CLR의 운영 체제 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-187">essentially acts as the operating system for the CLR when it is hosted inside [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="2d29b-188">CLR에서는 스레딩, 일정 예약, 동기화 및 메모리 관리를 위해 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]에 구현된 하위 수준의 루틴을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-188">The CLR calls low-level routines implemented by [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] for threading, scheduling, synchronization, and memory management.</span></span> <span data-ttu-id="2d29b-189">이는 나머지 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 엔진에서 사용하는 기본 형식과 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-189">These are the same primitives that the rest of the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] engine uses.</span></span> <span data-ttu-id="2d29b-190">이 방식을 사용하면 확장성, 안정성 및 보안상 여러 가지 이점을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-190">This approach provides several scalability, reliability, and security benefits.</span></span>  
  
###### <a name="scalability-common-threading-scheduling-and-synchronization"></a><span data-ttu-id="2d29b-191">확장성: 일반 스레딩, 일정 예약 및 동기화</span><span class="sxs-lookup"><span data-stu-id="2d29b-191">Scalability: Common threading, scheduling, and synchronization</span></span>  
 <span data-ttu-id="2d29b-192">CLR에서는 사용자 코드를 실행하기 위한 경우나 내부적인 용도로 사용하기 위한 경우 모두 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] API를 호출하여 스레드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-192">CLR calls [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] APIs for creating threads, both for running user code and for its own internal use.</span></span> <span data-ttu-id="2d29b-193">여러 스레드를 동기화하기 위해 CLR에서는 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 동기화 개체를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-193">In order to synchronize between multiple threads, the CLR calls [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] synchronization objects.</span></span> <span data-ttu-id="2d29b-194">이렇게 하면 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 스케줄러는 스레드가 동기화 개체를 대기하고 있을 때 다른 태스크의 일정을 예약할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-194">This allows the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] scheduler to schedule other tasks when a thread is waiting on a synchronization object.</span></span> <span data-ttu-id="2d29b-195">예를 들어 CLR에서 가비지 수집을 시작하면 가비지 수집이 완료될 때까지 모든 스레드가 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-195">For example, when the CLR initiates garbage collection, all of its threads wait for garbage collection to finish.</span></span> <span data-ttu-id="2d29b-196">CLR 스레드 및 CLR 스레드에서 대기 중인 동기화 개체를 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 스케줄러가 알고 있기 때문에 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]에서는 CLR과 관련되지 않은 다른 데이터베이스 태스크를 실행하는 스레드를 예약할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-196">Because the CLR threads and the synchronization objects they are waiting on are known to the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] scheduler, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can schedule threads that are running other database tasks not involving the CLR.</span></span> <span data-ttu-id="2d29b-197">또한 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]에서는 CLR 동기화 개체의 잠금과 관련된 교착 상태를 검색한 후 일반적인 기술을 사용하여 교착 상태를 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-197">This also enables [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to detect deadlocks that involve locks taken by CLR synchronization objects and employ traditional techniques for deadlock removal.</span></span>  
  
 <span data-ttu-id="2d29b-198">관리 코드는 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]에서 선점형 모드로 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-198">Managed code runs preemptively in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="2d29b-199">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 스케줄러에는 리소스를 오랫동안 점유하고 있는 스레드를 확인하여 중지하는 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-199">The [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] scheduler has the ability to detect and stop threads that have not yielded for a significant amount of time.</span></span> <span data-ttu-id="2d29b-200">CLR 스레드를 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 스레드에 후크하는 기능은 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 스케줄러가 CLR의 "런어웨이" 스레드를 식별하여 해당 스레드의 우선 순위를 관리할 수 있음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-200">The ability to hook CLR threads to [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] threads implies that the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] scheduler can identify "runaway" threads in the CLR and manage their priority.</span></span> <span data-ttu-id="2d29b-201">이와 같은 런어웨이 스레드는 일시 중지되어 큐에 다시 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-201">Such runaway threads are suspended and put back in the queue.</span></span> <span data-ttu-id="2d29b-202">런어웨이 스레드로 반복적으로 식별되는 스레드는 작업을 수행하는 다른 스레드가 실행될 수 있도록 일정 기간 동안 일시 중지됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-202">Threads that are repeatedly identified as runaway threads are not allowed to run for a given period of time so that other executing workers can run.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="2d29b-203">데이터에 액세스하거나 가비지 수집이 트리거될 정도로 많은 양의 메모리를 할당하는 장기 실행 관리 코드는 자동으로 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-203">Long-running managed code that accesses data or allocates enough memory to trigger garbage collection will yield automatically.</span></span> <span data-ttu-id="2d29b-204">반면 데이터에 액세스하지 않거나 가비지 수집이 트리거될 정도의 충분한 메모리를 할당하지 않는 장기 실행 관리 코드는 .NET Framework의 System.Thread.Sleep() 함수를 호출하여 명시적으로 해제해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-204">Long-running managed code that does not access data or allocate enough managed memory to trigger garbage collection should explicitly yield by calling the System.Thread.Sleep() function of the .NET Framework.</span></span>  
  
###### <a name="scalability-common-memory-management"></a><span data-ttu-id="2d29b-205">확장성: 일반적인 메모리 관리</span><span class="sxs-lookup"><span data-stu-id="2d29b-205">Scalability: Common memory management</span></span>  
 <span data-ttu-id="2d29b-206">CLR은 메모리를 할당하거나 할당을 취소하기 위해 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 기본 형식을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-206">The CLR calls [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] primitives for allocating and de-allocating its memory.</span></span> <span data-ttu-id="2d29b-207">CLR에서 사용하는 메모리는 시스템의 총 메모리 사용량에 포함되기 때문에 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]에서는 구성된 메모리 제한을 초과하지 않으면서 CLR과 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]가 메모리를 차지하기 위해 서로 경쟁하지 않도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-207">Because the memory used by the CLR is accounted for in the total memory usage of the system, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can stay within its configured memory limits and ensure the CLR and [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] are not competing with each other for memory.</span></span> [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]<span data-ttu-id="2d29b-208">에서는 시스템 메모리가 제한되었을 때 CLR 메모리 요청을 거부할 수 있으며 다른 태스크에 메모리가 필요할 때 메모리 사용을 줄이도록 CLR에 요청할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-208">can also reject CLR memory requests when system memory is constrained, and ask CLR to reduce its memory use when other tasks need memory.</span></span>  
  
###### <a name="reliability-application-domains-and-unrecoverable-exceptions"></a><span data-ttu-id="2d29b-209">안정성: 응용 프로그램 도메인 및 복구할 수 없는 예외</span><span class="sxs-lookup"><span data-stu-id="2d29b-209">Reliability: Application domains and unrecoverable exceptions</span></span>  
 <span data-ttu-id="2d29b-210">.NET Framework API의 관리 코드에서 메모리 부족 또는 스택 오버플로와 같은 중대한 예외가 발견되었을 때 이러한 오류를 복구하여 API 구현의 의미를 일관되고 올바르게 유지하지 못하는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-210">When managed code in the .NET Framework APIs encounters critical exceptions, such as out-of-memory or stack overflow, it is not always possible to recover from such failures and ensure consistent and correct semantics for their implementation.</span></span> <span data-ttu-id="2d29b-211">이러한 API는 이와 같은 오류에 대한 응답으로 스레드 중단 예외를 발생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-211">These APIs raise a thread abort exception in response to these failures.</span></span>  
  
 <span data-ttu-id="2d29b-212">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]에서 호스팅되는 경우 이러한 스레드 중단은 다음과 같이 처리됩니다. 즉, CLR이 애플리케이션 도메인 내에서 스레드 중단이 발생한 모든 공유 상태를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-212">When hosted in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], such thread aborts are handled as follows: the CLR detects any shared state in the application domain in which the thread abort occurs.</span></span> <span data-ttu-id="2d29b-213">CLR은 동기화 개체가 있는지 여부를 확인하여 이 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-213">The CLR does this by checking for the presence of synchronization objects.</span></span> <span data-ttu-id="2d29b-214">애플리케이션 도메인에 공유 상태가 있으면 애플리케이션 도메인 자체가 언로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-214">If there is shared state in the application domain, then the application domain itself is unloaded.</span></span> <span data-ttu-id="2d29b-215">애플리케이션 도메인이 언로드되면 해당 애플리케이션 도메인에서 현재 실행 중인 데이터베이스 트랜잭션이 중지됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-215">The unloading of the application domain stops database transactions that are currently running in that application domain.</span></span> <span data-ttu-id="2d29b-216">공유 상태가 있는 경우 예외를 트리거한 세션 이외의 다른 사용자 세션도 이와 같은 중대한 예외의 영향을 받을 수 있기 때문에 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]와 CLR은 공유 상태의 가능성을 줄이기 위한 조치를 취합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-216">Because the presence of shared state can widen the impact of such critical exceptions to user sessions other than the one triggering the exception, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and the CLR have taken steps to reduce the likelihood of shared state.</span></span> <span data-ttu-id="2d29b-217">자세한 내용은 .NET Framework 설명서를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="2d29b-217">For more information, see the .NET Framework documentation.</span></span>  
  
###### <a name="security-permission-sets"></a><span data-ttu-id="2d29b-218">보안: 권한 집합</span><span class="sxs-lookup"><span data-stu-id="2d29b-218">Security: Permission sets</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]<span data-ttu-id="2d29b-219">에서는 데이터베이스에 배포되는 코드의 안정성 및 보안 요구 사항을 사용자가 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-219">allows users to specify the reliability and security requirements for code deployed into the database.</span></span> <span data-ttu-id="2d29b-220">어셈블리를 데이터베이스에 업로드 하면 어셈블리 작성자는 해당 어셈블리에 대해 SAFE, EXTERNAL_ACCESS 및 UNSAFE의 세 가지 권한 집합 중 하나를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-220">When assemblies are uploaded into the database, the author of the assembly can specify one of three permission sets for that assembly: SAFE, EXTERNAL_ACCESS and UNSAFE.</span></span>  
  
|||||  
|-|-|-|-|  
|<span data-ttu-id="2d29b-221">권한 집합</span><span class="sxs-lookup"><span data-stu-id="2d29b-221">Permission set</span></span>|<span data-ttu-id="2d29b-222">SAFE</span><span class="sxs-lookup"><span data-stu-id="2d29b-222">SAFE</span></span>|<span data-ttu-id="2d29b-223">EXTERNAL_ACCESS</span><span class="sxs-lookup"><span data-stu-id="2d29b-223">EXTERNAL_ACCESS</span></span>|<span data-ttu-id="2d29b-224">UNSAFE</span><span class="sxs-lookup"><span data-stu-id="2d29b-224">UNSAFE</span></span>|  
|<span data-ttu-id="2d29b-225">코드 액세스 보안</span><span class="sxs-lookup"><span data-stu-id="2d29b-225">Code Access Security</span></span>|<span data-ttu-id="2d29b-226">실행 전용</span><span class="sxs-lookup"><span data-stu-id="2d29b-226">Execute only</span></span>|<span data-ttu-id="2d29b-227">실행 및 외부 리소스 액세스</span><span class="sxs-lookup"><span data-stu-id="2d29b-227">Execute + access to external resources</span></span>|<span data-ttu-id="2d29b-228">제한 없음</span><span class="sxs-lookup"><span data-stu-id="2d29b-228">Unrestricted</span></span>|  
|<span data-ttu-id="2d29b-229">프로그래밍 모델 제한 사항</span><span class="sxs-lookup"><span data-stu-id="2d29b-229">Programming model restrictions</span></span>|<span data-ttu-id="2d29b-230">예</span><span class="sxs-lookup"><span data-stu-id="2d29b-230">Yes</span></span>|<span data-ttu-id="2d29b-231">예</span><span class="sxs-lookup"><span data-stu-id="2d29b-231">Yes</span></span>|<span data-ttu-id="2d29b-232">제한 없음</span><span class="sxs-lookup"><span data-stu-id="2d29b-232">No restrictions</span></span>|  
|<span data-ttu-id="2d29b-233">안정성 요구 사항</span><span class="sxs-lookup"><span data-stu-id="2d29b-233">Verifiability requirement</span></span>|<span data-ttu-id="2d29b-234">예</span><span class="sxs-lookup"><span data-stu-id="2d29b-234">Yes</span></span>|<span data-ttu-id="2d29b-235">예</span><span class="sxs-lookup"><span data-stu-id="2d29b-235">Yes</span></span>|<span data-ttu-id="2d29b-236">예</span><span class="sxs-lookup"><span data-stu-id="2d29b-236">No</span></span>|  
|<span data-ttu-id="2d29b-237">네이티브 코드를 호출하는 기능</span><span class="sxs-lookup"><span data-stu-id="2d29b-237">Ability to call native code</span></span>|<span data-ttu-id="2d29b-238">예</span><span class="sxs-lookup"><span data-stu-id="2d29b-238">No</span></span>|<span data-ttu-id="2d29b-239">예</span><span class="sxs-lookup"><span data-stu-id="2d29b-239">No</span></span>|<span data-ttu-id="2d29b-240">예</span><span class="sxs-lookup"><span data-stu-id="2d29b-240">Yes</span></span>|  
  
 <span data-ttu-id="2d29b-241">SAFE는 가장 신뢰할 수 있고 안전한 모드로, 허용되는 프로그래밍 모델에 대한 제한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-241">SAFE is the most reliable and secure mode with associated restrictions in terms of the allowed programming model.</span></span> <span data-ttu-id="2d29b-242">SAFE 어셈블리는 실행하고, 계산을 수행하고, 로컬 데이터베이스에 액세스할 수 있는 권한이 부여됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-242">SAFE assemblies are given enough permission to run, perform computations, and have access to the local database.</span></span> <span data-ttu-id="2d29b-243">SAFE 어셈블리는 확인할 수 있는 형식 안전 어셈블리여야 하며 비관리 코드를 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-243">SAFE assemblies need to be verifiably type safe and are not allowed to call unmanaged code.</span></span>  
  
 <span data-ttu-id="2d29b-244">UNSAFE는 데이터베이스 관리자만 만들 수 있는 신뢰 수준이 높은 코드용입니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-244">UNSAFE is for highly trusted code that can only be created by database administrators.</span></span> <span data-ttu-id="2d29b-245">이 신뢰되는 코드는 코드 액세스 보안 제한이 없으며 비관리(네이티브) 코드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-245">This trusted code has no code access security restrictions, and it can call unmanaged (native) code.</span></span>  
  
 <span data-ttu-id="2d29b-246">EXTERNAL_ACCESS는 중급 보안 옵션을 제공하며 코드가 데이터베이스 외부의 리소스에 액세스하도록 허용하지만 여전히 SAFE 수준의 안정성과 보안을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-246">EXTERNAL_ACCESS provides an intermediate security option, allowing code to access resources external to the database but still having the reliability guarantees of SAFE.</span></span>  
  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]<span data-ttu-id="2d29b-247">는 호스트 수준의 CAS 정책 계층을 사용하여 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 카탈로그에 저장되어 있는 권한 집합에 기초하여 세 가지 권한 집합 중 하나를 부여하는 호스트 정책을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-247">uses the host-level CAS policy layer to set up a host policy that grants one of the three sets of permissions based on the permission set stored in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] catalogs.</span></span> <span data-ttu-id="2d29b-248">데이터베이스 내부에서 실행되는 관리 코드에는 항상 이러한 코드 액세스 권한 집합 중 하나가 부여됩니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-248">Managed code running inside the database always gets one of these code access permission sets.</span></span>  
  
### <a name="programming-model-restrictions"></a><span data-ttu-id="2d29b-249">프로그래밍 모델 제한 사항</span><span class="sxs-lookup"><span data-stu-id="2d29b-249">Programming Model Restrictions</span></span>  
 <span data-ttu-id="2d29b-250">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]의 관리 코드에 대한 프로그래밍 모델에서는 여러 호출에 걸쳐 유지되는 상태를 사용하거나 여러 사용자 세션에서 상태를 공유할 필요가 없는 함수, 프로시저 및 형식을 작성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-250">The programming model for managed code in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] involves writing functions, procedures, and types which typically do not require the use of state held across multiple invocations or the sharing of state across multiple user sessions.</span></span> <span data-ttu-id="2d29b-251">또한 앞서 설명한 것과 같이 공유된 상태가 있으면 해당 애플리케이션의 확장성과 안정성에 영향을 주는 중대한 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-251">Further, as described earlier, the presence of shared state can cause critical exceptions that impact the scalability and the reliability of the application.</span></span>  
  
 <span data-ttu-id="2d29b-252">이러한 점을 고려하여 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]에서 사용하는 클래스의 정적 변수와 정적 데이터 멤버는 사용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-252">Given these considerations, we discourage the use of static variables and static data members of classes used in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="2d29b-253">SAFE 및 EXTERNAL_ACCESS 어셈블리의 경우 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]에서 CREATE ASSEMBLY 시간에 해당 어셈블리의 메타데이터를 검사하고 정적 데이터 멤버와 변수가 사용된 경우 어셈블리를 만드는 데 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-253">For SAFE and EXTERNAL_ACCESS assemblies, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] examines the metadata of the assembly at CREATE ASSEMBLY time and fails the creation of such assemblies if it finds the use of static data members and variables.</span></span>  
  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]<span data-ttu-id="2d29b-254">에서는 `SharedState`, `Synchronization` 및 `ExternalProcessMgmt` 호스트 보호 특성으로 주석이 지정된 .NET Framework API의 호출을 허용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-254">also disallows calls to .NET Framework APIs that are annotated with the `SharedState`, `Synchronization` and `ExternalProcessMgmt` host protection attributes.</span></span> <span data-ttu-id="2d29b-255">이로 인해 SAFE 및 EXTERNAL_ACCESS 어셈블리에서는 상태를 공유하고, 동기화를 수행하며, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 프로세스의 무결성에 영향을 주는 API를 호출하지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="2d29b-255">This prevents SAFE and EXTERNAL_ACCESS assemblies from calling any APIs that enable sharing state, performing synchronization, and affecting the integrity of the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] process.</span></span> <span data-ttu-id="2d29b-256">자세한 내용은 [CLR 통합 프로그래밍 모델 제한](database-objects/clr-integration-programming-model-restrictions.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2d29b-256">For more information, see [CLR Integration Programming Model Restrictions](database-objects/clr-integration-programming-model-restrictions.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2d29b-257">참고 항목</span><span class="sxs-lookup"><span data-stu-id="2d29b-257">See Also</span></span>  
 <span data-ttu-id="2d29b-258">[CLR 통합 보안](security/clr-integration-security.md) </span><span class="sxs-lookup"><span data-stu-id="2d29b-258">[CLR Integration Security](security/clr-integration-security.md) </span></span>  
 [<span data-ttu-id="2d29b-259">통합된 CLR의 성능</span><span class="sxs-lookup"><span data-stu-id="2d29b-259">Performance of CLR Integration</span></span>](clr-integration-architecture-performance.md)  
  
  
