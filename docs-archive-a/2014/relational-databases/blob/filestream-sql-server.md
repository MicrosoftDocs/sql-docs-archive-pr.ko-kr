---
title: FILESTREAM(SQL Server) | Microsoft 문서
ms.custom: ''
ms.date: 06/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: filestream
ms.topic: conceptual
helpviewer_keywords:
- FILESTREAM [SQL Server]
- FILESTREAM [SQL Server], about
- FILESTREAM [SQL Server], overview
ms.assetid: 9a5a8166-bcbe-4680-916c-26276253eafa
author: MikeRayMSFT
ms.author: mikeray
ms.openlocfilehash: 971f45fd69f381a8997bb2f8f08444f4d9c107c4
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87740071"
---
# <a name="filestream-sql-server"></a><span data-ttu-id="4728d-102">FILESTREAM(SQL Server)</span><span class="sxs-lookup"><span data-stu-id="4728d-102">FILESTREAM (SQL Server)</span></span>
  <span data-ttu-id="4728d-103">FILESTREAM을 사용하면 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]기반 애플리케이션에서 문서 및 이미지와 같은 구조화되지 않은 데이터를 파일 시스템에 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-103">FILESTREAM enables [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]-based applications to store unstructured data, such as documents and images, on the file system.</span></span> <span data-ttu-id="4728d-104">애플리케이션은 풍부한 스트리밍 API 및 파일 시스템의 성능을 활용할 수 있고 동시에 구조화되지 않은 데이터와 해당되는 구조화된 데이터 간에 트랜잭션 일관성을 유지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-104">Applications can leverage the rich streaming APIs and performance of the file system and at the same time maintain transactional consistency between the unstructured data and corresponding structured data.</span></span>  
  
 <span data-ttu-id="4728d-105">FILESTREAM은 `varbinary(max)` BLOB(Binary Large Object) 데이터를 파일 시스템의 파일로 저장하여 [!INCLUDE[ssDEnoversion](../../includes/ssdenoversion-md.md)]을 NTFS 파일 시스템과 통합합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-105">FILESTREAM integrates the [!INCLUDE[ssDEnoversion](../../includes/ssdenoversion-md.md)] with an NTFS file system by storing `varbinary(max)` binary large object (BLOB) data as files on the file system.</span></span> [!INCLUDE[tsql](../../includes/tsql-md.md)] <span data-ttu-id="4728d-106">문은 FILESTREAM 데이터를 삽입, 업데이트, 쿼리, 검색 및 백업할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-106">statements can insert, update, query, search, and back up FILESTREAM data.</span></span> <span data-ttu-id="4728d-107">Win32 파일 시스템 인터페이스에서는 데이터에 대한 스트리밍 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-107">Win32 file system interfaces provide streaming access to the data.</span></span>  
  
 <span data-ttu-id="4728d-108">FILESTREAM은 파일 데이터를 캐시하기 위해 NT 시스템 캐시를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-108">FILESTREAM uses the NT system cache for caching file data.</span></span> <span data-ttu-id="4728d-109">이를 통해 FILESTREAM 데이터가 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 성능에 미치는 영향을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-109">This helps reduce any effect that FILESTREAM data might have on [!INCLUDE[ssDE](../../includes/ssde-md.md)] performance.</span></span> <span data-ttu-id="4728d-110">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 버퍼 풀이 사용되지 않으므로 이 메모리는 쿼리 처리용으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-110">The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] buffer pool is not used; therefore, this memory is available for query processing.</span></span>  
  
 <span data-ttu-id="4728d-111">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]를 설치하거나 업그레이드할 때 FILESTREAM이 자동으로 사용하도록 설정되지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-111">FILESTREAM is not automatically enabled when you install or upgrade [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="4728d-112">SQL Server 구성 관리자 및 [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)]를 사용하여 FILESTREAM을 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-112">You must enable FILESTREAM by using SQL Server Configuration Manager and [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)].</span></span> <span data-ttu-id="4728d-113">FILESTREAM을 사용하려면 특수 파일 그룹 유형을 포함하도록 데이터베이스를 만들거나 수정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-113">To use FILESTREAM, you must create or modify a database to contain a special type of filegroup.</span></span> <span data-ttu-id="4728d-114">그런 다음 FILESTREAM 특성이 있는 `varbinary(max)` 열을 포함하도록 테이블을 만들거나 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-114">Then, create or modify a table so that it contains a `varbinary(max)` column with the FILESTREAM attribute.</span></span> <span data-ttu-id="4728d-115">이러한 태스크를 완료한 후에는 [!INCLUDE[tsql](../../includes/tsql-md.md)] 및 Win32를 사용하여 FILESTREAM 데이터를 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-115">After you complete these tasks, you can use [!INCLUDE[tsql](../../includes/tsql-md.md)] and Win32 to manage the FILESTREAM data.</span></span>  
  
 <span data-ttu-id="4728d-116">FILESTREAM을 설치 및 사용하는 방법은 [관련 태스크](#reltasks)목록을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="4728d-116">For more information about installing and using FILESTREAM, see the list of [Related Tasks](#reltasks).</span></span>  
  
##  <a name="when-to-use-filestream"></a><a name="whentouse"></a><span data-ttu-id="4728d-117">FILESTREAM을 사용 하는 경우</span><span class="sxs-lookup"><span data-stu-id="4728d-117">When to Use FILESTREAM</span></span>  
 <span data-ttu-id="4728d-118">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]에서 BLOB는 테이블에 데이터를 저장하는 표준 `varbinary(max)` 데이터 또는 파일 시스템에 데이터를 저장하는 FILESTREAM `varbinary(max)` 개체가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-118">In [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], BLOBs can be standard `varbinary(max)` data that stores the data in tables, or FILESTREAM `varbinary(max)` objects that store the data in the file system.</span></span> <span data-ttu-id="4728d-119">데이터베이스 스토리지를 사용해야 할지 또는 파일 시스템 스토리지를 사용해야 할지 여부는 데이터의 크기와 사용으로 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-119">The size and use of the data determines whether you should use database storage or file system storage.</span></span> <span data-ttu-id="4728d-120">다음 조건에 해당될 경우 FILESTREAM을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-120">If the following conditions are true, you should consider using FILESTREAM:</span></span>  
  
-   <span data-ttu-id="4728d-121">저장되는 개체가 평균적으로 1MB를 초과할 경우</span><span class="sxs-lookup"><span data-stu-id="4728d-121">Objects that are being stored are, on average, larger than 1 MB.</span></span>  
  
-   <span data-ttu-id="4728d-122">신속한 읽기 액세스가 중요할 경우</span><span class="sxs-lookup"><span data-stu-id="4728d-122">Fast read access is important.</span></span>  
  
-   <span data-ttu-id="4728d-123">중간 계층 애플리케이션 논리를 사용하는 애플리케이션을 개발할 경우</span><span class="sxs-lookup"><span data-stu-id="4728d-123">You are developing applications that use a middle tier for application logic.</span></span>  
  
 <span data-ttu-id="4728d-124">크기가 작은 개체의 경우 데이터베이스에 `varbinary(max)` BLOB를 저장하면 스트리밍 성능이 더 좋아집니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-124">For smaller objects, storing `varbinary(max)` BLOBs in the database often provides better streaming performance.</span></span>  
  
  
##  <a name="filestream-storage"></a><a name="storage"></a><span data-ttu-id="4728d-125">FILESTREAM 저장소</span><span class="sxs-lookup"><span data-stu-id="4728d-125">FILESTREAM Storage</span></span>  
 <span data-ttu-id="4728d-126">FILESTREAM 스토리지는 데이터가 파일 시스템에 BLOB로 저장된 `varbinary(max)` 열로 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-126">FILESTREAM storage is implemented as a `varbinary(max)` column in which the data is stored as BLOBs in the file system.</span></span> <span data-ttu-id="4728d-127">BLOB의 크기는 파일 시스템의 볼륨 크기로만 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-127">The sizes of the BLOBs are limited only by the volume size of the file system.</span></span> <span data-ttu-id="4728d-128">표준 `varbinary(max)` 제한은 2GB의 파일 크기로 파일 시스템에 저장된 BLOB에 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-128">The standard `varbinary(max)` limitation of 2-GB file sizes does not apply to BLOBs that are stored in the file system.</span></span>  
  
 <span data-ttu-id="4728d-129">파일 시스템에 열의 데이터를 저장하도록 지정하려면 `varbinary(max)` 열에 FILESTREAM 특성을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-129">To specify that a column should store data on the file system, specify the FILESTREAM attribute on a `varbinary(max)` column.</span></span> <span data-ttu-id="4728d-130">이렇게 하면 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 에서 해당 열의 모든 데이터를 데이터베이스 파일이 아닌 파일 시스템에 저장하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-130">This causes the [!INCLUDE[ssDE](../../includes/ssde-md.md)] to store all data for that column on the file system, but not in the database file.</span></span>  
  
 <span data-ttu-id="4728d-131">FILESTREAM 데이터는 FILESTREAM 파일 그룹에 저장되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-131">FILESTREAM data must be stored in FILESTREAM filegroups.</span></span> <span data-ttu-id="4728d-132">FILESTREAM 파일 그룹은 파일 자체가 아닌 파일 시스템 디렉터리를 포함하는 특수한 파일 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-132">A FILESTREAM filegroup is a special filegroup that contains file system directories instead of the files themselves.</span></span> <span data-ttu-id="4728d-133">이러한 파일 시스템 디렉터리를 *데이터 컨테이너*라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-133">These file system directories are called *data containers*.</span></span> <span data-ttu-id="4728d-134">데이터 컨테이너는 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 스토리지와 파일 시스템 스토리지 사이의 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-134">Data containers are the interface between [!INCLUDE[ssDE](../../includes/ssde-md.md)] storage and file system storage.</span></span>  
  
 <span data-ttu-id="4728d-135">FILESTREAM 스토리지를 사용할 때 다음 사항을 고려하십시오.</span><span class="sxs-lookup"><span data-stu-id="4728d-135">When you use FILESTREAM storage, consider the following:</span></span>  
  
-   <span data-ttu-id="4728d-136">테이블에 FILESTREAM 열이 있을 경우 각 행에는 Null이 아닌 고유한 행 ID가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-136">When a table contains a FILESTREAM column, each row must have a nonnull unique row ID.</span></span>  
  
-   <span data-ttu-id="4728d-137">FILESTREAM 파일 그룹에는 여러 개의 데이터 컨테이너를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-137">Multiple data containers can be added to a FILESTREAM filegroup.</span></span>  
  
-   <span data-ttu-id="4728d-138">FILESTREAM 데이터 컨테이너는 중첩될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-138">FILESTREAM data containers cannot be nested.</span></span>  
  
-   <span data-ttu-id="4728d-139">장애 조치(failover) 클러스터링을 사용할 경우 FILESTREAM 파일 그룹이 공유 디스크 리소스에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-139">When you are using failover clustering, the FILESTREAM filegroups must be on shared disk resources.</span></span>  
  
-   <span data-ttu-id="4728d-140">FILESTREAM 파일 그룹은 압축된 볼륨에 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-140">FILESTREAM filegroups can be on compressed volumes.</span></span>  
  
### <a name="integrated-management"></a><span data-ttu-id="4728d-141">통합 관리</span><span class="sxs-lookup"><span data-stu-id="4728d-141">Integrated Management</span></span>  
 <span data-ttu-id="4728d-142">FILESTREAM이 `varbinary(max)` 열로 구현되어 [!INCLUDE[ssDE](../../includes/ssde-md.md)]으로 바로 통합되었으므로 대부분의 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 관리 도구 및 기능이 FILESTREAM 데이터를 수정하지 않고 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-142">Because FILESTREAM is implemented as a `varbinary(max)` column and integrated directly into the [!INCLUDE[ssDE](../../includes/ssde-md.md)], most [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] management tools and functions work without modification for FILESTREAM data.</span></span> <span data-ttu-id="4728d-143">예를 들어 FILESTREAM 데이터로 모든 백업 및 복구 모델을 사용할 수 있고 FILESTREAM 데이터는 구조화된 데이터와 함께 데이터베이스에 백업됩니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-143">For example, you can use all backup and recovery models with FILESTREAM data, and the FILESTREAM data is backed up with the structured data in the database.</span></span> <span data-ttu-id="4728d-144">FILESTREAM 데이터를 관계형 데이터와 함께 백업하지 않으려면 부분 백업을 사용하여 FILESTREAM 파일 그룹을 제외할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-144">If you do not want to back up FILESTREAM data with relational data, you can use a partial backup to exclude FILESTREAM filegroups.</span></span>  

  
### <a name="integrated-security"></a><span data-ttu-id="4728d-145">Integrated Security</span><span class="sxs-lookup"><span data-stu-id="4728d-145">Integrated Security</span></span>  
 <span data-ttu-id="4728d-146">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]에서 FILESTREAM 데이터는 다른 데이터와 마찬가지로 테이블 또는 열 수준에서 사용 권한을 부여하여 보안이 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-146">In [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], FILESTREAM data is secured just like other data is secured: by granting permissions at the table or column levels.</span></span> <span data-ttu-id="4728d-147">사용자가 테이블의 FILESTREAM 열에 대한 사용 권한이 있을 경우 이 사용자는 관련 파일을 열 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-147">If a user has permission to the FILESTREAM column in a table, the user can open the associated files.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="4728d-148">암호화는 FILESTREAM 데이터에서 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-148">Encryption is not supported on FILESTREAM data.</span></span>  
  
 <span data-ttu-id="4728d-149">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 서비스 계정을 실행하는 계정에만 FILESTREAM 컨테이너에 대한 NTFS 사용 권한이 부여됩니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-149">Only the account under which the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] service account runs is granted NTFS permissions to the FILESTREAM container.</span></span> <span data-ttu-id="4728d-150">다른 계정에는 데이터 컨테이너에 대한 사용 권한을 부여하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-150">We recommend that no other account be granted permissions on the data container.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="4728d-151">SQL 로그인은 FILESTREAM 컨테이너에서 작동하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-151">SQL logins will not work with FILESTREAM containers.</span></span> <span data-ttu-id="4728d-152">NTFS 인증만 FILESTREAM 컨테이너에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-152">Only NTFS authentication will work with FILESTREAM containers.</span></span>  
  
##  <a name="accessing-blob-data-with-transact-sql-and-file-system-streaming-access"></a><a name="dual"></a> <span data-ttu-id="4728d-153">TRANSACT-SQL 및 파일 시스템 스트리밍 액세스를 사용하여 BLOB 데이터 액세스</span><span class="sxs-lookup"><span data-stu-id="4728d-153">Accessing BLOB Data with Transact-SQL and File System Streaming Access</span></span>  
 <span data-ttu-id="4728d-154">FILESTREAM 열에 데이터를 저장한 후 [!INCLUDE[tsql](../../includes/tsql-md.md)] 트랜잭션 또는 Win32 API를 사용하여 해당 파일에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-154">After you store data in a FILESTREAM column, you can access the files by using [!INCLUDE[tsql](../../includes/tsql-md.md)] transactions or by using Win32 APIs.</span></span>  
  
### <a name="transact-sql-access"></a><span data-ttu-id="4728d-155">Transact-SQL 액세스</span><span class="sxs-lookup"><span data-stu-id="4728d-155">Transact-SQL Access</span></span>  
 <span data-ttu-id="4728d-156">[!INCLUDE[tsql](../../includes/tsql-md.md)]을 사용하여 FILESTREAM 데이터를 삽입, 업데이트 및 삭제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-156">By using [!INCLUDE[tsql](../../includes/tsql-md.md)], you can insert, update, and delete FILESTREAM data:</span></span>  
  
-   <span data-ttu-id="4728d-157">삽입 작업을 통해 FILESTREAM 필드를 Null 값, 비어 있는 값 또는 상대적으로 짧은 인라인 데이터로 미리 채울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-157">You can use an insert operation to prepopulate a FILESTREAM field with a null value, empty value, or relatively short inline data.</span></span> <span data-ttu-id="4728d-158">그러나 크기가 큰 데이터는 Win32 인터페이스를 사용하는 파일로 좀 더 효율적으로 스트리밍됩니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-158">However, a large amount of data is more efficiently streamed into a file that uses Win32 interfaces.</span></span>  
  
-   <span data-ttu-id="4728d-159">FILESTREAM 필드를 업데이트할 때 파일 시스템의 기본 BLOB 데이터를 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-159">When you update a FILESTREAM field, you modify the underlying BLOB data in the file system.</span></span> <span data-ttu-id="4728d-160">FILESTREAM 필드를 NULL로 설정하면 이 필드와 연결된 BLOB 데이터가 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-160">When a FILESTREAM field is set to NULL, the BLOB data associated with the field is deleted.</span></span> <span data-ttu-id="4728d-161">데이터의 부분 업데이트를 수행하기 위해 UPDATE [!INCLUDE[tsql](../../includes/tsql-md.md)] .**Write()로 구현된**청크 업데이트를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-161">You cannot use a [!INCLUDE[tsql](../../includes/tsql-md.md)] chunked update, implemented as UPDATE **.** Write(), to perform partial updates to the data.</span></span>  
  
-   <span data-ttu-id="4728d-162">행을 삭제하거나 FILESTREAM 데이터가 들어 있는 테이블을 삭제하거나 잘라내면 파일 시스템의 기본 BLOB 데이터가 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-162">When you delete a row or delete or truncate a table that contains FILESTREAM data, you delete the underlying BLOB data in the file system.</span></span>  
  
### <a name="file-system-streaming-access"></a><span data-ttu-id="4728d-163">파일 시스템 스트리밍 액세스</span><span class="sxs-lookup"><span data-stu-id="4728d-163">File System Streaming Access</span></span>  
 <span data-ttu-id="4728d-164">Win32 스트리밍은 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 트랜잭션 컨텍스트의 작업을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-164">The Win32 streaming support works in the context of a [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] transaction.</span></span> <span data-ttu-id="4728d-165">트랜잭션 내에서 FILESTREAM 기능을 사용하여 파일의 논리 UNC 파일 시스템 경로를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-165">Within a transaction, you can use FILESTREAM functions to obtain a logical UNC file system path of a file.</span></span> <span data-ttu-id="4728d-166">그런 다음 OpenSqlFilestream API를 사용하여 파일 핸들을 얻습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-166">You then use the OpenSqlFilestream API to obtain a file handle.</span></span> <span data-ttu-id="4728d-167">이 핸들은 파일 시스템의 방식에 따라 파일에 액세스하여 업데이트하기 위해 ReadFile() 및 WriteFile() 같은 Win32 파일 스트리밍 인터페이스에서 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-167">This handle can then be used by Win32 file streaming interfaces, such as ReadFile() and WriteFile(), to access and update the file by way of the file system.</span></span>  
  
 <span data-ttu-id="4728d-168">파일 작업이 트랜잭션이므로 파일 시스템을 통해 FILESTREAM 파일을 삭제하거나 이 파일의 이름을 바꿀 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-168">Because file operations are transactional, you cannot delete or rename FILESTREAM files through the file system.</span></span>  
  
 <span data-ttu-id="4728d-169">**문 모델**</span><span class="sxs-lookup"><span data-stu-id="4728d-169">**Statement Model**</span></span>  
  
 <span data-ttu-id="4728d-170">FILESTREAM 파일 시스템 액세스는 파일 열기 및 닫기를 통해 [!INCLUDE[tsql](../../includes/tsql-md.md)] 문을 모델로 합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-170">The FILESTREAM file system access models a [!INCLUDE[tsql](../../includes/tsql-md.md)] statement by using file open and close.</span></span> <span data-ttu-id="4728d-171">파일 핸들이 열릴 때 문이 시작되고 파일 핸들이 닫힐 때 문이 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-171">The statement starts when a file handle is opened and ends when the handle is closed.</span></span> <span data-ttu-id="4728d-172">예를 들어 쓰기 핸들이 닫히면 UPDATE 문이 완료된 경우와 같이 테이블에 등록된 가능한 모든 AFTER 트리거가 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-172">For example, when a write handle is closed, any possible AFTER trigger that is registered on the table fires as if an UPDATE statement is completed.</span></span>  
  
 <span data-ttu-id="4728d-173">**스토리지 네임스페이스**</span><span class="sxs-lookup"><span data-stu-id="4728d-173">**Storage Namespace**</span></span>  
  
 <span data-ttu-id="4728d-174">FILESTREAM에서 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 은 BLOB 물리적 파일 시스템 네임스페이스를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-174">In FILESTREAM, the [!INCLUDE[ssDE](../../includes/ssde-md.md)] controls the BLOB physical file system namespace.</span></span> <span data-ttu-id="4728d-175">새 내장 함수인 [PathName](/sql/relational-databases/system-functions/pathname-transact-sql)에서는 테이블의 각 FILESTREAM 셀에 해당하는 BLOB의 논리 UNC 경로를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-175">A new intrinsic function, [PathName](/sql/relational-databases/system-functions/pathname-transact-sql), provides the logical UNC path of the BLOB that corresponds to each FILESTREAM cell in the table.</span></span> <span data-ttu-id="4728d-176">애플리케이션에서는 이 논리 경로를 사용하여 Win32 핸들을 얻고 일반적인 Win32 파일 시스템 인터페이스를 사용하여 BLOB 데이터에 대한 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-176">The application uses this logical path to obtain the Win32 handle and operate on the BLOB data by using regular Win32 file system interfaces.</span></span> <span data-ttu-id="4728d-177">FILESTREAM 열의 값이 NULL인 경우 함수는 NULL을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-177">The function returns NULL if the value of the FILESTREAM column is NULL.</span></span>  
  
 <span data-ttu-id="4728d-178">**트랜잭션된 파일 시스템 액세스**</span><span class="sxs-lookup"><span data-stu-id="4728d-178">**Transacted File System Access**</span></span>  
  
 <span data-ttu-id="4728d-179">새 내장 함수인 [GET_FILESTREAM_TRANSACTION_CONTEXT()](/sql/t-sql/functions/get-filestream-transaction-context-transact-sql)에서는 세션에 연결된 현재 트랜잭션을 나타내는 토큰을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-179">A new intrinsic function, [GET_FILESTREAM_TRANSACTION_CONTEXT()](/sql/t-sql/functions/get-filestream-transaction-context-transact-sql), provides the token that represents the current transaction that the session is associated with.</span></span> <span data-ttu-id="4728d-180">트랜잭션이 시작되었지만 아직 중단되거나 커밋되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-180">The transaction must have been started and not yet aborted or committed.</span></span> <span data-ttu-id="4728d-181">토큰을 가져와서 애플리케이션은 FILESTREAM 파일 시스템 스트리밍 작업을 시작된 트랜잭션과 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-181">By obtaining a token, the application binds the FILESTREAM file system streaming operations with a started transaction.</span></span> <span data-ttu-id="4728d-182">명시적으로 시작된 트랜잭션이 없을 경우에는 함수는 NULL을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-182">The function returns NULL in case of no explicitly started transaction.</span></span>  
  
 <span data-ttu-id="4728d-183">트랜잭션이 커밋되거나 중단되기 전에는 모든 파일 핸들이 닫혀 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-183">All file handles must be closed before the transaction commits or aborts.</span></span> <span data-ttu-id="4728d-184">핸들이 트랜잭션 범위 이상으로 열려 있으면 핸들에 대한 추가 읽기가 실패하고 이 핸들에 대한 추가 쓰기는 성공하지만 실제 데이터가 디스크에 작성되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-184">If a handle is left open beyond the transaction scope, additional reads against the handle will cause a failure; additional writes against the handle will succeed, but the actual data will not be written to disk.</span></span> <span data-ttu-id="4728d-185">비슷하게 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 의 데이터베이스나 인스턴스가 종료되면 열려 있는 모든 핸들이 무효화됩니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-185">Similarly, if the database or instance of the [!INCLUDE[ssDE](../../includes/ssde-md.md)] shuts down, all open handles are invalidated.</span></span>  
  
 <span data-ttu-id="4728d-186">**트랜잭션 내구성**</span><span class="sxs-lookup"><span data-stu-id="4728d-186">**Transactional Durability**</span></span>  
  
 <span data-ttu-id="4728d-187">트랜잭션 커밋에 FILESTREAM을 사용하면 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 에서는 파일 시스템 스트리밍 액세스에서 수정된 FILESTREAM BLOB 데이터에 트랜잭션 유지 기능을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-187">With FILESTREAM, upon transaction commit, the [!INCLUDE[ssDE](../../includes/ssde-md.md)] ensures transaction durability for FILESTREAM BLOB data that is modified from the file system streaming access.</span></span>  
  
 <span data-ttu-id="4728d-188">**격리 의미 체계**</span><span class="sxs-lookup"><span data-stu-id="4728d-188">**Isolation Semantics**</span></span>  
  
 <span data-ttu-id="4728d-189">격리 의미 체계는 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 트랜잭션 격리 수준에 따라 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-189">The isolation semantics are governed by [!INCLUDE[ssDE](../../includes/ssde-md.md)] transaction isolation levels.</span></span> <span data-ttu-id="4728d-190">[!INCLUDE[tsql](../../includes/tsql-md.md)] 및 파일 시스템 액세스에는 커밋된 읽기 격리 수준이 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-190">Read-committed isolation level is supported for [!INCLUDE[tsql](../../includes/tsql-md.md)] and file system access.</span></span> <span data-ttu-id="4728d-191">반복 읽기 작업과 직렬화 가능 및 스냅샷 격리도 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-191">Repeatable read operations, and also serializable and snapshot isolations, are supported.</span></span> <span data-ttu-id="4728d-192">커밋되지 않은 읽기는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-192">Dirty read is not supported.</span></span>  
  
 <span data-ttu-id="4728d-193">파일 시스템 액세스 열기 작업은 잠금을 기다리지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-193">The file system access open operations do not wait for any locks.</span></span> <span data-ttu-id="4728d-194">대신 트랜잭션 격리로 인해 데이터에 액세스할 수 없을 경우 즉시 열기 작업에 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-194">Instead, the open operations fail immediately if they cannot access the data because of transaction isolation.</span></span> <span data-ttu-id="4728d-195">격리 위반으로 인해 열기 작업을 계속 진행할 수 없을 경우 ERROR_SHARING_VIOLATION이 발생하며 스트리밍 API 호출에 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-195">The streaming API calls fail with ERROR_SHARING_VIOLATION if the open operation cannot continue because of isolation violation.</span></span>  
  
 <span data-ttu-id="4728d-196">부분 업데이트가 수행되도록 허용하려면 애플리케이션이 디바이스 FS 컨트롤(FSCTL_SQL_FILESTREAM_FETCH_OLD_CONTENT)을 실행하여 이전 내용을 열려 있는 핸들이 참조하는 파일로 인출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-196">To allow for partial updates to be made, the application can issue a device FS control (FSCTL_SQL_FILESTREAM_FETCH_OLD_CONTENT) to fetch the old content into the file that the opened handle references.</span></span> <span data-ttu-id="4728d-197">이 작업으로 인해 서버 쪽의 오래된 내용 복사가 트리거됩니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-197">This will trigger a server-side old content copy.</span></span> <span data-ttu-id="4728d-198">애플리케이션 성능을 더 향상시키고 큰 파일로 작업 시 제한 시간이 초과되는 것을 방지하려면 비동기 I/O를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-198">For better application performance and to avoid running into potential time-outs when you are working with very large files, we recommend that you use asynchronous I/O.</span></span>  
  
 <span data-ttu-id="4728d-199">핸들이 작성된 후 FSCTL이 실행되면 마지막 쓰기 작업이 유지되고 핸들에 기록된 이전의 쓰기 작업은 손실됩니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-199">If the FSCTL is issued after the handle has been written to, the last write operation will persist, and prior writes that were made to the handle are lost.</span></span>  
  
 <span data-ttu-id="4728d-200">**파일 시스템 API 및 지원되는 격리 수준**</span><span class="sxs-lookup"><span data-stu-id="4728d-200">**File System APIs and Supported Isolation Levels**</span></span>  
  
 <span data-ttu-id="4728d-201">격리 위반으로 인해 파일 시스템 API에서 파일을 열 수 없는 경우 ERROR_SHARING_VIOLATION 예외가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-201">When a file system API cannot open a file because of an isolation violation, an ERROR_SHARING_VIOLATION exception is returned.</span></span> <span data-ttu-id="4728d-202">두 트랜잭션에서 동일한 파일에 액세스를 시도하면 이 격리 위반이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-202">This isolation violation occurs when two transactions try to access the same file.</span></span> <span data-ttu-id="4728d-203">액세스 작업의 결과는 파일이 열릴 때의 모드와 트랜잭션이 실행되고 있는 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 의 버전에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-203">The outcome of the access operation depends on the mode the file was opened in and the version of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] that the transaction is running on.</span></span> <span data-ttu-id="4728d-204">다음 표에서는 두 트랜잭션에서 동일한 파일에 액세스할 때 발생할 수 있는 결과를 간략하게 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-204">The following table outlines the possibly outcomes for two transactions that are accessing the same file.</span></span>  
  
|<span data-ttu-id="4728d-205">트랜잭션 1</span><span class="sxs-lookup"><span data-stu-id="4728d-205">Transaction 1</span></span>|<span data-ttu-id="4728d-206">트랜잭션 2</span><span class="sxs-lookup"><span data-stu-id="4728d-206">Transaction 2</span></span>|<span data-ttu-id="4728d-207">SQL Server 2008에서의 결과</span><span class="sxs-lookup"><span data-stu-id="4728d-207">Outcome on SQL Server 2008</span></span>|<span data-ttu-id="4728d-208">SQL Server 2008 R2 이상에서의 결과</span><span class="sxs-lookup"><span data-stu-id="4728d-208">Outcome on SQL Server 2008 R2 and later versions</span></span>|  
|-------------------|-------------------|--------------------------------|------------------------------------------------------|  
|<span data-ttu-id="4728d-209">읽기를 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-209">Open for read.</span></span>|<span data-ttu-id="4728d-210">읽기를 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-210">Open for read.</span></span>|<span data-ttu-id="4728d-211">모두 성공</span><span class="sxs-lookup"><span data-stu-id="4728d-211">Both succeed.</span></span>|<span data-ttu-id="4728d-212">모두 성공</span><span class="sxs-lookup"><span data-stu-id="4728d-212">Both succeed.</span></span>|  
|<span data-ttu-id="4728d-213">읽기를 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-213">Open for read.</span></span>|<span data-ttu-id="4728d-214">쓰기를 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-214">Open for write.</span></span>|<span data-ttu-id="4728d-215">모두 성공</span><span class="sxs-lookup"><span data-stu-id="4728d-215">Both succeed.</span></span> <span data-ttu-id="4728d-216">트랜잭션 2에서 수행되는 쓰기 작업이 트랜잭션 1에서 수행되는 읽기 작업에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-216">Write operations under transaction 2 do not affect read operations performed in transaction 1.</span></span>|<span data-ttu-id="4728d-217">모두 성공</span><span class="sxs-lookup"><span data-stu-id="4728d-217">Both succeed.</span></span> <span data-ttu-id="4728d-218">트랜잭션 2에서 수행되는 쓰기 작업이 트랜잭션 1에서 수행되는 읽기 작업에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-218">Write operations under transaction 2 do not affect read operations performed in transaction 1.</span></span>|  
|<span data-ttu-id="4728d-219">쓰기를 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-219">Open for write.</span></span>|<span data-ttu-id="4728d-220">읽기를 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-220">Open for read.</span></span>|<span data-ttu-id="4728d-221">트랜잭션 2의 열기 작업이 실패하고 ERROR_SHARING_VIOLATION 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-221">Open for transaction 2 fails with an ERROR_SHARING_VIOLATION exception.</span></span>|<span data-ttu-id="4728d-222">모두 성공</span><span class="sxs-lookup"><span data-stu-id="4728d-222">Both succeed.</span></span>|  
|<span data-ttu-id="4728d-223">쓰기를 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-223">Open for write.</span></span>|<span data-ttu-id="4728d-224">쓰기를 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-224">Open for write.</span></span>|<span data-ttu-id="4728d-225">트랜잭션 2의 열기 작업이 실패하고 ERROR_SHARING_VIOLATION 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-225">Open for transaction 2 fails with an ERROR_SHARING_VIOLATION exception.</span></span>|<span data-ttu-id="4728d-226">트랜잭션 2의 열기 작업이 실패하고 ERROR_SHARING_VIOLATION 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-226">Open for transaction 2 fails with an ERROR_SHARING_VIOLATION exception.</span></span>|  
|<span data-ttu-id="4728d-227">읽기를 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-227">Open for read.</span></span>|<span data-ttu-id="4728d-228">선택을 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-228">Open for SELECT.</span></span>|<span data-ttu-id="4728d-229">모두 성공</span><span class="sxs-lookup"><span data-stu-id="4728d-229">Both succeed.</span></span>|<span data-ttu-id="4728d-230">모두 성공</span><span class="sxs-lookup"><span data-stu-id="4728d-230">Both succeed.</span></span>|  
|<span data-ttu-id="4728d-231">읽기를 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-231">Open for read.</span></span>|<span data-ttu-id="4728d-232">업데이트 또는 삭제를 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-232">Open for UPDATE or DELETE.</span></span>|<span data-ttu-id="4728d-233">모두 성공</span><span class="sxs-lookup"><span data-stu-id="4728d-233">Both succeed.</span></span> <span data-ttu-id="4728d-234">트랜잭션 2에서 수행되는 쓰기 작업이 트랜잭션 1에서 수행되는 읽기 작업에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-234">Write operations under transaction 2 do not affect read operations performed in transaction 1.</span></span>|<span data-ttu-id="4728d-235">모두 성공</span><span class="sxs-lookup"><span data-stu-id="4728d-235">Both succeed.</span></span> <span data-ttu-id="4728d-236">트랜잭션 2에서 수행되는 쓰기 작업이 트랜잭션 1에서 수행되는 읽기 작업에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-236">Write operations under transaction 2 do not affect read operations performed in transaction 1.</span></span>|  
|<span data-ttu-id="4728d-237">쓰기를 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-237">Open for write.</span></span>|<span data-ttu-id="4728d-238">선택을 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-238">open for SELECT.</span></span>|<span data-ttu-id="4728d-239">트랜잭션 1이 트랜잭션을 커밋 또는 종료하거나 트랜잭션 잠금 시간이 초과될 때까지 트랜잭션 2가 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-239">Transaction 2 blocks until transaction 1 commits or ends the transaction, or the transaction lock times out.</span></span>|<span data-ttu-id="4728d-240">모두 성공</span><span class="sxs-lookup"><span data-stu-id="4728d-240">Both succeed.</span></span>|  
|<span data-ttu-id="4728d-241">쓰기를 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-241">Open for write.</span></span>|<span data-ttu-id="4728d-242">업데이트 또는 삭제를 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-242">Open for UPDATE or DELETE.</span></span>|<span data-ttu-id="4728d-243">트랜잭션 1이 트랜잭션을 커밋 또는 종료하거나 트랜잭션 잠금 시간이 초과될 때까지 트랜잭션 2가 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-243">Transaction 2 blocks until transaction 1 commits or ends the transaction, or the transaction lock times out.</span></span>|<span data-ttu-id="4728d-244">트랜잭션 1이 트랜잭션을 커밋 또는 종료하거나 트랜잭션 잠금 시간이 초과될 때까지 트랜잭션 2가 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-244">Transaction 2 blocks until transaction 1 commits or ends the transaction, or the transaction lock times out.</span></span>|  
|<span data-ttu-id="4728d-245">선택을 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-245">Open for SELECT.</span></span>|<span data-ttu-id="4728d-246">읽기를 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-246">Open for read.</span></span>|<span data-ttu-id="4728d-247">모두 성공</span><span class="sxs-lookup"><span data-stu-id="4728d-247">Both succeed.</span></span>|<span data-ttu-id="4728d-248">모두 성공</span><span class="sxs-lookup"><span data-stu-id="4728d-248">Both succeed.</span></span>|  
|<span data-ttu-id="4728d-249">선택을 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-249">Open for SELECT.</span></span>|<span data-ttu-id="4728d-250">쓰기를 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-250">Open for write.</span></span>|<span data-ttu-id="4728d-251">모두 성공</span><span class="sxs-lookup"><span data-stu-id="4728d-251">Both succeed.</span></span> <span data-ttu-id="4728d-252">트랜잭션 2의 쓰기 작업이 트랜잭션 1에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-252">Write operations under transaction 2 do not affect transaction 1.</span></span>|<span data-ttu-id="4728d-253">모두 성공</span><span class="sxs-lookup"><span data-stu-id="4728d-253">Both succeed.</span></span> <span data-ttu-id="4728d-254">트랜잭션 2의 쓰기 작업이 트랜잭션 1에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-254">Write operations under transaction 2 do not affect transaction 1.</span></span>|  
|<span data-ttu-id="4728d-255">업데이트 또는 삭제를 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-255">Open for UPDATE or DELETE.</span></span>|<span data-ttu-id="4728d-256">읽기를 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-256">Open for read.</span></span>|<span data-ttu-id="4728d-257">트랜잭션 2의 열기 작업이 실패하고 ERROR_SHARING_VIOLATION 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-257">The open operation on transaction 2 fails with an ERROR_SHARING_VIOLATION exception.</span></span>|<span data-ttu-id="4728d-258">모두 성공</span><span class="sxs-lookup"><span data-stu-id="4728d-258">Both succeed.</span></span>|  
|<span data-ttu-id="4728d-259">업데이트 또는 삭제를 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-259">Open for UPDATE or DELETE.</span></span>|<span data-ttu-id="4728d-260">쓰기를 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-260">Open for write.</span></span>|<span data-ttu-id="4728d-261">트랜잭션 2의 열기 작업이 실패하고 ERROR_SHARING_VIOLATION 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-261">The open operation on transaction 2 fails with an ERROR_SHARING_VIOLATION exception.</span></span>|<span data-ttu-id="4728d-262">트랜잭션 2의 열기 작업이 실패하고 ERROR_SHARING_VIOLATION 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-262">The open operation on transaction 2 fails with an ERROR_SHARING_VIOLATION exception.</span></span>|  
|<span data-ttu-id="4728d-263">선택을 위해 열기(반복 읽기 사용)</span><span class="sxs-lookup"><span data-stu-id="4728d-263">Open for SELECT with repeatable read.</span></span>|<span data-ttu-id="4728d-264">읽기를 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-264">Open for read.</span></span>|<span data-ttu-id="4728d-265">모두 성공</span><span class="sxs-lookup"><span data-stu-id="4728d-265">Both succeed.</span></span>|<span data-ttu-id="4728d-266">모두 성공</span><span class="sxs-lookup"><span data-stu-id="4728d-266">Both succeed.</span></span>|  
|<span data-ttu-id="4728d-267">선택을 위해 열기(반복 읽기 사용)</span><span class="sxs-lookup"><span data-stu-id="4728d-267">Open for SELECT with repeatable read.</span></span>|<span data-ttu-id="4728d-268">쓰기를 위해 열기</span><span class="sxs-lookup"><span data-stu-id="4728d-268">Open for write.</span></span>|<span data-ttu-id="4728d-269">트랜잭션 2의 열기 작업이 실패하고 ERROR_SHARING_VIOLATION 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-269">The open operation on transaction 2 fails with an ERROR_SHARING_VIOLATION exception.</span></span>|<span data-ttu-id="4728d-270">트랜잭션 2의 열기 작업이 실패하고 ERROR_SHARING_VIOLATION 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-270">The open operation on transaction 2 fails with an ERROR_SHARING_VIOLATION exception.</span></span>|  
  
 <span data-ttu-id="4728d-271">**원격 클라이언트를 통한 쓰기**</span><span class="sxs-lookup"><span data-stu-id="4728d-271">**Write-Through from Remote Clients**</span></span>  
  
 <span data-ttu-id="4728d-272">FILESTREAM 데이터에 대한 원격 파일 시스템 액세스는 SMB(서버 메시지 블록) 프로토콜을 통해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-272">Remote file system access to FILESTREAM data is enabled over the Server Message Block (SMB) protocol.</span></span> <span data-ttu-id="4728d-273">클라이언트가 원격일 경우 클라이언트 쪽에서 캐시하는 쓰기 작업이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-273">If the client is remote, no write operations are cached by the client side.</span></span> <span data-ttu-id="4728d-274">쓰기 작업은 항상 서버로 전송되고,</span><span class="sxs-lookup"><span data-stu-id="4728d-274">The write operations will always be sent to the server.</span></span> <span data-ttu-id="4728d-275">데이터는 서버 쪽에서 캐시합니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-275">The data can be cached on the server side.</span></span> <span data-ttu-id="4728d-276">원격 클라이언트에서 실행 중인 애플리케이션은 작은 쓰기 작업을 통합하여 더 큰 크기의 데이터를 사용하는 쓰기 작업이 적어집니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-276">We recommend that applications that are running on remote clients consolidate small write operations to make fewer write operations using larger data size.</span></span>  
  
 <span data-ttu-id="4728d-277">FILESTREAM 핸들을 사용하여 메모리 매핑된 뷰(메모리 매핑된 I/O)를 만들 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-277">Creating memory mapped views (memory mapped I/O) by using a FILESTREAM handle is not supported.</span></span> <span data-ttu-id="4728d-278">메모리 매핑을 FILESTREAM 데이터에 사용할 경우 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 은 데이터의 일관성과 지속성 또는 데이터베이스의 무결성을 보장할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4728d-278">If memory mapping is used for FILESTREAM data, the [!INCLUDE[ssDE](../../includes/ssde-md.md)] cannot guarantee consistency and durability of the data or the integrity of the database.</span></span>  
  
##  <a name="related-tasks"></a><a name="reltasks"></a> <span data-ttu-id="4728d-279">관련 작업</span><span class="sxs-lookup"><span data-stu-id="4728d-279">Related Tasks</span></span>  
 [<span data-ttu-id="4728d-280">Enable and Configure FILESTREAM</span><span class="sxs-lookup"><span data-stu-id="4728d-280">Enable and Configure FILESTREAM</span></span>](enable-and-configure-filestream.md)  
  [<span data-ttu-id="4728d-281">FILESTREAM 사용 데이터베이스 만들기</span><span class="sxs-lookup"><span data-stu-id="4728d-281">Create a FILESTREAM-Enabled Database</span></span>](create-a-filestream-enabled-database.md)  
  [<span data-ttu-id="4728d-282">FILESTREAM 데이터 저장용 테이블 만들기</span><span class="sxs-lookup"><span data-stu-id="4728d-282">Create a Table for Storing FILESTREAM Data</span></span>](create-a-table-for-storing-filestream-data.md)  
  [<span data-ttu-id="4728d-283">Transact-SQL을 사용하여 FILESTREAM 데이터 액세스</span><span class="sxs-lookup"><span data-stu-id="4728d-283">Access FILESTREAM Data with Transact-SQL</span></span>](access-filestream-data-with-transact-sql.md)  
  [<span data-ttu-id="4728d-284">FILESTREAM 데이터용 클라이언트 애플리케이션 만들기</span><span class="sxs-lookup"><span data-stu-id="4728d-284">Create Client Applications for FILESTREAM Data</span></span>](create-client-applications-for-filestream-data.md)  
  [<span data-ttu-id="4728d-285">OpenSqlFilestream을 사용하여 FILESTREAM 데이터 액세스</span><span class="sxs-lookup"><span data-stu-id="4728d-285">Access FILESTREAM Data with OpenSqlFilestream</span></span>](access-filestream-data-with-opensqlfilestream.md)  
  [<span data-ttu-id="4728d-286">FILESTREAM 데이터 부분 업데이트</span><span class="sxs-lookup"><span data-stu-id="4728d-286">Make Partial Updates to FILESTREAM Data</span></span>](make-partial-updates-to-filestream-data.md)  
  [<span data-ttu-id="4728d-287">FILESTREAM 애플리케이션에서 데이터베이스 작업과의 충돌 방지</span><span class="sxs-lookup"><span data-stu-id="4728d-287">Avoid Conflicts with Database Operations in FILESTREAM Applications</span></span>](avoid-conflicts-with-database-operations-in-filestream-applications.md)  
  [<span data-ttu-id="4728d-288">FILESTREAM 사용 데이터베이스 이동</span><span class="sxs-lookup"><span data-stu-id="4728d-288">Move a FILESTREAM-Enabled Database</span></span>](move-a-filestream-enabled-database.md)  
  [<span data-ttu-id="4728d-289">장애 조치(Failover) 클러스터에서 FILESTREAM 설정</span><span class="sxs-lookup"><span data-stu-id="4728d-289">Set Up FILESTREAM on a Failover Cluster</span></span>](set-up-filestream-on-a-failover-cluster.md)  
  [<span data-ttu-id="4728d-290">FILESTREAM 액세스를 위한 방화벽 구성</span><span class="sxs-lookup"><span data-stu-id="4728d-290">Configure a Firewall for FILESTREAM Access</span></span>](configure-a-firewall-for-filestream-access.md)  
  
##  <a name="related-content"></a><a name="relcontent"></a> <span data-ttu-id="4728d-291">관련 내용</span><span class="sxs-lookup"><span data-stu-id="4728d-291">Related Content</span></span>  
 [<span data-ttu-id="4728d-292">FILESTREAM과 기타 SQL Server 기능 간 호환성</span><span class="sxs-lookup"><span data-stu-id="4728d-292">FILESTREAM Compatibility with Other SQL Server Features</span></span>](filestream-compatibility-with-other-sql-server-features.md)  
  
