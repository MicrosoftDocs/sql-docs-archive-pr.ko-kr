---
title: 실행 계획 논리 및 물리 연산자 참조 | Microsoft 문서
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
f1_keywords:
- sql12.swb.showplan.nestedloops.f1
- sql12.swb.showplan.dynamic.f1
- sql12.swb.showplan.tableinsert.f1
- sql12.swb.showplan.remoteinsert.f1
- sql12.swb.showplan.lazyspool.f1
- sql12.swb.showplan.RIDLookup
- sql12.swb.showplan.hashmatchteam.f1
- sql12.swb.showplan.tablespool.f1
- sql12.swb.showplan.print.f1
- sql12.swb.showplan.clusteredindexupdate.f1
- sql12.swb.showplan.assert.f1
- sql12.swb.showplan.columnstoreindexscan.f1
- sql12.swb.showplan.tablevaluedfunction.f1
- sql12.swb.showplan.split.f1
- sql12.swb.showplan.union.f1
- sql12.swb.showplan.clusteredindexseek.f1
- sql12.swb.showplan.indexspool.f1
- sql12.swb.showplan.indexinsert.f1
- sql12.swb.showplan.clusteredindexscan.f1
- sql12.swb.showplan.buildhash.f1
- sql12.swb.showplan.clusteredindexmerge.f1
- sql12.swb.showplan.sequence.f1
- sql12.swb.showplan.hashmatchroot.f1
- sql12.swb.showplan.columnstoreindexupdate.f1
- sql12.swb.showplan.rightsemijoin.f1
- sql12.swb.showplan.fetchquery.f1
- sql12.swb.showplan.distinct.f1
- sql12.swb.showplan.hashmatch.f1
- sql12.swb.showplan.segment.f1
- sql12.swb.showplan.top.f1
- sql12.swb.showplan.columnstoreindexdelete.f1
- sql12.swb.showplan.gatherstreams.f1
- sql12.swb.showplan.remotedelete.f1
- sql12.swb.showplan.insert.f1
- sql12.swb.showplan.declare.f1
- sql12.swb.showplan.snapshot.f1
- sql12.swb.showplan.assign.f1
- sql12.swb.showplan.intrinsic.f1
- sql12.swb.showplan.mergejoin.f1
- sql12.swb.showplan.concatenation.f1
- sql12.swb.showplan.rowcountspool.f1
- sql12.swb.showplan.parametertablescan.f1
- sql12.swb.showplan.indexscan.f1
- sql12.swb.showplan.while.f1
- sql12.swb.showplan.columnstoreindexinsert.f1
- sql12.swb.showplan.tablemerge.f1
- sql12.swb.showplan.spool.f1
- sql12.swb.showplan.streamaggregate.f1
- sql12.swb.showplan.update.f1
- sql12.swb.showplan.innerjoin.f1
- sql12.swb.showplan.flowdistinct.f1
- sql12.swb.showplan.tableupdate.f1
- sql12.swb.showplan.result.f1
- sql12.swb.showplan.bitmap.f1
- sql12.swb.showplan.remoteindexseek.f1
- sql12.swb.showplan.populationquery.f1
- sql12.swb.showplan.rightouterjoin.f1
- sql12.swb.showplan.columnstoreindexmerge.f1
- sql12.swb.showplan.remotescan.f1
- sql12.swb.showplan.remoteupdate.f1
- sql12.swb.showplan.keyset.f1
- sql12.swb.showplan.collapse.f1
- sql12.swb.showplan.arithmeticexpression.f1
- sql12.swb.showplan.clusteredindexinsert.f1
- sql12.swb.showplan.computescalar
- sql12.swb.showplan.sort.f1
- sql12.swb.showplan.locate.f1
- sql12.swb.showplan.constantscan.f1
- sql12.swb.showplan.computescalar.f1
- sql12.swb.showplan.indexseek.f1
- sql12.swb.showplan.leftsemijoin.f1
- sql12.swb.showplan.leftantisemijoin.f1
- sql12.swb.showplan.fullouterjoin.f1
- sql12.swb.showplan.filter.f1
- sql12.swb.showplan.indexdelete.f1
- sql12.swb.showplan.repartitionstreams.f1
- sql12.swb.showplan.crossjoin.f1
- sql12.swb.showplan.mergeinterval.f1
- sql12.swb.showplan.bookmarklookup.f1
- sql12.swb.showplan.convert.f1
- sql12.swb.showplan.refreshquery.f1
- sql12.swb.showplan.distinctsort.f1
- sql12.swb.showplan.leftouterjoin.f1
- sql12.swb.showplan.rightantisemijoin.f1
- sql12.swb.showplan.deletedscan.f1
- sql12.swb.showplan.udx.f1
- sql12.swb.showplan.broadcast.f1
- sql12.swb.showplan.delete.f1
- sql12.swb.showplan.aggregate.f1
- sql12.swb.showplan.setfunction.f1
- sql12.swb.showplan.switch.f1
- sql12.swb.showplan.remoteindexscan.f1
- sql12.swb.showplan.eagerspool.f1
- sql12.swb.showplan.indexupdate.f1
- sql12.swb.showplan.keylookup.f1
- sql12.swb.showplan.branchrepartition.f1
- sql12.swb.showplan.rank.f1
- sql12.swb.showplan.tablescan.f1
- sql12.swb.showplan.distributestreams.f1
- sql12.swb.showplan.logrowscan.f1
- sql12.swb.showplan.parallelism.f1
- sql12.swb.showplan.bitmapcreate.f1
- sql12.swb.showplan.insertedscan.f1
- sql12.swb.showplan.tabledelete.f1
- sql12.swb.showplan.clusteredindexdelete.f1
- sql12.swb.showplan.remotequery.f1
- sql12.swb.showplan.if.f1
- sql12.swb.showplan.cache.f1
- sql12.swb.showplan.partialaggregate.f1
- sql12.swb.showplan.sql.f1
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
author: rothja
ms.author: jroth
ms.openlocfilehash: bc45a5fa14785294093385e6f90b47a8bdb6dff3
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87733768"
---
# <a name="showplan-logical-and-physical-operators-reference"></a><span data-ttu-id="69bb6-102">실행 계획 논리 및 물리 연산자 참조</span><span class="sxs-lookup"><span data-stu-id="69bb6-102">Showplan Logical and Physical Operators Reference</span></span>
  <span data-ttu-id="69bb6-103">연산자는 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 에서 쿼리 또는 DML(데이터 조작 언어) 문이 실행되는 방식을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-103">Operators describe how [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] executes a query or a Data Manipulation Language (DML) statement.</span></span> <span data-ttu-id="69bb6-104">쿼리 최적화 프로그램은 연산자를 사용하여 쿼리 계획을 작성함으로써 쿼리에 지정된 결과를 만들거나 DML 문에 지정된 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-104">The query optimizer uses operators to build a query plan to create the result specified in the query, or to perform the operation specified in the DML statement.</span></span> <span data-ttu-id="69bb6-105">쿼리 계획은 물리 연산자로 구성된 트리입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-105">The query plan is a tree consisting of physical operators.</span></span> <span data-ttu-id="69bb6-106">SET SHOWPLAN 문, [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]의 그래픽 실행 계획 옵션 또는 SQL Server Profiler의 Showplan 이벤트 클래스를 사용하여 쿼리 계획을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-106">You can view the query plan by using the SET SHOWPLAN statements, the graphical execution plan options in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], or the SQL Server Profiler Showplan event classes.</span></span>  
  
 <span data-ttu-id="69bb6-107">연산자는 논리 연산자와 물리 연산자로 분류됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-107">Operators are classified as logical and physical operators.</span></span>  
  
 <span data-ttu-id="69bb6-108">**논리 연산자**</span><span class="sxs-lookup"><span data-stu-id="69bb6-108">**Logical Operators**</span></span>  
 <span data-ttu-id="69bb6-109">논리 연산자는 문을 처리할 때 사용되는 관계형 대수 연산을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-109">Logical operators describe the relational algebraic operation used to process a statement.</span></span> <span data-ttu-id="69bb6-110">즉, 논리 연산자는 어떤 작업을 수행해야 하는지 개념적으로 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-110">In other words, logical operators describe conceptually what operation needs to be performed.</span></span>  
  
 <span data-ttu-id="69bb6-111">**물리 연산자**</span><span class="sxs-lookup"><span data-stu-id="69bb6-111">**Physical Operators**</span></span>  
 <span data-ttu-id="69bb6-112">물리 연산자는 논리 연산자가 설명한 작업을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-112">Physical operators implement the operation described by logical operators.</span></span> <span data-ttu-id="69bb6-113">각 물리 연산자는 연산을 수행하는 개체 또는 루틴입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-113">Each physical operator is an object or routine that performs an operation.</span></span> <span data-ttu-id="69bb6-114">예를 들어 일부 물리 연산자는 테이블, 인덱스 또는 뷰에서 열이나 행에 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-114">For example, some physical operators access columns or rows from a table, index or view.</span></span> <span data-ttu-id="69bb6-115">다른 물리 연산자는 계산, 집계, 데이터 무결성 검사 또는 조인 같은 다른 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-115">Other physical operators perform other operations such as calculations, aggregations, data integrity checks or joins.</span></span> <span data-ttu-id="69bb6-116">물리 연산자는 비용과 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-116">Physical operators have costs associated with them.</span></span>  
  
 <span data-ttu-id="69bb6-117">물리 연산자는 초기화하고 데이터를 수집하며 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-117">The physical operators initialize, collect data, and close.</span></span> <span data-ttu-id="69bb6-118">특히 물리 연산자는 다음 3개의 메서드 호출에 응답할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-118">Specifically, the physical operator can answer the following three method calls:</span></span>  
  
-   <span data-ttu-id="69bb6-119">**Init()** : **Init()** 메서드는 물리 연산자가 초기화하고 필요한 데이터 구조를 설정하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-119">**Init()**: The **Init()** method causes a physical operator to initialize itself and set up any required data structures.</span></span> <span data-ttu-id="69bb6-120">일반적으로 물리 연산자는 하나의 **Init()** 호출을 받지만 여러 개의 호출을 받을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-120">The physical operator may receive many **Init()** calls, though typically a physical operator receives only one.</span></span>  
  
-   <span data-ttu-id="69bb6-121">**GetNext()** : **GetNext()** 메서드는 물리 연산자가 처음 또는 다음 데이터 행을 가져오도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-121">**GetNext()**: The **GetNext()** method causes a physical operator to get the first, or subsequent row of data.</span></span> <span data-ttu-id="69bb6-122">물리 연산자는 **GetNext()** 호출을 받지 않을 수도 있고 여러 개의 호출을 받을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-122">The physical operator may receive zero or many **GetNext()** calls.</span></span>  
  
-   <span data-ttu-id="69bb6-123">**Close()** : **Close()** 메서드는 물리 연산자가 정리 작업을 수행하고 종료하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-123">**Close()**: The **Close()** method causes a physical operator to perform some clean-up operations and shut itself down.</span></span> <span data-ttu-id="69bb6-124">물리 연산자는 하나의 **Close()** 호출만 받습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-124">A physical operator only receives one **Close()** call.</span></span>  
  
 <span data-ttu-id="69bb6-125">**GetNext()** 메서드는 하나의 데이터 행을 반환하며 호출 횟수는 SET STATISTICS PROFILE ON 또는 SET STATISTICS XML ON을 사용하여 생성된 실행 계획 출력에 **ActualRows**로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-125">The **GetNext()** method returns one row of data, and the number of times it is called appears as **ActualRows** in the Showplan output that is produced by using SET STATISTICS PROFILE ON or SET STATISTICS XML ON.</span></span> <span data-ttu-id="69bb6-126">이러한 SET 옵션에 대한 자세한 내용은 [SET STATISTICS PROFILE&#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-profile-transact-sql) 및 [SET STATISTICS XML&#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-xml-transact-sql)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="69bb6-126">For more information about these SET options, see [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-profile-transact-sql) and [SET STATISTICS XML &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-xml-transact-sql).</span></span>  
  
 <span data-ttu-id="69bb6-127">실행 계획 출력에 나타나는 **ActualRebinds** 및 **ActualRewinds** 개수는 **Init()** 메서드가 호출된 횟수를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-127">The **ActualRebinds** and **ActualRewinds** counts that appear in Showplan output refer to the number of times that the **Init()** method is called.</span></span> <span data-ttu-id="69bb6-128">연산자가 루프 조인의 내부 측면에 있지 않으면 **ActualRebinds** 는 1이고 **ActualRewinds** 는 0입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-128">Unless an operator is on the inner side of a loop join, **ActualRebinds** equals one and **ActualRewinds** equals zero.</span></span> <span data-ttu-id="69bb6-129">연산자가 루프 조인의 내부 측면에 있으면 다시 바인딩 횟수와 되감기 횟수의 합계가 조인 외부 측면에서 처리된 행 수와 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-129">If an operator is on the inner side of a loop join, the sum of the number of rebinds and rewinds should equal the number of rows processed on the outer side of the join.</span></span> <span data-ttu-id="69bb6-130">다시 바인딩은 조인의 상호 관련된 매개 변수가 하나 이상 변경되었으며 내부 측면을 다시 평가해야 함을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-130">A rebind means that one or more of the correlated parameters of the join changed and the inner side must be reevaluated.</span></span> <span data-ttu-id="69bb6-131">되감기는 상호 관련된 매개 변수가 변경되지 않았으며 이전 내부 결과 집합을 다시 사용할 수 있음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-131">A rewind means that none of the correlated parameters changed and the prior inner result set may be reused.</span></span>  
  
 <span data-ttu-id="69bb6-132">**ActualRebinds** 및 **ActualRewinds** 는 SET STATISTICS XML ON을 사용하여 생성된 XML 실행 계획 출력에 표시되며</span><span class="sxs-lookup"><span data-stu-id="69bb6-132">**ActualRebinds** and **ActualRewinds** are present in XML Showplan output produced by using SET STATISTICS XML ON.</span></span> <span data-ttu-id="69bb6-133">**비클러스터형 인덱스 spool**, `Remote Query` , **Row Count spool**, `Sort` **table Spool**및 **테이블 반환 함수** 연산자에 대해서만 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-133">They are only populated for the **Nonclustered Index Spool**, `Remote Query`, **Row Count Spool**, `Sort`, **Table Spool**, and **Table-valued Function** operators.</span></span> <span data-ttu-id="69bb6-134">**ActualRebinds** **ActualRewinds** `Assert` **Startupexpression** 특성이 TRUE로 설정 된 경우 및 **필터** 연산자에 대해서도 ActualRebinds 및 ActualRewinds가 채워질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-134">**ActualRebinds** and **ActualRewinds** may also be populated for the `Assert` and **Filter** operators when the **StartupExpression** attribute is set to TRUE.</span></span>  
  
 <span data-ttu-id="69bb6-135">**ActualRebinds** 와 **ActualRewinds** 가 XML 실행 계획에 있을 경우 **EstimateRebinds** 및 **EstimateRewinds**와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-135">When **ActualRebinds** and **ActualRewinds** are present in an XML Showplan, they are comparable to **EstimateRebinds** and **EstimateRewinds**.</span></span> <span data-ttu-id="69bb6-136">두 값이 없으면 예상 행 수(**EstimateRows**)가 실제 행 수(**ActualRows**)와 같으며</span><span class="sxs-lookup"><span data-stu-id="69bb6-136">When they are absent, the estimated number of rows (**EstimateRows**) is comparable to the actual number of rows (**ActualRows**).</span></span> <span data-ttu-id="69bb6-137">실제 그래픽 실행 계획 출력에 실제 다시 바인딩 횟수와 실제 되감기 횟수가 모두 0으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-137">Note that actual graphical Showplan output displays zeros for the actual rebinds and actual rewinds when they are absent.</span></span>  
  
 <span data-ttu-id="69bb6-138">관련 카운터인 **ActualEndOfScans**는 SET STATISTICS XML ON을 사용하여 실행 계획 출력이 생성된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-138">A related counter, **ActualEndOfScans**, is available only when Showplan output is produced by using SET STATISTICS XML ON.</span></span> <span data-ttu-id="69bb6-139">이 카운터는 물리 연산자가 데이터 스트림의 끝에 도달할 때마다 1씩 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-139">Whenever a physical operator reaches the end of its data stream, this counter is incremented by one.</span></span> <span data-ttu-id="69bb6-140">물리 연산자는 데이터 스트림의 끝에 도달하지 않거나 1회 이상 여러 번 도달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-140">A physical operator can reach the end of its data stream zero, one, or multiple times.</span></span> <span data-ttu-id="69bb6-141">다시 바인딩 및 되감기와 마찬가지로 검색 끝 수도 연산자가 루프 조인의 내부 측면에 있는 경우에만 둘 이상이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-141">As with rebinds and rewinds, the number of end of scans can be more than one only if the operator is on the inner side of a loop join.</span></span> <span data-ttu-id="69bb6-142">검색 끝 수는 다시 바인딩 횟수와 되감기 횟수의 합계보다 작거나 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-142">The number of end of scans should be less than or equal to the sum of the number of rebinds and rewinds.</span></span>  
  
## <a name="mapping-physical-and-logical-operators"></a><span data-ttu-id="69bb6-143">물리 및 논리 연산자 매핑</span><span class="sxs-lookup"><span data-stu-id="69bb6-143">Mapping Physical and Logical Operators</span></span>  
 <span data-ttu-id="69bb6-144">쿼리 최적화 프로그램은 쿼리 계획을 논리 연산자로 이루어진 트리로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-144">The query optimizer creates a query plan as a tree consisting of logical operators.</span></span> <span data-ttu-id="69bb6-145">쿼리 최적화 프로그램은 쿼리 계획을 만든 다음 각 논리 연산자에 대해 가장 효율적인 물리 연산자를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-145">After the query optimizer creates the plan, the query optimizer chooses the most efficient physical operator for each logical operator.</span></span> <span data-ttu-id="69bb6-146">쿼리 최적화 프로그램은 비용에 기반을 둔 방법을 사용하여 논리 연산자를 구현할 물리 연산자를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-146">The query optimizer uses a cost-based approach to determine which physical operator will implement a logical operator.</span></span>  
  
 <span data-ttu-id="69bb6-147">일반적으로 여러 물리 연산자가 하나의 논리 연산자를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-147">Usually, a logical operation can be implemented by multiple physical operators.</span></span> <span data-ttu-id="69bb6-148">그러나 간혹 하나의 물리 연산자가 여러 논리 연산자를 구현하는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-148">However, in rare cases, a physical operator can implement multiple logical operations as well.</span></span>  
  
## <a name="operator-descriptions"></a><span data-ttu-id="69bb6-149">연산자 설명</span><span class="sxs-lookup"><span data-stu-id="69bb6-149">Operator Descriptions</span></span>  
 <span data-ttu-id="69bb6-150">이 섹션에서는 논리 및 물리 연산자에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-150">This section contains descriptions of the logical and physical operators.</span></span>  
  
|<span data-ttu-id="69bb6-151">그래픽 실행 계획 아이콘</span><span class="sxs-lookup"><span data-stu-id="69bb6-151">Graphical Execution Plan Icon</span></span>|<span data-ttu-id="69bb6-152">실행 계획 연산자</span><span class="sxs-lookup"><span data-stu-id="69bb6-152">Showplan Operator</span></span>|<span data-ttu-id="69bb6-153">Description</span><span class="sxs-lookup"><span data-stu-id="69bb6-153">Description</span></span>|  
|-----------------------------------|-----------------------|-----------------|  
|<span data-ttu-id="69bb6-154">없음</span><span class="sxs-lookup"><span data-stu-id="69bb6-154">None</span></span>|`Aggregate`|<span data-ttu-id="69bb6-155">`Aggregate` 연산자는 MIN, MAX, SUM, COUNT 또는 AVG를 포함하는 식을 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-155">The `Aggregate` operator calculates an expression containing MIN, MAX, SUM, COUNT or AVG.</span></span> <span data-ttu-id="69bb6-156">`Aggregate` 연산자는 논리 또는 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-156">The `Aggregate` operator can be a logical operator or a physical operator.</span></span>|  
|<span data-ttu-id="69bb6-157">![Arithmetic Expression 연산자 아이콘](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "Arithmetic Expression 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-157">![Arithmetic expression operator icon](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "Arithmetic expression operator icon")</span></span>|`Arithmetic Expression`|<span data-ttu-id="69bb6-158">`Arithmetic Expression` 연산자는 한 행의 기존 값에서 새 값을 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-158">The `Arithmetic Expression` operator computes a new value from existing values in a row.</span></span> <span data-ttu-id="69bb6-159">[!INCLUDE[ssCurrent](../includes/sscurrent-md.md)]에서는 `Arithmetic Expression`이 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-159">`Arithmetic Expression` is not used in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span>|  
|<span data-ttu-id="69bb6-160">![Assert 연산자 아이콘](../../2014/database-engine/media/assert-32x.gif "Assert 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-160">![Assert operator icon](../../2014/database-engine/media/assert-32x.gif "Assert operator icon")</span></span>|`Assert`|<span data-ttu-id="69bb6-161">`Assert` 연산자는 조건을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-161">The `Assert` operator verifies a condition.</span></span> <span data-ttu-id="69bb6-162">예를 들어 참조 무결성을 확인하거나 스칼라 하위 쿼리에서 한 개의 행을 반환하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-162">For example, it validates referential integrity or ensures that a scalar subquery returns one row.</span></span> <span data-ttu-id="69bb6-163">연산자는 각 입력 행에 대해 `Assert` `Argument` 실행 계획의 열에 있는 식을 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-163">For each input row, the `Assert` operator evaluates the expression in the `Argument` column of the execution plan.</span></span> <span data-ttu-id="69bb6-164">이 식이 NULL이면 `Assert` 연산자를 통해 행이 전달되고 쿼리 실행을 계속합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-164">If this expression evaluates to NULL, the row is passed through the `Assert` operator and the query execution continues.</span></span> <span data-ttu-id="69bb6-165">이 식이 NULL이 아니면 해당 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-165">If this expression evaluates to a nonnull value, the appropriate error will be raised.</span></span> <span data-ttu-id="69bb6-166">`Assert` 연산자는 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-166">The `Assert` operator is a physical operator.</span></span>|  
|<span data-ttu-id="69bb6-167">![Assign 언어 요소 아이콘](../../2014/database-engine/media/assign-32.gif "Assign 언어 요소 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-167">![Assign language element icon](../../2014/database-engine/media/assign-32.gif "Assign language element icon")</span></span>|`Assign`|<span data-ttu-id="69bb6-168">`Assign` 연산자는 식 값 또는 상수 값을 변수에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-168">The `Assign` operator assigns the value of an expression or a constant to a variable.</span></span> <span data-ttu-id="69bb6-169">`Assign`는 언어 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-169">`Assign` is a language element.</span></span>|  
|<span data-ttu-id="69bb6-170">없음</span><span class="sxs-lookup"><span data-stu-id="69bb6-170">None</span></span>|`Asnyc Concat`|<span data-ttu-id="69bb6-171">`Asnyc Concat` 연산자는 원격 쿼리(분산 쿼리)에서만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-171">The `Asnyc Concat` operator is used only in remote queries (distributed queries).</span></span> <span data-ttu-id="69bb6-172">Asnyc Concat은 부모 노드 하나와 *n* 개의 자식 노드를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-172">It has *n* children and one parent node.</span></span> <span data-ttu-id="69bb6-173">일반적으로 일부 자식 노드는 분산 쿼리에 참여하는 원격 컴퓨터에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-173">Usually, some of the children are remote computers that participate in a distributed query.</span></span> <span data-ttu-id="69bb6-174">`Asnyc Concat`은 모든 자식에게 동시에 `open()` 호출을 수행한 다음 각 자식에게 비트맵을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-174">`Asnyc Concat` issues `open()` calls to all of the children simultaneously and then applies a bitmap to each child.</span></span> <span data-ttu-id="69bb6-175">값이 1인 각 비트에 대해 `Async Concat`은 요청 시 출력 행을 부모 노드로 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-175">For each bit that is a 1, `Async Concat` sends the output rows to the parent node on demand.</span></span>|  
|<span data-ttu-id="69bb6-176">![Bitmap 연산자 아이콘](../../2014/database-engine/media/bitmap-32x.gif "Bitmap 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-176">![Bitmap operator icon](../../2014/database-engine/media/bitmap-32x.gif "Bitmap operator icon")</span></span>|`Bitmap`|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]<span data-ttu-id="69bb6-177">연산자를 사용 하 여 `Bitmap` 병렬 쿼리 계획에 비트맵 필터링을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-177">uses the `Bitmap` operator to implement bitmap filtering in parallel query plans.</span></span> <span data-ttu-id="69bb6-178">비트맵 필터링은 연산자와 같은 다른 연산자를 통해 행을 전달 하기 전에 조인 레코드를 생성할 수 없는 키 값이 있는 행을 제거 하 여 쿼리 실행 속도를 향상 시킵니다 `Parallelism` .</span><span class="sxs-lookup"><span data-stu-id="69bb6-178">Bitmap filtering speeds up query execution by eliminating rows with key values that cannot produce any join records before passing rows through another operator such as the `Parallelism` operator.</span></span> <span data-ttu-id="69bb6-179">비트맵 필터는 연산자 트리의 한 부분에 있는 테이블의 값 집합에 대한 압축된 표현을 사용하여 트리의 다른 부분에 있는 다른 테이블에서 행을 필터링합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-179">A bitmap filter uses a compact representation of a set of values from a table in one part of the operator tree to filter rows from a second table in another part of the tree.</span></span> <span data-ttu-id="69bb6-180">쿼리 초기 단계에서 필요 없는 행을 제거하면 이후 연산자에서 작업할 행 수가 더 적어지고 쿼리의 전체적인 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-180">By removing unnecessary rows early in the query, subsequent operators have fewer rows to work with, and the overall performance of the query improves.</span></span> <span data-ttu-id="69bb6-181">최적화 프로그램은 비트맵이 유용할 만큼 충분히 선택 가능성이 높아지는 시점과 필터를 적용할 연산자를 판단합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-181">The optimizer determines when a bitmap is selective enough to be useful and in which operators to apply the filter.</span></span> <span data-ttu-id="69bb6-182">`Bitmap`는 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-182">`Bitmap` is a physical operator.</span></span>|  
|<span data-ttu-id="69bb6-183">![Bitmap 연산자 아이콘](../../2014/database-engine/media/bitmap-32x.gif "Bitmap 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-183">![Bitmap operator icon](../../2014/database-engine/media/bitmap-32x.gif "Bitmap operator icon")</span></span>|`Bitmap Create`|<span data-ttu-id="69bb6-184">`Bitmap Create` 연산자는 비트맵이 작성된 실행 계획 출력에 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-184">The `Bitmap Create` operator appears in the Showplan output where bitmaps are built.</span></span> <span data-ttu-id="69bb6-185">`Bitmap Create`는 논리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-185">`Bitmap Create` is a logical operator.</span></span>|  
|<span data-ttu-id="69bb6-186">![Bookmark lookup 연산자 아이콘](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark lookup 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-186">![Bookmark lookup operator icon](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark lookup operator icon")</span></span>|`Bookmark Lookup`|<span data-ttu-id="69bb6-187">`Bookmark Lookup` 연산자는 책갈피(행 ID 또는 클러스터링 키)를 사용하여 테이블이나 클러스터형 인덱스에서 해당 행을 조회합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-187">The `Bookmark Lookup` operator uses a bookmark (row ID or clustering key) to look up the corresponding row in the table or clustered index.</span></span> <span data-ttu-id="69bb6-188">열에는 `Argument` 테이블이 나 클러스터형 인덱스에서 행을 조회 하는 데 사용 되는 책갈피 레이블이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-188">The `Argument` column contains the bookmark label used to look up the row in the table or clustered index.</span></span> <span data-ttu-id="69bb6-189">열에는 `Argument` 행을 조회 하는 테이블 또는 클러스터형 인덱스의 이름도 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-189">The `Argument` column also contains the name of the table or clustered index in which the row is looked up.</span></span> <span data-ttu-id="69bb6-190">열에 WITH 프리페치 절이 표시 되는 경우 `Argument` 쿼리 프로세서는 테이블이 나 클러스터형 인덱스에서 책갈피를 조회할 때 비동기 프리페치 (미리 읽기)를 사용 하는 것이 최적 임을 확인 했습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-190">If the WITH PREFETCH clause appears in the `Argument` column, the query processor has determined that it is optimal to use asynchronous prefetching (read-ahead) when looking up bookmarks in the table or clustered index.</span></span><br /><br /> <span data-ttu-id="69bb6-191">[!INCLUDE[ssCurrent](../includes/sscurrent-md.md)]에서는 `Bookmark Lookup`이 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-191">`Bookmark Lookup` is not used in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span> <span data-ttu-id="69bb6-192">대신 `Clustered Index Seek` 및 `RID Lookup`이 책갈피 조회 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-192">Instead, `Clustered Index Seek` and `RID Lookup` provide bookmark lookup functionality.</span></span> <span data-ttu-id="69bb6-193">`Key Lookup` 연산자도 이 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-193">The `Key Lookup` operator also provides this functionality.</span></span>|  
|<span data-ttu-id="69bb6-194">없음</span><span class="sxs-lookup"><span data-stu-id="69bb6-194">None</span></span>|`Branch Repartition`|<span data-ttu-id="69bb6-195">병렬 쿼리 계획에는 반복자라는 개념 영역이 존재하기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-195">In a parallel query plan, sometimes there are conceptual regions of iterators.</span></span> <span data-ttu-id="69bb6-196">이 영역에 있는 모든 반복자는 병렬 스레드에 의해 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-196">All of the iterators within such a region can be executed by parallel threads.</span></span> <span data-ttu-id="69bb6-197">영역 자체는 직렬로 실행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-197">The regions themselves must be executed serially.</span></span> <span data-ttu-id="69bb6-198">개별 영역 내에 있는 일부 `Parallelism` 반복자를 `Branch Repartition`이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-198">Some of the `Parallelism` iterators within an individual region are called `Branch Repartition`.</span></span> <span data-ttu-id="69bb6-199">이러한 두 영역의 경계에 있는 `Parallelism` 반복자를 `Segment Repartition`이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-199">The `Parallelism` iterator at the boundary of two such regions is called `Segment Repartition`.</span></span> <span data-ttu-id="69bb6-200">`Branch Repartition`과 `Segment Repartition`은 논리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-200">`Branch Repartition` and `Segment Repartition` are logical operators.</span></span>|  
|<span data-ttu-id="69bb6-201">없음</span><span class="sxs-lookup"><span data-stu-id="69bb6-201">None</span></span>|`Broadcast`|<span data-ttu-id="69bb6-202">`Broadcast`자식 노드 하 나와 부모 노드 *n* 개를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-202">`Broadcast` has one child node and *n* parent nodes.</span></span> <span data-ttu-id="69bb6-203">`Broadcast`는 요청 시 여러 소비자에게 입력 행을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-203">`Broadcast` sends its input rows to multiple consumers on demand.</span></span> <span data-ttu-id="69bb6-204">각 소비자는 모든 행을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-204">Each consumer gets all of the rows.</span></span> <span data-ttu-id="69bb6-205">예를 들어 모든 소비자가 해시 조인의 양쪽에 생성되면 *n* 개의 해시 테이블 복사본이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-205">For example, if all of the consumers are build sides of a hash join, then *n* copies of the hash tables will be built.</span></span>|  
|<span data-ttu-id="69bb6-206">![Build hash 연산자 아이콘](../../2014/database-engine/media/build-hash.gif "Build hash 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-206">![Build hash operator icon](../../2014/database-engine/media/build-hash.gif "Build hash operator icon")</span></span>|`Build Hash`|<span data-ttu-id="69bb6-207">xVelocity 메모리 최적화 columnstore 인덱스에 대한 일괄 해시 테이블의 빌드를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-207">Indicates the build of a batch hash table for an xVelocity memory optimized columnstore index.</span></span>|  
|<span data-ttu-id="69bb6-208">None</span><span class="sxs-lookup"><span data-stu-id="69bb6-208">None</span></span>|`Cache`|<span data-ttu-id="69bb6-209">`Cache`는 **스풀** 연산자의 특수 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-209">`Cache` is a specialized version of the **Spool** operator.</span></span> <span data-ttu-id="69bb6-210">이 연산자는 한 행의 데이터만 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-210">It stores only one row of data.</span></span> <span data-ttu-id="69bb6-211">`Cache`는 논리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-211">`Cache` is a logical operator.</span></span> <span data-ttu-id="69bb6-212">[!INCLUDE[ssCurrent](../includes/sscurrent-md.md)]에서는 `Cache`이 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-212">`Cache` is not used in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span>|  
|<span data-ttu-id="69bb6-213">![Clustered Index Delete 연산자 아이콘](../../2014/database-engine/media/clustered-index-delete-32x.gif "Clustered Index Delete 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-213">![Clustered index delete operator icon](../../2014/database-engine/media/clustered-index-delete-32x.gif "Clustered index delete operator icon")</span></span>|`Clustered Index Delete`|<span data-ttu-id="69bb6-214">`Clustered Index Delete` 연산자는 쿼리 실행 계획의 Argument 열에 지정된 클러스터형 인덱스에서 행을 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-214">The `Clustered Index Delete` operator deletes rows from the clustered index specified in the Argument column of the query execution plan.</span></span> <span data-ttu-id="69bb6-215">WHERE:() 조건자가 Argument 열에 있으면 조건자에 부합되는 행만 삭제됩니다.`Clustered Index Delete`</span><span class="sxs-lookup"><span data-stu-id="69bb6-215">If a WHERE:() predicate is present in the Argument column, then only those rows that satisfy the predicate are deleted.`Clustered Index Delete`</span></span> <span data-ttu-id="69bb6-216">는 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-216">is a physical operator.</span></span>|  
|<span data-ttu-id="69bb6-217">![Clustered Index Insert 연산자 아이콘](../../2014/database-engine/media/clustered-index-insert-32x.gif "Clustered Index Insert 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-217">![Clustered index insert operator icon](../../2014/database-engine/media/clustered-index-insert-32x.gif "Clustered index insert operator icon")</span></span>|`Clustered Index Insert`|<span data-ttu-id="69bb6-218">`Clustered Index Insert` 실행 계획 연산자는 해당 입력의 행을 Argument 열에 지정된 클러스터형 인덱스에 삽입합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-218">The `Clustered Index Insert` Showplan operator inserts rows from its input into the clustered index specified in the Argument column.</span></span> <span data-ttu-id="69bb6-219">Argument 열에는 각 열의 설정 값을 나타내는 SET:() 조건자도 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-219">The Argument column also contains a SET:() predicate, which indicates the value to which each column is set.</span></span> <span data-ttu-id="69bb6-220">에 `Clustered Index Insert` 삽입 값에 대 한 자식이 없는 경우 삽입 된 행은 `Insert` 연산자 자체에서 가져옵니다.`Clustered Index Insert`</span><span class="sxs-lookup"><span data-stu-id="69bb6-220">If `Clustered Index Insert` has no children for insert values, the row inserted is taken from the `Insert` operator itself.`Clustered Index Insert`</span></span> <span data-ttu-id="69bb6-221">는 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-221">is a physical operator.</span></span>|  
|<span data-ttu-id="69bb6-222">![Clustered Index Merge 연산자](../../2014/database-engine/media/clustered-index-merge-32x.gif "Clustered Index Merge 연산자")</span><span class="sxs-lookup"><span data-stu-id="69bb6-222">![Clustered index merge operator](../../2014/database-engine/media/clustered-index-merge-32x.gif "Clustered index merge operator")</span></span>|<span data-ttu-id="69bb6-223">**Clustered Index Merge**</span><span class="sxs-lookup"><span data-stu-id="69bb6-223">**Clustered Index Merge**</span></span>|<span data-ttu-id="69bb6-224">**Clustered Index Merge** 연산자는 병합 데이터 스트림을 클러스터형 인덱스에 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-224">The **Clustered Index Merge** operator applies a merge data stream to a clustered index.</span></span> <span data-ttu-id="69bb6-225">연산자는 연산자의 열에 지정 된 클러스터형 인덱스에서 행을 삭제, 업데이트 또는 삽입 합니다 `Argument` .</span><span class="sxs-lookup"><span data-stu-id="69bb6-225">The operator deletes, updates, or inserts rows from the clustered index specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="69bb6-226">수행 되는 실제 작업은 연산자의 열에 지정 된 **작업** 열의 런타임 값에 따라 달라 집니다 `Argument` .</span><span class="sxs-lookup"><span data-stu-id="69bb6-226">The actual operation performed depends on the runtime value of the **ACTION** column specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="69bb6-227">**Clustered Index Merge** 는 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-227">**Clustered Index Merge** is a physical operator.</span></span>|  
|<span data-ttu-id="69bb6-228">![Clustered Index Scan 연산자 아이콘](../../2014/database-engine/media/clustered-index-scan-32x.gif "Clustered Index Scan 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-228">![Clustered index scan operator icon](../../2014/database-engine/media/clustered-index-scan-32x.gif "Clustered index scan operator icon")</span></span>|`Clustered Index Scan`|<span data-ttu-id="69bb6-229">`Clustered Index Scan` 연산자는 쿼리 실행 계획의 Argument 열에 지정된 클러스터형 인덱스를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-229">The `Clustered Index Scan` operator scans the clustered index specified in the Argument column of the query execution plan.</span></span> <span data-ttu-id="69bb6-230">선택 사항인 WHERE:() 조건자가 있는 경우에는 조건자에 부합되는 행만 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-230">When an optional WHERE:() predicate is present, only those rows that satisfy the predicate are returned.</span></span> <span data-ttu-id="69bb6-231">Argument 열에 ORDERED 절이 있으면 쿼리 프로세서가 행의 출력이 클러스터형 인덱스에 의해 정렬되는 순서로 반환되도록 요청한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-231">If the Argument column contains the ORDERED clause, the query processor has requested that the output of the rows be returned in the order in which the clustered index has sorted it.</span></span> <span data-ttu-id="69bb6-232">ORDERED 절이 없으면 스토리지 엔진은 출력을 정렬하지 않고 최적의 방법으로 인덱스를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-232">If the ORDERED clause is not present, the storage engine scans the index in the optimal way, without necessarily sorting the output.</span></span> <span data-ttu-id="69bb6-233">`Clustered Index Scan`은 논리 및 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-233">`Clustered Index Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-234">![Clustered Index Seek 연산자 아이콘](../../2014/database-engine/media/clustered-index-seek-32x.gif "Clustered Index Seek 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-234">![Clustered index seek operator icon](../../2014/database-engine/media/clustered-index-seek-32x.gif "Clustered index seek operator icon")</span></span>|`Clustered Index Seek`|<span data-ttu-id="69bb6-235">`Clustered Index Seek` 연산자는 인덱스 검색 기능을 사용하여 클러스터형 인덱스에서 행을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-235">The `Clustered Index Seek` operator uses the seeking ability of indexes to retrieve rows from a clustered index.</span></span> <span data-ttu-id="69bb6-236">`Argument`열에는 사용 되는 클러스터형 인덱스의 이름과 SEEK: () 조건자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-236">The `Argument` column contains the name of the clustered index being used and the SEEK:() predicate.</span></span> <span data-ttu-id="69bb6-237">스토리지 엔진은 이 인덱스를 사용하여 SEEK:() 조건자에 부합되는 행만 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-237">The storage engine uses the index to process only those rows that satisfy this SEEK:() predicate.</span></span> <span data-ttu-id="69bb6-238">또한 스토리지 엔진은 SEEK:() 조건자에 부합되는 행에 대해서만 평가를 수행하는 WHERE:() 조건자를 포함할 수 있지만 이는 선택적이며 이 작업을 완료하는 데는 인덱스를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-238">It can also include a WHERE:() predicate where the storage engine evaluates against all rows that satisfy the SEEK:() predicate, but this is optional and does not use indexes to complete this process.</span></span><br /><br /> <span data-ttu-id="69bb6-239">열에 `Argument` 정렬 된 절이 포함 되어 있는 경우 쿼리 프로세서는 클러스터형 인덱스가 정렬 한 순서 대로 행을 반환 해야 한다고 결정 했습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-239">If the `Argument` column contains the ORDERED clause, the query processor has determined that the rows must be returned in the order in which the clustered index has sorted them.</span></span> <span data-ttu-id="69bb6-240">ORDERED 절이 없으면 스토리지 엔진은 출력을 정렬하지 않고 최적의 방법으로 인덱스를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-240">If the ORDERED clause is not present, the storage engine searches the index in the optimal way, without necessarily sorting the output.</span></span> <span data-ttu-id="69bb6-241">출력 순서를 유지하는 것보다 정렬하지 않고 출력하는 것이 더 효율적일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-241">Allowing the output to retain its ordering can be less efficient than producing nonsorted output.</span></span> <span data-ttu-id="69bb6-242">키워드 LOOKUP을 사용하면 책갈피 조회가 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-242">When the keyword LOOKUP appears, then a bookmark lookup is being performed.</span></span> <span data-ttu-id="69bb6-243">[!INCLUDE[ssKatmai](../includes/sskatmai-md.md)]이상 버전에서 `Key Lookup` 연산자는 책갈피 조회 기능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-243">In [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] and later versions, the `Key Lookup` operator provides bookmark lookup functionality.</span></span> <span data-ttu-id="69bb6-244">`Clustered Index Seek`은 논리 및 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-244">`Clustered Index Seek` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-245">![Clustered Index Update 연산자 아이콘](../../2014/database-engine/media/clustered-index-update-32x.gif "Clustered Index Update 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-245">![Clustered index update operator icon](../../2014/database-engine/media/clustered-index-update-32x.gif "Clustered index update operator icon")</span></span>|`Clustered Index Update`|<span data-ttu-id="69bb6-246">`Clustered Index Update`연산자는 열에 지정 된 클러스터형 인덱스의 입력 행을 업데이트 합니다 `Argument` . WHERE: () predicate가 있는 경우이 조건자를 충족 하는 행만 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-246">The `Clustered Index Update` operator updates input rows in the clustered index specified in the `Argument` column.If a WHERE:() predicate is present, only those rows that satisfy this predicate are updated.</span></span> <span data-ttu-id="69bb6-247">SET:() 조건자가 있는 경우에는 업데이트된 각 열이 이 값으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-247">If a SET:() predicate is present, each updated column is set to this value.</span></span> <span data-ttu-id="69bb6-248">DEFINE:() 조건자가 있는 경우에는 이 연산자가 정의하는 값이 나열됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-248">If a DEFINE:() predicate is present, the values that this operator defines are listed.</span></span> <span data-ttu-id="69bb6-249">이러한 값은 SET 절 또는 이 연산자의 다른 곳과 이 쿼리 내의 다른 곳에서 참조될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-249">These values may be referenced in the SET clause or elsewhere within this operator and elsewhere within this query.</span></span> <span data-ttu-id="69bb6-250">`Clustered Index Update`은 논리 및 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-250">`Clustered Index Update` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-251">![Collapse 연산자 아이콘](../../2014/database-engine/media/collapse-32x.gif "Collapse 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-251">![Collapse operator icon](../../2014/database-engine/media/collapse-32x.gif "Collapse operator icon")</span></span>|`Collapse`|<span data-ttu-id="69bb6-252">`Collapse` 연산자는 업데이트 처리를 최적화합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-252">The `Collapse` operator optimizes update processing.</span></span> <span data-ttu-id="69bb6-253">업데이트 처리는 `Split` 연산자를 사용하여 삭제와 삽입으로 분리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-253">When an update is performed, it can be split (using the `Split` operator) into a delete and an insert.</span></span> <span data-ttu-id="69bb6-254">열에는 `Argument` 키 열 목록을 지정 하는 GROUP BY: () 절이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-254">The `Argument` column contains a GROUP BY:() clause that specifies a list of key columns.</span></span> <span data-ttu-id="69bb6-255">쿼리 프로세서가 동일한 키 값을 삭제 및 삽입하는 인접 행을 발견하면 별개의 두 작업을 보다 효율적인 한 개의 업데이트 작업으로 교체합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-255">If the query processor encounters adjacent rows that delete and insert the same key values, it replaces these separate operations with a single more efficient update operation.</span></span> <span data-ttu-id="69bb6-256">`Collapse`은 논리 및 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-256">`Collapse` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-257">![Columnstore 인덱스 검색](../../2014/database-engine/media/columnstoreindexscan.gif "Columnstore 인덱스 검색")</span><span class="sxs-lookup"><span data-stu-id="69bb6-257">![Columnstore Index Scan](../../2014/database-engine/media/columnstoreindexscan.gif "Columnstore Index Scan")</span></span>|`Columnstore Index Scan`|<span data-ttu-id="69bb6-258">`Columnstore Index Scan`연산자는 `Argument` 쿼리 실행 계획의 열에 지정 된 columnstore 인덱스를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-258">The `Columnstore Index Scan` operator scans the columnstore index specified in the `Argument` column of the query execution plan.</span></span>|  
|<span data-ttu-id="69bb6-259">![Compute Scalar 연산자 아이콘](../../2014/database-engine/media/compute-scalar-32x.gif "Compute Scalar 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-259">![Compute scalar operator icon](../../2014/database-engine/media/compute-scalar-32x.gif "Compute scalar operator icon")</span></span>|`Compute Scalar`|<span data-ttu-id="69bb6-260">`Compute Scalar`연산자는 식을 계산 하 여 계산 된 스칼라 값을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-260">The `Compute Scalar` operator evaluates an expression to produce a computed scalar value.</span></span> <span data-ttu-id="69bb6-261">이 값은 사용자에 반환되거나 그 외에 쿼리에서 참조되거나 둘 다일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-261">This may then be returned to the user, referenced elsewhere in the query, or both.</span></span> <span data-ttu-id="69bb6-262">예를 들어 두 작업은 모두 필터 조건자 또는 조인 조건자에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-262">An example of both is in a filter predicate or join predicate.</span></span> <span data-ttu-id="69bb6-263">`Compute Scalar`은 논리 및 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-263">`Compute Scalar` is a logical and physical operator.</span></span><br /><br /> <span data-ttu-id="69bb6-264">`Compute Scalar`SET STATISTICS XML에 의해 생성 된 실행 계획에 표시 되는 연산자에는 요소가 포함 되지 않을 수 있습니다 `RunTimeInformation` .</span><span class="sxs-lookup"><span data-stu-id="69bb6-264">`Compute Scalar` operators that appear in Showplans generated by SET STATISTICS XML might not contain the `RunTimeInformation` element.</span></span> <span data-ttu-id="69bb6-265">**에서**실제 실행 계획 포함 **옵션을 선택하면 그래픽 실행 계획의**속성 **창에** 실제 행 수 **,** 실제 다시 바인딩 횟수 **및** 실제 되감기 횟수 [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]가 표시되지 않을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-265">In graphical Showplans, **Actual Rows**, **Actual Rebinds**, and **Actual Rewinds** might be absent from the **Properties** window when the **Include Actual Execution Plan** option is selected in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)].</span></span> <span data-ttu-id="69bb6-266">이 경우 컴파일된 쿼리 계획에서 이러한 연산자가 사용된 경우에도 런타임 쿼리 계획의 다른 연산자가 해당 작업을 수행한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-266">When this occurs, it means that although these operators were used in the compiled query plan, their work was performed by other operators in the run-time query plan.</span></span> <span data-ttu-id="69bb6-267">또한 SET STATISTICS PROFILE로 만든 실행 계획 출력의 실행 수는 SET STATISTICS XML로 만든 실행 계획의 다시 바인딩 및 다시 감기의 합과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-267">Also note that the number of executes in Showplan output generated by SET STATISTICS PROFILE is equivalent to the sum of rebinds and rewinds in Showplans generated by SET STATISTICS XML.</span></span>|  
|<span data-ttu-id="69bb6-268">![Concatenation 연산자 아이콘](../../2014/database-engine/media/concatenation-32x.gif "Concatenation 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-268">![Concatenation operator icon](../../2014/database-engine/media/concatenation-32x.gif "Concatenation operator icon")</span></span>|<span data-ttu-id="69bb6-269">**Concatenation**</span><span class="sxs-lookup"><span data-stu-id="69bb6-269">**Concatenation**</span></span>|<span data-ttu-id="69bb6-270">**Concatenation** 연산자는 여러 개의 입력을 검색하고 검색된 각 행을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-270">The **Concatenation** operator scans multiple inputs, returning each row scanned.</span></span> <span data-ttu-id="69bb6-271">**Concatenation** 은 일반적으로 [!INCLUDE[tsql](../includes/tsql-md.md)] UNION ALL 구조를 구현하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-271">**Concatenation** is typically used to implement the [!INCLUDE[tsql](../includes/tsql-md.md)] UNION ALL construct.</span></span> <span data-ttu-id="69bb6-272">**Concatenation** 물리 연산자에는 두 개 이상의 입력과 한 개의 출력이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-272">The **Concatenation** physical operator has two or more inputs and one output.</span></span> <span data-ttu-id="69bb6-273">Concatenation은 첫 번째 입력 스트림에서 출력 스트림으로 행을 복사한 다음 이 연산을 각 추가 입력 스트림에 대해 반복합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-273">Concatenation copies rows from the first input stream to the output stream, then repeats this operation for each additional input stream.</span></span> <span data-ttu-id="69bb6-274">**Concatenation** 은 논리 및 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-274">**Concatenation** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-275">![Constant Scan 연산자 아이콘](../../2014/database-engine/media/constant-scan-32x.gif "Constant Scan 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-275">![Constant scan operator icon](../../2014/database-engine/media/constant-scan-32x.gif "Constant scan operator icon")</span></span>|`Constant Scan`|<span data-ttu-id="69bb6-276">`Constant Scan`연산자는 하나 이상의 상수 행을 쿼리에 도입 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-276">The `Constant Scan` operator introduces one or more constant rows into a query.</span></span> <span data-ttu-id="69bb6-277">연산자는가 `Compute Scalar` `Constant Scan` 연산자에 의해 생성 된 행에 열을 추가 하는 경우에 자주 사용 됩니다 `Constant Scan` .</span><span class="sxs-lookup"><span data-stu-id="69bb6-277">A `Compute Scalar` operator is often used after a `Constant Scan` to add columns to a row produced by the `Constant Scan` operator.</span></span>|  
|<span data-ttu-id="69bb6-278">![Convert(데이터베이스 엔진) 언어 요소 아이콘](../../2014/database-engine/media/convert-32x.gif "Convert(데이터베이스 엔진) 언어 요소 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-278">![Convert (Database Engine) language element icon](../../2014/database-engine/media/convert-32x.gif "Convert (Database Engine) language element icon")</span></span>|`Convert`|<span data-ttu-id="69bb6-279">`Convert` 연산자는 스칼라 데이터 형식을 다른 형식으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-279">The `Convert` operator converts one scalar data type to another.</span></span> <span data-ttu-id="69bb6-280">`Convert`는 언어 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-280">`Convert` is a language element.</span></span>|  
|<span data-ttu-id="69bb6-281">없음</span><span class="sxs-lookup"><span data-stu-id="69bb6-281">None</span></span>|`Cross Join`|<span data-ttu-id="69bb6-282">`Cross Join` 논리 연산자는 첫 번째(최상위) 입력의 각 행을 두 번째(최하위) 입력의 각 행과 조인합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-282">The `Cross Join` operator joins each row from the first (top) input with each row from the second (bottom) input.</span></span> <span data-ttu-id="69bb6-283">`Cross Join`는 논리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-283">`Cross Join` is a logical operator.</span></span>|  
|<span data-ttu-id="69bb6-284">![Cursor catchall 커서 연산자 아이콘](../../2014/database-engine/media/cursor-catch-all.gif "Cursor catchall 커서 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-284">![Cursor catchall cursor operator icon](../../2014/database-engine/media/cursor-catch-all.gif "Cursor catchall cursor operator icon")</span></span>|`catchall`|<span data-ttu-id="69bb6-285">그래픽 실행 계획을 생성하는 논리에서 반복자에 적합한 아이콘을 찾지 못하면 캐치올 아이콘이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-285">The catchall icon is displayed when a suitable icon for the iterator cannot be found by the logic that produces graphical showplans.</span></span> <span data-ttu-id="69bb6-286">캐치올 아이콘이 반드시 오류 상태를 나타내는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-286">The catchall icon does not necessarily indicate an error condition.</span></span> <span data-ttu-id="69bb6-287">캐치올 아이콘은 파랑(반복자), 주황(커서) 및 녹색( [!INCLUDE[tsql](../includes/tsql-md.md)] 언어 요소)의 3가지 유형이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-287">There are three catchall icons: blue (for iterators), orange (for cursors), and green (for [!INCLUDE[tsql](../includes/tsql-md.md)] language elements).</span></span>|  
|<span data-ttu-id="69bb6-288">None</span><span class="sxs-lookup"><span data-stu-id="69bb6-288">None</span></span>|<span data-ttu-id="69bb6-289">**커서**</span><span class="sxs-lookup"><span data-stu-id="69bb6-289">**Cursor**</span></span>|<span data-ttu-id="69bb6-290">**Cursor** 논리 및 물리 연산자는 커서 작업이 수반되는 쿼리 또는 업데이트가 실행되는 방식을 설명하기 위해 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-290">The **Cursor** logical and physical operators are used to describe how a query or update involving cursor operations is executed.</span></span> <span data-ttu-id="69bb6-291">물리 연산자는 커서를 처리하는 데 사용하는 물리적 구현 알고리즘(예: 키 집합 커서의 사용)을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-291">The physical operators describe the physical implementation algorithm used to process the cursor; for example, using a keyset-driven cursor.</span></span> <span data-ttu-id="69bb6-292">커서 실행의 각 단계마다 물리 연산자가 수반됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-292">Each step in the execution of a cursor involves a physical operator.</span></span> <span data-ttu-id="69bb6-293">논리 연산자는 커서의 속성(예: 커서가 읽기 전용임)을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-293">The logical operators describe a property of the cursor, such as the cursor is read only.</span></span><br /><br /> <span data-ttu-id="69bb6-294">논리 연산자에는 Asynchronous, Optimistic, Primary, Read Only, Scroll Locks, Secondary 및 Synchronous가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-294">Logical operators include Asynchronous, Optimistic, Primary, Read Only, Scroll Locks, and Secondary and Synchronous.</span></span><br /><br /> <span data-ttu-id="69bb6-295">물리 연산자에는 Dynamic, Fetch Query, Keyset, Population Query, Refresh Query 및 Snapshot이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-295">Physical operators include Dynamic, Fetch Query, Keyset, Population Query, Refresh Query and Snapshot.</span></span>|  
|<span data-ttu-id="69bb6-296">![Declare 언어 요소 아이콘](../../2014/database-engine/media/declare-32x.gif "Declare 언어 요소 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-296">![Declare language element icon](../../2014/database-engine/media/declare-32x.gif "Declare language element icon")</span></span>|`Declare`|<span data-ttu-id="69bb6-297">`Declare`연산자는 쿼리 계획에 지역 변수를 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-297">The `Declare`  operator allocates a local variable in the query plan.</span></span> <span data-ttu-id="69bb6-298">`Declare`는 언어 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-298">`Declare` is a language element.</span></span>|  
|<span data-ttu-id="69bb6-299">![Delete(데이터베이스 엔진) 연산자 아이콘](../../2014/database-engine/media/delete-32x.gif "Delete(데이터베이스 엔진) 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-299">![Delete (Database Engine) operator icon](../../2014/database-engine/media/delete-32x.gif "Delete (Database Engine) operator icon")</span></span>|`Delete`|<span data-ttu-id="69bb6-300">`Delete`연산자는 열의 선택적 조건자를 만족 하는 개체 행에서 삭제 됩니다 `Argument` .</span><span class="sxs-lookup"><span data-stu-id="69bb6-300">The `Delete` operator deletes from an object rows that satisfy the optional predicate in the `Argument` column.</span></span>|  
|<span data-ttu-id="69bb6-301">![Delete scan 연산자 아이콘](../../2014/database-engine/media/delete-scan-32x.gif "Delete scan 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-301">![Delete scan operator icon](../../2014/database-engine/media/delete-scan-32x.gif "Delete scan operator icon")</span></span>|`Deleted Scan`|<span data-ttu-id="69bb6-302">`Deleted Scan` 연산자는 트리거 내에서 삭제된 테이블을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-302">The `Deleted Scan` operator scans the deleted table within a trigger.</span></span>|  
|<span data-ttu-id="69bb6-303">없음</span><span class="sxs-lookup"><span data-stu-id="69bb6-303">None</span></span>|`Distinct`|<span data-ttu-id="69bb6-304">`Distinct` 연산자는 행 집합 또는 값 컬렉션에서 중복 요소를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-304">The `Distinct` operator removes duplicates from a rowset or from a collection of values.</span></span> <span data-ttu-id="69bb6-305">`Distinct`는 논리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-305">`Distinct` is a logical operator.</span></span>|  
|<span data-ttu-id="69bb6-306">없음</span><span class="sxs-lookup"><span data-stu-id="69bb6-306">None</span></span>|`Distinct Sort`|<span data-ttu-id="69bb6-307">`Distinct Sort`논리 연산자는 입력을 검색 하 여 중복을 제거 하 고 열의 DISTINCT ORDER by: () 조건자에 지정 된 열을 기준으로 정렬 `Argument` 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-307">The `Distinct Sort` logical operator scans the input, removing duplicates and sorting by the columns specified in the DISTINCT ORDER BY:() predicate of the `Argument` column.</span></span> <span data-ttu-id="69bb6-308">`Distinct Sort`는 논리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-308">`Distinct Sort` is a logical operator.</span></span>|  
|<span data-ttu-id="69bb6-309">![Distribute streams parallelism 연산자 아이콘](../../2014/database-engine/media/parallelism-distribute-stream.gif "Distribute streams parallelism 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-309">![Distribute streams parallelism operator icon](../../2014/database-engine/media/parallelism-distribute-stream.gif "Distribute streams parallelism operator icon")</span></span>|<span data-ttu-id="69bb6-310">**Distribute Streams**</span><span class="sxs-lookup"><span data-stu-id="69bb6-310">**Distribute Streams**</span></span>|<span data-ttu-id="69bb6-311">**Distribute Streams** 연산자는 병렬 쿼리 계획에서만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-311">The **Distribute Streams** operator is used only in parallel query plans.</span></span> <span data-ttu-id="69bb6-312">**Distribute Streams** 연산자는 레코드의 단일 입력 스트림을 사용하여 여러 개의 출력 스트림을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-312">The **Distribute Streams** operator takes a single input stream of records and produces multiple output streams.</span></span> <span data-ttu-id="69bb6-313">레코드 내용과 형식은 변경되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-313">The record contents and format are not changed.</span></span> <span data-ttu-id="69bb6-314">입력 스트림의 각 레코드는 출력 스트림 중 하나에 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-314">Each record from the input stream appears in one of the output streams.</span></span> <span data-ttu-id="69bb6-315">이 연산자는 입력 레코드의 상대적인 순서를 출력 스트림에서 자동으로 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-315">This operator automatically preserves the relative order of the input records in the output streams.</span></span> <span data-ttu-id="69bb6-316">대개 특정 입력 레코드가 어떤 출력 스트림에 포함될지 결정하는 데는 해시가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-316">Usually, hashing is used to decide to which output stream a particular input record belongs.</span></span><br /><br /> <span data-ttu-id="69bb6-317">출력이 분할 된 경우 열에는 `Argument` PARTITION columns: () 조건자와 분할 열이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-317">If the output is partitioned, then the `Argument` column contains a PARTITION COLUMNS:() predicate and the partitioning columns.</span></span> <span data-ttu-id="69bb6-318">**Distribute Streams** 는 논리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-318">**Distribute Streams** is a logical operator</span></span>|  
|<span data-ttu-id="69bb6-319">![Dynamic 커서 연산자 아이콘](../../2014/database-engine/media/dynamic-32x.gif "Dynamic 커서 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-319">![Dynamic cursor operator icon](../../2014/database-engine/media/dynamic-32x.gif "Dynamic cursor operator icon")</span></span>|`Dynamic`|<span data-ttu-id="69bb6-320">`Dynamic` 연산자는 다른 커서가 변경한 모든 내용을 볼 수 있는 커서를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-320">The `Dynamic` operator uses a cursor that can see all changes made by others.</span></span>|  
|<span data-ttu-id="69bb6-321">![Spool 연산자 아이콘](../../2014/database-engine/media/spool-32x.gif "Spool 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-321">![Spool operator icon](../../2014/database-engine/media/spool-32x.gif "Spool operator icon")</span></span>|<span data-ttu-id="69bb6-322">**Eager Spool**</span><span class="sxs-lookup"><span data-stu-id="69bb6-322">**Eager Spool**</span></span>|<span data-ttu-id="69bb6-323">**즉시 스풀** 연산자는 전체 입력을 받아 각 행을 데이터베이스에 저장 된 숨겨진 임시 개체에 저장 합니다 `tempdb` .</span><span class="sxs-lookup"><span data-stu-id="69bb6-323">The **Eager Spool** operator takes the entire input, storing each row in a hidden temporary object stored in the `tempdb` database.</span></span> <span data-ttu-id="69bb6-324">연산자가 되감을 (예: 연산자)이 고 리바인딩이 필요 하지 않은 경우에는 입력을 다시 검사 하는 `Nested Loops` 대신 스풀링된 데이터가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-324">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span> <span data-ttu-id="69bb6-325">다시 바인딩해야 하는 경우에는 스풀된 데이터를 삭제하고 다시 바인딩된 입력을 다시 검색하여 스풀 개체를 다시 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-325">If rebinding is needed, the spooled data is discarded and the spool object is rebuilt by rescanning the (rebound) input.</span></span> <span data-ttu-id="69bb6-326">**Eager Spool** 연산자는 "신속하게" 스풀 파일을 만듭니다. 스풀의 부모 연산자가 첫 번째 행을 요청하면 스풀 연산자는 입력 연산자로부터 모든 행을 받아 스풀에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-326">The **Eager Spool** operator builds its spool file in an "eager" manner: when the spool's parent operator asks for the first row, the spool operator consumes all rows from its input operator and stores them in the spool.</span></span> <span data-ttu-id="69bb6-327">**Eager Spool** 은 논리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-327">**Eager Spool** is a logical operator.</span></span>|  
|<span data-ttu-id="69bb6-328">![Fetch Query 커서 연산자 아이콘](../../2014/database-engine/media/fetch-query-32x.gif "Fetch Query 커서 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-328">![Fetch query cursor operator icon](../../2014/database-engine/media/fetch-query-32x.gif "Fetch query cursor operator icon")</span></span>|`Fetch Query`|<span data-ttu-id="69bb6-329">이 `Fetch Query` 연산자는 커서에 대해 인출이 실행될 때 행을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-329">The `Fetch Query` operator retrieves rows when a fetch is issued against a cursor.</span></span>|  
|<span data-ttu-id="69bb6-330">![Filter(데이터베이스 엔진) 연산자 아이콘](../../2014/database-engine/media/filter-32x.gif "Filter(데이터베이스 엔진) 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-330">![Filter (Database Engine) operator icon](../../2014/database-engine/media/filter-32x.gif "Filter (Database Engine) operator icon")</span></span>|<span data-ttu-id="69bb6-331">**Filter**</span><span class="sxs-lookup"><span data-stu-id="69bb6-331">**Filter**</span></span>|<span data-ttu-id="69bb6-332">**Filter** 연산자는 입력을 검색 하 여 열에 표시 되는 필터 식 (조건자)에 부합 되는 행만 반환 합니다 `Argument` .</span><span class="sxs-lookup"><span data-stu-id="69bb6-332">The **Filter** operator scans the input, returning only those rows that satisfy the filter expression (predicate) that appears in the `Argument` column.</span></span>|  
|<span data-ttu-id="69bb6-333">없음</span><span class="sxs-lookup"><span data-stu-id="69bb6-333">None</span></span>|`Flow Distinct`|<span data-ttu-id="69bb6-334">`Flow Distinct` 논리 연산자는 입력을 검색하며 중복 요소를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-334">The `Flow Distinct` logical operator scans the input, removing duplicates.</span></span> <span data-ttu-id="69bb6-335">연산자는 `Distinct` 출력을 만들기 전에 모든 입력을 사용 하지만 **flowdistinct** 연산자는 입력에서 가져온 각 행을 반환 합니다. 단, 해당 행이 중복 된 경우에는 삭제 됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-335">Whereas the `Distinct` operator consumes all input before producing any output, the **FlowDistinct** operator returns each row as it is obtained from the input (unless that row is a duplicate, in which case it is discarded).</span></span>|  
|<span data-ttu-id="69bb6-336">없음</span><span class="sxs-lookup"><span data-stu-id="69bb6-336">None</span></span>|`Full Outer Join`|<span data-ttu-id="69bb6-337">`Full Outer Join` 논리 연산자는 두 번째(최하위) 입력의 각 행과 조인된 첫 번째(최상위) 입력의 조인 조건자에 부합되는 각 행을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-337">The `Full Outer Join` logical operator returns each row satisfying the join predicate from the first (top) input joined with each row from the second (bottom) input.</span></span> <span data-ttu-id="69bb6-338">다음 항목으로부터 행을 반환하기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-338">It also returns rows from:</span></span><br /><br /> <span data-ttu-id="69bb6-339">-두 번째 입력과 일치하는 요소가 없는 첫 번째 입력</span><span class="sxs-lookup"><span data-stu-id="69bb6-339">-The first input that had no matches in the second input.</span></span><br /><br /> <span data-ttu-id="69bb6-340">-첫 번째 입력과 일치하는 요소가 없는 두 번째 입력</span><span class="sxs-lookup"><span data-stu-id="69bb6-340">-The second input that had no matches in the first input.</span></span><br /><br /> <br /><br /> <span data-ttu-id="69bb6-341">일치되는 값이 없는 입력은 Null 값으로 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-341">The input that does not contain the matching values is returned as a null value.</span></span> <span data-ttu-id="69bb6-342">`Full Outer Join`는 논리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-342">`Full Outer Join` is a logical operator.</span></span>|  
|<span data-ttu-id="69bb6-343">![Gather streams parallelism 연산자 아이콘](../../2014/database-engine/media/parallelism-32x.gif "Gather streams parallelism 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-343">![Gather streams parallelism operator icon](../../2014/database-engine/media/parallelism-32x.gif "Gather streams parallelism operator icon")</span></span>|<span data-ttu-id="69bb6-344">**Gather Streams**</span><span class="sxs-lookup"><span data-stu-id="69bb6-344">**Gather Streams**</span></span>|<span data-ttu-id="69bb6-345">**Gather Streams** 연산자는 병렬 쿼리 계획에서만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-345">The **Gather Streams** operator is only used in parallel query plans.</span></span> <span data-ttu-id="69bb6-346">**Gather Streams** 연산자는 몇 개의 입력 스트림을 사용하고 해당 입력 스트림을 결합하여 레코드의 단일 출력 스트림을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-346">The **Gather Streams** operator consumes several input streams and produces a single output stream of records by combining the input streams.</span></span> <span data-ttu-id="69bb6-347">레코드 내용과 형식은 변경되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-347">The record contents and format are not changed.</span></span> <span data-ttu-id="69bb6-348">이 연산자가 순서를 그대로 유지하는 경우에는 모든 입력 스트림이 정렬되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-348">If this operator is order preserving, all input streams must be ordered.</span></span> <span data-ttu-id="69bb6-349">출력이 정렬 되는 경우 열에 `Argument` ORDER BY: () 조건자와 정렬 될 열 이름이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-349">If the output is ordered, the `Argument` column contains an ORDER BY:() predicate and the names of columns being ordered.</span></span> <span data-ttu-id="69bb6-350">**Gather Streams** 는 논리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-350">**Gather Streams** is a logical operator.</span></span>|  
|<span data-ttu-id="69bb6-351">![Hash match 연산자 아이콘](../../2014/database-engine/media/hash-match-32x.gif "Hash match 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-351">![Hash match operator icon](../../2014/database-engine/media/hash-match-32x.gif "Hash match operator icon")</span></span>|`Hash Match`|<span data-ttu-id="69bb6-352">`Hash Match` 연산자는 빌드 입력으로부터 각 행에 대한 해시 값을 계산하여 해시 테이블을 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-352">The `Hash Match` operator builds a hash table by computing a hash value for each row from its build input.</span></span> <span data-ttu-id="69bb6-353">해시: () 조건자는 해시 값을 만드는 데 사용 된 열 목록과 함께 열에 표시 됩니다 `Argument` .</span><span class="sxs-lookup"><span data-stu-id="69bb6-353">A HASH:() predicate with a list of columns used to create a hash value appears in the `Argument` column.</span></span> <span data-ttu-id="69bb6-354">이 조건자는 각 검색 행에 대해 동일한 해시 함수를 사용하여 해시 값을 계산하고 해시 테이블에서 일치하는 항목을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-354">Then, for each probe row (as applicable), it computes a hash value (using the same hash function) and looks in the hash table for matches.</span></span> <span data-ttu-id="69bb6-355">잔여 조건자가 있는 경우 (열에서 잔여: ()으로 식별 됨 `Argument` ) 행이 일치 하는 것으로 간주 되려면 해당 조건자도 충족 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-355">If a residual predicate is present (identified by RESIDUAL:() in the `Argument` column), that predicate must also be satisfied for rows to be considered a match.</span></span> <span data-ttu-id="69bb6-356">수행되는 논리 연산에 따라 다음과 같이 동작이 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-356">Behavior depends on the logical operation being performed:</span></span><br /><br /> <span data-ttu-id="69bb6-357">모든 조인에 대해 첫 번째(최상위) 입력을 사용하여 해시 테이블을 작성하고 두 번째(최하위) 입력을 사용하여 해시 테이블을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-357">For any joins, use the first (top) input to build the hash table and the second (bottom) input to probe the hash table.</span></span> <span data-ttu-id="69bb6-358">출력은 조인 유형으로 지정된 대로 일치(또는 불일치)됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-358">Output matches (or nonmatches) as dictated by the join type.</span></span> <span data-ttu-id="69bb6-359">여러 조인에서 같은 조인 열을 사용하는 경우에는 이러한 연산이 해시 팀으로 그룹화됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-359">If multiple joins use the same join column, these operations are grouped into a hash team.</span></span><br /><br /> <span data-ttu-id="69bb6-360">distinct 또는 aggregate 연산자에 대해서는 입력을 사용하여 해시 테이블을 작성합니다(중복 요소를 제거하고 모든 집계 식을 계산).</span><span class="sxs-lookup"><span data-stu-id="69bb6-360">For the distinct or aggregate operators, use the input to build the hash table (removing duplicates and computing any aggregate expressions).</span></span> <span data-ttu-id="69bb6-361">해시 테이블이 작성되면 테이블을 검색하고 모든 항목을 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-361">When the hash table is built, scan the table and output all entries.</span></span><br /><br /> <span data-ttu-id="69bb6-362">union 연산자에 대해서는 첫 번째 입력을 사용하여 해시 테이블을 작성합니다(중복 요소 제거).</span><span class="sxs-lookup"><span data-stu-id="69bb6-362">For the union operator, use the first input to build the hash table (removing duplicates).</span></span> <span data-ttu-id="69bb6-363">다음 두 번째 입력(중복 요소가 없어야 함)을 사용하여 해시 테이블을 검색하고 일치되는 항목이 없는 모든 행을 반환한 뒤 해시 테이블을 검색하여 모든 항목을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-363">Use the second input (which must have no duplicates) to probe the hash table, returning all rows that have no matches, then scan the hash table and return all entries.</span></span><br /><br /> <br /><br /> <span data-ttu-id="69bb6-364">`Hash Match`는 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-364">`Hash Match` is a physical operator.</span></span>|  
|<span data-ttu-id="69bb6-365">![If 언어 요소 아이콘](../../2014/database-engine/media/if-32x.gif "If 언어 요소 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-365">![If language element icon](../../2014/database-engine/media/if-32x.gif "If language element icon")</span></span>|`If`|<span data-ttu-id="69bb6-366">`If` 연산자는 식을 기준으로 조건부 처리를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-366">The `If` operator carries out conditional processing based on an expression.</span></span> <span data-ttu-id="69bb6-367">`If`는 언어 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-367">`If` is a language element.</span></span>|  
|<span data-ttu-id="69bb6-368">없음</span><span class="sxs-lookup"><span data-stu-id="69bb6-368">None</span></span>|`Inner Join`|<span data-ttu-id="69bb6-369">`Inner Join` 논리 연산자는 첫 번째(최상위) 입력과 두 번째(최하위) 입력의 조인에 부합되는 각 행을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-369">The `Inner Join` logical operator returns each row that satisfies the join of the first (top) input with the second (bottom) input.</span></span>|  
|<span data-ttu-id="69bb6-370">![Insert(데이터베이스 엔진) 연산자 아이콘](../../2014/database-engine/media/insert-32x.gif "Insert(데이터베이스 엔진) 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-370">![Insert (Database Engine) operator icon](../../2014/database-engine/media/insert-32x.gif "Insert (Database Engine) operator icon")</span></span>|`Insert`|<span data-ttu-id="69bb6-371">`Insert`논리 연산자는 입력의 각 행을 열에 지정 된 개체에 삽입 합니다 `Argument` .</span><span class="sxs-lookup"><span data-stu-id="69bb6-371">The `Insert` logical operator inserts each row from its input into the object specified in the `Argument` column.</span></span> <span data-ttu-id="69bb6-372">물리 연산자는 `Table Insert`, `Index Insert` 또는 `Clustered Index Insert` 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-372">The physical operator is either the `Table Insert`, `Index Insert`, or `Clustered Index Insert` operator.</span></span>|  
|<span data-ttu-id="69bb6-373">![Inserted scan 연산자 아이콘](../../2014/database-engine/media/inserted-scan-32x.gif "Inserted scan 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-373">![Inserted scan operator icon](../../2014/database-engine/media/inserted-scan-32x.gif "Inserted scan operator icon")</span></span>|<span data-ttu-id="69bb6-374">**Inserted Scan**</span><span class="sxs-lookup"><span data-stu-id="69bb6-374">**Inserted Scan**</span></span>|<span data-ttu-id="69bb6-375">**Inserted Scan** 연산자는 **inserted** 테이블을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-375">The **Inserted Scan** operator scans the **inserted** table.</span></span> <span data-ttu-id="69bb6-376">**Inserted Scan** 은 논리 및 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-376">**Inserted Scan** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-377">![내장 언어 요소 아이콘](../../2014/database-engine/media/intrinsic-32x.gif "내장 언어 요소 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-377">![Intrinsic language element icon](../../2014/database-engine/media/intrinsic-32x.gif "Intrinsic language element icon")</span></span>|`Intrinsic`|<span data-ttu-id="69bb6-378">`Intrinsic` 연산자는 내부 [!INCLUDE[tsql](../includes/tsql-md.md)] 함수를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-378">The `Intrinsic` operator invokes an internal [!INCLUDE[tsql](../includes/tsql-md.md)] function.</span></span> <span data-ttu-id="69bb6-379">`Intrinsic`는 언어 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-379">`Intrinsic` is a language element.</span></span>|  
|<span data-ttu-id="69bb6-380">![Iterator catchall 연산자 아이콘](../../2014/database-engine/media/iterator-catch-all.gif "Iterator catchall 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-380">![Iterator catchall operator icon](../../2014/database-engine/media/iterator-catch-all.gif "Iterator catchall operator icon")</span></span>|`Iterator`|<span data-ttu-id="69bb6-381">그래픽 실행 계획을 생성하는 논리에서 반복자에 적합한 아이콘을 찾지 못하면 `Iterator` 캐치올 아이콘이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-381">The `Iterator` catchall icon is displayed when a suitable icon for the iterator cannot be found by the logic that produces graphical Showplans.</span></span> <span data-ttu-id="69bb6-382">캐치올 아이콘이 반드시 오류 상태를 나타내는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-382">The catchall icon does not necessarily indicate an error condition.</span></span> <span data-ttu-id="69bb6-383">캐치올 아이콘은 파랑(반복자), 주황(커서) 및 녹색( [!INCLUDE[tsql](../includes/tsql-md.md)] 언어 구문)의 3가지 유형이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-383">There are three catchall icons: blue (for iterators), orange (for cursors), and green (for [!INCLUDE[tsql](../includes/tsql-md.md)] language constructs).</span></span>|  
|<span data-ttu-id="69bb6-384">![Bookmark lookup 연산자 아이콘](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark lookup 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-384">![Bookmark lookup operator icon](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark lookup operator icon")</span></span>|`Key Lookup`|<span data-ttu-id="69bb6-385">`Key Lookup`연산자는 클러스터형 인덱스가 있는 테이블에 대 한 책갈피 조회입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-385">The `Key Lookup` operator is a bookmark lookup on a table with a clustered index.</span></span> <span data-ttu-id="69bb6-386">열에는 클러스터형 인덱스의 `Argument` 이름과 클러스터형 인덱스에서 행을 조회 하는 데 사용 되는 클러스터링 키가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-386">The `Argument` column contains the name of the clustered index and the clustering key used to look up the row in the clustered index.</span></span> <span data-ttu-id="69bb6-387">`Key Lookup`는 항상 연산자와 함께 제공 됩니다 `Nested Loops` .</span><span class="sxs-lookup"><span data-stu-id="69bb6-387">`Key Lookup` is always accompanied by a `Nested Loops` operator.</span></span> <span data-ttu-id="69bb6-388">열에 WITH 프리페치 절이 표시 되는 경우 `Argument` 쿼리 프로세서는 클러스터형 인덱스에서 책갈피를 조회할 때 비동기 프리페치 (미리 읽기)를 사용 하는 것이 최적 임을 확인 했습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-388">If the WITH PREFETCH clause appears in the `Argument` column, the query processor has determined that it is optimal to use asynchronous prefetching (read-ahead) when looking up bookmarks in the clustered index.</span></span><br /><br /> <span data-ttu-id="69bb6-389">쿼리 계획에서 연산자를 사용 하는 것은 `Key Lookup` 쿼리에서 성능 튜닝의 이점을 활용할 수 있음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-389">The use of a `Key Lookup` operator in a query plan indicates that the query might benefit from performance tuning.</span></span> <span data-ttu-id="69bb6-390">예를 들어 포함 인덱스를 추가하여 쿼리 성능을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-390">For example, query performance might be improved by adding a covering index.</span></span>|  
|<span data-ttu-id="69bb6-391">![Keyset 커서 연산자 아이콘](../../2014/database-engine/media/keyset-32x.gif "Keyset 커서 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-391">![Keyset cursor operator icon](../../2014/database-engine/media/keyset-32x.gif "Keyset cursor operator icon")</span></span>|`Keyset`|<span data-ttu-id="69bb6-392">`Keyset` 연산자는 다른 사용자의 업데이트 내용은 볼 수 있지만 삽입 내용은 볼 수 없는 커서를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-392">The `Keyset` operator uses a cursor that can see updates, but not inserts made by others.</span></span>|  
|<span data-ttu-id="69bb6-393">![Language 요소 캐치올 아이콘](../../2014/database-engine/media/language-construct-catch-all.gif "Language 요소 캐치올 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-393">![Language element catchall icon](../../2014/database-engine/media/language-construct-catch-all.gif "Language element catchall icon")</span></span>|`Language Element`|<span data-ttu-id="69bb6-394">그래픽 실행 계획을 생성하는 논리에서 반복자에 적합한 아이콘을 찾지 못하면 `Language Element` 캐치올 아이콘이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-394">The `Language Element` catchall icon is displayed when a suitable icon for the iterator cannot be found by the logic that produces graphical Showplans.</span></span> <span data-ttu-id="69bb6-395">캐치올 아이콘이 반드시 오류 상태를 나타내는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-395">The catchall icon does not necessarily indicate an error condition.</span></span> <span data-ttu-id="69bb6-396">캐치올 아이콘은 파랑(반복자), 주황(커서) 및 녹색( [!INCLUDE[tsql](../includes/tsql-md.md)] 언어 구문)의 3가지 유형이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-396">There are three catchall icons: blue (for iterators), orange (for cursors), and green (for [!INCLUDE[tsql](../includes/tsql-md.md)] language constructs).</span></span>|  
|<span data-ttu-id="69bb6-397">![Spool 연산자 아이콘](../../2014/database-engine/media/spool-32x.gif "Spool 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-397">![Spool operator icon](../../2014/database-engine/media/spool-32x.gif "Spool operator icon")</span></span>|<span data-ttu-id="69bb6-398">**Lazy Spool**</span><span class="sxs-lookup"><span data-stu-id="69bb6-398">**Lazy Spool**</span></span>|<span data-ttu-id="69bb6-399">**Lazy Spool** 논리 연산자는 입력의 각 행을 데이터베이스에 저장 된 숨겨진 임시 개체에 저장 `tempdb` 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-399">The **Lazy Spool** logical operator stores each row from its input in a hidden temporary object stored in the `tempdb` database.</span></span> <span data-ttu-id="69bb6-400">연산자가 되감을 (예: 연산자)이 고 리바인딩이 필요 하지 않은 경우에는 입력을 다시 검사 하는 `Nested Loops` 대신 스풀링된 데이터가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-400">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span> <span data-ttu-id="69bb6-401">다시 바인딩해야 하는 경우에는 스풀된 데이터를 삭제하고 다시 바인딩된 입력을 다시 검색하여 스풀 개체를 다시 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-401">If rebinding is needed, the spooled data is discarded and the spool object is rebuilt by rescanning the (rebound) input.</span></span> <span data-ttu-id="69bb6-402">**Lazy Spool** 연산자는 스풀 파일을 "지연" 방식으로 작성합니다. 즉, 스풀의 부모 연산자가 행을 요청할 때마다 스풀 연산자는 한 번에 모든 행을 사용하는 대신 입력 연산자로부터 하나의 행을 받아 스풀에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-402">The **Lazy Spool** operator builds its spool file in a "lazy" manner, that is, each time the spool's parent operator asks for a row, the spool operator gets a row from its input operator and stores it in the spool, rather than consuming all rows at once.</span></span> <span data-ttu-id="69bb6-403">Lazy Spool은 논리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-403">Lazy Spool is a logical operator.</span></span>|  
|<span data-ttu-id="69bb6-404">없음</span><span class="sxs-lookup"><span data-stu-id="69bb6-404">None</span></span>|`Left Anti Semi Join`|<span data-ttu-id="69bb6-405">`Left Anti Semi Join` 연산자는 두 번째(최하위) 입력에 일치 행이 없는 경우 첫 번째(최상위) 입력으로부터 각 행을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-405">The `Left Anti Semi Join` operator returns each row from the first (top) input when there is no matching row in the second (bottom) input.</span></span> <span data-ttu-id="69bb6-406">열에 조인 조건자가 없으면 `Argument` 각 행이 일치 하는 행입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-406">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="69bb6-407">`Left Anti Semi Join`는 논리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-407">`Left Anti Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="69bb6-408">없음</span><span class="sxs-lookup"><span data-stu-id="69bb6-408">None</span></span>|`Left Outer Join`|<span data-ttu-id="69bb6-409">`Left Outer Join` 연산자는 첫 번째(최상위) 입력과 두 번째(최하위) 입력의 조인에 부합되는 각 행을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-409">The `Left Outer Join` operator returns each row that satisfies the join of the first (top) input with the second (bottom) input.</span></span> <span data-ttu-id="69bb6-410">또한 첫 번째 입력에서 두 번째 입력에 일치 행이 없는 행을 모두 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-410">It also returns any rows from the first input that had no matching rows in the second input.</span></span> <span data-ttu-id="69bb6-411">두 번째 입력에서 일치되지 않는 행은 Null 값으로 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-411">The nonmatching rows in the second input are returned as null values.</span></span> <span data-ttu-id="69bb6-412">열에 조인 조건자가 없으면 `Argument` 각 행이 일치 하는 행입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-412">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="69bb6-413">`Left Outer Join`는 논리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-413">`Left Outer Join` is a logical operator.</span></span>|  
|<span data-ttu-id="69bb6-414">없음</span><span class="sxs-lookup"><span data-stu-id="69bb6-414">None</span></span>|`Left Semi Join`|<span data-ttu-id="69bb6-415">`Left Semi Join` 연산자는 첫 번째(최상위) 입력 중 두 번째(최하위) 입력에 일치 행이 있는 각 행을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-415">The `Left Semi Join` operator returns each row from the first (top) input when there is a matching row in the second (bottom) input.</span></span> <span data-ttu-id="69bb6-416">열에 조인 조건자가 없으면 `Argument` 각 행이 일치 하는 행입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-416">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="69bb6-417">`Left Semi Join`는 논리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-417">`Left Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="69bb6-418">![Log row scan 연산자 아이콘](../../2014/database-engine/media/log-row-scan-32x.gif "Log row scan 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-418">![Log row scan operator icon](../../2014/database-engine/media/log-row-scan-32x.gif "Log row scan operator icon")</span></span>|`Log Row Scan`|<span data-ttu-id="69bb6-419">`Log Row Scan` 연산자는 트랜잭션 로그를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-419">The `Log Row Scan` operator scans the transaction log.</span></span> <span data-ttu-id="69bb6-420">`Log Row Scan`은 논리 및 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-420">`Log Row Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-421">![Merge interval 연산자 아이콘](../../2014/database-engine/media/merge-interval-32x.gif "Merge interval 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-421">![Merge interval operator icon](../../2014/database-engine/media/merge-interval-32x.gif "Merge interval operator icon")</span></span>|`Merge Interval`|<span data-ttu-id="69bb6-422">`Merge Interval` 연산자는 겹칠 수도 있는 여러 개의 간격을 병합하여 최소한의 겹치지 않는 간격을 생성하는데, 이 간격은 인덱스 항목 검색에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-422">The `Merge Interval` operator merges multiple (potentially overlapping) intervals to produce minimal, nonoverlapping intervals that are then used to seek index entries.</span></span> <span data-ttu-id="69bb6-423">이 연산자는 일반적으로 `Compute Scalar` `Constant Scan` 이 연산자가 병합 하는 간격 (행에서 열로 표시 됨)을 구성 하는 연산자 위에 있는 하나 이상의 연산자 위에 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-423">This operator typically appears above one or more `Compute Scalar` operators over `Constant Scan` operators, which construct the intervals (represented as columns in a row) that this operator merges.</span></span> <span data-ttu-id="69bb6-424">`Merge Interval`은 논리 및 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-424">`Merge Interval` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-425">![Merge Join 연산자 아이콘](../../2014/database-engine/media/merge-join-32x.gif "Merge Join 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-425">![Merge join operator icon](../../2014/database-engine/media/merge-join-32x.gif "Merge join operator icon")</span></span>|<span data-ttu-id="69bb6-426">**병합 조인**</span><span class="sxs-lookup"><span data-stu-id="69bb6-426">**Merge Join**</span></span>|<span data-ttu-id="69bb6-427">**Merge Join** 연산자는 내부 조인, 왼쪽 우선 외부 조인, 왼쪽 세미 조인, 왼쪽 앤티 세미 조인, 오른쪽 우선 외부 조인, 오른쪽 세미 조인, 오른쪽 앤티 세미 조인 및 합집합 논리 연산을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-427">The **Merge Join** operator performs the inner join, left outer join, left semi join, left anti semi join, right outer join, right semi join, right anti semi join, and union logical operations.</span></span><br /><br /> <span data-ttu-id="69bb6-428">작업에서 다 대 다 조인을 수행 하는 경우에는 열에 merge `Argument` **Join** 연산자가 일대다 조인을 수행 하거나 다대다 merge: () 조건자를 포함 하는 경우 merge: () predicate를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-428">In the `Argument` column, the **Merge Join** operator contains a MERGE:() predicate if the operation is performing a one-to-many join, or a MANY-TO-MANY MERGE:() predicate if the operation is performing a many-to-many join.</span></span> <span data-ttu-id="69bb6-429">이 `Argument` 열에는 작업을 수행 하는 데 사용 되는 쉼표로 구분 된 열 목록도 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-429">The `Argument` column also includes a comma-separated list of columns used to perform the operation.</span></span> <span data-ttu-id="69bb6-430">**Merge Join** 연산자에는 쿼리 계획에 명시적인 정렬 연산을 삽입하여 해당 열을 기준으로 정렬된 2개의 입력이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-430">The **Merge Join** operator requires two inputs sorted on their respective columns, possibly by inserting explicit sort operations into the query plan.</span></span> <span data-ttu-id="69bb6-431">Merge Join은 명시적인 정렬이 필요하지 않은 경우 예를 들면 데이터베이스에 적합한 B-트리 인덱스가 있거나 병합 조인과 롤업을 통한 그룹화와 같은 여러 개의 연산에 대해 정렬 순서를 사용할 수 있는 경우에 특히 효과적입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-431">Merge join is particularly effective if explicit sorting is not required, for example, if there is a suitable B-tree index in the database or if the sort order can be exploited for multiple operations, such as a merge join and grouping with roll up.</span></span> <span data-ttu-id="69bb6-432">**Merge Join** 은 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-432">**Merge Join** is a physical operator.</span></span>|  
|<span data-ttu-id="69bb6-433">![Nested loops 연산자 아이콘](../../2014/database-engine/media/nested-loops-32x.gif "Nested loops 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-433">![Nested loops operator icon](../../2014/database-engine/media/nested-loops-32x.gif "Nested loops operator icon")</span></span>|`Nested Loops`|<span data-ttu-id="69bb6-434">`Nested Loops` 연산자는 내부 조인, 왼쪽 우선 외부 조인, 왼쪽 세미 조인 및 왼쪽 앤티 세미 조인 논리 연산을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-434">The `Nested Loops` operator performs the inner join, left outer join, left semi join, and left anti semi join logical operations.</span></span> <span data-ttu-id="69bb6-435">중첩 루프 조인에서는 대개 인덱스를 사용하여 내부 테이블에서 외부 테이블의 각 행을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-435">Nested loops joins perform a search on the inner table for each row of the outer table, typically using an index.</span></span> <span data-ttu-id="69bb6-436">쿼리 프로세서는 예상 비용에 따라 내부 입력을 통한 인덱스 검색의 위치 정확성을 높이기 위해 외부 입력을 정렬할지 여부를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-436">The query processor decides, based on anticipated costs, whether to sort the outer input in order to improve locality of the searches on the index over the inner input.</span></span> <span data-ttu-id="69bb6-437">열에서 (옵션) 조건자를 충족 하는 모든 행 `Argument` 은 수행 되는 논리 연산에 따라 해당 하는 것으로 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-437">Any rows that satisfy the (optional) predicate in the `Argument` column are returned as applicable, based on the logical operation being performed.</span></span> <span data-ttu-id="69bb6-438">`Nested Loops`는 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-438">`Nested Loops` is a physical operator.</span></span>|  
|<span data-ttu-id="69bb6-439">![NonClustered Index Delete 연산자 아이콘](../../2014/database-engine/media/nonclust-index-delete-32x.gif "NonClustered Index Delete 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-439">![Nonclustered index delete operator icon](../../2014/database-engine/media/nonclust-index-delete-32x.gif "Nonclustered index delete operator icon")</span></span>|`Nonclustered Index Delete`|<span data-ttu-id="69bb6-440">`Nonclustered Index Delete`연산자는 열에 지정 된 비클러스터형 인덱스에서 입력 행을 삭제 합니다 `Argument` .</span><span class="sxs-lookup"><span data-stu-id="69bb6-440">The `Nonclustered Index Delete` operator deletes input rows from the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="69bb6-441">`Nonclustered Index Delete`는 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-441">`Nonclustered Index Delete` is a physical operator.</span></span>|  
|<span data-ttu-id="69bb6-442">![NonClustered Index Insert 연산자 아이콘](../../2014/database-engine/media/nonclust-index-insert-32x.gif "NonClustered Index Insert 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-442">![Nonclustered index insert operator icon](../../2014/database-engine/media/nonclust-index-insert-32x.gif "Nonclustered index insert operator icon")</span></span>|`Index Insert`|<span data-ttu-id="69bb6-443">`Index Insert`연산자는 입력의 행을 열에 지정 된 비클러스터형 인덱스에 삽입 `Argument` 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-443">The `Index Insert` operator inserts rows from its input into the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="69bb6-444">`Argument` 열에는 각 열의 설정 값을 나타내는 SET:() 조건자도 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-444">The `Argument` column also contains a SET:() predicate, which indicates the value to which each column is set.</span></span> <span data-ttu-id="69bb6-445">`Index Insert`는 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-445">`Index Insert` is a physical operator.</span></span>|  
|<span data-ttu-id="69bb6-446">![Nonclustered index scan 연산자 아이콘](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "Nonclustered index scan 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-446">![Nonclustered index scan operator icon](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "Nonclustered index scan operator icon")</span></span>|`Index Scan`|<span data-ttu-id="69bb6-447">`Index Scan`연산자는 열에 지정 된 비클러스터형 인덱스에서 모든 행을 검색 합니다 `Argument` .</span><span class="sxs-lookup"><span data-stu-id="69bb6-447">The `Index Scan` operator retrieves all rows from the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="69bb6-448">선택 사항인 WHERE: () 조건자가 열에 나타나는 경우에는 `Argument` 조건자에 부합 되는 행만 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-448">If an optional WHERE:() predicate appears in the `Argument` column, only those rows that satisfy the predicate are returned.</span></span> <span data-ttu-id="69bb6-449">`Index Scan`은 논리 및 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-449">`Index Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-450">![Nonclustered index seek 연산자 아이콘](../../2014/database-engine/media/index-seek-32x.gif "Nonclustered index seek 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-450">![Nonclustered index seek operator icon](../../2014/database-engine/media/index-seek-32x.gif "Nonclustered index seek operator icon")</span></span>|`Index Seek`|<span data-ttu-id="69bb6-451">`Index Seek` 연산자는 인덱스 검색 기능을 사용하여 비클러스터형 인덱스에서 행을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-451">The `Index Seek` operator uses the seeking ability of indexes to retrieve rows from a nonclustered index.</span></span> <span data-ttu-id="69bb6-452">`Argument`열에는 사용 중인 비클러스터형 인덱스의 이름이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-452">The `Argument` column contains the name of the nonclustered index being used.</span></span> <span data-ttu-id="69bb6-453">SEEK:() 조건자도 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-453">It also contains the SEEK:() predicate.</span></span> <span data-ttu-id="69bb6-454">스토리지 엔진은 이 인덱스를 사용하여 SEEK:() 조건자에 부합되는 행만 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-454">The storage engine uses the index to process only those rows that satisfy the SEEK:() predicate.</span></span> <span data-ttu-id="69bb6-455">필요에 따라 스토리지 엔진이 SEEK:() 조건자에 부합되는 모든 행에 대한 평가를 수행할 WHERE:() 조건자가 포함될 수도 있습니다(이 수행을 위해 인덱스를 사용하지는 않음).</span><span class="sxs-lookup"><span data-stu-id="69bb6-455">It optionally may include a WHERE:() predicate, which the storage engine will evaluate against all rows that satisfy the SEEK:() predicate (it does not use the indexes to do this).</span></span> <span data-ttu-id="69bb6-456">열에 `Argument` 정렬 된 절이 포함 되어 있는 경우 쿼리 프로세서는 비클러스터형 인덱스에서 행을 정렬 한 순서 대로 행을 반환 해야 한다고 결정 했습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-456">If the `Argument` column contains the ORDERED clause, the query processor has determined that the rows must be returned in the order in which the nonclustered index has sorted them.</span></span> <span data-ttu-id="69bb6-457">ORDERED 절이 없으면 스토리지 엔진이 인덱스를 최적의 방법(출력 정렬은 보장하지 않음)으로 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-457">If the ORDERED clause is not present, the storage engine searches the index in the optimal way (which does not guarantee that the output will be sorted).</span></span> <span data-ttu-id="69bb6-458">출력 순서를 유지하는 것보다는 정렬되지 않은 출력을 만드는 것이 더 효율적일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-458">Allowing the output to retain its ordering may be less efficient than producing nonsorted output.</span></span> <span data-ttu-id="69bb6-459">`Index Seek`은 논리 및 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-459">`Index Seek` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-460">![Nonclustered index spool 연산자 아이콘](../../2014/database-engine/media/index-spool-32x.gif "Nonclustered index spool 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-460">![Nonclustered index spool operator icon](../../2014/database-engine/media/index-spool-32x.gif "Nonclustered index spool operator icon")</span></span>|<span data-ttu-id="69bb6-461">**Index Spool**</span><span class="sxs-lookup"><span data-stu-id="69bb6-461">**Index Spool**</span></span>|<span data-ttu-id="69bb6-462">**Index Spool** 물리 연산자는 열에 SEEK: () 조건자를 포함 합니다 `Argument` .</span><span class="sxs-lookup"><span data-stu-id="69bb6-462">The **Index Spool** physical operator contains a SEEK:() predicate in the `Argument` column.</span></span> <span data-ttu-id="69bb6-463">**Index Spool** 연산자는 입력 행을 검색 하 여 각 행의 복사본을 숨겨진 스풀 파일에 배치 하 고 (데이터베이스에 저장 되 `tempdb` 고 쿼리 수명 동안만 존재) 행에 비클러스터형 인덱스를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-463">The **Index Spool** operator scans its input rows, placing a copy of each row in a hidden spool file (stored in the `tempdb` database and existing only for the lifetime of the query), and builds a nonclustered index on the rows.</span></span> <span data-ttu-id="69bb6-464">이렇게 하면 인덱스의 검색 기능을 사용하여 SEEK:() 조건자에 부합되는 행만 출력할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-464">This allows you to use the seeking capability of indexes to output only those rows that satisfy the SEEK:() predicate.</span></span> <span data-ttu-id="69bb6-465">연산자가 되감을 (예: 연산자)이 고 리바인딩이 필요 하지 않은 경우에는 입력을 다시 검사 하는 `Nested Loops` 대신 스풀링된 데이터가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-465">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span>|  
|<span data-ttu-id="69bb6-466">![Nonclustered index update 연산자 아이콘](../../2014/database-engine/media/nonclust-index-update-32x.gif "Nonclustered index update 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-466">![Nonclustered index update operator icon](../../2014/database-engine/media/nonclust-index-update-32x.gif "Nonclustered index update operator icon")</span></span>|`Nonclustered Index Update`|<span data-ttu-id="69bb6-467">`Nonclustered Index Update`물리 연산자는 열에 지정 된 비클러스터형 인덱스의 입력에서 행을 업데이트 합니다 `Argument` .</span><span class="sxs-lookup"><span data-stu-id="69bb6-467">The `Nonclustered Index Update` physical operator updates rows from its input in the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="69bb6-468">SET:() 조건자가 있는 경우에는 업데이트된 각 열이 이 값으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-468">If a SET:() predicate is present, each updated column is set to this value.</span></span> <span data-ttu-id="69bb6-469">`Nonclustered Index Update`는 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-469">`Nonclustered Index Update` is a physical operator.</span></span>|  
|<span data-ttu-id="69bb6-470">![Online index insert 연산자 아이콘](../../2014/database-engine/media/online-index-32x.gif "Online index insert 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-470">![Online index insert operator icon](../../2014/database-engine/media/online-index-32x.gif "Online index insert operator icon")</span></span>|<span data-ttu-id="69bb6-471">**Online Index Insert**</span><span class="sxs-lookup"><span data-stu-id="69bb6-471">**Online Index Insert**</span></span>|<span data-ttu-id="69bb6-472">**Online Index Insert** 물리 연산자는 인덱스, 만들기, 변경 또는 삭제 작업이 온라인으로 수행됨을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-472">The **Online Index Insert** physical operator indicates that an index create, alter, or drop operation is performed online.</span></span> <span data-ttu-id="69bb6-473">즉, 사용자가 인덱스 작업 동안 기본 테이블 데이터를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-473">That is, the underlying table data remains available to users during the index operation.</span></span>|  
|<span data-ttu-id="69bb6-474">None</span><span class="sxs-lookup"><span data-stu-id="69bb6-474">None</span></span>|`Parallelism`|<span data-ttu-id="69bb6-475">`Parallelism`연산자는 스트림 배포, 스트림 수집 및 스트림 다시 분할 논리 작업을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-475">The `Parallelism` operator performs the distribute streams, gather streams, and repartition streams logical operations.</span></span> <span data-ttu-id="69bb6-476">열에는 `Argument` 분할 된 열에 대 한 쉼표로 구분 된 목록을 포함 하는 PARTITION columns: () 조건자가 포함 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-476">The `Argument` columns can contain a PARTITION COLUMNS:() predicate with a comma-separated list of the columns being partitioned.</span></span> <span data-ttu-id="69bb6-477">열에는 `Argument` ORDER by: () 조건자가 포함 될 수도 있습니다. 열을 나열 하 여 분할 중에 대 한 정렬 순서를 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-477">The `Argument` columns can also contain an ORDER BY:() predicate, listing the columns to preserve the sort order for during partitioning.</span></span> <span data-ttu-id="69bb6-478">`Parallelism`는 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-478">`Parallelism` is a physical operator.</span></span><br /><br /> <span data-ttu-id="69bb6-479">참고: 쿼리가 병렬 쿼리로 컴파일 되었지만 런타임에 직렬 쿼리로 실행 되는 경우 SET STATISTICS XML 이나의 **실제 실행 계획 포함** 옵션을 사용 하 여 생성 된 실행 계획 출력에는 [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] `RunTimeInformation` 연산자의 요소가 포함 되지 않습니다 `Parallelism` .</span><span class="sxs-lookup"><span data-stu-id="69bb6-479">Note: If a query has been compiled as a parallel query, but at run time it is run as a serial query, the Showplan output generated by SET STATISTICS XML or by using the **Include Actual Execution Plan** option in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] will not contain the `RunTimeInformation` element for the `Parallelism` operator.</span></span> <span data-ttu-id="69bb6-480">SET STATISTICS PROFILE 출력에서 실제 행 개수와 실제 실행 수는 연산자에 대해 0을 표시 `Parallelism` 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-480">In SET STATISTICS PROFILE output, the actual row counts and actual number of executes will display zeroes for the `Parallelism` operator.</span></span> <span data-ttu-id="69bb6-481">두 조건 중 하나가 발생 하는 경우 `Parallelism` 연산자가 쿼리 컴파일 중에만 사용 되었으며 런타임 쿼리 계획에는 사용 되지 않았음을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-481">When either condition occurs, it means that the `Parallelism` operator was only used during query compilation and not in the run-time query plan.</span></span> <span data-ttu-id="69bb6-482">서버에 동시 로드 양이 많으면 병렬 쿼리 계획이 직렬로 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-482">Note that sometimes parallel query plans are run in serial if there is a high concurrent load on the server.</span></span>|  
|<span data-ttu-id="69bb6-483">![Parameter table scan 연산자 아이콘](../../2014/database-engine/media/parameter-table-scan-32x.gif "Parameter table scan 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-483">![Parameter table scan operator icon](../../2014/database-engine/media/parameter-table-scan-32x.gif "Parameter table scan operator icon")</span></span>|`Parameter Table Scan`|<span data-ttu-id="69bb6-484">`Parameter Table Scan` 연산자는 현재 쿼리에서 매개 변수의 역할을 하는 테이블을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-484">The `Parameter Table Scan` operator scans a table that is acting as a parameter in the current query.</span></span> <span data-ttu-id="69bb6-485">일반적으로 이 연산자는 저장 프로시저 안에서 INSERT 쿼리에 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-485">Typically, this is used for INSERT queries within a stored procedure.</span></span> <span data-ttu-id="69bb6-486">`Parameter Table Scan`은 논리 및 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-486">`Parameter Table Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-487">None</span><span class="sxs-lookup"><span data-stu-id="69bb6-487">None</span></span>|<span data-ttu-id="69bb6-488">**Partial Aggregate**</span><span class="sxs-lookup"><span data-stu-id="69bb6-488">**Partial Aggregate**</span></span>|<span data-ttu-id="69bb6-489">**Partial Aggregate** 는 병렬 계획에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-489">**Partial Aggregate** is used in parallel plans.</span></span> <span data-ttu-id="69bb6-490">Partial Aggregate는 최대한 많은 입력 행에 집계 함수를 적용하여 디스크 쓰기("spill"이라고 함)가 필요가 없도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-490">It applies an aggregation function to as many input rows as possible so that writing to disk (known as a "spill") is not necessary.</span></span> <span data-ttu-id="69bb6-491">`Hash Match`는 파티션 집계를 구현 하는 유일한 물리 연산자 (반복기)입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-491">`Hash Match` is the only physical operator (iterator) that implements partition aggregation.</span></span> <span data-ttu-id="69bb6-492">**Partial Aggregate** 는 논리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-492">**Partial Aggregate** is a logical operator.</span></span>|  
|<span data-ttu-id="69bb6-493">![Population Query 커서 연산자 아이콘](../../2014/database-engine/media/poulation-query-32x.gif "Population Query 커서 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-493">![Population query cursor operator icon](../../2014/database-engine/media/poulation-query-32x.gif "Population query cursor operator icon")</span></span>|`Population Query`|<span data-ttu-id="69bb6-494">`Population Query` 연산자는 커서가 열려 있을 때 커서의 작업 테이블을 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-494">The `Population Query` operator populates the work table of a cursor when the cursor is opened.</span></span>|  
|<span data-ttu-id="69bb6-495">![Refresh Query 커서 연산자 아이콘](../../2014/database-engine/media/refresh-query-32x.gif "Refresh Query 커서 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-495">![Refresh query cursor operator icon](../../2014/database-engine/media/refresh-query-32x.gif "Refresh query cursor operator icon")</span></span>|`Refresh Query`|<span data-ttu-id="69bb6-496">`Refresh Query` 연산자는 인출 버퍼에서 행에 대한 현재 데이터를 인출합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-496">The `Refresh Query` operator fetches current data for rows in the fetch buffer.</span></span>|  
|<span data-ttu-id="69bb6-497">![Remote delete 연산자 아이콘](../../2014/database-engine/media/remote-delete-32x.gif "Remote delete 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-497">![Remote delete operator icon](../../2014/database-engine/media/remote-delete-32x.gif "Remote delete operator icon")</span></span>|`Remote Delete`|<span data-ttu-id="69bb6-498">`Remote Delete` 연산자는 원격 개체로부터의 입력 행을 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-498">The `Remote Delete` operator deletes the input rows from a remote object.</span></span> <span data-ttu-id="69bb6-499">`Remote Delete`은 논리 및 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-499">`Remote Delete` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-500">![remote index seek 실행 계획 연산자](../../2014/database-engine/media/remote-index-scan-32x.gif "remote index seek 실행 계획 연산자")</span><span class="sxs-lookup"><span data-stu-id="69bb6-500">![remote index seek showplan operator](../../2014/database-engine/media/remote-index-scan-32x.gif "remote index seek showplan operator")</span></span>|<span data-ttu-id="69bb6-501">**Remote Index Scan**</span><span class="sxs-lookup"><span data-stu-id="69bb6-501">**Remote Index Scan**</span></span>|<span data-ttu-id="69bb6-502">**Remote Index Scan** 연산자는 Argument 열에 지정한 원격 인덱스를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-502">The **Remote Index Scan** operator scans the remote index specified in the Argument column.</span></span> <span data-ttu-id="69bb6-503">**Remote Insert Scan** 은 논리/물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-503">**Remote Index Scan** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-504">![remote index seek 실행 계획 연산자](../../2014/database-engine/media/remote-index-seek-32x.gif "remote index seek 실행 계획 연산자")</span><span class="sxs-lookup"><span data-stu-id="69bb6-504">![remote index seek showplan operator](../../2014/database-engine/media/remote-index-seek-32x.gif "remote index seek showplan operator")</span></span>|<span data-ttu-id="69bb6-505">**Remote Index Seek**</span><span class="sxs-lookup"><span data-stu-id="69bb6-505">**Remote Index Seek**</span></span>|<span data-ttu-id="69bb6-506">**Remote Index Seek** 연산자는 원격 인덱스 개체의 검색 기능을 사용하여 행을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-506">The **Remote Index Seek** operator uses the seeking ability of a remote index object to retrieve rows.</span></span> <span data-ttu-id="69bb6-507">`Argument`열에는 사용할 원격 인덱스의 이름 및 SEEK: () 조건자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-507">The `Argument` column contains the name of the remote index being used and the SEEK:() predicate.</span></span> <span data-ttu-id="69bb6-508">**Remote Index Seek** 는 논리/물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-508">**Remote Index Seek** is a logical physical operator.</span></span>|  
|<span data-ttu-id="69bb6-509">![Remote insert 연산자 아이콘](../../2014/database-engine/media/remote-insert-32x.gif "Remote insert 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-509">![Remote insert operator icon](../../2014/database-engine/media/remote-insert-32x.gif "Remote insert operator icon")</span></span>|<span data-ttu-id="69bb6-510">**Remote Insert**</span><span class="sxs-lookup"><span data-stu-id="69bb6-510">**Remote Insert**</span></span>|<span data-ttu-id="69bb6-511">**Remote Insert** 연산자는 입력 행을 원격 개체에 삽입합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-511">The **Remote Insert** operator inserts the input rows into a remote object.</span></span> <span data-ttu-id="69bb6-512">**Remote Insert** 는 논리/물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-512">**Remote Insert** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-513">![Remote Query 연산자 아이콘](../../2014/database-engine/media/remote-query-32x.gif "Remote Query 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-513">![Remote query operator icon](../../2014/database-engine/media/remote-query-32x.gif "Remote query operator icon")</span></span>|`Remote Query`|<span data-ttu-id="69bb6-514">`Remote Query` 연산자는 쿼리를 원격 원본으로 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-514">The `Remote Query` operator submits a query to a remote source.</span></span> <span data-ttu-id="69bb6-515">원격 서버에 전송 되는 쿼리 텍스트가 열에 표시 됩니다 `Argument` .</span><span class="sxs-lookup"><span data-stu-id="69bb6-515">The text of the query sent to the remote server appears in the `Argument` column.</span></span> <span data-ttu-id="69bb6-516">`Remote Query`은 논리 및 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-516">`Remote Query` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-517">![Remote Scan 연산자 아이콘](../../2014/database-engine/media/remote-scan-32x.gif "Remote Scan 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-517">![Remote scan operator icon](../../2014/database-engine/media/remote-scan-32x.gif "Remote scan operator icon")</span></span>|`Remote Scan`|<span data-ttu-id="69bb6-518">`Remote Scan` 연산자는 원격 개체를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-518">The `Remote Scan` operator scans a remote object.</span></span> <span data-ttu-id="69bb6-519">원격 개체의 이름이 열에 표시 됩니다 `Argument` .</span><span class="sxs-lookup"><span data-stu-id="69bb6-519">The name of the remote object appears in the `Argument` column.</span></span> <span data-ttu-id="69bb6-520">`Remote Scan`은 논리 및 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-520">`Remote Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-521">![Remote Update 연산자 아이콘](../../2014/database-engine/media/remote-update-32x.gif "Remote Update 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-521">![Remote update operator icon](../../2014/database-engine/media/remote-update-32x.gif "Remote update operator icon")</span></span>|`Remote Update`|<span data-ttu-id="69bb6-522">`Remote Update` 연산자는 원격 개체에서 입력 행을 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-522">The `Remote Update` operator updates the input rows in a remote object.</span></span> <span data-ttu-id="69bb6-523">`Remote Update`은 논리 및 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-523">`Remote Update` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-524">![Repartition streams parallelism 연산자 아이콘](../../2014/database-engine/media/parallelism-repartition-stream.gif "Repartition streams parallelism 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-524">![Repartition streams parallelism operator icon](../../2014/database-engine/media/parallelism-repartition-stream.gif "Repartition streams parallelism operator icon")</span></span>|<span data-ttu-id="69bb6-525">**Repartition Streams**</span><span class="sxs-lookup"><span data-stu-id="69bb6-525">**Repartition Streams**</span></span>|<span data-ttu-id="69bb6-526">**Repartition Streams** 연산자는 여러 개의 스트림을 사용하며 여러 개의 레코드 스트림을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-526">The **Repartition Streams** operator consumes multiple streams and produces multiple streams of records.</span></span> <span data-ttu-id="69bb6-527">레코드 내용과 형식은 변경되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-527">The record contents and format are not changed.</span></span> <span data-ttu-id="69bb6-528">쿼리 최적화 프로그램이 비트맵 필터를 사용하면 출력 스트림의 행 수가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-528">If the query optimizer uses a bitmap filter, the number of rows in the output stream is reduced.</span></span> <span data-ttu-id="69bb6-529">입력 스트림의 각 레코드가 한 개의 출력 스트림에 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-529">Each record from an input stream is placed into one output stream.</span></span> <span data-ttu-id="69bb6-530">이 연산자가 순서를 그대로 유지하는 경우에는 모든 입력 스트림이 정렬되어 여러 개의 정렬된 출력 스트림으로 병합되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-530">If this operator is order preserving, all input streams must be ordered and merged into several ordered output streams.</span></span> <span data-ttu-id="69bb6-531">출력이 분할 되는 경우 열에는 `Argument` PARTITION columns: () 조건자와 분할 열이 포함 됩니다. 출력이 정렬 되는 경우 열에 `Argument` ORDER BY: () 조건자와 정렬 될 열이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-531">If the output is partitioned, the `Argument` column contains a PARTITION COLUMNS:() predicate and the partitioning columns.If the output is ordered, the `Argument` column contains an ORDER BY:() predicate and the columns being ordered.</span></span> <span data-ttu-id="69bb6-532">**Repartition Streams** 는 논리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-532">**Repartition Streams** is a logical operator.</span></span> <span data-ttu-id="69bb6-533">이 연산자는 병렬 쿼리 계획에서만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-533">The operator is used only in parallel query plans.</span></span>|  
|<span data-ttu-id="69bb6-534">![Result 언어 요소 아이콘](../../2014/database-engine/media/result-32x.gif "Result 언어 요소 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-534">![Result language element icon](../../2014/database-engine/media/result-32x.gif "Result language element icon")</span></span>|`Result`|<span data-ttu-id="69bb6-535">`Result` 연산자는 쿼리 계획의 끝에 반환되는 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-535">The `Result` operator is the data returned at the end of a query plan.</span></span> <span data-ttu-id="69bb6-536">이는 일반적으로 실행 계획의 루트 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-536">This is usually the root element of a Showplan.</span></span> <span data-ttu-id="69bb6-537">`Result`는 언어 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-537">`Result` is a language element.</span></span>|  
|<span data-ttu-id="69bb6-538">![RID lookup 연산자 아이콘](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "RID lookup 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-538">![RID lookup operator icon](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "RID lookup operator icon")</span></span>|`RID Lookup`|<span data-ttu-id="69bb6-539">`RID Lookup`은 제공된 RID(행 식별자)를 사용하여 힙을 조회하는 책갈피 조회입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-539">`RID Lookup` is a bookmark lookup on a heap using a supplied row identifier (RID).</span></span> <span data-ttu-id="69bb6-540">열에는 `Argument` 테이블의 행을 조회 하는 데 사용 되는 책갈피 레이블 및 행을 조회할 테이블의 이름이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-540">The `Argument` column contains the bookmark label used to look up the row in the table and the name of the table in which the row is looked up.</span></span> <span data-ttu-id="69bb6-541">`RID Lookup`은 항상 NESTED LOOP JOIN과 함께 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-541">`RID Lookup` is always accompanied by a NESTED LOOP JOIN.</span></span> <span data-ttu-id="69bb6-542">`RID Lookup`는 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-542">`RID Lookup` is a physical operator.</span></span> <span data-ttu-id="69bb6-543">책갈피 조회에 대한 자세한 내용은 MSDN SQL Server 블로그의 "[책갈피 조회(Bookmark Lookup)](https://go.microsoft.com/fwlink/?LinkId=132568)"를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="69bb6-543">For more information about bookmark lookups, see "[Bookmark Lookup](https://go.microsoft.com/fwlink/?LinkId=132568)" on the MSDN SQL Server blog.</span></span>|  
|<span data-ttu-id="69bb6-544">없음</span><span class="sxs-lookup"><span data-stu-id="69bb6-544">None</span></span>|`Right Anti Semi Join`|<span data-ttu-id="69bb6-545">`Right Anti Semi Join` 연산자는 첫 번째(최상위) 입력에 일치하는 행이 없는 경우 두 번째(최하위) 입력의 각 행을 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-545">The `Right Anti Semi Join` operator outputs each row from the second (bottom) input when a matching row in the first (top) input does not exist.</span></span> <span data-ttu-id="69bb6-546">일치 하는 행은 열에서 조건자를 충족 하는 행으로 정의 됩니다 `Argument` . 조건자가 없으면 각 행이 일치 하는 행입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-546">A matching row is defined as a row that satisfies the predicate in the `Argument` column (if no predicate exists, each row is a matching row).</span></span> <span data-ttu-id="69bb6-547">`Right Anti Semi Join`는 논리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-547">`Right Anti Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="69bb6-548">없음</span><span class="sxs-lookup"><span data-stu-id="69bb6-548">None</span></span>|`Right Outer Join`|<span data-ttu-id="69bb6-549">`Right Outer Join` 연산자는 두 번째(최하위) 입력 중에서 첫 번째(최상위) 입력과 일치하는 각 행을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-549">The `Right Outer Join` operator returns each row that satisfies the join of the second (bottom) input with each matching row from the first (top) input.</span></span> <span data-ttu-id="69bb6-550">또한 첫 번째 입력과 일치하지 않는 두 번째 입력의 모든 행도 NULL로 조인하여 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-550">It also returns any rows from the second input that had no matching rows in the first input, joined with NULL.</span></span> <span data-ttu-id="69bb6-551">열에 조인 조건자가 없으면 `Argument` 각 행이 일치 하는 행입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-551">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="69bb6-552">`Right Outer Join`는 논리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-552">`Right Outer Join` is a logical operator.</span></span>|  
|<span data-ttu-id="69bb6-553">없음</span><span class="sxs-lookup"><span data-stu-id="69bb6-553">None</span></span>|`Right Semi Join`|<span data-ttu-id="69bb6-554">`Right Semi Join` 연산자는 첫 번째(최상위) 입력에 일치하는 행이 있는 경우 두 번째(최하위) 입력의 각 행을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-554">The `Right Semi Join` operator returns each row from the second (bottom) input when there is a matching row in the first (top) input.</span></span> <span data-ttu-id="69bb6-555">열에 조인 조건자가 없으면 `Argument` 각 행이 일치 하는 행입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-555">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="69bb6-556">`Right Semi Join`는 논리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-556">`Right Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="69bb6-557">![Row count spool 연산자 아이콘](../../2014/database-engine/media/remote-count-spool-32x.gif "Row count spool 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-557">![Row count spool operator icon](../../2014/database-engine/media/remote-count-spool-32x.gif "Row count spool operator icon")</span></span>|<span data-ttu-id="69bb6-558">**Row Count Spool**</span><span class="sxs-lookup"><span data-stu-id="69bb6-558">**Row Count Spool**</span></span>|<span data-ttu-id="69bb6-559">**Row Count Spool** 연산자는 입력을 검색하여 얼마나 많은 행이 있는지 계산하고 데이터는 포함되지 않은 상태로 그 수만큼의 행을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-559">The **Row Count Spool** operator scans the input, counting how many rows are present and returning the same number of rows without any data in them.</span></span> <span data-ttu-id="69bb6-560">이 연산자는 행에 포함된 데이터보다는 행 자체의 존재 유무를 검사하는 것이 중요한 경우에 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-560">This operator is used when it is important to check for the existence of rows, rather than the data contained in the rows.</span></span> <span data-ttu-id="69bb6-561">예를 들어 연산자가 `Nested Loops` left 세미 join 연산을 수행 하 고 조인 조건자가 내부 입력에 적용 되는 경우 행 개수 spool이 연산자의 내부 입력 위쪽에 배치 될 수 있습니다 `Nested Loops` .</span><span class="sxs-lookup"><span data-stu-id="69bb6-561">For example, if a `Nested Loops` operator performs a left semi join operation and the join predicate applies to inner input, a row count spool may be placed at the top of the inner input of the `Nested Loops` operator.</span></span> <span data-ttu-id="69bb6-562">그런 다음 `Nested Loops` 연산자는 내부 측의 실제 데이터가 필요 하지 않기 때문에 행 개수 스풀에 의해 출력 되는 행 수를 확인 하 여 외부 행의 반환 여부를 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-562">Then the `Nested Loops` operator can determine how many rows are output by the row count spool (because the actual data from the inner side is not needed) to determine whether to return the outer row.</span></span> <span data-ttu-id="69bb6-563">**Row Count Spool** 은 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-563">**Row Count Spool** is a physical operator.</span></span>|  
|<span data-ttu-id="69bb6-564">![Segment 연산자 아이콘](../../2014/database-engine/media/segment-32x.gif "Segment 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-564">![Segment operator icon](../../2014/database-engine/media/segment-32x.gif "Segment operator icon")</span></span>|<span data-ttu-id="69bb6-565">**Segment**</span><span class="sxs-lookup"><span data-stu-id="69bb6-565">**Segment**</span></span>|<span data-ttu-id="69bb6-566">**Segment** 는 물리 및 논리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-566">**Segment** is a physical and a logical operator.</span></span> <span data-ttu-id="69bb6-567">이 연산자는 하나 이상의 열 값에 따라 입력 집합을 세그먼트로 나눕니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-567">It divides the input set into segments based on the value of one or more columns.</span></span> <span data-ttu-id="69bb6-568">이러한 열은 **Segment** 연산자의 인수로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-568">These columns are shown as arguments in the **Segment** operator.</span></span> <span data-ttu-id="69bb6-569">그런 다음 연산자는 한 번에 한 세그먼트씩 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-569">The operator then outputs one segment at a time.</span></span>|  
|<span data-ttu-id="69bb6-570">없음</span><span class="sxs-lookup"><span data-stu-id="69bb6-570">None</span></span>|`Segment Repartition`|<span data-ttu-id="69bb6-571">병렬 쿼리 계획에는 반복자라는 개념 영역이 존재하기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-571">In a parallel query plan, sometimes there are conceptual regions of iterators.</span></span> <span data-ttu-id="69bb6-572">이 영역에 있는 모든 반복자는 병렬 스레드에 의해 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-572">All of the iterators within such a region can be executed by parallel threads.</span></span> <span data-ttu-id="69bb6-573">영역 자체는 직렬로 실행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-573">The regions themselves must be executed serially.</span></span> <span data-ttu-id="69bb6-574">개별 영역 내에 있는 일부 `Parallelism` 반복자를 `Branch Repartition`이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-574">Some of the `Parallelism` iterators within an individual region are called `Branch Repartition`.</span></span> <span data-ttu-id="69bb6-575">이러한 두 영역의 경계에 있는 `Parallelism` 반복자를 `Segment Repartition`이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-575">The `Parallelism` iterator at the boundary of two such regions is called `Segment Repartition`.</span></span> <span data-ttu-id="69bb6-576">`Branch Repartition`과 `Segment Repartition`은 논리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-576">`Branch Repartition` and `Segment Repartition` are logical operators.</span></span>|  
|<span data-ttu-id="69bb6-577">![Sequence 연산자 아이콘](../../2014/database-engine/media/sequence-32x.gif "Sequence 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-577">![Sequence operator icon](../../2014/database-engine/media/sequence-32x.gif "Sequence operator icon")</span></span>|`Sequence`|<span data-ttu-id="69bb6-578">`Sequence` 연산자는 광범위한 업데이트 계획을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-578">The `Sequence` operator drives wide update plans.</span></span> <span data-ttu-id="69bb6-579">각 입력은 위에서 아래 방향으로 차례로 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-579">Functionally, it executes each input in sequence (top to bottom).</span></span> <span data-ttu-id="69bb6-580">각 입력은 대개 서로 다른 개체의 업데이트이며</span><span class="sxs-lookup"><span data-stu-id="69bb6-580">Each input is usually an update of a different object.</span></span> <span data-ttu-id="69bb6-581">마지막(최하위) 입력으로부터의 행만 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-581">It returns only those rows that come from its last (bottom) input.</span></span> <span data-ttu-id="69bb6-582">`Sequence`은 논리 및 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-582">`Sequence` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-583">![Sequence project 연산자 아이콘](../../2014/database-engine/media/sequence-project-32x.gif "Sequence project 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-583">![Sequence project operator icon](../../2014/database-engine/media/sequence-project-32x.gif "Sequence project operator icon")</span></span>|`Sequence Project`|<span data-ttu-id="69bb6-584">`Sequence Project` 연산자는 열을 추가하여 정렬된 집합에 대한 계산을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-584">The `Sequence Project` operator adds columns to perform computations over an ordered set.</span></span> <span data-ttu-id="69bb6-585">이 연산자는 하나 이상의 열 값에 따라 입력 집합을 세그먼트로 나눕니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-585">It divides the input set into segments based on the value of one or more columns.</span></span> <span data-ttu-id="69bb6-586">그런 다음 연산자는 한 번에 한 세그먼트씩 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-586">The operator then outputs one segment at a time.</span></span> <span data-ttu-id="69bb6-587">이런 열은 `Sequence Project` 연산자에서 인수로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-587">These columns are shown as arguments in the `Sequence Project` operator.</span></span> <span data-ttu-id="69bb6-588">`Sequence Project`은 논리 및 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-588">`Sequence Project` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-589">![Snapshot 커서 연산자 아이콘](../../2014/database-engine/media/snapshot-32x.gif "Snapshot 커서 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-589">![Snapshot cursor operator icon](../../2014/database-engine/media/snapshot-32x.gif "Snapshot cursor operator icon")</span></span>|<span data-ttu-id="69bb6-590">**스냅샷**</span><span class="sxs-lookup"><span data-stu-id="69bb6-590">**Snapshot**</span></span>|<span data-ttu-id="69bb6-591">**Snapshot** 연산자는 다른 연산자가 만든 변경 내용을 확인하지 않는 커서를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-591">The **Snapshot** operator creates a cursor that does not see changes made by others.</span></span>|  
|<span data-ttu-id="69bb6-592">![Sort 연산자 아이콘](../../2014/database-engine/media/sort-32x.gif "Sort 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-592">![Sort operator icon](../../2014/database-engine/media/sort-32x.gif "Sort operator icon")</span></span>|`Sort`|<span data-ttu-id="69bb6-593">`Sort`연산자는 모든 들어오는 행을 정렬 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-593">The `Sort` operator sorts all incoming rows.</span></span> <span data-ttu-id="69bb6-594">`Argument`이 작업에서 중복을 제거 하는 경우 열에는 DISTINCT ORDER by: () 조건자가 포함 되 고, 정렬 된 열을 쉼표로 구분한 목록이 있는 ORDER by: () 조건자가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-594">The `Argument` column contains either a DISTINCT ORDER BY:() predicate if duplicates are removed by this operation, or an ORDER BY:() predicate with a comma-separated list of the columns being sorted.</span></span> <span data-ttu-id="69bb6-595">열이 오름차순으로 정렬되는 경우에는 ASC 값, 내림차순으로 정렬되는 경우에는 DESC 값이 열의 접두사로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-595">The columns are prefixed with the value ASC if the columns are sorted in ascending order, or the value DESC if the columns are sorted in descending order.</span></span> <span data-ttu-id="69bb6-596">`Sort`은 논리 및 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-596">`Sort` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-597">![Split 연산자 아이콘](../../2014/database-engine/media/split-32x.gif "Split 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-597">![Split operator icon](../../2014/database-engine/media/split-32x.gif "Split operator icon")</span></span>|`Split`|<span data-ttu-id="69bb6-598">`Split`연산자는 업데이트 처리를 최적화 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-598">The `Split` operator is used to optimize update processing.</span></span> <span data-ttu-id="69bb6-599">즉, 각 업데이트 작업을 삭제 및 삽입 작업으로 분할합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-599">It splits each update operation into a delete and an insert operation.</span></span> <span data-ttu-id="69bb6-600">`Split`은 논리 및 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-600">`Split` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-601">![Spool 연산자 아이콘](../../2014/database-engine/media/spool-32x.gif "Spool 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-601">![Spool operator icon](../../2014/database-engine/media/spool-32x.gif "Spool operator icon")</span></span>|<span data-ttu-id="69bb6-602">**Spool**</span><span class="sxs-lookup"><span data-stu-id="69bb6-602">**Spool**</span></span>|<span data-ttu-id="69bb6-603">**Spool** 연산자는 데이터베이스에 중간 쿼리 결과를 저장 합니다 `tempdb` .</span><span class="sxs-lookup"><span data-stu-id="69bb6-603">The **Spool** operator saves an intermediate query result to the `tempdb` database.</span></span>|  
|<span data-ttu-id="69bb6-604">![Stream aggregate 연산자 아이콘](../../2014/database-engine/media/stream-aggregate-32x.gif "Stream aggregate 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-604">![Stream aggregate operator icon](../../2014/database-engine/media/stream-aggregate-32x.gif "Stream aggregate operator icon")</span></span>|`Stream Aggregate`|<span data-ttu-id="69bb6-605">`Stream Aggregate` 연산자는 하나 이상의 열로 행을 그룹화한 후 쿼리가 반환한 하나 이상의 집계 식을 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-605">The `Stream Aggregate` operator groups rows by one or more columns and then calculates one or more aggregate expressions returned by the query.</span></span> <span data-ttu-id="69bb6-606">이 연산자의 출력은 쿼리에서 이후 연산자에 의해 참조되거나 클라이언트에 반환되거나 둘 다 수행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-606">The output of this operator can be referenced by later operators in the query, returned to the client, or both.</span></span> <span data-ttu-id="69bb6-607">`Stream Aggregate` 연산자를 사용하려면 입력이 그룹 내의 열을 기준으로 정렬되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-607">The `Stream Aggregate` operator requires input ordered by the columns within its groups.</span></span> <span data-ttu-id="69bb6-608">최적화 프로그램은 앞서 `Sort` 연산자 또는 정렬된 Index Seek나 Index Scan을 통해 데이터를 아직 정렬하지 않은 경우 이 연산자보다 먼저 `Sort` 연산자를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-608">The optimizer will use a `Sort` operator prior to this operator if the data is not already sorted due to a prior `Sort` operator or due to an ordered index seek or scan.</span></span> <span data-ttu-id="69bb6-609">의 SHOWPLAN_ALL 문 또는 그래픽 실행 계획에서는 [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] GROUP BY 조건자의 열이 열에 나열 되 `Argument` 고 집계 식이 **정의 된 값** 열에 나열 됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-609">In the SHOWPLAN_ALL statement or the graphical execution plan in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], the columns in the GROUP BY predicate are listed in the `Argument` column, and the aggregate expressions are listed in the **Defined Values** column.</span></span> <span data-ttu-id="69bb6-610">`Stream Aggregate`는 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-610">`Stream Aggregate` is a physical operator.</span></span>|  
|<span data-ttu-id="69bb6-611">![Switch 연산자 아이콘](../../2014/database-engine/media/switch-32x.gif "Switch 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-611">![Switch operator icon](../../2014/database-engine/media/switch-32x.gif "Switch operator icon")</span></span>|<span data-ttu-id="69bb6-612">**스위치**</span><span class="sxs-lookup"><span data-stu-id="69bb6-612">**Switch**</span></span>|<span data-ttu-id="69bb6-613">**Switch** 는 *n* 개의 입력을 갖는 특수한 유형의 연결 반복기입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-613">**Switch** is a special type of concatenation iterator that has *n* inputs.</span></span> <span data-ttu-id="69bb6-614">각 **Switch** 연산자에 식이 연결되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-614">An expression is associated with each **Switch** operator.</span></span> <span data-ttu-id="69bb6-615">식의 반환 값(0과 *n*-1 사이)에 따라 **Switch** 는 적절한 입력 스트림을 출력 스트림으로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-615">Depending on the return value of the expression (between 0 and *n*-1), **Switch** copies the appropriate input stream to the output stream.</span></span> <span data-ttu-id="69bb6-616">**Switch** 의 용도 중 하나는 **TOP** 연산자 같은 특정 연산자와 빠른 전진 커서가 관련된 쿼리 계획을 구현하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-616">One use of **Switch** is to implement query plans involving fast forward cursors with certain operators such as the **TOP** operator.</span></span> <span data-ttu-id="69bb6-617">**Switch** 는 논리 연산자이면서 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-617">**Switch** is both a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-618">![Table delete 연산자 아이콘](../../2014/database-engine/media/table-delete-32x.gif "Table delete 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-618">![Table delete operator icon](../../2014/database-engine/media/table-delete-32x.gif "Table delete operator icon")</span></span>|`Table Delete`|<span data-ttu-id="69bb6-619">`Table Delete`물리 연산자는 `Argument` 쿼리 실행 계획의 열에 지정 된 테이블에서 행을 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-619">The `Table Delete` physical operator deletes rows from the table specified in the `Argument` column of the query execution plan.</span></span>|  
|<span data-ttu-id="69bb6-620">![Table insert 연산자 아이콘](../../2014/database-engine/media/table-insert-32x.gif "Table insert 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-620">![Table insert operator icon](../../2014/database-engine/media/table-insert-32x.gif "Table insert operator icon")</span></span>|`Table Insert`|<span data-ttu-id="69bb6-621">`Table Insert`연산자는 입력의 행을 `Argument` 쿼리 실행 계획의 열에 지정 된 테이블에 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-621">The `Table Insert` operator inserts rows from its input into the table specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="69bb6-622">`Argument` 열에는 각 열의 설정 값을 나타내는 SET:() 조건자도 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-622">The `Argument` column also contains a SET:() predicate, which indicates the value to which each column is set.</span></span> <span data-ttu-id="69bb6-623">`Table Insert`에 삽입 값에 대한 자식이 없는 경우 삽입된 행을 Insert 연산자 자체에서 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-623">If `Table Insert` has no children for insert values, then the row inserted is taken from the Insert operator itself.</span></span> <span data-ttu-id="69bb6-624">`Table Insert`는 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-624">`Table Insert` is a physical operator.</span></span>|  
|<span data-ttu-id="69bb6-625">![Table merge 연산자](../../2014/database-engine/media/table-merge-32x.gif "Table merge 연산자")</span><span class="sxs-lookup"><span data-stu-id="69bb6-625">![Table merge operator](../../2014/database-engine/media/table-merge-32x.gif "Table merge operator")</span></span>|<span data-ttu-id="69bb6-626">**Table Merge**</span><span class="sxs-lookup"><span data-stu-id="69bb6-626">**Table Merge**</span></span>|<span data-ttu-id="69bb6-627">**Table Merge** 연산자는 병합 데이터 스트림을 힙에 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-627">The **Table Merge** operator applies a merge data stream to a heap.</span></span> <span data-ttu-id="69bb6-628">연산자는 연산자의 열에 지정 된 테이블에서 행을 삭제, 업데이트 또는 삽입 합니다 `Argument` .</span><span class="sxs-lookup"><span data-stu-id="69bb6-628">The operator deletes, updates, or inserts rows in the table specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="69bb6-629">수행 되는 실제 작업은 연산자의 열에 지정 된 **작업** 열의 런타임 값에 따라 달라 집니다 `Argument` .</span><span class="sxs-lookup"><span data-stu-id="69bb6-629">The actual operation performed depends on the run-time value of the **ACTION** column specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="69bb6-630">**Table Merge** 는 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-630">**Table Merge** is a physical operator.</span></span>|  
|<span data-ttu-id="69bb6-631">![Table scan 연산자 아이콘](../../2014/database-engine/media/table-scan-32x.gif "Table scan 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-631">![Table scan operator icon](../../2014/database-engine/media/table-scan-32x.gif "Table scan operator icon")</span></span>|`Table Scan`|<span data-ttu-id="69bb6-632">`Table Scan`연산자는 `Argument` 쿼리 실행 계획의 열에 지정 된 테이블에서 모든 행을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-632">The `Table Scan` operator retrieves all rows from the table specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="69bb6-633">WHERE: () 조건자가 열에 나타나는 경우에는 `Argument` 조건자에 부합 되는 행만 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-633">If a WHERE:() predicate appears in the `Argument` column, only those rows that satisfy the predicate are returned.</span></span> <span data-ttu-id="69bb6-634">`Table Scan`은 논리 및 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-634">`Table Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-635">![Table spool 연산자 아이콘](../../2014/database-engine/media/table-spool-32x.gif "Table spool 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-635">![Table spool operator icon](../../2014/database-engine/media/table-spool-32x.gif "Table spool operator icon")</span></span>|<span data-ttu-id="69bb6-636">**Table Spool**</span><span class="sxs-lookup"><span data-stu-id="69bb6-636">**Table Spool**</span></span>|<span data-ttu-id="69bb6-637">**Table Spool** 연산자는 입력을 검색하고 각 행의 복사본을 숨겨진 스풀 테이블에 배치합니다. 이 스풀 테이블은 [tempdb](../relational-databases/databases/tempdb-database.md) 데이터베이스에 저장되어 쿼리 사용 기간 중에만 존재합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-637">The **Table Spool** operator scans the input and places a copy of each row in a hidden spool table that is stored in the [tempdb](../relational-databases/databases/tempdb-database.md) database and existing only for the lifetime of the query.</span></span> <span data-ttu-id="69bb6-638">연산자가 되감을 (예: 연산자)이 고 리바인딩이 필요 하지 않은 경우에는 입력을 다시 검사 하는 `Nested Loops` 대신 스풀링된 데이터가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-638">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span> <span data-ttu-id="69bb6-639">**Table Spool** 은 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-639">**Table Spool** is a physical operator.</span></span>|  
|<span data-ttu-id="69bb6-640">![Table update 연산자 아이콘](../../2014/database-engine/media/table-update-32x.gif "Table update 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-640">![Table update operator icon](../../2014/database-engine/media/table-update-32x.gif "Table update operator icon")</span></span>|`Table Update`|<span data-ttu-id="69bb6-641">`Table Update`물리 연산자는 `Argument` 쿼리 실행 계획의 열에 지정 된 테이블의 입력 행을 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-641">The `Table Update` physical operator updates input rows in the table specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="69bb6-642">SET:() 조건자는 각 업데이트된 열의 값을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-642">The SET:() predicate determines the value of each updated column.</span></span> <span data-ttu-id="69bb6-643">이러한 값은 SET 절 또는 이 연산자의 다른 곳과 이 쿼리 내의 다른 곳에서 참조될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-643">These values may be referenced in the SET clause or elsewhere within this operator as well as elsewhere within this query.</span></span>|  
|<span data-ttu-id="69bb6-644">![Table-valued function 연산자 아이콘](../../2014/database-engine/media/table-valued-function-32x.gif "Table-valued function 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-644">![Table-valued function operator icon](../../2014/database-engine/media/table-valued-function-32x.gif "Table-valued function operator icon")</span></span>|<span data-ttu-id="69bb6-645">**Table-valued Function**</span><span class="sxs-lookup"><span data-stu-id="69bb6-645">**Table-valued Function**</span></span>|<span data-ttu-id="69bb6-646">**Table-valued Function** 연산자는 테이블 반환 함수( [!INCLUDE[tsql](../includes/tsql-md.md)] 또는 CLR)를 계산하고 결과 행을 [tempdb](../relational-databases/databases/tempdb-database.md) 데이터베이스에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-646">The **Table-valued Function** operator evaluates a table-valued function (either [!INCLUDE[tsql](../includes/tsql-md.md)] or CLR), and stores the resulting rows in the [tempdb](../relational-databases/databases/tempdb-database.md) database.</span></span> <span data-ttu-id="69bb6-647">부모 반복기가 행을 요청 하면 **테이블 반환 함수** 는에서 행을 반환 합니다 `tempdb` .</span><span class="sxs-lookup"><span data-stu-id="69bb6-647">When the parent iterators request the rows, **Table-valued Function** returns the rows from `tempdb`.</span></span><br /><br /> <span data-ttu-id="69bb6-648">테이블 반환 함수를 호출하는 쿼리는 **테이블 반환 함수** 반복자로 쿼리 계획을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-648">Queries with calls to table-valued functions generate query plans with the **Table-valued Function** iterator.</span></span> <span data-ttu-id="69bb6-649">다양한 매개 변수 값으로**테이블 반환 함수** 를 계산할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-649">**Table-valued Function** can be evaluated with different parameter values:</span></span><br /><br /> <span data-ttu-id="69bb6-650">**테이블 반환 함수 XML 판독기** 는 매개 변수로 XML BLOB을 입력하여 XML 문서순으로 정렬된 XML 노드를 나타내는 행 집합을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-650">**Table-valued Function XML Reader** inputs an XML BLOB as a parameter and produces a rowset representing XML nodes in XML document order.</span></span> <span data-ttu-id="69bb6-651">다른 입력 매개 변수를 사용하여 XML 문서의 일부만 반환하도록 XML 노드를 제한할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-651">Other input parameters may restrict XML nodes returned to a subset of XML document.</span></span><br /><br /> <span data-ttu-id="69bb6-652">**XPath 필터가 포함된 테이블 반환 함수 XML 판독기** 는 XPath 식을 만족하는 XML 노드로 출력을 제한하는 특수한 유형의 **XML 판독기 테이블 반환 함수** 입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-652">**Table Valued Function XML Reader with XPath filter** is a special type of **XML Reader Table-valued Function** that restricts output to XML nodes satisfying an XPath expression.</span></span><br /><br /> <br /><br /> <span data-ttu-id="69bb6-653">**테이블 반환 함수** 는 논리/물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-653">**Table-valued Function** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-654">![Top 연산자 아이콘](../../2014/database-engine/media/top-32x.gif "Top 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-654">![Top operator icon](../../2014/database-engine/media/top-32x.gif "Top operator icon")</span></span>|<span data-ttu-id="69bb6-655">**상위**</span><span class="sxs-lookup"><span data-stu-id="69bb6-655">**Top**</span></span>|<span data-ttu-id="69bb6-656">**Top** 연산자는 입력을 검색하고 정렬 순서 등을 기준으로 행의 지정된 첫째 번호나 백분율만 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-656">The **Top** operator scans the input, returning only the first specified number or percent of rows, possibly based on a sort order.</span></span> <span data-ttu-id="69bb6-657">열에는 `Argument` 동률을 확인할 열 목록이 포함 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-657">The `Argument` column can contain a list of the columns that are being checked for ties.</span></span> <span data-ttu-id="69bb6-658">업데이트 계획에서는 행 개수 제한을 보장하기 위해 **Top** 연산자를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-658">In update plans, the **Top** operator is used to enforce row count limits.</span></span> <span data-ttu-id="69bb6-659">**Top** 은 논리 및 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-659">**Top** is a logical and physical operator.</span></span> <span data-ttu-id="69bb6-660">**Top** 은 논리 및 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-660">**Top** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="69bb6-661">None</span><span class="sxs-lookup"><span data-stu-id="69bb6-661">None</span></span>|<span data-ttu-id="69bb6-662">**Top N Sort**</span><span class="sxs-lookup"><span data-stu-id="69bb6-662">**Top N Sort**</span></span>|<span data-ttu-id="69bb6-663">**Top n Sort** 는 `Sort` 전체 결과 집합이 아니라 처음 *n 개* 행만 필요 하다는 점을 제외 하 고 반복기와 유사 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-663">**Top N Sort** is similar to the `Sort` iterator, except that only the first *N* rows are needed, and not the entire result set.</span></span> <span data-ttu-id="69bb6-664">*N*의 값이 작으면 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 쿼리 실행 엔진이 메모리에서 전체 정렬 작업을 수행하려 하고</span><span class="sxs-lookup"><span data-stu-id="69bb6-664">For small values of *N*, the [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] query execution engine attempts to perform the entire sort operation in memory.</span></span> <span data-ttu-id="69bb6-665">*N*의 값이 크면 *N* 을 매개 변수로 사용하지 않는 일반적인 정렬 방법으로 다시 정렬합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-665">For large values of *N*, the query execution engine resorts to the more generic method of sorting to which *N* is not a parameter.</span></span>|  
|<span data-ttu-id="69bb6-666">![Extended 연산자(UDX) 아이콘](../../2014/database-engine/media/udx-32x.gif "Extended 연산자(UDX) 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-666">![Extended operator (UDX) icon](../../2014/database-engine/media/udx-32x.gif "Extended operator (UDX) icon")</span></span>|`UDX`|<span data-ttu-id="69bb6-667">확장 연산자(UDX)는 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]에서 여러 XQuery 및 XPath 연산 중 하나를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-667">Extended Operators (UDX) implement one of many XQuery and XPath operations in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="69bb6-668">모든 UDX 연산자는 논리/물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-668">All UDX operators are both logical and physical operators.</span></span><br /><br /> <span data-ttu-id="69bb6-669">확장 연산자(UDX) `FOR XML`은 XML 표현으로 입력되는 관계형 행 집합을 하나의 BLOB 열에 직렬화하여 한 행으로 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-669">Extended operator (UDX) `FOR XML` is used to serialize the relational row set it inputs into XML representation in a single BLOB column in a single output row.</span></span> <span data-ttu-id="69bb6-670">이 연산자는 입력 순서에 따라 결과가 달라지는 XML 집계 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-670">It is an order sensitive XML aggregation operator.</span></span><br /><br /> <span data-ttu-id="69bb6-671">확장 연산자(UDX) `XML SERIALIZER`는 입력 순서에 따라 결과가 달라지는 XML 집계 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-671">Extended operator (UDX) `XML SERIALIZER` is an order sensitive XML aggregation operator.</span></span> <span data-ttu-id="69bb6-672">이 연산자는 XML 문서 순서대로 입력된 XML 노드 또는 XQuery 스칼라 행을 하나의 XML BLOB 열로 직렬화하여 한 XML 행으로 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-672">It inputs rows representing XML nodes or XQuery scalars in XML document order and produces a serialized XML BLOB in a single XML column in a single output row.</span></span><br /><br /> <span data-ttu-id="69bb6-673">확장 연산자(UDX) `XML FRAGMENT SERIALIZER`는 XQuery 삽입 데이터 수정 확장에 삽입되는 XML 조각 입력 행을 처리하는 데 사용되는 특별한 유형의 `XML SERIALIZER`입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-673">Extended operator (UDX) `XML FRAGMENT SERIALIZER` is a special type of `XML SERIALIZER` that is used for processing input rows representing XML fragments being inserted in XQuery insert data modification extension.</span></span><br /><br /> <span data-ttu-id="69bb6-674">확장 연산자(UDX) `XQUERY STRING`은 XML 노드로 입력된 입력 행의 XQuery 문자열 값을 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-674">Extended operator (UDX) `XQUERY STRING` evaluates the XQuery string value of input rows representing XML nodes.</span></span> <span data-ttu-id="69bb6-675">이 연산자는 입력 순서에 따라 결과가 달라지는 문자열 집계 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-675">It is an order sensitive string aggregation operator.</span></span> <span data-ttu-id="69bb6-676">입력된 문자열 값을 포함하는 XQuery 스칼라를 한 행으로 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-676">It outputs one row with columns representing the XQuery scalar that contains string value of the input.</span></span><br /><br /> <span data-ttu-id="69bb6-677">확장 연산자(UDX) `XQUERY LIST DECOMPOSER`는 XQuery 목록 분해 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-677">Extended operator (UDX) `XQUERY LIST DECOMPOSER` is an XQuery list decomposition operator.</span></span> <span data-ttu-id="69bb6-678">이 연산자는 XML 노드를 입력받아 각 행의 입력이 XSD 목록 유형인 경우 목록 요소 값을 포함하는 XQuery 스칼라를 각각 하나 이상의 행으로 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-678">For each input row representing an XML node it produces one or more rows each representing XQuery scalar containing a list element value if the input is of XSD list type.</span></span><br /><br /> <span data-ttu-id="69bb6-679">확장 연산자(UDX) `XQUERY DATA`는 XML 노드를 입력받아 입력 값에 대한 XQuery fn:data() 함수를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-679">Extended operator (UDX) `XQUERY DATA` evaluates the XQuery fn:data() function on input representing XML nodes.</span></span> <span data-ttu-id="69bb6-680">이 연산자는 입력 순서에 따라 결과가 달라지는 문자열 집계 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-680">It is an order sensitive string aggregation operator.</span></span> <span data-ttu-id="69bb6-681">**fn:data()** 의 결과를 포함하는 XQuery 스칼라를 열로 구성한 하나의 행을 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-681">It outputs one row with columns representing XQuery scalar that contains the result of **fn:data()**.</span></span><br /><br /> <span data-ttu-id="69bb6-682">확장 연산자(UDX) `XQUERY CONTAINS`는 XML 노드를 입력받아 입력 값에 대한 XQuery fn:contains() 함수를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-682">Extended operator `XQUERY CONTAINS` evaluates the XQuery fn:contains() function on input representing XML nodes.</span></span> <span data-ttu-id="69bb6-683">이 연산자는 입력 순서에 따라 결과가 달라지는 문자열 집계 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-683">It is an order sensitive string aggregation operator.</span></span> <span data-ttu-id="69bb6-684">**fn:contains()** 의 결과를 포함하는 XQuery 스칼라를 열로 구성한 하나의 행을 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-684">It outputs one row with columns representing XQuery scalar that contains the result of **fn:contains()**.</span></span><br /><br /> <span data-ttu-id="69bb6-685">확장 연산자는 `UPDATE XML NODE` xml 유형에 대 한 **modify ()** 메서드의 XQuery 대체 데이터 수정 확장의 xml 노드를 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-685">Extended operator `UPDATE XML NODE` updates XML node in the XQuery replace data modification extension in the **modify()** method on XML type.</span></span>|  
|<span data-ttu-id="69bb6-686">None</span><span class="sxs-lookup"><span data-stu-id="69bb6-686">None</span></span>|<span data-ttu-id="69bb6-687">**Union**</span><span class="sxs-lookup"><span data-stu-id="69bb6-687">**Union**</span></span>|<span data-ttu-id="69bb6-688">**Union** 논리 연산자는 여러 개의 입력을 검색하여 검색된 각 행을 출력하고 중복 요소는 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-688">The **Union** operator scans multiple inputs, outputting each row scanned and removing duplicates.</span></span> <span data-ttu-id="69bb6-689">**Union** 은 논리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-689">**Union** is a logical operator.</span></span>|  
|<span data-ttu-id="69bb6-690">![Update(데이터베이스 엔진) 연산자 아이콘](../../2014/database-engine/media/update-32x.gif "Update(데이터베이스 엔진) 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-690">![Update (Database Engine) operator icon](../../2014/database-engine/media/update-32x.gif "Update (Database Engine) operator icon")</span></span>|`Update`|<span data-ttu-id="69bb6-691">`Update`연산자는 `Argument` 쿼리 실행 계획의 열에 지정 된 개체의 입력에서 각 행을 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-691">The `Update` operator updates each row from its input in the object specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="69bb6-692">`Update`는 논리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-692">`Update` is a logical operator.</span></span> <span data-ttu-id="69bb6-693">물리 연산자는 `Table Update`, `Index Update` 또는 `Clustered Index Update`입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-693">The physical operator is `Table Update`, `Index Update`, or `Clustered Index Update`.</span></span>|  
|<span data-ttu-id="69bb6-694">![While 언어 요소 아이콘](../../2014/database-engine/media/while-32x.gif "While 언어 요소 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-694">![While language element icon](../../2014/database-engine/media/while-32x.gif "While language element icon")</span></span>|`While`|<span data-ttu-id="69bb6-695">`While` 연산자는 [!INCLUDE[tsql](../includes/tsql-md.md)] while 루프를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-695">The `While` operator implements the [!INCLUDE[tsql](../includes/tsql-md.md)] while loop.</span></span> <span data-ttu-id="69bb6-696">`While`은 언어 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-696">`While` is a language element</span></span>|  
|<span data-ttu-id="69bb6-697">![Table spool 연산자 아이콘](../../2014/database-engine/media/table-spool-32x.gif "Table spool 연산자 아이콘")</span><span class="sxs-lookup"><span data-stu-id="69bb6-697">![Table spool operator icon](../../2014/database-engine/media/table-spool-32x.gif "Table spool operator icon")</span></span>|`Window Spool`|<span data-ttu-id="69bb6-698">`Window Spool` 연산자는 각 행을 행과 관련된 창을 나타내는 행 집합으로 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-698">The `Window Spool` operator expands each row into the set of rows that represents the window associated with it.</span></span> <span data-ttu-id="69bb6-699">쿼리에서 OVER 절은 쿼리 결과 집합과 창 함수를 포함하는 창을 정의한 다음 창의 각 행에 대한 값을 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-699">In a query, the OVER clause defines the window within a query result set and a window function then computes a value for each row in the window.</span></span> <span data-ttu-id="69bb6-700">`Window Spool`은 논리 및 물리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="69bb6-700">`Window Spool` is a logical and physical operator.</span></span>|  
  
  
