---
title: 데이터 형식 사용 | Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- ODBC data types
- ODBC data types, about ODBC data types
- SQL Server Native Client ODBC driver, result sets
- ODBC applications, result sets
- data types [ODBC]
- SQL Server Native Client ODBC driver, data types
- data types [ODBC], about data types
ms.assetid: 4f19b0d6-94ac-4a98-a121-57d38787864c
author: rothja
ms.author: jroth
ms.openlocfilehash: 8333f45fd9e3b742b3765efaee5ae7a865161bc2
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87740911"
---
# <a name="data-type-usage"></a><span data-ttu-id="a3bb5-102">데이터 형식 사용</span><span class="sxs-lookup"><span data-stu-id="a3bb5-102">Data Type Usage</span></span>
  <span data-ttu-id="a3bb5-103">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]Native CLIENT ODBC 드라이버는 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 다음과 같은 데이터 형식을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-103">The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver and [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] impose the following use of data types.</span></span>  
  
|<span data-ttu-id="a3bb5-104">데이터 형식</span><span class="sxs-lookup"><span data-stu-id="a3bb5-104">Data type</span></span>|<span data-ttu-id="a3bb5-105">제한 사항</span><span class="sxs-lookup"><span data-stu-id="a3bb5-105">Limitation</span></span>|  
|---------------|----------------|  
|<span data-ttu-id="a3bb5-106">날짜 리터럴</span><span class="sxs-lookup"><span data-stu-id="a3bb5-106">Date literals</span></span>|<span data-ttu-id="a3bb5-107">날짜 리터럴은 SQL_TYPE_TIMESTAMP 열 ( [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] **datetime** 또는 **smalldatetime**의 데이터 형식)에 저장 된 경우 시간 값 12:00:00:00:00:00:00:00:00:00.000</span><span class="sxs-lookup"><span data-stu-id="a3bb5-107">Date literals, when stored in a SQL_TYPE_TIMESTAMP column ([!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] data types of **datetime** or **smalldatetime**), have a time value of 12:00:00.000 A.M.</span></span>|  
|<span data-ttu-id="a3bb5-108">**money** 및 **smallmoney**</span><span class="sxs-lookup"><span data-stu-id="a3bb5-108">**money** and **smallmoney**</span></span>|<span data-ttu-id="a3bb5-109">**Money** 및 **smallmoney** 데이터 형식의 정수 부분만 의미가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-109">Only the integer parts of the **money** and **smallmoney** data types are significant.</span></span> <span data-ttu-id="a3bb5-110">데이터 형식 변환 중에 SQL **money** 데이터의 소수 부분이 잘린 경우 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC 드라이버는 오류가 아닌 경고를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-110">If the decimal part of SQL **money** data is truncated during data type conversion, the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver returns a warning, not an error.</span></span>|  
|<span data-ttu-id="a3bb5-111">SQL_BINARY(Null 허용)</span><span class="sxs-lookup"><span data-stu-id="a3bb5-111">SQL_BINARY (nullable)</span></span>|<span data-ttu-id="a3bb5-112">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 6.0 이전 버전의 인스턴스에 연결되어 있으면 SQL_BINARY 열에서 Null을 허용하는 경우 데이터 원본에 저장된 데이터에 0이 붙지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-112">When connected to an instance of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] version 6.0 and earlier, if a SQL_BINARY column is nullable, the data that is stored in the data source is not padded with zeroes.</span></span> <span data-ttu-id="a3bb5-113">이러한 열의 데이터가 검색 되 면 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native CLIENT ODBC 드라이버는 오른쪽에 0으로 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-113">When data from such a column is retrieved, the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver pads it with zeroes on the right.</span></span> <span data-ttu-id="a3bb5-114">하지만 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]가 수행한 작업(예: 연결)에서 만들어진 데이터에는 이러한 패딩이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-114">However, data that is created in operations performed by [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], such as concatenation, does not have such padding.</span></span><br /><br /> <span data-ttu-id="a3bb5-115">또한 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 6.0 이전 버전의 인스턴스에서 데이터가 이러한 열에 배치되면 데이터가 너무 길어 열에 맞지 않을 경우 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]에서 오른쪽의 데이터를 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-115">Also, when data is placed in such a column in an instance of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 6.0 or earlier, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] truncates the data on the right if it is too long to fit into the column.</span></span> <span data-ttu-id="a3bb5-116">**참고:**  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]Native CLIENT ODBC 드라이버는 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 6.5 및 이전 버전에 대 한 연결을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-116">**Note:**  The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver does support connecting to [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 6.5 and earlier.</span></span>|  
|<span data-ttu-id="a3bb5-117">SQL_CHAR(잘림)</span><span class="sxs-lookup"><span data-stu-id="a3bb5-117">SQL_CHAR (truncation)</span></span>|<span data-ttu-id="a3bb5-118">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 6.0 이전 버전의 인스턴스에 연결되어 있고 데이터가 SQL_CHAR 열에 배치되면 데이터가 너무 길어 열에 맞지 않을 경우 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]에서 경고 없이 오른쪽의 데이터를 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-118">When connected to an instance of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 6.0 and earlier, and data is placed into a SQL_CHAR column, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] truncates it on the right without warning if the data is too long to fit into the column.</span></span> <span data-ttu-id="a3bb5-119">**참고:**  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]Native CLIENT ODBC 드라이버는 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 6.5 및 이전 버전에 대 한 연결을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-119">**Note:**  The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver does support connecting to [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 6.5 and earlier.</span></span>|  
|<span data-ttu-id="a3bb5-120">SQL_CHAR(Null 허용)</span><span class="sxs-lookup"><span data-stu-id="a3bb5-120">SQL_CHAR (nullable)</span></span>|<span data-ttu-id="a3bb5-121">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 6.0 이전 버전의 인스턴스에 연결되어 있으면 SQL_CHAR 열에서 Null을 허용하는 경우 데이터 원본에 저장된 데이터에 공백이 붙지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-121">When connected to an instance of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 6.0 and earlier, if a SQL_CHAR column is nullable, the data that is stored in the data source is not padded with blanks.</span></span> <span data-ttu-id="a3bb5-122">이러한 열의 데이터가 검색 되 면 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native CLIENT ODBC 드라이버는 오른쪽에 공백을 사용 하 여 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-122">When data from such a column is retrieved, the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver pads it with blanks on the right.</span></span> <span data-ttu-id="a3bb5-123">하지만 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]가 수행한 작업(예: 연결)에서 만들어진 데이터에는 이러한 패딩이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-123">However, data that is created in operations performed by [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], such as concatenation, does not have such padding.</span></span> <span data-ttu-id="a3bb5-124">**참고:**  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]Native CLIENT ODBC 드라이버는 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 6.5 및 이전 버전에 대 한 연결을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-124">**Note:**  The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver does support connecting to [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 6.5 and earlier.</span></span>|  
|<span data-ttu-id="a3bb5-125">SQL_LONGVARBINARY, SQL_LONGVARCHAR, SQL_WLONGVARCHAR</span><span class="sxs-lookup"><span data-stu-id="a3bb5-125">SQL_LONGVARBINARY, SQL_LONGVARCHAR, SQL_WLONGVARCHAR</span></span>|<span data-ttu-id="a3bb5-126">인스턴스에 연결 된 경우 여러 행에 영향을 주는 SQL_LONGVARBINARY, SQL_LONGVARCHAR 또는 SQL_WLONGVARCHAR 데이터 형식 (WHERE 절 사용)의 열 업데이트가 완전히 지원 됩니다 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] .\* x\* 이상.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-126">Updates of columns with SQL_LONGVARBINARY, SQL_LONGVARCHAR, or SQL_WLONGVARCHAR data types (using a WHERE clause) that affect multiple rows are fully supported when connected to an instance of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 6.*x* and later.</span></span> <span data-ttu-id="a3bb5-127">4.2 x 인스턴스에 연결 된 경우 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] S1000*x*"부분 삽입/업데이트" 라는 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-127">When connected to an instance of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 4.2*x*, an S1000 error, "Partial insert/update.</span></span> <span data-ttu-id="a3bb5-128">텍스트 또는 이미지 열의 삽입/업데이트가 실패했습니다"가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-128">The insert/update of a text or image column(s) did not succeed" is returned if the update affects more than one row.</span></span> <span data-ttu-id="a3bb5-129">**참고:**  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]Native CLIENT ODBC 드라이버는 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 6.5 및 이전 버전에 대 한 연결을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-129">**Note:**  The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver does support connecting to [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 6.5 and earlier.</span></span>|  
|<span data-ttu-id="a3bb5-130">문자열 함수 매개 변수</span><span class="sxs-lookup"><span data-stu-id="a3bb5-130">String function parameters</span></span>|<span data-ttu-id="a3bb5-131">문자열 함수에 대 한 *string_exp* 매개 변수는 SQL_CHAR 또는 SQL_VARCHAR 데이터 형식 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-131">*string_exp* parameters to the string functions must be of data type SQL_CHAR or SQL_VARCHAR.</span></span> <span data-ttu-id="a3bb5-132">SQL_LONG_VARCHAR 데이터 형식은 문자열 함수에서 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-132">SQL_LONG_VARCHAR data types are not supported in the string functions.</span></span> <span data-ttu-id="a3bb5-133">SQL_CHAR 및 SQL_VARCHAR 데이터 형식은 최대 8000 문자로 제한 되므로 *count* 매개 변수는 8000 보다 작거나 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-133">The *count* parameter must be less than or equal to 8,000 because the SQL_CHAR and SQL_VARCHAR data types are limited to a maximum length of 8,000 characters.</span></span>|  
|<span data-ttu-id="a3bb5-134">시간 리터럴</span><span class="sxs-lookup"><span data-stu-id="a3bb5-134">Time literals</span></span>|<span data-ttu-id="a3bb5-135">시간 리터럴은 SQL_TIMESTAMP 열에 저장 된 경우 (날짜 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] **/시간** 또는 **smalldatetime**의 데이터 형식) 1900 년 1 월 1 일의 날짜 값을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-135">Time literals, when stored in a SQL_TIMESTAMP column ([!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] data types of **datetime** or **smalldatetime**), have a date value of January 1, 1900.</span></span>|  
|<span data-ttu-id="a3bb5-136">**timestamp**</span><span class="sxs-lookup"><span data-stu-id="a3bb5-136">**timestamp**</span></span>|<span data-ttu-id="a3bb5-137">**Timestamp** 열에는 NULL 값만 수동으로 삽입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-137">Only a NULL value can be manually inserted into a **timestamp** column.</span></span> <span data-ttu-id="a3bb5-138">그러나 **timestamp**열은에 의해 자동으로 업데이트 되기 때문에 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] NULL 값을 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-138">However, because **timestamp**columns are automatically updated by [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], a NULL value is overwritten.</span></span>|  
|<span data-ttu-id="a3bb5-139">**tinyint**</span><span class="sxs-lookup"><span data-stu-id="a3bb5-139">**tinyint**</span></span>|<span data-ttu-id="a3bb5-140">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] **Tinyint** 데이터 형식은 부호가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-140">The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] **tinyint** data type is unsigned.</span></span> <span data-ttu-id="a3bb5-141">**Tinyint** 열은 기본적으로 SQL_C_UTINYINT 데이터 형식의 변수에 바인딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-141">A **tinyint** column is bound to a variable of data type SQL_C_UTINYINT by default.</span></span>|  
|<span data-ttu-id="a3bb5-142">별칭 데이터 형식</span><span class="sxs-lookup"><span data-stu-id="a3bb5-142">Alias data types</span></span>|<span data-ttu-id="a3bb5-143">4.2 x 인스턴스에 연결 된 경우 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] ODBC*x*드라이버는 열의 null 허용 여부를 명시적으로 선언 하지 않는 열 정의에 NULL을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-143">When connected to an instance of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 4.2*x*, the ODBC driver adds NULL to a column definition that does not explicitly declare a column's nullability.</span></span> <span data-ttu-id="a3bb5-144">따라서 별칭 데이터 형식의 정의에 저장된 Null 허용 여부는 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-144">Therefore, the nullability that is stored in the definition of an alias data type is ignored.</span></span><br /><br /> <span data-ttu-id="a3bb5-145">4.2 x 인스턴스에 연결 된 경우 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 기본*x*데이터 형식이 **char** 또는 **binary** 이 고 null 허용 여부가 선언 되지 않은 별칭 데이터 형식의 열이 **varchar** 또는 **varbinary**데이터 형식으로 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-145">When connected to an instance of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 4.2*x*, columns with an alias data type that has a base data type of **char** or **binary** and for which no nullability is declared are created as data type **varchar** or **varbinary**.</span></span> <span data-ttu-id="a3bb5-146">[Sqlcolattribute](../native-client-odbc-api/sqlcolattribute.md), [Sqlcolumns](../native-client-odbc-api/sqlcolumns.md)및 [SQLDescribeCol](../native-client-odbc-api/sqldescribecol.md) 는 SQL_VARCHAR 또는 SQL_VARBINARY를 이러한 열의 데이터 형식으로 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-146">[SQLColAttribute](../native-client-odbc-api/sqlcolattribute.md), [SQLColumns](../native-client-odbc-api/sqlcolumns.md), and [SQLDescribeCol](../native-client-odbc-api/sqldescribecol.md) return SQL_VARCHAR or SQL_VARBINARY as the data type for these columns.</span></span> <span data-ttu-id="a3bb5-147">해당 열에서 검색한 데이터는 채워지지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-147">Data that is retrieved from these columns is not padded.</span></span> <span data-ttu-id="a3bb5-148">**참고:**  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]Native CLIENT ODBC 드라이버는 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 6.5 및 이전 버전에 대 한 연결을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-148">**Note:**  The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver does support connecting to [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 6.5 and earlier.</span></span>|  
|<span data-ttu-id="a3bb5-149">LONG 데이터 형식</span><span class="sxs-lookup"><span data-stu-id="a3bb5-149">LONG data types</span></span>|<span data-ttu-id="a3bb5-150">*실행 시 데이터* 매개 변수는 SQL_LONGVARBINARY 및 SQL_LONGVARCHAR 데이터 형식 모두에 대해 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-150">*data-at-execution* parameters are restricted for both the SQL_LONGVARBINARY and the SQL_LONGVARCHAR data types.</span></span>|  
|<span data-ttu-id="a3bb5-151">큰 값 형식</span><span class="sxs-lookup"><span data-stu-id="a3bb5-151">Large value types</span></span>|<span data-ttu-id="a3bb5-152">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]Native CLIENT odbc 드라이버는 ODBC SQL 데이터 형식을 허용 하거나 반환 하는 api에서 **varchar (max)**, **varbinary (max)** 및 **nvarchar (max)** 형식을 각각 SQL_VARCHAR, SQL_VARBINARY 및 SQL_WVARCHAR (각각)로 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-152">The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver will expose **varchar(max)**, **varbinary(max)**, and **nvarchar(max)** types as SQL_VARCHAR, SQL_VARBINARY and SQL_WVARCHAR (respectively) in APIs that accept or return ODBC SQL data types.</span></span>|  
|<span data-ttu-id="a3bb5-153">UDT(사용자 정의 형식)</span><span class="sxs-lookup"><span data-stu-id="a3bb5-153">User-defined type (UDT)</span></span>|<span data-ttu-id="a3bb5-154">UDT 열은 SQL_SS_UDT로 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-154">UDT columns are mapped as SQL_SS_UDT.</span></span> <span data-ttu-id="a3bb5-155">UDT의 ToString() 또는 ToXMLString() 메서드를 사용하거나 CAST/CONVERT 함수를 통해 SQL 문에서 명시적으로 UDT 열이 다른 형식에 매핑되어 있으면 결과 집합의 열 형식은 해당 열이 변환된 실제 형식을 반영합니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-155">If a UDT column is mapped explicitly to another type in the SQL statement using the ToString() or ToXMLString() methods of the UDT, or via the CAST/CONVERT functions, the type of the column in the result set will reflect the actual type to which the column was converted.</span></span><br /><br /> <span data-ttu-id="a3bb5-156">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]Native CLIENT ODBC 드라이버는 UDT 열에 이진 으로만 바인딩할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-156">The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver can only bind to a UDT column as binary.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]<span data-ttu-id="a3bb5-157">는 SQL_SS_UDT 및 SQL_C_BINARY 데이터 형식 간의 변환만 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-157">only supports conversion between the SQL_SS_UDT and SQL_C_BINARY data types.</span></span>|  
|<span data-ttu-id="a3bb5-158">XML</span><span class="sxs-lookup"><span data-stu-id="a3bb5-158">XML</span></span>|[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]<span data-ttu-id="a3bb5-159">는 자동으로 XML을 유니코드 텍스트로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-159">will automatically convert XML to Unicode text.</span></span> <span data-ttu-id="a3bb5-160">XML 유형은 SQL_SS_XML로 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3bb5-160">The XML type is mapped as SQL_SS_XML.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="a3bb5-161">참고 항목</span><span class="sxs-lookup"><span data-stu-id="a3bb5-161">See Also</span></span>  
 [<span data-ttu-id="a3bb5-162">ODBC&#41;&#40;결과 처리</span><span class="sxs-lookup"><span data-stu-id="a3bb5-162">Processing Results &#40;ODBC&#41;</span></span>](processing-results-odbc.md)  
  
  
