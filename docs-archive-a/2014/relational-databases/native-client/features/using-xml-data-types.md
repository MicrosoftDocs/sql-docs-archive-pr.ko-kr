---
title: XML 데이터 형식 사용 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- IRowsetChange interface
- IRowsetUpdate interface
- data access [SQL Server Native Client], xml data type
- SQL Server Native Client OLE DB schema rowsets
- PROVIDER_TYPES rowset
- IColumnsInfo interface
- IRowsetFind interface
- IColumnsRowset interface
- PROCEDURE_PARAMETERS rowset
- SQLNCLI, XML
- xml data type [SQL Server], SQL Server Native Client
- SQL Server Native Client, XML
- IRowset interface
- ISequentialStream interface
- ISSCommandWithParameters interface
- SS_XMLSCHEMA rowset
- SQL Server Native Client OLE DB interfaces
- XML [SQL Server], SQL Server Native Client
- COLUMNS rowset
ms.assetid: a7af5b72-c5c2-418d-a636-ae4ac6270ee5
author: rothja
ms.author: jroth
ms.openlocfilehash: 3d0dcc8cf7259a24e53281724d8440c6ff2209f1
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87653317"
---
# <a name="using-xml-data-types"></a><span data-ttu-id="27a28-102">XML 데이터 형식 사용</span><span class="sxs-lookup"><span data-stu-id="27a28-102">Using XML Data Types</span></span>
  [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)]<span data-ttu-id="27a28-103">에는 XML 문서와 조각을 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 데이터베이스에 저장할 수 있는 **xml** 데이터 형식이 도입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-103">introduced an **xml** data type that enables you to store XML documents and fragments in a [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] database.</span></span> <span data-ttu-id="27a28-104">**xml** 데이터 형식은 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]의 기본 제공 데이터 형식이며 **int** 및 **varchar**와 같은 다른 기본 제공 형식과 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-104">The **xml** data type is a built-in data type in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], and is in some ways similar to other built-in types, such as **int** and **varchar**.</span></span> <span data-ttu-id="27a28-105">다른 기본 제공 형식과 마찬가지로 **xml** 데이터 형식도 변수 유형, 매개 변수 유형, 함수 반환 유형 또는 테이블을 만드는 경우 열 유형으로 사용하거나 CAST 및 CONVERT 함수에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-105">As with other built-in types, you can use the **xml** data type as a column type when creating a table; as a variable type, a parameter type, or a function-return type; or in CAST and CONVERT functions.</span></span>  
  
## <a name="programming-considerations"></a><span data-ttu-id="27a28-106">프로그래밍 고려 사항</span><span class="sxs-lookup"><span data-stu-id="27a28-106">Programming Considerations</span></span>  
 <span data-ttu-id="27a28-107">XML은 원하는 경우 문서의 인코딩을 지정하는 XML 헤더를 포함할 수 있다는 점에서 자체 설명적 데이터 형식이라고 할 수 있습니다. 예를 들면 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-107">XML can be self-describing in that it can optionally include an XML header that specifies the encoding of the document, for example:</span></span>  
  
 `<?xml version="1.0" encoding="windows-1252"?><doc/>`  
  
 <span data-ttu-id="27a28-108">XML 표준은 XML 프로세서가 문서의 처음 몇 바이트를 검사하여 문서에 사용된 인코딩을 검색하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-108">The XML standard describes how an XML processor can detect the encoding used for a document by examining the first few bytes of the document.</span></span> <span data-ttu-id="27a28-109">애플리케이션에서 지정한 인코딩이 문서에 지정된 인코딩과 충돌하는 경우가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-109">There are opportunities for the encoding specified by the application to conflict with the encoding specified by the document.</span></span> <span data-ttu-id="27a28-110">바인딩된 매개 변수로 전달된 문서의 경우 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]에서 XML을 이진 데이터로 처리하므로 변환이 수행되지 않으며 XML 파서는 문서 내에 지정된 인코딩을 아무런 문제없이 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-110">For documents passed as bound parameters, XML is treated as binary data by [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], so no conversions are made and the XML parser can use the encoding specified within the document without problems.</span></span> <span data-ttu-id="27a28-111">그러나 WSTR로 바인딩된 XML 데이터의 경우 문서가 유니코드로 인코딩되도록 애플리케이션에서 관련 작업을 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-111">However, for XML data that is bound as WSTR, then the application must ensure that the document is encoded as Unicode.</span></span> <span data-ttu-id="27a28-112">즉, 문서를 DOM으로 로드하고 인코딩을 유니코드로 변경한 다음 문서를 직렬화해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-112">This may entail loading the document into a DOM, changing the encoding to Unicode and serializing the document.</span></span> <span data-ttu-id="27a28-113">이 작업을 수행하지 않으면 데이터 변환이 일어날 수 있으며 그 결과 XML이 잘못되거나 손상될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-113">If this is not done, data conversions may occur, resulting in invalid or corrupt XML.</span></span>  
  
 <span data-ttu-id="27a28-114">XML이 리터럴로 지정된 경우에도 충돌이 발생할 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-114">There is also potential for conflict when XML is specified in literals.</span></span> <span data-ttu-id="27a28-115">예를 들어 다음은 잘못된 XML 지정입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-115">For example the following are invalid:</span></span>  
  
 `INSERT INTO xmltable(xmlcol) VALUES('<?xml version="1.0" encoding="UTF-16"?><doc/>')`  
  
 `INSERT INTO xmltable(xmlcol) VALUES(N'<?xml version="1.0" encoding="UTF-8"?><doc/>')`  
  
## <a name="sql-server-native-client-ole-db-provider"></a><span data-ttu-id="27a28-116">SQL Server Native Client OLE DB 공급자</span><span class="sxs-lookup"><span data-stu-id="27a28-116">SQL Server Native Client OLE DB Provider</span></span>  
 <span data-ttu-id="27a28-117">DBTYPE_XML은 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client OLE DB 공급자의 XML과 관련된 새로운 데이터 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-117">DBTYPE_XML is a new data type specific to XML in the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client OLE DB provider.</span></span> <span data-ttu-id="27a28-118">DBTYPE_BYTES, DBTYPE_WSTR, DBTYPE_BSTR, DBTYPE_XML, DBTYPE_STR, DBTYPE_VARIANT, DBTYPE_IUNKNOWN 등 기존의 OLE DB 형식을 통해서도 XML 데이터에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-118">In addition, XML data can be accessed through the existing OLE DB types of DBTYPE_BYTES, DBTYPE_WSTR, DBTYPE_BSTR, DBTYPE_XML, DBTYPE_STR, DBTYPE_VARIANT, and DBTYPE_IUNKNOWN.</span></span> <span data-ttu-id="27a28-119">XML 형식 열에 저장된 데이터는 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client OLE DB 공급자 행 집합에 있는 다음 형식의 열에서 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-119">Data stored in columns of type XML can be retrieved from a column in a [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client OLE DB provider rowset in the following formats:</span></span>  
  
-   <span data-ttu-id="27a28-120">텍스트 문자열</span><span class="sxs-lookup"><span data-stu-id="27a28-120">A text string</span></span>  
  
-   <span data-ttu-id="27a28-121">**ISequentialStream**</span><span class="sxs-lookup"><span data-stu-id="27a28-121">An **ISequentialStream**</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="27a28-122">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]Native Client OLE DB 공급자에는 sax 판독기가 포함 되어 있지 않지만 **ISEQUENTIALSTREAM** 는 MSXML의 sax 및 DOM 개체에 쉽게 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-122">The [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client OLE DB provider does not include a SAX reader, but the **ISequentialStream** can be easily passed to SAX and DOM objects in MSXML.</span></span>  
  
 <span data-ttu-id="27a28-123">**ISequentialStream** 는 대량 XML 문서를 검색 하는 데 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-123">**ISequentialStream** should be use used for retrieval of large XML documents.</span></span> <span data-ttu-id="27a28-124">다른 큰 값 유형에 사용되는 방법이 XML에도 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-124">The same techniques used for other large value types also apply to XML.</span></span> <span data-ttu-id="27a28-125">자세한 내용은 [큰 값 형식 사용](using-large-value-types.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="27a28-125">For more information, see [Using Large Value Types](using-large-value-types.md).</span></span>  
  
 <span data-ttu-id="27a28-126">행 집합의 XML 형식 열에 저장된 데이터는 **IRow::GetColumns**, **IRowChange::SetColumns** 및 **ICommand::Execute** 같은 일반 인터페이스를 통해 애플리케이션에 의해서도 검색, 삽입 또는 업데이트될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-126">Data stored in columns of type XML in a rowset can also be retrieved, inserted, or updated by an application via the usual interfaces such as **IRow::GetColumns**, **IRowChange::SetColumns**, and **ICommand::Execute**.</span></span> <span data-ttu-id="27a28-127">검색 사례와 마찬가지로 응용 프로그램은 텍스트 문자열이 나 **ISequentialStream** 를 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client OLE DB 공급자에 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-127">Similarly to the retrieval case, an application program can pass either a text string or an **ISequentialStream** to the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client OLE DB provider.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="27a28-128">문자열 형식의 XML 데이터를 **ISequentialStream** 인터페이스를 통해 보내려면 바인딩에서 DBTYPE_IUNKNOWN을 지정하고 해당 *pObject* 인수를 null로 설정하여 **ISequentialStream**을 가져와야 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-128">To send XML data in string format through the **ISequentialStream** interface, you must obtain **ISequentialStream** by specifying DBTYPE_IUNKNOWN and set its *pObject* argument to null in the binding.</span></span>  
  
 <span data-ttu-id="27a28-129">소비자 버퍼가 너무 작아 검색된 XML 데이터가 잘린 경우 길이가 알 수 없는 길이를 나타내는 0xffffffff로 반환될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-129">When retrieved XML data is truncated due to the consumer buffer being too small, the length may be returned as 0xffffffff, which means that the length is unknown.</span></span> <span data-ttu-id="27a28-130">이는 실제 데이터를 보내기 전에 길이 정보를 보내지 않고 클라이언트로 스트리밍되는 데이터 형식으로 구현하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-130">This is consistent with its implementation as a data type that is streamed to the client without sending length information ahead of the actual data.</span></span> <span data-ttu-id="27a28-131">경우에 따라 공급자가 전체 값 (예: **IRowset:: GetData** )을 버퍼링 했을 때 데이터 변환이 수행 될 때 실제 길이가 반환 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-131">In some cases the actual length may be returned when the provider has buffered the whole value, such as **IRowset::GetData** and where data conversion is performed.</span></span>  
  
 <span data-ttu-id="27a28-132">SQL Server로 전송된 XML 데이터는 서버에서 이진 데이터로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-132">XML data sent to SQL Server is treated as binary data by the server.</span></span> <span data-ttu-id="27a28-133">따라서 어떠한 변환도 일어나지 않으며 XML 파서는 XML 인코딩을 자동 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-133">This prevents any conversions occurring and allows the XML parser to auto-detect the XML encoding.</span></span> <span data-ttu-id="27a28-134">이를 통해 보다 광범위한 XML 문서(예: UTF-8로 인코딩된 문서)를 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]에 대한 입력으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-134">This allows a wider range of XML documents (for example those encoded in UTF-8) to be accepted as input to [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span>  
  
 <span data-ttu-id="27a28-135">입력 XML이 DBTYPE_WSTR로 바인딩된 경우 애플리케이션에서는 XML이 이미 유니코드로 인코딩되었는지 확인하여 원치 않는 데이터 변환으로 인해 데이터가 손상되는 것을 방지해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-135">If input XML is bound as DBTYPE_WSTR, the application must ensure it is already Unicode encoded to avoid any possibility of corruption by unwanted data conversions.</span></span>  
  
### <a name="data-bindings-and-coercions"></a><span data-ttu-id="27a28-136">데이터 바인딩 및 강제 변환</span><span class="sxs-lookup"><span data-stu-id="27a28-136">Data Bindings and Coercions</span></span>  
 <span data-ttu-id="27a28-137">다음 표에서는 표에 나열된 데이터 형식을 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] **xml** 데이터 형식과 함께 사용할 때 발생하는 바인딩 및 강제 변환에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-137">The following table describes the binding and coercion that occurs when using the listed data types with the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] **xml** data type.</span></span>  
  
|<span data-ttu-id="27a28-138">데이터 형식</span><span class="sxs-lookup"><span data-stu-id="27a28-138">Data type</span></span>|<span data-ttu-id="27a28-139">SQL Server의</span><span class="sxs-lookup"><span data-stu-id="27a28-139">To Server</span></span><br /><br /> <span data-ttu-id="27a28-140">**XML**</span><span class="sxs-lookup"><span data-stu-id="27a28-140">**XML**</span></span>|<span data-ttu-id="27a28-141">SQL Server의</span><span class="sxs-lookup"><span data-stu-id="27a28-141">To Server</span></span><br /><br /> <span data-ttu-id="27a28-142">**비XML**</span><span class="sxs-lookup"><span data-stu-id="27a28-142">**Non-XML**</span></span>|<span data-ttu-id="27a28-143">SQL Server의</span><span class="sxs-lookup"><span data-stu-id="27a28-143">From Server</span></span><br /><br /> <span data-ttu-id="27a28-144">**XML**</span><span class="sxs-lookup"><span data-stu-id="27a28-144">**XML**</span></span>|<span data-ttu-id="27a28-145">SQL Server의</span><span class="sxs-lookup"><span data-stu-id="27a28-145">From Server</span></span><br /><br /> <span data-ttu-id="27a28-146">**비XML**</span><span class="sxs-lookup"><span data-stu-id="27a28-146">**Non-XML**</span></span>|  
|---------------|---------------------------|--------------------------------|-----------------------------|----------------------------------|  
|<span data-ttu-id="27a28-147">DBTYPE_XML</span><span class="sxs-lookup"><span data-stu-id="27a28-147">DBTYPE_XML</span></span>|<span data-ttu-id="27a28-148">통과<sup>6,7</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-148">Pass through<sup>6,7</sup></span></span>|<span data-ttu-id="27a28-149">오류<sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-149">Error<sup>1</sup></span></span>|<span data-ttu-id="27a28-150">확인<sup>11, 6</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-150">OK<sup>11, 6</sup></span></span>|<span data-ttu-id="27a28-151">오류<sup>8</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-151">Error<sup>8</sup></span></span>|  
|<span data-ttu-id="27a28-152">DBTYPE_BYTES</span><span class="sxs-lookup"><span data-stu-id="27a28-152">DBTYPE_BYTES</span></span>|<span data-ttu-id="27a28-153">통과<sup>6,7</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-153">Pass through<sup>6,7</sup></span></span>|<span data-ttu-id="27a28-154">해당 없음<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-154">N/A<sup>2</sup></span></span>|<span data-ttu-id="27a28-155">확인<sup>11, 6</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-155">OK <sup>11, 6</sup></span></span>|<span data-ttu-id="27a28-156">해당 없음<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-156">N/A <sup>2</sup></span></span>|  
|<span data-ttu-id="27a28-157">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="27a28-157">DBTYPE_WSTR</span></span>|<span data-ttu-id="27a28-158">통과<sup>6,10</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-158">Pass through<sup>6,10</sup></span></span>|<span data-ttu-id="27a28-159">해당 없음<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-159">N/A <sup>2</sup></span></span>|<span data-ttu-id="27a28-160">OK<sup>4, 6, 12</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-160">OK<sup>4, 6, 12</sup></span></span>|<span data-ttu-id="27a28-161">해당 없음<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-161">N/A <sup>2</sup></span></span>|  
|<span data-ttu-id="27a28-162">DBTYPE_BSTR</span><span class="sxs-lookup"><span data-stu-id="27a28-162">DBTYPE_BSTR</span></span>|<span data-ttu-id="27a28-163">통과<sup>6,10</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-163">Pass through<sup>6,10</sup></span></span>|<span data-ttu-id="27a28-164">해당 없음<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-164">N/A <sup>2</sup></span></span>|<span data-ttu-id="27a28-165">확인<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-165">OK <sup>3</sup></span></span>|<span data-ttu-id="27a28-166">해당 없음<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-166">N/A <sup>2</sup></span></span>|  
|<span data-ttu-id="27a28-167">DBTYPE_STR</span><span class="sxs-lookup"><span data-stu-id="27a28-167">DBTYPE_STR</span></span>|<span data-ttu-id="27a28-168">확인<sup>6, 9, 10</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-168">OK<sup>6, 9, 10</sup></span></span>|<span data-ttu-id="27a28-169">해당 없음<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-169">N/A <sup>2</sup></span></span>|<span data-ttu-id="27a28-170">확인<sup>5, 6, 12</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-170">OK<sup>5, 6, 12</sup></span></span>|<span data-ttu-id="27a28-171">해당 없음<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-171">N/A <sup>2</sup></span></span>|  
|<span data-ttu-id="27a28-172">DBTYPE_IUNKNOWN</span><span class="sxs-lookup"><span data-stu-id="27a28-172">DBTYPE_IUNKNOWN</span></span>|<span data-ttu-id="27a28-173">**ISequentialStream**을 통한 바이트 스트림<sup>7</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-173">Byte stream via **ISequentialStream**<sup>7</sup></span></span>|<span data-ttu-id="27a28-174">해당 없음<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-174">N/A <sup>2</sup></span></span>|<span data-ttu-id="27a28-175">**ISequentialStream**을 통한 바이트 스트림<sup>11</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-175">Byte stream via **ISequentialStream**<sup>11</sup></span></span>|<span data-ttu-id="27a28-176">해당 없음<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-176">N/A <sup>2</sup></span></span>|  
|<span data-ttu-id="27a28-177">DBTYPE_VARIANT(VT_UI1 &#124; VT_ARRAY)</span><span class="sxs-lookup"><span data-stu-id="27a28-177">DBTYPE_VARIANT (VT_UI1 &#124; VT_ARRAY)</span></span>|<span data-ttu-id="27a28-178">통과<sup>6,7</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-178">Pass through<sup>6,7</sup></span></span>|<span data-ttu-id="27a28-179">해당 없음<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-179">N/A <sup>2</sup></span></span>|<span data-ttu-id="27a28-180">해당 없음</span><span class="sxs-lookup"><span data-stu-id="27a28-180">N/A</span></span>|<span data-ttu-id="27a28-181">해당 없음<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-181">N/A <sup>2</sup></span></span>|  
|<span data-ttu-id="27a28-182">DBTYPE_VARIANT (VT_BSTR)</span><span class="sxs-lookup"><span data-stu-id="27a28-182">DBTYPE_VARIANT (VT_BSTR)</span></span>|<span data-ttu-id="27a28-183">통과<sup>6,10</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-183">Pass through<sup>6,10</sup></span></span>|<span data-ttu-id="27a28-184">해당 없음<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-184">N/A <sup>2</sup></span></span>|<span data-ttu-id="27a28-185">확인<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-185">OK<sup>3</sup></span></span>|<span data-ttu-id="27a28-186">해당 없음<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="27a28-186">N/A <sup>2</sup></span></span>|  
  
 <span data-ttu-id="27a28-187"><sup>1</sup> **ICommandWithParameters:: SetParameterInfo** 를 사용 하 여 DBTYPE_XML 이외의 서버 유형을 지정 하 고 접근자 유형을 DBTYPE_XML 하면 문이 실행 될 때 오류가 발생 합니다 (DB_E_ERRORSOCCURRED, 매개 변수 상태가 DBSTATUS_E_BADACCESSOR). 그렇지 않으면 데이터가 서버로 전송 되지만 XML에서 매개 변수의 데이터 형식으로의 암시적 변환이 없음을 나타내는 오류가 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-187"><sup>1</sup>If a server type other than DBTYPE_XML is specified with **ICommandWithParameters::SetParameterInfo** and the accessor type is DBTYPE_XML, an error occurs when the statement is executed (DB_E_ERRORSOCCURRED, the parameter status is DBSTATUS_E_BADACCESSOR); otherwise the data is sent to the server, but the server returns an error indicating that there is no implicit conversion from XML to the parameter's data type.</span></span>  
  
 <span data-ttu-id="27a28-188"><sup>2</sup> 이 항목의 범위를 벗어났습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-188"><sup>2</sup>Beyond the scope of this topic.</span></span>  
  
 <span data-ttu-id="27a28-189"><sup>3</sup>형식이 UTF-16이고 BOM(바이트 순서 표시), 인코딩 사양 및 null 종결을 포함하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-189"><sup>3</sup>Format is UTF-16, no bye-order mark (BOM), no encoding specification, no null termination.</span></span>  
  
 <span data-ttu-id="27a28-190"><sup>4</sup>형식이 UTF-16이고 BOM, 인코딩 사양을 포함하지 않지만 null 종결은 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-190"><sup>4</sup>Format is UTF-16, no BOM, no encoding specification, null termination.</span></span>  
  
 <span data-ttu-id="27a28-191"><sup>5</sup>형식이 클라이언트 코드 페이지로 인코딩된 멀티바이트 문자이고 null 종결자를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-191"><sup>5</sup>Format is multibyte characters encoded in client code page with null terminator.</span></span> <span data-ttu-id="27a28-192">서버에서 제공하는 유니코드에서 변환되면 데이터가 손상될 수 있으므로 이 바인딩은 사용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-192">Conversion from server supplied Unicode may cause data corruption, so this binding is strongly discouraged.</span></span>  
  
 <span data-ttu-id="27a28-193"><sup>6</sup>BY_REF가 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-193"><sup>6</sup>BY_REF may be used.</span></span>  
  
 <span data-ttu-id="27a28-194"><sup>7</sup>UTF-16 데이터는 BOM으로 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-194"><sup>7</sup>UTF-16 data must start with a BOM.</span></span> <span data-ttu-id="27a28-195">그렇지 않으면 서버에서 인코딩을 올바르게 인식할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-195">If it does not, the encoding may not be correctly recognized by the server.</span></span>  
  
 <span data-ttu-id="27a28-196"><sup>8</sup>접근자 생성 시간 또는 인출 시간에 유효성 검사가 수행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-196"><sup>8</sup>Validation can happen at create accessor time, or at fetch time.</span></span> <span data-ttu-id="27a28-197">오류는 DB_E_ERRORSOCCURRED이고 바인딩 상태는 DBBINDSTATUS_UNSUPPORTEDCONVERSION으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-197">The error is DB_E_ERRORSOCCURRED, binding status set to DBBINDSTATUS_UNSUPPORTEDCONVERSION.</span></span>  
  
 <span data-ttu-id="27a28-198"><sup>9</sup>데이터가 서버로 전송되기 전에 클라이언트 코드 페이지를 사용하여 유니코드로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-198"><sup>9</sup>Data is converted to Unicode using the client codepage before being sent to the server.</span></span> <span data-ttu-id="27a28-199">문서 인코딩이 클라이언트 코드 페이지와 일치하지 않으면 데이터가 손상될 수 있으므로 이 바인딩은 사용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-199">If the document encoding does not match the client codepage, this can result in data corruption, so this binding is strongly discouraged.</span></span>  
  
 <span data-ttu-id="27a28-200"><sup>10</sup>서버로 전송된 데이터에 항상 BOM이 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-200"><sup>10</sup>A BOM is always added to data sent to the server.</span></span> <span data-ttu-id="27a28-201">데이터의 시작 부분에 이미 BOM이 있는 경우 결과적으로 버퍼 시작 부분에 두 개의 BOM이 오게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-201">If the data already started with a BOM, this results in two BOMs at the start of the buffer.</span></span> <span data-ttu-id="27a28-202">서버에서는 첫 번째 BOM을 통해 인코딩을 UTF-16으로 인식한 다음 이 BOM을 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-202">The server uses the first BOM to recognize the encoding as UTF-16 and then discards it.</span></span> <span data-ttu-id="27a28-203">두 번째 BOM은 너비가 0인 줄 바꿈하지 않는 공백 문자로 해석됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-203">The second BOM is interpreted as a zero-width nonbreaking space character.</span></span>  
  
 <span data-ttu-id="27a28-204"><sup>11</sup>형식이 UTF-16이고 인코딩 사양을 포함하지 않으며 서버에서 받은 데이터에 BOM이 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-204"><sup>11</sup>Format is UTF-16, no encoding specification, a BOM is added to data received from the server.</span></span> <span data-ttu-id="27a28-205">서버에서 빈 문자열을 반환하더라도 BOM이 애플리케이션에 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-205">If an empty string is returned by the server, a BOM is still returned to the application.</span></span> <span data-ttu-id="27a28-206">버퍼 길이가 홀수 바이트이면 데이터가 올바르게 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-206">If the buffer length is an odd number of bytes, the data is truncated correctly.</span></span> <span data-ttu-id="27a28-207">전체 값이 청크로 반환되면 연결해서 올바른 값으로 다시 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-207">If the whole value is returned in chunks, they can be concatenated to reconstitute the correct value.</span></span>  
  
 <span data-ttu-id="27a28-208"><sup>12</sup> 버퍼 길이가 두 문자 보다 작은 경우 즉, null 종결을 위한 공간이 충분 하지 않은 경우 오버플로 오류가 보고 됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-208"><sup>12</sup>If the buffer length is less than two characters--that is, not enough space for null termination--an overflow error is reported.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="27a28-209">NULL XML 값에 대해서는 데이터가 반환되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-209">No data is returned for NULL XML values.</span></span>  
  
 <span data-ttu-id="27a28-210">XML 표준을 따르려면 UTF-16로 인코딩된 XML이 BOM(바이트 순서 표시), 즉 UTF-16 문자 코드 0xFEFF로 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-210">The XML standard requires UTF-16 encoded XML to start with a byte-order mark (BOM), UTF-16 character code 0xFEFF.</span></span> <span data-ttu-id="27a28-211">WSTR 및 BSTR 바인딩을 사용 하 여 작업 하는 경우 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 인코딩이 바인딩에서 암시적으로 암시 되므로 Native Client는 BOM을 요구 하거나 추가 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-211">When working with WSTR and BSTR bindings, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client does not require or add a BOM as the encoding is implied by the binding.</span></span> <span data-ttu-id="27a28-212">BYTES, XML 또는 IUNKNOWN 바인딩을 사용하는 경우 BOM을 추가하는 목적은 다른 XML 프로세서 및 스토리지 시스템을 간편하게 다룰 수 있도록 하는 데 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-212">When working with BYTES, XML, or IUNKNOWN bindings, the intent is to provide simplicity in dealing with other XML processors and storage systems.</span></span> <span data-ttu-id="27a28-213">이 경우 UTF-16으로 인코딩된 XML에 BOM을 제공해야 합니다. SQL Server를 비롯한 대부분의 XML 프로세서는 값의 처음 몇 바이트를 검사하여 인코딩을 추론하기 때문에 애플리케이션에서는 실제 인코딩을 확인할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-213">In this case a BOM should be present with UTF-16 encoded XML, and the application need not be concerned with the actual encoding, since the majority of XML processors (including SQL Server) deduces the encoding by inspecting the first few bytes of the value.</span></span> <span data-ttu-id="27a28-214">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]바이트, XML 또는 IUNKNOWN 바인딩을 사용 하 여 Native Client에서 받은 xml 데이터는 항상 u t f-16으로, 포함 된 인코딩 선언이 없는 u t f-16으로 인코딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-214">XML data received from [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client using BYTES, XML, or IUNKNOWN bindings is always encoded in UTF-16 with a BOM and without an embedded encoding declaration.</span></span>  
  
 <span data-ttu-id="27a28-215">OLE DB 핵심 서비스에서 제공하는 데이터 변환(**IDataConvert**)은 DBTYPE_XML에 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-215">Data conversions supplied by OLE DB core services (**IDataConvert**) are not applicable to DBTYPE_XML.</span></span>  
  
 <span data-ttu-id="27a28-216">데이터가 서버로 전송되면 유효성 검사가 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-216">Validation is done when data is sent to the server.</span></span> <span data-ttu-id="27a28-217">클라이언트 쪽 유효성 검사 및 인코딩 변경은 애플리케이션에서 처리해야 하므로 XML 데이터를 직접 처리하는 대신 DOM이나 SAX 판독기를 사용하여 처리하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-217">Client-side validation and encoding changes should be handled by your application, and it is strongly recommended that you not process the XML data directly, but should instead use a DOM or SAX reader to process it.</span></span>  
  
 <span data-ttu-id="27a28-218">DBTYPE_NULL 및 DBTYPE_EMPTY는 입력 매개 변수에 대해서는 바인딩할 수 있지만 출력 매개 변수나 결과에 대해서는 바인딩할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-218">DBTYPE_NULL and DBTYPE_EMPTY can be bound for input parameters but not for output parameters or results.</span></span> <span data-ttu-id="27a28-219">입력 매개 변수에 대해 바인딩할 경우 상태를 DBSTATUS_S_ISNULL 또는 DBSTATUS_S_DEFAULT로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-219">When bound for input parameters the status must be set to DBSTATUS_S_ISNULL or DBSTATUS_S_DEFAULT.</span></span>  
  
 <span data-ttu-id="27a28-220">DBTYPE_XML은 DBTYPE_EMPTY와 DBTYPE_NULL로 변환할 수 있습니다. DBTYPE_EMPTY는 DBTYPE_XML로 변환할 수 있지만 DBTYPE_NULL은 DBTYPE_XML로 변환할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-220">DBTYPE_XML can be converted to DBTYPE_EMPTY and DBTYPE_NULL, DBTYPE_EMPTY can be converted to DBTYPE_XML, but DBTYPE_NULL cannot be converted to DBTYPE_XML.</span></span> <span data-ttu-id="27a28-221">이는 DBTYPE_WSTR와 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-221">This is consistent with DBTYPE_WSTR.</span></span>  
  
 <span data-ttu-id="27a28-222">위의 표에서 볼 수 있듯이 DBTYPE_IUNKNOWN은 지원되는 바인딩이지만 DBTYPE_XML과 DBTYPE_IUNKNOWN 간에는 변환이 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-222">DBTYPE_IUNKNOWN is a supported binding (as shown in the above table), but there are no conversions between DBTYPE_XML and DBTYPE_IUNKNOWN.</span></span> <span data-ttu-id="27a28-223">DBTYPE_IUNKNOWN을 DBTYPE_BYREF와는 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-223">DBTYPE_IUNKNOWN may not be used with DBTYPE_BYREF.</span></span>  
  
### <a name="ole-db-rowset-additions-and-changes"></a><span data-ttu-id="27a28-224">OLE DB 행 집합의 추가 내용 및 변경 내용</span><span class="sxs-lookup"><span data-stu-id="27a28-224">OLE DB Rowset Additions and Changes</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]<span data-ttu-id="27a28-225">Native Client는 많은 핵심 OLE DB 스키마 행 집합에 새로운 값 이나 변경 내용을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-225">Native Client adds new values or changes to many of the core OLE DB schema rowsets.</span></span>  
  
#### <a name="the-columns-and-procedure_parameters-schema-rowsets"></a><span data-ttu-id="27a28-226">COLUMNS 및 PROCEDURE_PARAMETERS 스키마 행 집합</span><span class="sxs-lookup"><span data-stu-id="27a28-226">The COLUMNS and PROCEDURE_PARAMETERS Schema Rowsets</span></span>  
 <span data-ttu-id="27a28-227">COLUMNS 및 PROCEDURE_PARAMETERS 스키마 행 집합에 추가된 열은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-227">Additions to the COLUMNS and PROCEDURE_PARAMETERS schema rowsets include the following columns.</span></span>  
  
|<span data-ttu-id="27a28-228">열 이름</span><span class="sxs-lookup"><span data-stu-id="27a28-228">Column name</span></span>|<span data-ttu-id="27a28-229">Type</span><span class="sxs-lookup"><span data-stu-id="27a28-229">Type</span></span>|<span data-ttu-id="27a28-230">Description</span><span class="sxs-lookup"><span data-stu-id="27a28-230">Description</span></span>|  
|-----------------|----------|-----------------|  
|<span data-ttu-id="27a28-231">SS_XML_SCHEMACOLLECTION_CATALOGNAME</span><span class="sxs-lookup"><span data-stu-id="27a28-231">SS_XML_SCHEMACOLLECTION_CATALOGNAME</span></span>|<span data-ttu-id="27a28-232">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="27a28-232">DBTYPE_WSTR</span></span>|<span data-ttu-id="27a28-233">XML 스키마 컬렉션이 정의된 카탈로그의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-233">The name of a catalog in which an XML schema collection is defined.</span></span> <span data-ttu-id="27a28-234">비XML 열 또는 형식화되지 않은 XML 열에 대해서는 NULL입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-234">NULL for a non-XML column or un-typed XML column.</span></span>|  
|<span data-ttu-id="27a28-235">SS_XML_SCHEMACOLLECTION_SCHEMANAME</span><span class="sxs-lookup"><span data-stu-id="27a28-235">SS_XML_SCHEMACOLLECTION_SCHEMANAME</span></span>|<span data-ttu-id="27a28-236">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="27a28-236">DBTYPE_WSTR</span></span>|<span data-ttu-id="27a28-237">XML 스키마 컬렉션이 정의된 스키마의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-237">The name of a schema in which an XML schema collection is defined.</span></span> <span data-ttu-id="27a28-238">비XML 열 또는 형식화되지 않은 XML 열에 대해서는 NULL입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-238">NULL for a non-XML column or un-typed XML column.</span></span>|  
|<span data-ttu-id="27a28-239">SS_XML_SCHEMACOLLECTIONNAME</span><span class="sxs-lookup"><span data-stu-id="27a28-239">SS_XML_SCHEMACOLLECTIONNAME</span></span>|<span data-ttu-id="27a28-240">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="27a28-240">DBTYPE_WSTR</span></span>|<span data-ttu-id="27a28-241">XML 스키마 컬렉션의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-241">The name of XML schema collection.</span></span> <span data-ttu-id="27a28-242">비XML 열 또는 형식화되지 않은 XML 열에 대해서는 NULL입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-242">NULL for a non-XML column or un-typed XML column.</span></span>|  
  
#### <a name="the-provider_types-schema-rowset"></a><span data-ttu-id="27a28-243">PROVIDER_TYPES 스키마 행 집합</span><span class="sxs-lookup"><span data-stu-id="27a28-243">The PROVIDER_TYPES Schema Rowset</span></span>  
 <span data-ttu-id="27a28-244">PROVIDER_TYPES 스키마 행 집합에서는 **xml** 데이터 형식에 대한 COLUMN_SIZE 값이 0이고 DATA_TYPE이 DBTYPE_XML입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-244">In the PROVIDER_TYPES schema rowset, the COLUMN_SIZE value is 0 for the **xml** data type, and the DATA_TYPE is DBTYPE_XML.</span></span>  
  
#### <a name="the-ss_xmlschema-schema-rowset"></a><span data-ttu-id="27a28-245">SS_XMLSCHEMA 스키마 행 집합</span><span class="sxs-lookup"><span data-stu-id="27a28-245">The SS_XMLSCHEMA Schema Rowset</span></span>  
 <span data-ttu-id="27a28-246">새로운 스키마 행 집합인 SS_XMLSCHEMA는 클라이언트가 XML 스키마 정보를 검색할 수 있도록 도입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-246">A new schema rowset SS_XMLSCHEMA is introduced for clients to retrieve XML schema information.</span></span> <span data-ttu-id="27a28-247">SS_XMLSCHEMA 행 집합에는 다음 열이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-247">The SS_XMLSCHEMA rowset contains the following columns.</span></span>  
  
|<span data-ttu-id="27a28-248">열 이름</span><span class="sxs-lookup"><span data-stu-id="27a28-248">Column name</span></span>|<span data-ttu-id="27a28-249">Type</span><span class="sxs-lookup"><span data-stu-id="27a28-249">Type</span></span>|<span data-ttu-id="27a28-250">Description</span><span class="sxs-lookup"><span data-stu-id="27a28-250">Description</span></span>|  
|-----------------|----------|-----------------|  
|<span data-ttu-id="27a28-251">SCHEMACOLLECTION_CATALOGNAME</span><span class="sxs-lookup"><span data-stu-id="27a28-251">SCHEMACOLLECTION_CATALOGNAME</span></span>|<span data-ttu-id="27a28-252">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="27a28-252">DBTYPE_WSTR</span></span>|<span data-ttu-id="27a28-253">XML 컬렉션이 속한 카탈로그입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-253">The catalog an XML collection belongs to.</span></span>|  
|<span data-ttu-id="27a28-254">SCHEMACOLLECTION_SCHEMANAME</span><span class="sxs-lookup"><span data-stu-id="27a28-254">SCHEMACOLLECTION_SCHEMANAME</span></span>|<span data-ttu-id="27a28-255">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="27a28-255">DBTYPE_WSTR</span></span>|<span data-ttu-id="27a28-256">XML 컬렉션이 속한 스키마입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-256">The schema an XML collection belongs to.</span></span>|  
|<span data-ttu-id="27a28-257">SCHEMACOLLECTIONNAME</span><span class="sxs-lookup"><span data-stu-id="27a28-257">SCHEMACOLLECTIONNAME</span></span>|<span data-ttu-id="27a28-258">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="27a28-258">DBTYPE_WSTR</span></span>|<span data-ttu-id="27a28-259">형식화된 XML 열에 대해서는 XML 스키마 컬렉션의 이름이고, 그렇지 않으면 NULL입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-259">The name of an XML schema collection for typed XML columns, NULL otherwise.</span></span>|  
|<span data-ttu-id="27a28-260">TARGETNAMESPACEURI</span><span class="sxs-lookup"><span data-stu-id="27a28-260">TARGETNAMESPACEURI</span></span>|<span data-ttu-id="27a28-261">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="27a28-261">DBTYPE_WSTR</span></span>|<span data-ttu-id="27a28-262">XML 스키마의 대상 네임스페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-262">The target name space of an XML schema.</span></span>|  
|<span data-ttu-id="27a28-263">SCHEMACONTENT</span><span class="sxs-lookup"><span data-stu-id="27a28-263">SCHEMACONTENT</span></span>|<span data-ttu-id="27a28-264">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="27a28-264">DBTYPE_WSTR</span></span>|<span data-ttu-id="27a28-265">XML 스키마 콘텐츠입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-265">The XML schema content.</span></span>|  
  
 <span data-ttu-id="27a28-266">각 XML 스키마는 카탈로그 이름, 스키마 이름, 스키마 컬렉션 이름 및 대상 네임스페이스 URI(Uniform Resource Identifier)로 범위가 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-266">Each XML schema is scoped by catalog name, schema name, schema collection name, and target name space Uniform Resource Identifier (URI).</span></span> <span data-ttu-id="27a28-267">또한 이름이 DBSCHEMA_XML_COLLECTIONS인 새 GUID도 정의되었습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-267">In addition, a new GUID with the name DBSCHEMA_XML_COLLECTIONS is also defined.</span></span> <span data-ttu-id="27a28-268">SS_XMLSCHEMA 스키마 행 집합에 대한 제한 수 및 제한된 열은 다음과 같이 정의되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-268">The number of restrictions and restricted columns for the SS_XMLSCHEMA schema rowset are defined as follows.</span></span>  
  
|<span data-ttu-id="27a28-269">GUID</span><span class="sxs-lookup"><span data-stu-id="27a28-269">GUID</span></span>|<span data-ttu-id="27a28-270">제한 수</span><span class="sxs-lookup"><span data-stu-id="27a28-270">Number of restrictions</span></span>|<span data-ttu-id="27a28-271">제한된 열</span><span class="sxs-lookup"><span data-stu-id="27a28-271">Restricted columns</span></span>|  
|----------|----------------------------|------------------------|  
|<span data-ttu-id="27a28-272">DBSCHEMA_XML_COLLECTIONS</span><span class="sxs-lookup"><span data-stu-id="27a28-272">DBSCHEMA_XML_COLLECTIONS</span></span>|<span data-ttu-id="27a28-273">4</span><span class="sxs-lookup"><span data-stu-id="27a28-273">4</span></span>|<span data-ttu-id="27a28-274">SCHEMACOLLECTION_CATALOGNAME</span><span class="sxs-lookup"><span data-stu-id="27a28-274">SCHEMACOLLECTION_CATALOGNAME</span></span><br /><br /> <span data-ttu-id="27a28-275">SCHEMACOLLECTION_SCHEMANAME</span><span class="sxs-lookup"><span data-stu-id="27a28-275">SCHEMACOLLECTION_SCHEMANAME</span></span><br /><br /> <span data-ttu-id="27a28-276">SCHEMACOLLECTIONNAME</span><span class="sxs-lookup"><span data-stu-id="27a28-276">SCHEMACOLLECTIONNAME</span></span><br /><br /> <span data-ttu-id="27a28-277">TARGETNAMESPACEURI</span><span class="sxs-lookup"><span data-stu-id="27a28-277">TARGETNAMESPACEURI</span></span>|  
  
### <a name="ole-db-property-set-additions-and-changes"></a><span data-ttu-id="27a28-278">OLE DB 속성 집합의 추가 내용 및 변경 내용</span><span class="sxs-lookup"><span data-stu-id="27a28-278">OLE DB Property Set Additions and Changes</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]<span data-ttu-id="27a28-279">Native Client는 많은 핵심 OLE DB 속성 집합에 새로운 값 이나 변경 된 값을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-279">Native Client adds new values or changes to many of the core OLE DB property sets.</span></span>  
  
#### <a name="the-dbpropset_sqlserverparameter-property-set"></a><span data-ttu-id="27a28-280">DBPROPSET_SQLSERVERPARAMETER 속성 집합</span><span class="sxs-lookup"><span data-stu-id="27a28-280">The DBPROPSET_SQLSERVERPARAMETER Property Set</span></span>  
 <span data-ttu-id="27a28-281">OLE DB를 통해 **xml** 데이터 형식을 지원 하기 위해 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client는 다음 값을 포함 하는 새 DBPROPSET_SQLSERVERPARAMETER 속성 집합을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-281">In order to support the **xml** data type through OLE DB, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client implements the new DBPROPSET_SQLSERVERPARAMETER property set, which contains the following values.</span></span>  
  
|<span data-ttu-id="27a28-282">Name</span><span class="sxs-lookup"><span data-stu-id="27a28-282">Name</span></span>|<span data-ttu-id="27a28-283">Type</span><span class="sxs-lookup"><span data-stu-id="27a28-283">Type</span></span>|<span data-ttu-id="27a28-284">Description</span><span class="sxs-lookup"><span data-stu-id="27a28-284">Description</span></span>|  
|----------|----------|-----------------|  
|<span data-ttu-id="27a28-285">SSPROP_PARAM_XML_SCHEMACOLLECTION_CATALOGNAME</span><span class="sxs-lookup"><span data-stu-id="27a28-285">SSPROP_PARAM_XML_SCHEMACOLLECTION_CATALOGNAME</span></span>|<span data-ttu-id="27a28-286">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="27a28-286">DBTYPE_WSTR</span></span>|<span data-ttu-id="27a28-287">XML 스키마 컬렉션이 정의된 카탈로그(데이터베이스)의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-287">The name of a catalog (database) in which an XML schema collection is defined.</span></span> <span data-ttu-id="27a28-288">SQL의 세 부분으로 구성된 이름 식별자의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-288">A part of the SQL three-part name identifier.</span></span>|  
|<span data-ttu-id="27a28-289">SSPROP_PARAM_XML_SCHEMACOLLECTION_SCHEMANAME</span><span class="sxs-lookup"><span data-stu-id="27a28-289">SSPROP_PARAM_XML_SCHEMACOLLECTION_SCHEMANAME</span></span>|<span data-ttu-id="27a28-290">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="27a28-290">DBTYPE_WSTR</span></span>|<span data-ttu-id="27a28-291">스키마 컬렉션 내 XML 스키마의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-291">The name of an XML schema within the schema collection.</span></span> <span data-ttu-id="27a28-292">SQL의 세 부분으로 구성된 이름 식별자의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-292">A part of the SQL three -part name identifier.</span></span>|  
|<span data-ttu-id="27a28-293">SSPROP_PARAM_XML_SCHEMACOLLECTIONNAME</span><span class="sxs-lookup"><span data-stu-id="27a28-293">SSPROP_PARAM_XML_SCHEMACOLLECTIONNAME</span></span>|<span data-ttu-id="27a28-294">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="27a28-294">DBTYPE_WSTR</span></span>|<span data-ttu-id="27a28-295">카탈로그 내 XML 스키마 컬렉션의 이름입니다. SQL의 세 부분으로 구성된 이름 식별자의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-295">The name of the XML schema collection within the catalog A part of the SQL three -part name identifier.</span></span>|  
  
#### <a name="the-dbpropset_sqlservercolumn-property-set"></a><span data-ttu-id="27a28-296">DBPROPSET_SQLSERVERCOLUMN 속성 집합</span><span class="sxs-lookup"><span data-stu-id="27a28-296">The DBPROPSET_SQLSERVERCOLUMN Property Set</span></span>  
 <span data-ttu-id="27a28-297">**Itabledefinition** 인터페이스에서 테이블 생성을 지원 하기 위해 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client는 DBPROPSET_SQLSERVERCOLUMN 속성 집합에 세 개의 새 열을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-297">To support the creation of tables in the **ITableDefinition** interface, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client adds three new columns to the DBPROPSET_SQLSERVERCOLUMN property set.</span></span>  
  
|<span data-ttu-id="27a28-298">Name</span><span class="sxs-lookup"><span data-stu-id="27a28-298">Name</span></span>|<span data-ttu-id="27a28-299">Type</span><span class="sxs-lookup"><span data-stu-id="27a28-299">Type</span></span>|<span data-ttu-id="27a28-300">Description</span><span class="sxs-lookup"><span data-stu-id="27a28-300">Description</span></span>|  
|----------|----------|-----------------|  
|<span data-ttu-id="27a28-301">SSPROP_COL_XML_SCHEMACOLLECTION_CATALOGNAME</span><span class="sxs-lookup"><span data-stu-id="27a28-301">SSPROP_COL_XML_SCHEMACOLLECTION_CATALOGNAME</span></span>|<span data-ttu-id="27a28-302">VT_BSTR</span><span class="sxs-lookup"><span data-stu-id="27a28-302">VT_BSTR</span></span>|<span data-ttu-id="27a28-303">형식화된 XML 열에 대해서는 이 속성이 XML 스키마가 저장된 카탈로그의 이름을 지정하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-303">For typed XML columns, this property is a string specifying the name of the catalog where the XML schema is stored.</span></span> <span data-ttu-id="27a28-304">다른 열 유형에 대해서는 이 속성이 빈 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-304">For other column types this property returns an empty string.</span></span>|  
|<span data-ttu-id="27a28-305">SSPROP_COL_XML_SCHEMACOLLECTION_SCHEMANAME</span><span class="sxs-lookup"><span data-stu-id="27a28-305">SSPROP_COL_XML_SCHEMACOLLECTION_SCHEMANAME</span></span>|<span data-ttu-id="27a28-306">VT_BSTR</span><span class="sxs-lookup"><span data-stu-id="27a28-306">VT_BSTR</span></span>|<span data-ttu-id="27a28-307">형식화된 XML 열에 대해서는 이 속성이 이 열을 정의하는 XML 스키마의 이름을 지정하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-307">For typed XML columns, this property is a string specifying the name of XML schema that defines this column.</span></span>|  
|<span data-ttu-id="27a28-308">SSPROP_COL_XML_SCHEMACOLLECTIONNAME</span><span class="sxs-lookup"><span data-stu-id="27a28-308">SSPROP_COL_XML_SCHEMACOLLECTIONNAME</span></span>|<span data-ttu-id="27a28-309">VT_BSTR</span><span class="sxs-lookup"><span data-stu-id="27a28-309">VT_BSTR</span></span>|<span data-ttu-id="27a28-310">형식화된 XML 열에 대해서는 이 속성이 값을 정의하는 XML 스키마 컬렉션의 이름을 지정하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-310">For typed XML columns, this property is a string specifying the name of the schema XML schema collection defining the value.</span></span>|  
  
 <span data-ttu-id="27a28-311">SSPROP_PARAM 값과 마찬가지로 이러한 속성은 모두 옵션이며 기본적으로 비어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-311">Like the SSPROP_PARAM values, all of these properties are optional and default to empty.</span></span> <span data-ttu-id="27a28-312">SSPROP_COL_XML_SCHEMACOLLECTION_CATALOGNAME 및 SSPROP_COL_XML_SCHEMACOLLECTION_SCHEMANAME은 SSPROP_COL_XML_SCHEMACOLLECTIONNAME이 지정된 경우에만 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-312">SSPROP_COL_XML_SCHEMACOLLECTION_CATALOGNAME and SSPROP_COL_XML_SCHEMACOLLECTION_SCHEMANAME may only be specified if SSPROP_COL_XML_SCHEMACOLLECTIONNAME is specified.</span></span> <span data-ttu-id="27a28-313">XML을 서버에 전달할 때 이러한 값이 포함되어 있으면 현재 데이터베이스에 대해 이들 속성의 존재 여부(유효성)가 확인되고 인스턴스 데이터가 스키마에 대해 검사됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-313">When passing XML to the server, if these values are included they are checked for existence (validity) against the current database and the instance data is checked against the schema.</span></span> <span data-ttu-id="27a28-314">어떤 경우든 이러한 속성은 모두 비어 있거나 모두 채워져 있어야 올바른 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-314">In all cases, to be valid they are either all empty or all filled in.</span></span>  
  
### <a name="ole-db-interface-additions-and-changes"></a><span data-ttu-id="27a28-315">OLE DB 인터페이스의 추가 내용 및 변경 내용</span><span class="sxs-lookup"><span data-stu-id="27a28-315">OLE DB Interface Additions and Changes</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]<span data-ttu-id="27a28-316">Native Client는 많은 핵심 OLE DB 인터페이스에 새로운 값 이나 변경 내용을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-316">Native Client adds new values or changes to many of the core OLE DB interfaces.</span></span>  
  
#### <a name="the-isscommandwithparameters-interface"></a><span data-ttu-id="27a28-317">ISSCommandWithParameters 인터페이스</span><span class="sxs-lookup"><span data-stu-id="27a28-317">The ISSCommandWithParameters Interface</span></span>  
 <span data-ttu-id="27a28-318">OLE DB를 통해 **xml** 데이터 형식을 지원 하기 위해 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client는 [ISSCommandWithParameters](../../native-client-ole-db-interfaces/isscommandwithparameters-ole-db.md) 인터페이스를 추가 하는 등의 많은 변경 내용을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-318">In order to support the **xml** data type through OLE DB, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client implements a number of changes including the addition of the [ISSCommandWithParameters](../../native-client-ole-db-interfaces/isscommandwithparameters-ole-db.md) interface.</span></span> <span data-ttu-id="27a28-319">이 새 인터페이스는 핵심 OLE DB 인터페이스인 **ICommandWithParameters**에서 상속됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-319">This new interface inherits from the core OLE DB interface **ICommandWithParameters**.</span></span> <span data-ttu-id="27a28-320">**ICommandWithParameters**에서 상속 된 세 가지 메서드 외에도 **GetParameterInfo**, **Mapparameternames**및 **SetParameterInfo**; **ISSCommandWithParameters** 은 서버별 데이터 형식을 처리 하는 데 사용 되는 [getparameterproperties](../../native-client-ole-db-interfaces/isscommandwithparameters-getparameterproperties-ole-db.md) 및 [setparameterproperties](../../native-client-ole-db-interfaces/isscommandwithparameters-setparameterproperties-ole-db.md) 메서드를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-320">In addition to the three methods inherited from **ICommandWithParameters**; **GetParameterInfo**, **MapParameterNames**, and **SetParameterInfo**; **ISSCommandWithParameters** provides the [GetParameterProperties](../../native-client-ole-db-interfaces/isscommandwithparameters-getparameterproperties-ole-db.md) and [SetParameterProperties](../../native-client-ole-db-interfaces/isscommandwithparameters-setparameterproperties-ole-db.md) methods that are used to handle server specific data types.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="27a28-321">또한 **ISSCommandWithParameters** 인터페이스는 새로운 SSPARAMPROPS 구조를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-321">The **ISSCommandWithParameters** interface also makes use of the new SSPARAMPROPS structure.</span></span>  
  
#### <a name="the-icolumnsrowset-interface"></a><span data-ttu-id="27a28-322">IColumnsRowset 인터페이스</span><span class="sxs-lookup"><span data-stu-id="27a28-322">The IColumnsRowset Interface</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]<span data-ttu-id="27a28-323">Native Client는 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] **IColumnRowset:: GetColumnsRowset** 메서드에서 반환 된 행 집합에 다음의 특정 열을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-323">Native Client adds the following [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]-specific columns to the rowset returned by the **IColumnRowset::GetColumnsRowset** method.</span></span> <span data-ttu-id="27a28-324">이러한 열에는 XML 스키마 컬렉션의 세 부분으로 구성된 이름이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-324">These columns contain the three-part name of an XML schema collection.</span></span> <span data-ttu-id="27a28-325">비XML 열이나 형식화되지 않은 XML 열에 대해서는 이 세 열 모두 기본값인 NULL을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-325">For non-XML columns or untyped XML columns, all three columns take the default value of NULL.</span></span>  
  
|<span data-ttu-id="27a28-326">열 이름</span><span class="sxs-lookup"><span data-stu-id="27a28-326">Column name</span></span>|<span data-ttu-id="27a28-327">Type</span><span class="sxs-lookup"><span data-stu-id="27a28-327">Type</span></span>|<span data-ttu-id="27a28-328">Description</span><span class="sxs-lookup"><span data-stu-id="27a28-328">Description</span></span>|  
|-----------------|----------|-----------------|  
|<span data-ttu-id="27a28-329">DBCOLUMN_SS_XML_SCHEMACOLLECTION_CATALOGNAME</span><span class="sxs-lookup"><span data-stu-id="27a28-329">DBCOLUMN_SS_XML_SCHEMACOLLECTION_CATALOGNAME</span></span>|<span data-ttu-id="27a28-330">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="27a28-330">DBTYPE_WSTR</span></span>|<span data-ttu-id="27a28-331">XML 스키마 컬렉션이 속한 카탈로그입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-331">The catalog an XML schema collection belongs to,</span></span><br /><br /> <span data-ttu-id="27a28-332">그렇지 않으면 NULL입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-332">NULL otherwise.</span></span>|  
|<span data-ttu-id="27a28-333">DBCOLUMN_SS_XML_SCHEMACOLLECTION_SCHEMANAME</span><span class="sxs-lookup"><span data-stu-id="27a28-333">DBCOLUMN_SS_XML_SCHEMACOLLECTION_SCHEMANAME</span></span>|<span data-ttu-id="27a28-334">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="27a28-334">DBTYPE_WSTR</span></span>|<span data-ttu-id="27a28-335">XML 스키마 컬렉션이 속한 스키마입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-335">The schema an XML schema collection belongs to.</span></span> <span data-ttu-id="27a28-336">그렇지 않으면 NULL입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-336">NULL otherwise.</span></span>|  
|<span data-ttu-id="27a28-337">DBCOLUMN_SS_XML_SCHEMACOLLECTIONNAME</span><span class="sxs-lookup"><span data-stu-id="27a28-337">DBCOLUMN_SS_XML_SCHEMACOLLECTIONNAME</span></span>|<span data-ttu-id="27a28-338">DBTYPE_WSTR</span><span class="sxs-lookup"><span data-stu-id="27a28-338">DBTYPE_WSTR</span></span>|<span data-ttu-id="27a28-339">형식화된 XML 열에 대해서는 XML 스키마 컬렉션의 이름이고, 그렇지 않으면 NULL입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-339">The name of XML schema collection for typed XML column, NULL otherwise.</span></span>|  
  
#### <a name="the-irowset-interface"></a><span data-ttu-id="27a28-340">IRowset 인터페이스</span><span class="sxs-lookup"><span data-stu-id="27a28-340">The IRowset Interface</span></span>  
 <span data-ttu-id="27a28-341">XML 열의 XML 인스턴스는 **IRowset::GetData** 메서드를 통해 검색됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-341">An XML instance in an XML column is retrieved through the **IRowset::GetData** method.</span></span> <span data-ttu-id="27a28-342">클라이언트에서 지정한 바인딩에 따라 XML 인스턴스가 DBTYPE_BSTR, DBTYPE_WSTR, DBTYPE_VARIANT, DBTYPE_XML, DBTYPE_STR, DBTYPE_BYTES로 검색되거나 DBTYPE_IUNKNOWN을 통해 인터페이스로 검색될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-342">Depending on the binding specified by the client, an XML instance can be retrieved as DBTYPE_BSTR, DBTYPE_WSTR, DBTYPE_VARIANT, DBTYPE_XML, DBTYPE_STR, DBTYPE_BYTES, or as an interface via DBTYPE_IUNKNOWN.</span></span> <span data-ttu-id="27a28-343">소비자가 DBTYPE_BSTR, DBTYPE_WSTR 또는 DBTYPE_VARIANT를 지정하면 공급자는 XML 인스턴스를 사용자가 요청한 형식으로 변환한 후 해당 바인딩에 지정된 위치에 가져다 놓습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-343">If the consumer specifies DBTYPE_BSTR, DBTYPE_WSTR, or DBTYPE_VARIANT, the provider converts the XML instance to the user requested type and put it into the location specified in the corresponding binding.</span></span>  
  
 <span data-ttu-id="27a28-344">소비자가 DBTYPE_IUNKNOWN을 지정하고 *pObject* 인수를 NULL로 설정하거나 *pObject* 인수를 IID_ISequentialStream으로 설정하면 소비자가 열에서 XML 데이터를 스트리밍할 수 있도록 공급자가 **ISequentialStream** 인터페이스를 소비자에게 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-344">If the consumer specifies DBTYPE_IUNKNOWN and sets the *pObject* argument to NULL, or sets the *pObject* argument to IID_ISequentialStream, the provider returns an **ISequentialStream** interface to the consumer so that the consumer can stream the XML data out of the column.</span></span> <span data-ttu-id="27a28-345">그러면 **ISequentialStream**이 XML 데이터를 유니코드 문자 스트림으로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-345">**ISequentialStream** then returns the XML data as a Unicode character stream.</span></span>  
  
 <span data-ttu-id="27a28-346">DBTYPE_IUNKNOWN에 바인딩된 XML 값을 반환할 때 공급자는 `sizeof (IUnknown *)`의 크기 값을 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-346">When returning an XML value bound to DBTYPE_IUNKNOWN, the provider reports a size value of `sizeof (IUnknown *)`.</span></span> <span data-ttu-id="27a28-347">이는 열이 DBTYPE_IUnknown 또는 DBTYPE_IDISPATCH로 바인딩되어 있는데 정확한 열 크기를 확인할 수 없는 경우 DBTYPE_IUNKNOWN/ISequentialStream이 취하는 방법과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-347">Note that this is consistent with the approach taken when a column is bound as DBTYPE_IUnknown or DBTYPE_IDISPATCH, and by DBTYPE_IUNKNOWN/ISequentialStream when the exact column size cannot be determined.</span></span>  
  
#### <a name="the-irowsetchange-interface"></a><span data-ttu-id="27a28-348">IRowsetChange 인터페이스</span><span class="sxs-lookup"><span data-stu-id="27a28-348">The IRowsetChange Interface</span></span>  
 <span data-ttu-id="27a28-349">소비자는 두 가지 방법으로 열의 XML 인스턴스를 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-349">There are two ways a consumer can update an XML instance in a column.</span></span> <span data-ttu-id="27a28-350">하나는 공급자가 만든 스토리지 개체 **ISequentialStream**을 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-350">The first one is through the storage object **ISequentialStream** created by the provider.</span></span> <span data-ttu-id="27a28-351">소비자는 **ISequentialStream::Write** 메서드를 호출하여 공급자가 반환한 XML 인스턴스를 직접 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-351">The consumer can call the **ISequentialStream::Write** method to directly update the XML instance returned by the provider.</span></span>  
  
 <span data-ttu-id="27a28-352">다른 하나는 **IRowsetChange::SetData** 또는 **IRowsetChange::InsertRow** 메서드를 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-352">The second approach is through **IRowsetChange::SetData** or **IRowsetChange::InsertRow** methods.</span></span> <span data-ttu-id="27a28-353">이 방법을 사용할 경우 소비자 버퍼의 XML 인스턴스를 DBTYPE_BSTR, DBTYPE_WSTR, DBTYPE_VARIANT, DBTYPE_XML 또는 DBTYPE_IUNKNOWN 유형의 바인딩에 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-353">In this approach, an XML instance in the consumer's buffer can be specified in a binding of type DBTYPE_BSTR, DBTYPE_WSTR, DBTYPE_VARIANT, DBTYPE_XML or DBTYPE_IUNKNOWN.</span></span>  
  
 <span data-ttu-id="27a28-354">DBTYPE_BSTR, DBTYPE_WSTR 또는 DBTYPE_VARIANT의 경우 공급자가 소비자 버퍼의 XML 인스턴스를 적절한 열에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-354">In case of DBTYPE_BSTR, DBTYPE_WSTR, or DBTYPE_VARIANT, the provider stores the XML instance residing in the consumer buffer into the proper column.</span></span>  
  
 <span data-ttu-id="27a28-355">DBTYPE_IUNKNOWN/ISequentialStream의 경우 소비자가 저장소 개체를 지정 하지 않은 경우 소비자는 사전에 **ISequentialStream** 개체를 만들고 XML 문서를 개체에 바인딩한 다음 **IRowsetChange:: SetData** 메서드를 통해 개체를 공급자에 게 전달 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-355">In the case of DBTYPE_IUNKNOWN/ISequentialStream, if the consumer does not specify any storage object, the consumer must create an **ISequentialStream** object in advance, bind the XML document with the object, and then pass the object to the provider through the **IRowsetChange::SetData** method.</span></span> <span data-ttu-id="27a28-356">소비자는 스토리지 개체를 만들고 pObject 인수를 IID_ISequentialStream으로 설정하고 **ISequentialStream** 개체를 만든 다음, 이 **ISequentialStream** 개체를 **IRowsetChange::SetData** 메서드에 전달할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-356">The consumer can also create a storage object, set the pObject argument to IID_ISequentialStream, create an **ISequentialStream** object and then pass the **ISequentialStream** object to the **IRowsetChange::SetData** method.</span></span> <span data-ttu-id="27a28-357">두 경우 모두 공급자는 **ISequentialStream** 개체를 통해 XML 개체를 검색하여 적절한 열에 삽입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-357">In both cases, the provider can retrieve the XML object through the **ISequentialStream** object and insert it into a proper column.</span></span>  
  
#### <a name="the-irowsetupdate-interface"></a><span data-ttu-id="27a28-358">IRowsetUpdate 인터페이스</span><span class="sxs-lookup"><span data-stu-id="27a28-358">The IRowsetUpdate Interface</span></span>  
 <span data-ttu-id="27a28-359">**IRowsetUpdate** 인터페이스는 지연된 업데이트에 사용할 수 있는 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-359">**IRowsetUpdate** interface provides functionality for delayed updates.</span></span> <span data-ttu-id="27a28-360">소비자가 **IRowsetUpdate: Update** 메서드를 호출할 때까지 행 집합에 사용할 수 있는 데이터를 다른 트랜잭션에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-360">The data made available to the rowsets is not made available to other transactions until the consumer calls the **IRowsetUpdate:Update** method.</span></span>  
  
#### <a name="the-irowsetfind-interface"></a><span data-ttu-id="27a28-361">IRowsetFind 인터페이스</span><span class="sxs-lookup"><span data-stu-id="27a28-361">The IRowsetFind Interface</span></span>  
 <span data-ttu-id="27a28-362">**IRowsetFind::FindNextRow** 메서드는 **xml** 데이터 형식에 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-362">The **IRowsetFind::FindNextRow** method does not work with the **xml** data type.</span></span> <span data-ttu-id="27a28-363">*hAccessor* 인수에 DBTYPE_XML 열이 지정되어 **IRowsetFind::FindNextRow**가 호출되면 DB_E_BADBINDINFO가 반환되며</span><span class="sxs-lookup"><span data-stu-id="27a28-363">When **IRowsetFind::FindNextRow** is called and the *hAccessor* argument specifies a column of DBTYPE_XML, DB_E_BADBINDINFO is returned.</span></span> <span data-ttu-id="27a28-364">이는 검색하는 열의 유형에 관계없이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-364">This occurs regardless of the type of column that is being searched.</span></span> <span data-ttu-id="27a28-365">이외 다른 바인딩 유형의 경우 검색하는 열이 **xml** 데이터 형식이면 **FindNextRow**가 실패하며 DB_E_BADCOMPAREOP가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-365">For any other binding type, the **FindNextRow** fails with DB_E_BADCOMPAREOP if the column to be searched is of the **xml** data type.</span></span>  
  
## <a name="sql-server-native-client-odbc-driver"></a><span data-ttu-id="27a28-366">SQL Server Native Client ODBC 드라이버</span><span class="sxs-lookup"><span data-stu-id="27a28-366">SQL Server Native Client ODBC Driver</span></span>  
 <span data-ttu-id="27a28-367">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]Native CLIENT ODBC 드라이버에서 **xml** 데이터 형식을 지원 하기 위해 다양 한 함수에 많은 변경 내용이 적용 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-367">In the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client ODBC driver, a number of changes have been made to various functions to support the **xml** data type.</span></span>  
  
### <a name="sqlcolattribute"></a><span data-ttu-id="27a28-368">SQLColAttribute</span><span class="sxs-lookup"><span data-stu-id="27a28-368">SQLColAttribute</span></span>  
 <span data-ttu-id="27a28-369">[Sqlcolattribute](../../native-client-odbc-api/sqlcolattribute.md) 함수는 SQL_CA_SS_XML_SCHEMACOLLECTION_CATALOG_NAME, SQL_CA_SS_XML_SCHEMACOLLECTION_SCHEMA_NAME 및 SQL_CA_SS _XML_SCHEMACOLLECTION_NAME를 포함 하 여 세 개의 새 필드 식별자를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-369">The [SQLColAttribute](../../native-client-odbc-api/sqlcolattribute.md) function has three new field identifiers, including SQL_CA_SS_XML_SCHEMACOLLECTION_CATALOG_NAME, SQL_CA_SS_XML_SCHEMACOLLECTION_SCHEMA_NAME, and SQL_CA_SS _XML_SCHEMACOLLECTION_NAME.</span></span>  
  
 <span data-ttu-id="27a28-370">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]Native CLIENT ODBC 드라이버는 SQL_DESC_DISPLAY_SIZE 및 SQL_DESC_LENGTH 열에 대 한 SQL_SS_LENGTH_UNLIMITED 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-370">The [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client ODBC driver reports SQL_SS_LENGTH_UNLIMITED for the SQL_DESC_DISPLAY_SIZE and SQL_DESC_LENGTH columns.</span></span>  
  
### <a name="sqlcolumns"></a><span data-ttu-id="27a28-371">SQLColumns</span><span class="sxs-lookup"><span data-stu-id="27a28-371">SQLColumns</span></span>  
 <span data-ttu-id="27a28-372">[Sqlcolumns](../../native-client-odbc-api/sqlcolumns.md) 함수는 SS_XML_SCHEMACOLLECTION_CATALOG_NAME, SS_XML_SCHEMACOLLECTION_SCHEMA_NAME 및 SS_XML_SCHEMACOLLECTION_NAME를 포함 하 여 세 개의 새 열을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-372">The [SQLColumns](../../native-client-odbc-api/sqlcolumns.md) function has three new columns including SS_XML_SCHEMACOLLECTION_CATALOG_NAME, SS_XML_SCHEMACOLLECTION_SCHEMA_NAME, and SS_XML_SCHEMACOLLECTION_NAME.</span></span> <span data-ttu-id="27a28-373">기존의 TYPE_NAME 열은 XML 형식의 이름을 나타내는 데 사용되고 XML 형식 열 또는 매개 변수에 대한 DATA_TYPE은 SQL_SS_XML입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-373">The existing TYPE_NAME column is used to indicate the name of the XML type, and the DATA_TYPE for a XML type column or parameter is SQL_SS_XML.</span></span>  
  
 <span data-ttu-id="27a28-374">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]Native CLIENT ODBC 드라이버는 COLUMN_SIZE 및 CHAR_OCTET_LENGTH 값에 대 한 SQL_SS_LENGTH_UNLIMITED 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-374">The [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client ODBC driver reports SQL_SS_LENGTH_UNLIMITED for the COLUMN_SIZE and CHAR_OCTET_LENGTH values.</span></span>  
  
### <a name="sqldescribecol"></a><span data-ttu-id="27a28-375">SQLDescribeCol</span><span class="sxs-lookup"><span data-stu-id="27a28-375">SQLDescribeCol</span></span>  
 <span data-ttu-id="27a28-376">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]Native CLIENT ODBC 드라이버는 [SQLDescribeCol](../../native-client-odbc-api/sqldescribecol.md) 함수에서 열 크기를 확인할 수 없을 때 SQL_SS_LENGTH_UNLIMITED 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-376">The [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client ODBC driver reports SQL_SS_LENGTH_UNLIMITED when the column size cannot be determined in the [SQLDescribeCol](../../native-client-odbc-api/sqldescribecol.md) function.</span></span>  
  
### <a name="sqlgettypeinfo"></a><span data-ttu-id="27a28-377">SQLGetTypeInfo</span><span class="sxs-lookup"><span data-stu-id="27a28-377">SQLGetTypeInfo</span></span>  
 <span data-ttu-id="27a28-378">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]Native CLIENT ODBC 드라이버는 [SQLGetTypeInfo](../../native-client-odbc-api/sqlgettypeinfo.md) 함수의 **xml** 데이터 형식에 대 한 최대 COLUMN_SIZE SQL_SS_LENGTH_UNLIMITED 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-378">The [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client ODBC driver reports SQL_SS_LENGTH_UNLIMITED as the maximum COLUMN_SIZE for the **xml** data type in the [SQLGetTypeInfo](../../native-client-odbc-api/sqlgettypeinfo.md) function.</span></span>  
  
### <a name="sqlprocedurecolumns"></a><span data-ttu-id="27a28-379">SQLProcedureColumns</span><span class="sxs-lookup"><span data-stu-id="27a28-379">SQLProcedureColumns</span></span>  
 <span data-ttu-id="27a28-380">[SQLProcedureColumns](../../native-client-odbc-api/sqlprocedurecolumns.md) 함수는 **sqlcolumns** 함수와 동일한 열을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-380">The [SQLProcedureColumns](../../native-client-odbc-api/sqlprocedurecolumns.md) function has the same column additions as the **SQLColumns** function.</span></span>  
  
 <span data-ttu-id="27a28-381">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]Native CLIENT ODBC 드라이버는 **xml** 데이터 형식에 대 한 최대 COLUMN_SIZE SQL_SS_LENGTH_UNLIMITED 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-381">The [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client ODBC driver reports SQL_SS_LENGTH_UNLIMITED as the maximum COLUMN_SIZE for the **xml** data type.</span></span>  
  
### <a name="supported-conversions"></a><span data-ttu-id="27a28-382">지원되는 변환</span><span class="sxs-lookup"><span data-stu-id="27a28-382">Supported Conversions</span></span>  
 <span data-ttu-id="27a28-383">SQL에서 C 데이터 형식으로 변환할 때 다음과 같은 조건 하에 SQL_C_WCHAR, SQL_C_BINARY 및 SQL_C_CHAR를 모두 SQL_SS_XML로 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-383">When converting from SQL to C data types, SQL_C_WCHAR, SQL_C_BINARY, and SQL_C_CHAR can all be converted to SQL_SS_XML, with the following stipulations:</span></span>  
  
-   <span data-ttu-id="27a28-384">SQL_C_WCHAR: Format은 u t f-16 이며, BOM (바이트 순서 표시)이 없고 null 종료를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-384">SQL_C_WCHAR: Format is UTF-16, no byte-order mark (BOM), with null termination.</span></span>  
  
-   <span data-ttu-id="27a28-385">SQL_C_BINARY: Format은 u t f-16 이며 null 종료 없이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-385">SQL_C_BINARY: Format is UTF-16, with no null termination.</span></span> <span data-ttu-id="27a28-386">서버에서 받은 데이터에 BOM이 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-386">A BOM is added to data received from the server.</span></span> <span data-ttu-id="27a28-387">서버에서 빈 문자열을 반환하더라도 BOM이 애플리케이션에 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-387">If an empty string is returned by the server a BOM is still returned to the application.</span></span> <span data-ttu-id="27a28-388">버퍼 길이가 홀수 바이트이면 데이터가 올바르게 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-388">If the buffer length is an odd number of bytes the data ise truncated correctly.</span></span> <span data-ttu-id="27a28-389">전체 값이 청크로 반환되면 연결해서 올바른 값으로 다시 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-389">If the whole value is returned in chunks they can be concatenated to re-constitute the correct value</span></span>  
  
-   <span data-ttu-id="27a28-390">SQL_C_CHAR: Format은 클라이언트 코드 페이지에서 null 종료로 인코딩된 멀티 바이트 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-390">SQL_C_CHAR: Format is multibyte characters encoded in client code page with null termination.</span></span> <span data-ttu-id="27a28-391">서버에서 제공하는 UTF-16에서 변환하면 데이터가 손상될 수 있으므로 이 바인딩은 사용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-391">Conversion from server supplied UTF-16 may cause data corruption, so this binding is strongly discouraged.</span></span>  
  
 <span data-ttu-id="27a28-392">C에서 SQL 데이터 형식으로 변환할 때 다음과 같은 조건 하에 SQL_C_WCHAR, SQL_C_BINARY 및 SQL_C_CHAR를 모두 SQL_SS_XML로 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-392">When converting from C to SQL data types, SQL_C_WCHAR, SQL_C_BINARY, and SQL_C_CHAR can all be converted to SQL_SS_XML, with the following stipulations:</span></span>  
  
-   <span data-ttu-id="27a28-393">SQL_C_WCHAR: BOM은 항상 서버로 전송 되는 데이터에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-393">SQL_C_WCHAR: A BOM is always be added to data sent to the server.</span></span> <span data-ttu-id="27a28-394">데이터의 시작 부분에 이미 BOM이 있는 경우 결과적으로 버퍼 시작 부분에 두 개의 BOM이 오게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-394">If the data already started with a BOM, this results in two BOMs at the start of the buffer.</span></span> <span data-ttu-id="27a28-395">서버에서는 첫 번째 BOM을 통해 인코딩을 UTF-16으로 인식한 다음 이 BOM을 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-395">The server uses the first BOM to recognize the encoding as UTF-16 and then discard it.</span></span> <span data-ttu-id="27a28-396">두 번째 BOM은 너비가 0인 줄 바꿈하지 않는 공백 문자로 해석됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-396">The second BOM is interpreted as a zero-width nonbreaking space character.</span></span>  
  
-   <span data-ttu-id="27a28-397">SQL_C_BINARY: 변환이 수행 되지 않으며 데이터가 서버에 "있는 그대로" 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-397">SQL_C_BINARY: No conversion is performed, and the data is passed to the server "as is."</span></span> <span data-ttu-id="27a28-398">UTF-16 데이터는 BOM으로 시작해야 합니다. 그렇지 않으면 서버에서 인코딩을 올바르게 인식할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-398">UTF-16 data must start with a BOM; if it does not, the encoding may not be correctly recognized by the server.</span></span>  
  
-   <span data-ttu-id="27a28-399">SQL_C_CHAR: 데이터가 클라이언트에서 u t f-16으로 변환 되 고 SQL_C_WCHAR (BOM 추가 포함)와 마찬가지로 서버로 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-399">SQL_C_CHAR: The data is converted to UTF-16 on the client and sent to the server just as SQL_C_WCHAR (including the addition of a BOM).</span></span> <span data-ttu-id="27a28-400">XML이 클라이언트 코드 페이지로 인코딩되지 않은 경우 데이터가 손상될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-400">If the XML is not encoded in the client code page this can cause data corruption.</span></span>  
  
 <span data-ttu-id="27a28-401">XML 표준을 따르려면 UTF-16로 인코딩된 XML이 BOM(바이트 순서 표시), 즉 UTF-16 문자 코드 0xFEFF로 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-401">The XML standard requires UTF-16 encoded XML to start with a byte-order mark (BOM), UTF-16 character code 0xFEFF.</span></span> <span data-ttu-id="27a28-402">바인딩을 사용 하 여 작업을 수행할 때 Native Client는 SQL_C_BINARY 바인딩을 사용 하 여 작업할 때 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] BOM을 요구 하거나 추가 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-402">When working with a SQL_C_BINARY binding, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client does not require or add a BOM, as the encoding is implied by the binding.</span></span> <span data-ttu-id="27a28-403">BOM을 추가하는 목적은 다른 XML 프로세서 및 스토리지 시스템을 간편하게 처리할 수 있도록 하기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-403">The intent is to provide simplicity in dealing with other XML processors and storage systems.</span></span> <span data-ttu-id="27a28-404">이 경우 UTF-16으로 인코딩된 XML에 BOM을 제공해야 합니다. [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]를 비롯한 대부분의 XML 프로세서는 값의 처음 몇 바이트를 검사하여 인코딩을 추론하기 때문에 애플리케이션에서는 실제 인코딩을 확인할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-404">In this case a BOM should be present with UTF-16 encoded XML, and the application need not be concerned with the actual encoding, because the majority of XML processors (including [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]) deduce the encoding by inspecting the first few bytes of the value.</span></span> <span data-ttu-id="27a28-405">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]SQL_C_BINARY 바인딩을 사용 하 여 Native Client에서 받은 XML 데이터는 항상 u t f-16으로, BOM은 포함 되 고, 포함 된 인코딩 선언 없이 인코딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="27a28-405">XML data received from [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client using SQL_C_BINARY bindings are always encoded in UTF-16 with a BOM and without an embedded encoding declaration.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="27a28-406">참고 항목</span><span class="sxs-lookup"><span data-stu-id="27a28-406">See Also</span></span>  
 <span data-ttu-id="27a28-407">[SQL Server Native Client 기능](sql-server-native-client-features.md) </span><span class="sxs-lookup"><span data-stu-id="27a28-407">[SQL Server Native Client Features](sql-server-native-client-features.md) </span></span>  
 [<span data-ttu-id="27a28-408">ISSCommandWithParameters&#40;OLE DB&#41;</span><span class="sxs-lookup"><span data-stu-id="27a28-408">ISSCommandWithParameters &#40;OLE DB&#41;</span></span>](../../native-client-ole-db-interfaces/isscommandwithparameters-ole-db.md)  
  
  
