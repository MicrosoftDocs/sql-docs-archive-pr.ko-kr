---
title: MARS(Multiple Active Result Set) 사용 | Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- SQL Server Native Client OLE DB provider, MARS
- SQLNCLI, MARS
- data access [SQL Server Native Client], MARS
- Multiple Active Result Sets
- SQL Server Native Client, MARS
- MARS [SQL Server]
- SQL Server Native Client ODBC driver, MARS
ms.assetid: ecfd9c6b-7d29-41d8-af2e-89d7fb9a1d83
author: rothja
ms.author: jroth
ms.openlocfilehash: 7119048df3de23b1cfc5d6c8fb41672d82be14f9
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87653315"
---
# <a name="using-multiple-active-result-sets-mars"></a><span data-ttu-id="11c0a-102">MARS(Multiple Active Result Sets) 사용</span><span class="sxs-lookup"><span data-stu-id="11c0a-102">Using Multiple Active Result Sets (MARS)</span></span>
  [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)]<span data-ttu-id="11c0a-103">에서 [!INCLUDE[ssDE](../../../includes/ssde-md.md)]에 액세스하는 애플리케이션에서 MARS(Multiple Active Result Sets)를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-103">introduced support for multiple active result sets (MARS) in applications accessing the [!INCLUDE[ssDE](../../../includes/ssde-md.md)].</span></span> <span data-ttu-id="11c0a-104">이전 버전의 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]에서는 데이터베이스 애플리케이션이 연결에 대한 다중 활성 문을 유지할 수 없었습니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-104">In earlier versions of [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], database applications could not maintain multiple active statements on a connection.</span></span> <span data-ttu-id="11c0a-105">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 기본 결과 집합을 사용할 경우 애플리케이션에서 한 일괄 작업의 모든 결과 집합을 처리하거나 취소해야만 해당 연결에서 다른 일괄 작업을 실행할 수 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-105">When using [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] default result sets, the application had to process or cancel all result sets from one batch before it could execute any other batch on that connection.</span></span> [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)]<span data-ttu-id="11c0a-106">에서는 애플리케이션에서 연결당 둘 이상의 보류 중인 요청을 유지할 수 있도록 하는 새로운 연결 특성이 도입되었습니다. 즉, 연결당 둘 이상의 활성 기본 결과 집합을 유지할 수 있게 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-106">introduced a new connection attribute that allows applications to have more than one pending request per connection, and in particular, to have more than one active default result set per connection.</span></span>  
  
 <span data-ttu-id="11c0a-107">MARS는 다음과 같은 새로운 기능을 사용하여 애플리케이션 디자인을 단순화합니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-107">MARS simplifies application design with the following new capabilities:</span></span>  
  
-   <span data-ttu-id="11c0a-108">애플리케이션에서 여러 기본 결과 집합을 열어 두고 읽기를 인터리브할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-108">Applications can have multiple default result sets open and can interleave reading from them.</span></span>  
  
-   <span data-ttu-id="11c0a-109">애플리케이션이 기본 결과 집합을 연 상태로 다른 문(INSERT, UPDATE, DELETE 및 저장 프로시저 호출 등)을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-109">Applications can execute other statements (for example, INSERT, UPDATE, DELETE, and stored procedure calls) while default result sets are open.</span></span>  
  
 <span data-ttu-id="11c0a-110">다음은 MARS를 사용하는 애플리케이션에 유용한 지침입니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-110">Applications using MARS will find the following guidelines beneficial:</span></span>  
  
-   <span data-ttu-id="11c0a-111">단일 SQL 문(SELECT, OUTPUT이 있는 DML, RECEIVE, READ TEXT 등)으로 생성된 일시적으로 존재하거나 크기가 작은 결과 집합에 대해서는 기본 결과 집합을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-111">Default results sets should be used for short lived or short result sets generated by single SQL statements (SELECT, DML with OUTPUT, RECEIVE, READ TEXT, and so on).</span></span>  
  
-   <span data-ttu-id="11c0a-112">단일 SQL 문으로 생성된 오래 존재하거나 크기가 큰 결과 집합에 대해서는 서버 커서를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-112">Server cursors should be used for longer lived or large result sets generated by single SQL statements.</span></span>  
  
-   <span data-ttu-id="11c0a-113">결과 반환 여부에 관계없이 프로시저 관련 요청이나 다중 결과를 반환하는 일괄 처리에서는 항상 결과의 끝까지 읽어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-113">Always read to the end of results for procedural requests regardless of whether they return results or not, and for batches that return multiple results.</span></span>  
  
-   <span data-ttu-id="11c0a-114">가능한 경우에는 항상 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 문 대신 API 호출을 사용하여 연결 속성을 변경하고 트랜잭션을 관리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-114">Wherever possible, use API calls to change connection properties and manage transactions in preference to [!INCLUDE[tsql](../../../includes/tsql-md.md)] statements.</span></span>  
  
-   <span data-ttu-id="11c0a-115">MARS에서 동시 일괄 처리가 실행되는 동안에는 세션 범위의 가장이 금지됩니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-115">In MARS, session-scoped impersonation is prohibited while concurrent batches are running.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="11c0a-116">기본적으로 MARS 기능은 설정되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-116">By default, MARS functionality is not enabled.</span></span> <span data-ttu-id="11c0a-117">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]에 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client를 사용하여 연결할 때 MARS를 사용하려면 연결 문자열 내에서 명확하게 MARS를 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-117">To use MARS when connecting to [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] with [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client, you must specifically enable it within a connection string.</span></span> <span data-ttu-id="11c0a-118">자세한 내용은 이 항목의 뒷부분에서 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client OLE DB 공급자 및 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client ODBC 드라이버 섹션을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="11c0a-118">For more information, see the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client OLE DB provider and [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client ODBC driver sections, later in this topic.</span></span>  
  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="11c0a-119">Native Client는 연결에서 활성 문의 수를 제한하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-119">Native Client does not limit the number of active statements on a connection.</span></span>  
  
 <span data-ttu-id="11c0a-120">여러 개의 다중 문 일괄 처리가 필요 없거나 저장 프로시저를 동시에 실행할 필요가 없는 일반적인 애플리케이션의 경우에는 MARS 구현 방법을 몰라도 MARS를 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-120">Typical applications which do not need to have more than a single multistatement batch or stored procedure executing at the same time will benefit from MARS without having to understand how MARS is implemented.</span></span> <span data-ttu-id="11c0a-121">하지만 요구 사항이 복잡한 애플리케이션에서는 MARS 구현 방법을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-121">However, applications with more complex requirements do need to take account of this.</span></span>  
  
 <span data-ttu-id="11c0a-122">MARS를 사용하면 단일 연결 내에서 여러 요청의 실행을 인터리브할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-122">MARS enables the interleaved execution of multiple requests within a single connection.</span></span> <span data-ttu-id="11c0a-123">즉, 일괄 처리를 실행할 수 있으며 해당 일괄 처리가 실행되는 동안 요청을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-123">That is, it allows a batch to run, and within its execution, it allows other requests to execute.</span></span> <span data-ttu-id="11c0a-124">하지만 MARS는 병렬 실행이 아니라 인터리브로 정의된다는 것에 주의하십시오.</span><span class="sxs-lookup"><span data-stu-id="11c0a-124">Note, however, that MARS is defined in terms of interleaving, not in terms of parallel execution.</span></span>  
  
 <span data-ttu-id="11c0a-125">MARS 인프라에서는 다중 일괄 처리를 인터리브 방식으로 실행할 수 있습니다. 하지만 실행은 잘 정의된 지점에서만 전환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-125">The MARS infrastructure allows multiple batches to execute in an interleaved fashion, though execution can only be switched at well defined points.</span></span> <span data-ttu-id="11c0a-126">또한 대부분의 문은 일괄 처리 내에서 개별적으로 실행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-126">In addition, most statements must run atomically within a batch.</span></span> <span data-ttu-id="11c0a-127">클라이언트에 행을 반환 하는 문 (예: *생성 지점이*라고도 함)은 행이 클라이언트에 전송 되는 동안 완료 되기 전에 인터리브 실행이 허용 됩니다. 예를 들면 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-127">Statements which return rows to the client, which are sometimes referred to as *yield points*, are allowed to interleave execution before completion while rows are being sent to the client, for example:</span></span>  
  
-   <span data-ttu-id="11c0a-128">SELECT</span><span class="sxs-lookup"><span data-stu-id="11c0a-128">SELECT</span></span>  
  
-   <span data-ttu-id="11c0a-129">FETCH</span><span class="sxs-lookup"><span data-stu-id="11c0a-129">FETCH</span></span>  
  
-   <span data-ttu-id="11c0a-130">RECEIVE</span><span class="sxs-lookup"><span data-stu-id="11c0a-130">RECEIVE</span></span>  
  
 <span data-ttu-id="11c0a-131">저장 프로시저나 일괄 처리의 일부로 실행되는 다른 모든 문은 실행이 완료된 후에만 다른 MARS 요청으로 실행을 전환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-131">Any other statements that are executed as part of a stored procedure or batch must run to completion before execution can be switched to other MARS requests.</span></span>  
  
 <span data-ttu-id="11c0a-132">일괄 처리에서 실행이 인터리브되는 세부적인 방식은 많은 요소의 영향을 받게 되므로 양보점을 포함하는 다중 일괄 처리에서 명령이 실행되는 정확한 순서를 예측하기 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-132">The exact manner in which batches interleave execution is influenced by a number of factors, and it is difficult to predict the exact sequence in which commands from multiple batches that contain yield points will be executed.</span></span> <span data-ttu-id="11c0a-133">따라서 이와 같은 복잡한 일괄 처리의 인터리브 실행 때문에 원하지 않는 결과가 나타나지 않도록 주의하십시오.</span><span class="sxs-lookup"><span data-stu-id="11c0a-133">Be careful to avoid unwanted side effects due to interleaved execution of such complex batches.</span></span>  
  
 <span data-ttu-id="11c0a-134">연결 상태(SET, USE) 및 트랜잭션(BEGIN TRAN, COMMIT, ROLLBACK)을 관리하는 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 문 대신 API 호출을 사용하여 양보점을 포함할 수 있는 다중 문 일괄 처리에 이러한 문이 포함되지 않도록 하고 모든 결과를 사용하거나 취소하여 이러한 일괄 처리의 실행을 직렬화함으로써 문제를 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-134">Avoid problems by using API calls rather than [!INCLUDE[tsql](../../../includes/tsql-md.md)] statements to manage connection state (SET, USE) and transactions (BEGIN TRAN, COMMIT, ROLLBACK) by not including these statements in multi-statement batches that also contain yield points, and by serializing execution of such batches by consuming or canceling all results.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="11c0a-135">MARS를 설정할 경우 수동 또는 암시적 트랜잭션을 시작하는 일괄 처리 또는 저장 프로시저는 트랜잭션을 완료한 후 일괄 처리를 종료해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-135">A batch or stored procedure which starts a manual or implicit transaction when MARS is enabled must complete the transaction before the batch exits.</span></span> <span data-ttu-id="11c0a-136">그렇지 않으면 일괄 처리가 완료될 때 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]에서 해당 트랜잭션으로 수행된 모든 변경 사항을 롤백합니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-136">If it does not, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] rolls back all changes made by the transaction when the batch finishes.</span></span> <span data-ttu-id="11c0a-137">그와 같은 트랜잭션은 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]에서 일괄 처리 범위 트랜잭션으로 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-137">Such a transaction is managed by [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] as a batch-scoped transaction.</span></span> <span data-ttu-id="11c0a-138">이것은 MARS를 설정할 경우 올바르게 동작하는 기존 저장 프로시저를 사용할 수 있도록 [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)]에 새로 도입된 트랜잭션 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-138">This is a new type of transaction introduced in [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)] to enable existing well-behaved stored procedures to be used when MARS is enabled.</span></span> <span data-ttu-id="11c0a-139">일괄 처리 범위의 트랜잭션에 대한 자세한 내용은 [트랜잭션 문&#40;Transact-SQL&#41;](/sql/t-sql/language-elements/transactions-transact-sql)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="11c0a-139">For more information about batch-scoped transactions, see [Transaction Statements &#40;Transact-SQL&#41;](/sql/t-sql/language-elements/transactions-transact-sql).</span></span>  
  
 <span data-ttu-id="11c0a-140">ADO에서 MARS를 사용 하는 예제는 [SQL Server Native Client에서 Ado 사용](../applications/using-ado-with-sql-server-native-client.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="11c0a-140">For an example of using MARS from ADO, see [Using ADO with SQL Server Native Client](../applications/using-ado-with-sql-server-native-client.md).</span></span>  
  
## <a name="sql-server-native-client-ole-db-provider"></a><span data-ttu-id="11c0a-141">SQL Server Native Client OLE DB 공급자</span><span class="sxs-lookup"><span data-stu-id="11c0a-141">SQL Server Native Client OLE DB Provider</span></span>  
 <span data-ttu-id="11c0a-142">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]Native Client OLE DB 공급자는 DBPROPSET_SQLSERVERDBINIT 속성 집합에서 구현 된 SSPROP_INIT_MARSCONNECTION 데이터 원본 초기화 속성을 추가 하 여 MARS를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-142">The [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client OLE DB provider supports MARS through the addition of the SSPROP_INIT_MARSCONNECTION data source initialization property, which is implemented in the DBPROPSET_SQLSERVERDBINIT property set.</span></span> <span data-ttu-id="11c0a-143">이와 함께 새 연결 문자열 키워드인 `MarsConn`이 추가되었습니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-143">In addition, a new connection string keyword, `MarsConn`, as been added.</span></span> <span data-ttu-id="11c0a-144">이 키워드는 `true` 또는 `false` 값을 받으며, 기본값은 `false`입니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-144">It accepts `true` or `false` values; `false` is the default.</span></span>  
  
 <span data-ttu-id="11c0a-145">데이터 원본 속성 DBPROP_MULTIPLECONNECTIONS의 기본값은 VARIANT_TRUE입니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-145">The data source property DBPROP_MULTIPLECONNECTIONS defaults to VARIANT_TRUE.</span></span> <span data-ttu-id="11c0a-146">이것은 공급자가 다중 동시 명령 및 행 집합 개체를 지원하기 위해 다중 연결을 생성한다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-146">This means the provider will spawn multiple connections in order to support multiple concurrent command and rowset objects.</span></span> <span data-ttu-id="11c0a-147">MARS를 사용 하는 경우 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client는 단일 연결에서 여러 명령 및 행 집합 개체를 지원할 수 있으므로 MULTIPLE_CONNECTIONS는 기본적으로 VARIANT_FALSE로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-147">When MARS is enabled, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client can support multiple command and rowset objects on a single connection, so MULTIPLE_CONNECTIONS is set to VARIANT_FALSE by default.</span></span>  
  
 <span data-ttu-id="11c0a-148">DBPROPSET_SQLSERVERDBINIT 속성 집합의 향상된 기능에 대한 자세한 내용은 [초기화 및 권한 부여 속성](../../native-client-ole-db-data-source-objects/initialization-and-authorization-properties.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="11c0a-148">For more information about enhancements made to the DBPROPSET_SQLSERVERDBINIT property set, see [Initialization and Authorization Properties](../../native-client-ole-db-data-source-objects/initialization-and-authorization-properties.md).</span></span>  
  
### <a name="sql-server-native-client-ole-db-provider-example"></a><span data-ttu-id="11c0a-149">SQL Server Native Client OLE DB 공급자 예</span><span class="sxs-lookup"><span data-stu-id="11c0a-149">SQL Server Native Client OLE DB Provider Example</span></span>  
 <span data-ttu-id="11c0a-150">이 예에서는 네이티브 OLE DB 공급자를 사용 하 여 데이터 원본 개체를 만들고, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] MARS는 세션 개체가 만들어지기 전에 DBPROPSET_SQLSERVERDBINIT 속성 집합을 사용 하 여 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-150">In this example, a data source object is created using the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native OLE DB provider, and MARS is enabled using the DBPROPSET_SQLSERVERDBINIT property set before the session object is created.</span></span>  
  
```  
#include <sqlncli.h>  
  
IDBInitialize *pIDBInitialize = NULL;  
IDBCreateSession *pIDBCreateSession = NULL;  
IDBProperties *pIDBProperties = NULL;  
  
// Create the data source object.  
hr = CoCreateInstance(CLSID_SQLNCLI10, NULL,  
   CLSCTX_INPROC_SERVER,  
   IID_IDBInitialize,   
    (void**)&pIDBInitialize);  
  
hr = pIDBInitialize->QueryInterface(IID_IDBProperties, (void**)&pIDBProperties);  
  
// Set the MARS property.  
DBPROP rgPropMARS;  
  
// The following is necessary since MARS is off by default.  
rgPropMARS.dwPropertyID = SSPROP_INIT_MARSCONNECTION;  
rgPropMARS.dwOptions = DBPROPOPTIONS_REQUIRED;  
rgPropMARS.dwStatus = DBPROPSTATUS_OK;  
rgPropMARS.colid = DB_NULLID;  
V_VT(&(rgPropMARS.vValue)) = VT_BOOL;  
V_BOOL(&(rgPropMARS.vValue)) = VARIANT_TRUE;  
  
// Create the structure containing the properties.  
DBPROPSET PropSet;  
PropSet.rgProperties = &rgPropMARS;  
PropSet.cProperties = 1;  
PropSet.guidPropertySet = DBPROPSET_SQLSERVERDBINIT;  
  
// Get an IDBProperties pointer and set the initialization properties.  
pIDBProperties->SetProperties(1, &PropSet);  
pIDBProperties->Release();  
  
// Initialize the data source object.  
hr = pIDBInitialize->Initialize();  
  
//Create a session object from a data source object.  
IOpenRowset * pIOpenRowset = NULL;  
hr = IDBInitialize->QueryInterface(IID_IDBCreateSession, (void**)&pIDBCreateSession));  
hr = pIDBCreateSession->CreateSession(  
   NULL,             // pUnkOuter  
   IID_IOpenRowset,  // riid  
  &pIOpenRowset ));  // ppSession  
  
// Create a rowset with a firehose mode cursor.  
IRowset *pIRowset = NULL;  
DBPROP rgRowsetProperties[2];  
  
// To get a firehose mode cursor request a   
// forward only read only rowset.  
rgRowsetProperties[0].dwPropertyID = DBPROP_IRowsetLocate;  
rgRowsetProperties[0].dwOptions = DBPROPOPTIONS_REQUIRED;  
rgRowsetProperties[0].dwStatus = DBPROPSTATUS_OK;  
rgRowsetProperties[0].colid = DB_NULLID;  
VariantInit(&(rgRowsetProperties[0].vValue));  
rgRowsetProperties[0].vValue.vt = VARIANT_BOOL;  
rgRowsetProperties[0].vValue.boolVal = VARIANT_FALSE;  
  
rgRowsetProperties[1].dwPropertyID = DBPROP_IRowsetChange;  
rgRowsetProperties[1].dwOptions = DBPROPOPTIONS_REQUIRED;  
rgRowsetProperties[1].dwStatus = DBPROPSTATUS_OK;  
rgRowsetProperties[1].colid = DB_NULLID;  
VariantInit(&(rgRowsetProperties[1].vValue));  
rgRowsetProperties[1].vValue.vt = VARIANT_BOOL;  
rgRowsetProperties[1].vValue.boolVal = VARIANT_FALSE;  
  
DBPROPSET rgRowsetPropSet[1];  
rgRowsetPropSet[0].rgProperties = rgRowsetProperties  
rgRowsetPropSet[0].cProperties = 2  
rgRowsetPropSet[0].guidPropertySet = DBPROPSET_ROWSET;  
  
hr = pIOpenRowset->OpenRowset (NULL,  
   &TableID,  
   NULL,  
   IID_IRowset,  
   1,  
   rgRowsetPropSet  
   (IUnknown**)&pIRowset);  
```  
  
## <a name="sql-server-native-client-odbc-driver"></a><span data-ttu-id="11c0a-151">SQL Server Native Client ODBC 드라이버</span><span class="sxs-lookup"><span data-stu-id="11c0a-151">SQL Server Native Client ODBC Driver</span></span>  
 <span data-ttu-id="11c0a-152">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]Native CLIENT ODBC 드라이버는 [SQLSetConnectAttr](../../native-client-odbc-api/sqlsetconnectattr.md) 및 [SQLGetConnectAttr](../../native-client-odbc-api/sqlgetconnectattr.md) 함수를 추가 하 여 MARS를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-152">The [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client ODBC driver supports MARS through additions to the [SQLSetConnectAttr](../../native-client-odbc-api/sqlsetconnectattr.md) and [SQLGetConnectAttr](../../native-client-odbc-api/sqlgetconnectattr.md) functions.</span></span> <span data-ttu-id="11c0a-153">SQL_MARS_ENABLED_YES 또는 SQL_MARS_ENABLED_NO를 받아들이는 SQL_COPT_SS_MARS_ENABLED가 추가되었으며 기본값은 SQL_MARS_ENABLED_NO입니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-153">SQL_COPT_SS_MARS_ENABLED has been added to accept either SQL_MARS_ENABLED_YES or SQL_MARS_ENABLED_NO, with SQL_MARS_ENABLED_NO being the default.</span></span> <span data-ttu-id="11c0a-154">이와 함께 새 연결 문자열 키워드인 `Mars_Connection`이 추가되었습니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-154">In addition, a new connection string keyword, `Mars_Connection`, as been added.</span></span> <span data-ttu-id="11c0a-155">이 키워드는 "yes" 또는 "no" 값을 받으며, 기본값은 "no"입니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-155">It accepts "yes" or "no" values; "no" is the default.</span></span>  
  
### <a name="sql-server-native-client-odbc-driver-example"></a><span data-ttu-id="11c0a-156">SQL Server Native Client ODBC 드라이버 예</span><span class="sxs-lookup"><span data-stu-id="11c0a-156">SQL Server Native Client ODBC Driver Example</span></span>  
 <span data-ttu-id="11c0a-157">이 예에서는 **SQLDriverConnect** 함수를 호출 하 여 데이터베이스를 연결 하기 전에 **SQLSetConnectAttr** 함수를 사용 하 여 MARS를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-157">In this example, the **SQLSetConnectAttr** function is used to enable MARS before calling the **SQLDriverConnect** function to connect the database.</span></span> <span data-ttu-id="11c0a-158">연결이 설정 되 면 두 개의 **Sqlexecdirect** 함수를 호출 하 여 동일한 연결에서 두 개의 별도 결과 집합을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="11c0a-158">Once the connection is made, two **SQLExecDirect** functions are called to create two separate result sets on the same connection.</span></span>  
  
```  
#include <sqlncli.h>  
  
SQLSetConnectAttr(hdbc, SQL_COPT_SS_MARS_ENABLED, SQL_MARS_ENABLED_YES, SQL_IS_UINTEGER);  
SQLDriverConnect(hdbc, hwnd,   
   "DRIVER=SQL Server Native Client 10.0;  
   SERVER=(local);trusted_connection=yes;", SQL_NTS, szOutConn,   
   MAX_CONN_OUT, &cbOutConn, SQL_DRIVER_COMPLETE);  
  
SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &hstmt1);  
SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &hstmt2);  
  
// The 2nd execute would have failed with connection busy error if  
// MARS were not enabled.  
SQLExecDirect(hstmt1, L"SELECT * FROM Authors", SQL_NTS);  
SQLExecDirect(hstmt2, L"SELECT * FROM Titles", SQL_NTS);  
  
// Result set processing can interleave.  
SQLFetch(hstmt1);  
SQLFetch(hstmt2);  
```  
  
## <a name="see-also"></a><span data-ttu-id="11c0a-159">참고 항목</span><span class="sxs-lookup"><span data-stu-id="11c0a-159">See Also</span></span>  
 <span data-ttu-id="11c0a-160">[SQL Server Native Client 기능](sql-server-native-client-features.md) </span><span class="sxs-lookup"><span data-stu-id="11c0a-160">[SQL Server Native Client Features](sql-server-native-client-features.md) </span></span>  
 [<span data-ttu-id="11c0a-161">SQL Server 기본 결과 집합 사용</span><span class="sxs-lookup"><span data-stu-id="11c0a-161">Using SQL Server Default Result Sets</span></span>](../../native-client-odbc-cursors/implementation/using-sql-server-default-result-sets.md)  
  
  
