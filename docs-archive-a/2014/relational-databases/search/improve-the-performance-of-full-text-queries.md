---
title: 전체 텍스트 쿼리 성능 향상 | Microsoft 문서
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: search
ms.topic: conceptual
ms.assetid: 0658dc74-25eb-4486-bbd6-e85c1f92c272
author: MikeRayMSFT
ms.author: mikeray
ms.openlocfilehash: a1437f710725df5c87d31f6a80939a5d7869b412
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87733803"
---
# <a name="improve-the-performance-of-full-text-queries"></a><span data-ttu-id="7e58a-102">전체 텍스트 쿼리 성능 향상</span><span class="sxs-lookup"><span data-stu-id="7e58a-102">Improve the Performance of Full-Text Queries</span></span>
  <span data-ttu-id="7e58a-103">다음은 전체 텍스트 쿼리 성능 향상에 도움이 될 권장 사항 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-103">The following is a list of recommendations that will help to improve the performance of full-text queries.</span></span>  
  
 <span data-ttu-id="7e58a-104">전체 텍스트 쿼리의 성능은 메모리, 디스크 속도, CPU 속도 및 컴퓨터 아키텍처와 같은 하드웨어 리소스의 영향도 받습니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-104">The performance of full-text queries is also influenced by hardware resources, such as memory, disk speed, CPU speed, and machine architecture.</span></span>  
  
-   <span data-ttu-id="7e58a-105">[ALTER INDEX REORGANIZE](/sql/t-sql/statements/alter-index-transact-sql)를 사용하여 기본 테이블의 인덱스를 조각 모음합니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-105">Defragment the index of the base table by using [ALTER INDEX REORGANIZE](/sql/t-sql/statements/alter-index-transact-sql).</span></span>  
  
-   <span data-ttu-id="7e58a-106">[ALTER FULLTEXT CATALOG REORGANIZE](/sql/t-sql/statements/alter-fulltext-catalog-transact-sql)를 사용하여 전체 텍스트 카탈로그를 다시 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-106">Reorganize the full-text catalog by using [ALTER FULLTEXT CATALOG REORGANIZE](/sql/t-sql/statements/alter-fulltext-catalog-transact-sql).</span></span> <span data-ttu-id="7e58a-107">이 문을 실행하면 해당 카탈로그에 있는 전체 텍스트 인덱스의 마스터 병합이 수행되므로 성능 테스트 전에 실행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-107">Make sure that you do this before performance testing because running this statement causes a master merge of the full-text indexes in that catalog.</span></span>  
  
-   <span data-ttu-id="7e58a-108">작은 열을 전체 텍스트 키 열로 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-108">Restrict your choice of full-text key columns to a small column.</span></span> <span data-ttu-id="7e58a-109">900바이트 열이 지원되지만 전체 텍스트 인덱스에서는 비교적 작은 키 열을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-109">Although a 900-byte column is supported, we recommend using a smaller key column in a full-text index.</span></span> <span data-ttu-id="7e58a-110">`int` 및 `bigint`는 최적의 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-110">`int` and `bigint` provide the best performance.</span></span>  
  
-   <span data-ttu-id="7e58a-111">정수 전체 텍스트 키를 사용하면 **docid** 매핑 테이블과의 조인이 방지됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-111">Using an integer full-text key avoids a join with the **docid** mapping table.</span></span> <span data-ttu-id="7e58a-112">따라서 정수 전체 텍스트 키는 작업량을 줄여 쿼리 성능을 높이고 탐색 성능을 개선합니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-112">Therefore, an integer full-text key improves query performance by an order of magnitude and improves crawl performance.</span></span> <span data-ttu-id="7e58a-113">전체 텍스트 키가 클러스터형 인덱스 키인 경우에도 또 다른 성능 이점을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-113">Additional performance benefits might result if the full-text key is also the clustered index key.</span></span>  
  
-   <span data-ttu-id="7e58a-114">여러 [CONTAINS](/sql/t-sql/queries/contains-transact-sql) 조건자를 하나의 CONTAINS 조건자에 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-114">Combine multiple [CONTAINS](/sql/t-sql/queries/contains-transact-sql) predicates into one CONTAINS predicate.</span></span> <span data-ttu-id="7e58a-115">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 에서는 CONTAINS 쿼리에 열 목록을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-115">In [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] you can specify a list of columns in the CONTAINS query.</span></span>  
  
-   <span data-ttu-id="7e58a-116">전체 텍스트 키 또는 순위 정보만 필요한 경우 CONTAINS 또는 FREETEXT를 사용하는 대신 [CONTAINSTABLE](/sql/relational-databases/system-functions/containstable-transact-sql) 또는 [FREETEXTTABLE](/sql/relational-databases/system-functions/freetexttable-transact-sql) 을 각각 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-116">If you only require full-text key or rank information, use [CONTAINSTABLE](/sql/relational-databases/system-functions/containstable-transact-sql) or [FREETEXTTABLE](/sql/relational-databases/system-functions/freetexttable-transact-sql) instead of CONTAINS or FREETEXT, respectively.</span></span>  
  
-   <span data-ttu-id="7e58a-117">결과를 제한하고 성능을 향상시키려면 FREETEXTTABLE 및 CONTAINSTABLE 함수의 *top_n_by_rank* 매개 변수를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-117">To limit results and increase performance, use the *top_n_by_rank* parameter of the FREETEXTTABLE and CONTAINSTABLE functions.</span></span> <span data-ttu-id="7e58a-118">*top_n_by_rank* 를 사용하면 관련성이 가장 높은 항목만 회수할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-118">*top_n_by_rank* allows you to recall only the most relevant hits.</span></span> <span data-ttu-id="7e58a-119">이 매개 변수는 비즈니스 시나리오에서 일치하는 모든 항목을 회수하지 않아도 되는 경우, 즉 *전체 회수*가 필요 없는 경우에만 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-119">Use this parameter only if your business scenario does not require recalling all possible hits (that is, it does not require *total recall*).</span></span>  
  
    > [!NOTE]  
    >  <span data-ttu-id="7e58a-120">전체 회수는 대개 법률 시나리오에 필요하지만 e-비즈니스와 같은 비즈니스 시나리오에서는 성능보다 중요하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-120">Total recall is typically necessary for legal scenarios but might be less important than performance for business scenarios such as an e-business.</span></span>  
  
-   <span data-ttu-id="7e58a-121">전체 텍스트 쿼리 계획을 검사하여 적절한 조인 계획이 선택되었는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-121">Check the full-text query plan to make sure that the appropriate join plan is chosen.</span></span> <span data-ttu-id="7e58a-122">필요한 경우 조인 힌트 또는 쿼리 힌트를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-122">Use a join hint or query hint if you have to.</span></span> <span data-ttu-id="7e58a-123">전체 텍스트 쿼리에서 매개 변수가 사용될 경우 매개 변수의 첫 번째 값이 쿼리 계획을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-123">If a parameter is used in the full-text query, the first-time value of the parameter determines the query plan.</span></span> <span data-ttu-id="7e58a-124">OPTIMIZE FOR [쿼리 힌트](/sql/t-sql/queries/hints-transact-sql-query) 를 사용하여 쿼리를 원하는 값으로 컴파일하도록 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-124">You can use the OPTIMIZE FOR [query hint](/sql/t-sql/queries/hints-transact-sql-query) to force the query to compile with the value you want.</span></span> <span data-ttu-id="7e58a-125">이렇게 하면 결정적 쿼리 계획 및 향상된 성능을 실현하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-125">This helps achieve a deterministic query plan and better performance.</span></span>  
  
-   <span data-ttu-id="7e58a-126">전체 텍스트 인덱스에 전체 텍스트 인덱스 조각이 너무 많으면 쿼리 성능이 크게 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-126">Too many full-text index fragments in the full-text index, can lead to substantial degradation in query performance.</span></span> <span data-ttu-id="7e58a-127">조각 수를 줄이려면 [ALTER FULLTEXT CATALOG](/sql/t-sql/statements/alter-fulltext-catalog-transact-sql)[!INCLUDE[tsql](../../includes/tsql-md.md)] 문의 REORGANIZE 옵션을 사용하여 전체 텍스트 카탈로그를 다시 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-127">To reduce the number of fragments, reorganize the full-text catalog by using the REORGANIZE option of the [ALTER FULLTEXT CATALOG](/sql/t-sql/statements/alter-fulltext-catalog-transact-sql)[!INCLUDE[tsql](../../includes/tsql-md.md)] statement.</span></span> <span data-ttu-id="7e58a-128">이 문은 기본적으로 모든 조각을 비교적 큰 하나의 조각으로 병합하고 전체 텍스트 인덱스에서 사용되지 않는 항목을 모두 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-128">This statement essentially merges all the fragments into a single larger fragment and removes all obsolete entries from the full-text index.</span></span>  
  
-   <span data-ttu-id="7e58a-129">전체 텍스트 검색에서 CONTAINSTABLE에 지정되는 논리 연산자(AND, OR)는 SQL 조인으로 구현하거나 전체 텍스트 실행 STVF(스트리밍 테이블 반환 함수) 내에서 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-129">In  full-text search, logical operators specified in CONTAINSTABLE (AND, OR) can be implemented either as SQL joins or inside the full-text execution streaming table-valued functions (STVF).</span></span> <span data-ttu-id="7e58a-130">일반적으로 한 가지 논리 연산자만 포함된 쿼리는 전체 텍스트 실행으로만 구현되는 데 반해 논리 연산자가 혼합되어 있는 쿼리는 SQL 조인도 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-130">Typically, queries with only one type of logical operators are implemented purely by full-text execution, whereas queries that mix logical operators also possess SQL joins.</span></span> <span data-ttu-id="7e58a-131">전체 텍스트 실행 STVF 내 논리 연산자 구현에는 SQL 조인보다 실행 속도가 빠른 일부 특수한 인덱스 속성이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-131">Implementation of a logical operator inside the full-text execution STVF uses some special index properties that make it much faster than SQL joins.</span></span> <span data-ttu-id="7e58a-132">따라서 가능하면 단일 유형의 논리 연산자만 사용하여 쿼리를 작성하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-132">For this reason, we recommend that, where possible, you frame queries using only a single type of logical operator.</span></span>  
  
-   <span data-ttu-id="7e58a-133">선택적 관계 조건을 포함하는 애플리케이션의 경우 선택적 관계 조건자와 비선택적 전체 텍스트 조건자를 사용하는 쿼리는 쿼리 최적화 프로그램을 사용하도록 작성되었을 때 최상의 성능을 발휘할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-133">For applications that contain selective-relation predications, queries that use selective relational predicates and unselective full-text predicates might perform best when they are written to use the query optimizer.</span></span> <span data-ttu-id="7e58a-134">이렇게 하면 쿼리 최적화 프로그램이 효과적인 쿼리 계획을 생성하기 위해 조건자나 범위 축소 중 어느 것을 이용할지 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-134">This allows the query optimizer to decide whether it can exploit predicate or range pushdown to produce an effective query plan.</span></span> <span data-ttu-id="7e58a-135">이러한 방식은 관계형 데이터를 전체 텍스트 데이터로 인덱싱하는 것보다 간단하고 효율적일 때가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="7e58a-135">This approach is simpler and often more efficient than indexing relational data as full-text data.</span></span>  
  
## <a name="related-resources"></a><span data-ttu-id="7e58a-136">관련 리소스</span><span class="sxs-lookup"><span data-stu-id="7e58a-136">Related Resources</span></span>  
 [<span data-ttu-id="7e58a-137">SQL Server 2008 전체 텍스트 검색: 내부 및 향상 내용</span><span class="sxs-lookup"><span data-stu-id="7e58a-137">SQL Server 2008 Full-Text Search: Internals and Enhancements</span></span>](https://go.microsoft.com/fwlink/?LinkId=129544)  
  
## <a name="see-also"></a><span data-ttu-id="7e58a-138">참고 항목</span><span class="sxs-lookup"><span data-stu-id="7e58a-138">See Also</span></span>  
 <span data-ttu-id="7e58a-139">[sys.dm_fts_memory_buffers&#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-fts-memory-buffers-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="7e58a-139">[sys.dm_fts_memory_buffers &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-fts-memory-buffers-transact-sql) </span></span>  
 [<span data-ttu-id="7e58a-140">sys.dm_fts_memory_pools&#40;Transact-SQL&#41;</span><span class="sxs-lookup"><span data-stu-id="7e58a-140">sys.dm_fts_memory_pools &#40;Transact-SQL&#41;</span></span>](/sql/relational-databases/system-dynamic-management-views/sys-dm-fts-memory-pools-transact-sql)  
  
  
