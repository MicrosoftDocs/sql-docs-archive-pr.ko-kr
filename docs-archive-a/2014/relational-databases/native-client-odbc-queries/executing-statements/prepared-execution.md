---
title: 준비 된 실행 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- deferred statement preparation
- prepared execution [ODBC]
- SQLPrepare function
- ODBC applications, statements
- SQLExecute function
- statements [ODBC], prepared execution
ms.assetid: f3a9d32b-6cd7-4f0c-b38d-c8ccc4ee40c3
author: rothja
ms.author: jroth
ms.openlocfilehash: 33ab9f35cd9d3eaf04e688a89390b5eb3f00ae58
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87646403"
---
# <a name="prepared-execution"></a><span data-ttu-id="2ae94-102">준비된 실행</span><span class="sxs-lookup"><span data-stu-id="2ae94-102">Prepared Execution</span></span>
  <span data-ttu-id="2ae94-103">ODBC API에서는 반복적인 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 문 실행과 관련한 구문 분석 및 컴파일 오버헤드를 줄이는 한 가지 방법으로 준비된 실행을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-103">The ODBC API defines prepared execution as a way to reduce the parsing and compiling overhead associated with repeatedly executing a [!INCLUDE[tsql](../../../includes/tsql-md.md)] statement.</span></span> <span data-ttu-id="2ae94-104">애플리케이션은 SQL 문이 포함된 문자열을 작성한 다음 두 단계로 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-104">The application builds a character string containing an SQL statement and then executes it in two stages.</span></span> <span data-ttu-id="2ae94-105">[Sqlprepare 함수](https://go.microsoft.com/fwlink/?LinkId=59360) 를 한 번 호출 하 여 문을 구문 분석 하 고에서 실행 계획으로 컴파일합니다 [!INCLUDE[ssDE](../../../includes/ssde-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="2ae94-105">It calls [SQLPrepare Function](https://go.microsoft.com/fwlink/?LinkId=59360) once to have the statement parsed and compiled into an execution plan by the [!INCLUDE[ssDE](../../../includes/ssde-md.md)].</span></span> <span data-ttu-id="2ae94-106">그런 다음 준비 된 실행 계획을 실행할 때마다 **Sqlexecute** 를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-106">It then calls **SQLExecute** for each execution of the prepared execution plan.</span></span> <span data-ttu-id="2ae94-107">이렇게 하면 각각의 실행에서 구문 분석 및 컴파일 오버헤드를 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-107">This saves the parsing and compiling overhead on each execution.</span></span> <span data-ttu-id="2ae94-108">준비된 실행은 애플리케이션에서 매개 변수가 있는 동일한 SQL 문을 반복적으로 실행하는 데 많이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-108">Prepared execution is commonly used by applications to repeatedly execute the same, parameterized SQL statement.</span></span>  
  
 <span data-ttu-id="2ae94-109">대부분의 데이터베이스에서 준비된 실행은 문을 직접 실행하는 경우보다 3-4배 이상 빠릅니다. 가장 큰 이유는 직접 실행할 경우 매번 문이 컴파일되는 반면에 준비된 실행에서는 문이 한 번만 컴파일되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-109">For most databases, prepared execution is faster than direct execution for statements executed more than three or four times primarily because the statement is compiled only once, while statements executed directly are compiled each time they are executed.</span></span> <span data-ttu-id="2ae94-110">또한 준비된 실행을 사용할 경우 문을 실행할 때마다 드라이버가 전체 SQL 문 대신 실행 계획 식별자와 매개 변수 값만 데이터 원본에 보내면 되므로 네트워크 트래픽도 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-110">Prepared execution can also provide a reduction in network traffic because the driver can send an execution plan identifier and the parameter values, rather than an entire SQL statement, to the data source each time the statement is executed.</span></span>  
  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]<span data-ttu-id="2ae94-111">**Sqlexecdirect**에서 실행 계획을 검색 하 고 다시 사용 하기 위한 향상 된 알고리즘을 통해 직접 실행과 준비 된 실행 간의 성능 차이를 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-111">reduces the performance difference between direct and prepared execution through improved algorithms for detecting and reusing execution plans from **SQLExecDirect**.</span></span> <span data-ttu-id="2ae94-112">따라서 문을 직접 실행할 때도 준비된 실행을 사용할 때와 같이 몇 가지 성능상의 이점을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-112">This makes some of the performance benefits of prepared execution available to statements executed directly.</span></span> <span data-ttu-id="2ae94-113">자세한 내용은 [직접 실행](direct-execution.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2ae94-113">For more information, see [Direct Execution](direct-execution.md).</span></span>  
  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]<span data-ttu-id="2ae94-114">에서는 준비된 실행을 기본으로 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-114">also provides native support for prepared execution.</span></span> <span data-ttu-id="2ae94-115">Sqlprepare가 호출 될 때 실행 계획은 **Sqlprepare** 이상 **SQLExecute** 에서 작성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-115">An execution plan is built on **SQLPrepare** and later executed when **SQLExecute** is called.</span></span> <span data-ttu-id="2ae94-116">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]는 **sqlprepare**에서 임시 저장 프로시저를 작성할 필요가 없기 때문에 **tempdb**의 시스템 테이블에 추가 오버 헤드가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-116">Because [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] is not required to build temporary stored procedures on **SQLPrepare**, there is no extra overhead on the system tables in **tempdb**.</span></span>  
  
 <span data-ttu-id="2ae94-117">성능상의 이유로 문 준비는 **Sqlexecute** 가 호출 되거나 메타 속성 작업 (예: [SQLDescribeCol](../../native-client-odbc-api/sqldescribecol.md) 또는 ODBC의 [SQLDescribeParam](../../native-client-odbc-api/sqldescribeparam.md) )이 수행 될 때까지 지연 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-117">For performance reasons, the statement preparation is deferred until **SQLExecute** is called or a metaproperty operation (such as [SQLDescribeCol](../../native-client-odbc-api/sqldescribecol.md) or [SQLDescribeParam](../../native-client-odbc-api/sqldescribeparam.md) in ODBC) is performed.</span></span> <span data-ttu-id="2ae94-118">기본 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-118">This is the default behavior.</span></span> <span data-ttu-id="2ae94-119">따라서 준비 중인 문에서 발생하는 모든 오류는 문이 실행되거나 메타 속성 작업이 수행될 때까지 알 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-119">Any errors in the statement being prepared are not known until the statement is executed or a metaproperty operation is performed.</span></span> <span data-ttu-id="2ae94-120">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client ODBC 드라이버 관련 문 특성 SQL_SOPT_SS_DEFER_PREPARE를 SQL_DP_OFF로 설정하면 이 기본 동작을 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-120">Setting the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client ODBC driver-specific statement attribute SQL_SOPT_SS_DEFER_PREPARE to SQL_DP_OFF can turn off this default behavior.</span></span>  
  
 <span data-ttu-id="2ae94-121">지연 된 준비가 된 경우 **Sqlexecute** 를 호출 하기 전에 **SQLDescribeCol** 또는 **SQLDescribeParam** 를 호출 하면 서버에 대 한 추가 왕복이 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-121">In case of deferred prepare, calling either **SQLDescribeCol** or **SQLDescribeParam** before calling **SQLExecute** generates an extra roundtrip to the server.</span></span> <span data-ttu-id="2ae94-122">**SQLDescribeCol**에서 드라이버는 쿼리에서 WHERE 절을 제거 하 고 SET FMTONLY ON으로 서버에 전송 하 여 쿼리에서 반환 된 첫 번째 결과 집합의 열에 대 한 설명을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-122">On **SQLDescribeCol**, the driver removes the WHERE clause from the query and sends it to the server with SET FMTONLY ON to get the description of the columns in the first result set returned by the query.</span></span> <span data-ttu-id="2ae94-123">**SQLDescribeParam**에서 드라이버는 서버를 호출 하 여 쿼리의 매개 변수 표식에서 참조 하는 식 또는 열에 대 한 설명을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-123">On **SQLDescribeParam**, the driver calls the server to get a description of the expressions or columns referenced by any parameter markers in the query.</span></span> <span data-ttu-id="2ae94-124">이 메서드에는 하위 쿼리의 매개 변수는 확인할 수 없는 등의 몇 가지 제한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-124">This method also has some restrictions, such as not being able to resolve parameters in subqueries.</span></span>  
  
 <span data-ttu-id="2ae94-125">Native Client ODBC 드라이버를 사용 하 여 **Sqlprepare** 를 과도 하 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 게 사용 하면 특히 이전 버전의 SQL Server에 연결 된 경우 성능이 저하 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-125">Excess use of **SQLPrepare** with the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client ODBC driver degrades performance, especially when connected to earlier versions of SQL Server.</span></span> <span data-ttu-id="2ae94-126">한 번만 실행되는 문에는 준비된 실행을 사용하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-126">Prepared execution should not be used for statements executed a single time.</span></span> <span data-ttu-id="2ae94-127">준비된 실행에는 클라이언트에서 서버로의 추가 네트워크 왕복이 필요하므로 문을 한 번만 실행할 때는 준비된 실행이 직접 실행보다 속도가 느립니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-127">Prepared execution is slower than direct execution for a single execution of a statement because it requires an extra network roundtrip from the client to the server.</span></span> <span data-ttu-id="2ae94-128">또한 이전 버전의 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]에서는 임시 저장 프로시저도 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-128">On earlier versions of [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] it also generates a temporary stored procedure.</span></span>  
  
 <span data-ttu-id="2ae94-129">준비된 문은 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]에서 임시 개체를 만드는 데 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-129">Prepared statements cannot be used to create temporary objects on [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span>  
  
 <span data-ttu-id="2ae94-130">일부 초기 ODBC 응용 프로그램에서는 [SQLBindParameter](../../native-client-odbc-api/sqlbindparameter.md) 를 사용할 때마다 **sqlprepare** 를 사용 했습니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-130">Some early ODBC applications used **SQLPrepare** any time [SQLBindParameter](../../native-client-odbc-api/sqlbindparameter.md) was used.</span></span> <span data-ttu-id="2ae94-131">**SQLBindParameter** 는 **sqlprepare**를 사용할 필요가 없습니다. **sqlexecdirect**에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-131">**SQLBindParameter** does not require the use of **SQLPrepare**, it can be used with **SQLExecDirect**.</span></span> <span data-ttu-id="2ae94-132">예를 들어 **SQLBindParameter** 와 함께 **sqlexecdirect** 를 사용 하 여 한 번만 실행 되는 저장 프로시저에서 반환 코드 또는 출력 매개 변수를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="2ae94-132">For example, use **SQLExecDirect** with **SQLBindParameter** to retrieve the return code or output parameters from a stored procedure that is only executed one time.</span></span> <span data-ttu-id="2ae94-133">동일한 문이 여러 번 실행 되는 경우를 제외 하 고 **SQLBindParameter** 에서 **sqlprepare** 를 사용 하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="2ae94-133">Do not use **SQLPrepare** with **SQLBindParameter** unless the same statement will be executed multiple times.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2ae94-134">참고 항목</span><span class="sxs-lookup"><span data-stu-id="2ae94-134">See Also</span></span>  
 [<span data-ttu-id="2ae94-135">ODBC&#41;&#40;문을 실행 하는 중</span><span class="sxs-lookup"><span data-stu-id="2ae94-135">Executing Statements &#40;ODBC&#41;</span></span>](executing-statements-odbc.md)  
  
  
