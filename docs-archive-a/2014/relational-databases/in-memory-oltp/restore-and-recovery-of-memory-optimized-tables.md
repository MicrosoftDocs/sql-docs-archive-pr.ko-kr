---
title: 메모리 액세스에 최적화된 테이블의 복원 및 복구 | Microsoft 문서
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 294975b7-e7d1-491b-b66a-fdb1100d2acc
author: CarlRabeler
ms.author: carlrab
ms.openlocfilehash: 5e702798ea68745a038407fb65af7726a5c5d50e
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87653370"
---
# <a name="restore-and-recovery-of-memory-optimized-tables"></a><span data-ttu-id="ca98e-102">메모리 액세스에 최적화된 테이블의 복원 및 복구</span><span class="sxs-lookup"><span data-stu-id="ca98e-102">Restore and Recovery of Memory-Optimized Tables</span></span>
  <span data-ttu-id="ca98e-103">메모리 최적화 테이블이 있는 데이터베이스를 복구하거나 복원하기 위한 기본 메커니즘은 디스크 기반 테이블만 있는 데이터베이스와 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-103">The basic mechanism to recover or restore a database with memory-optimized tables is similar to databases with only disk-based tables.</span></span> <span data-ttu-id="ca98e-104">하지만 디스크 기반 테이블과 달리, 메모리 최적화 테이블은 먼저 메모리에 로드해야만 사용자가 데이터베이스에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-104">But unlike disk-based tables, memory-optimized tables must be loaded into memory before database is available for user access.</span></span> <span data-ttu-id="ca98e-105">따라서 데이터베이스 복구에 새로운 단계가 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-105">This adds a new step in the database recovery.</span></span> <span data-ttu-id="ca98e-106">수정된 데이터 복구 단계는 다음과 같이 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-106">The modified steps in database recovery are changed as follows:</span></span>

 <span data-ttu-id="ca98e-107">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 가 다시 시작되면 각 데이터베이스가 다음 세 단계로 구성된 복구 단계를 거칩니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-107">When the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] restarts, each database goes through a recovery phase that consists of the following three phases:</span></span>

1.  <span data-ttu-id="ca98e-108">분석 단계.</span><span class="sxs-lookup"><span data-stu-id="ca98e-108">The analysis phase.</span></span> <span data-ttu-id="ca98e-109">이 단계 중에는 커밋된 트랜잭션과 커밋되지 않은 트랜잭션을 감지하기 위한 패스가 활성 트랜잭션 로그에 작성됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-109">During this phase, a pass is made on the active transaction logs to detect committed and uncommitted transactions.</span></span> <span data-ttu-id="ca98e-110">메모리 내 OLTP 엔진은 로드할 검사점을 식별하고 시스템 테이블 로그 항목을 미리 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-110">The In-Memory OLTP engine identifies the checkpoint to load and preloads its system table log entries.</span></span> <span data-ttu-id="ca98e-111">또한 일부 파일 할당 로그 레코드도 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-111">It will also process some file allocation log records.</span></span>

2.  <span data-ttu-id="ca98e-112">다시 실행 단계.</span><span class="sxs-lookup"><span data-stu-id="ca98e-112">The redo phase.</span></span> <span data-ttu-id="ca98e-113">이 단계는 디스크 기반 테이블과 메모리 최적화 테이블에서 동시에 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-113">This phase is run concurrently on both disk-based and memory-optimized tables.</span></span>

     <span data-ttu-id="ca98e-114">디스크 기반 테이블의 경우 데이터베이스가 현재 시점으로 이동하고 커밋되지 않은 트랜잭션에 있는 잠금을 획득합니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-114">For disk-based tables, the database is moved to the current point in time and acquires locks taken by uncommitted transactions.</span></span>

     <span data-ttu-id="ca98e-115">메모리 최적화 테이블의 경우 데이터 및 델타 파일 쌍의 데이터가 메모리에 로드된 다음 마지막 지속성 검사점을 기반으로 활성 트랜잭션 로그를 사용하여 데이터를 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-115">For memory-optimized tables, data from the data and delta file pairs are loaded into memory and then update the data with the active transaction log based on the last durable checkpoint.</span></span>

     <span data-ttu-id="ca98e-116">디스크 기반 테이블과 메모리 최적화 테이블에서 위의 연산이 완료되면 데이터베이스에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-116">When the above operations on disk-based and memory-optimized tables are complete, the database is available for access.</span></span>

3.  <span data-ttu-id="ca98e-117">실행 취소 단계.</span><span class="sxs-lookup"><span data-stu-id="ca98e-117">The undo phase.</span></span> <span data-ttu-id="ca98e-118">이 단계에서는 커밋되지 않은 트랜잭션이 롤백됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-118">In this phase, the uncommitted transactions are rolled back.</span></span>

 <span data-ttu-id="ca98e-119">메모리 최적화 테이블을 메모리에 로드하면 RTO(복구 시간 목표)의 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-119">Loading memory-optimized tables into memory can affect performance of the recovery time objective (RTO).</span></span> <span data-ttu-id="ca98e-120">데이터 및 델타 파일에서 메모리 최적화 데이터를 로드하는 시간을 개선하기 위해 메모리 내 OLTP 엔진은 다음과 같이 데이터/델타 파일을 병렬로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-120">To improve the load time of memory-optimized data from data and delta files, the In-Memory OLTP engine loads the data/delta files in parallel as follows:</span></span>

-   <span data-ttu-id="ca98e-121">델타 맵 필터 만들기.</span><span class="sxs-lookup"><span data-stu-id="ca98e-121">Creating a Delta Map Filter.</span></span> <span data-ttu-id="ca98e-122">델타 파일은 삭제된 행에 대한 참조를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-122">Delta files store references to the deleted rows.</span></span> <span data-ttu-id="ca98e-123">컨테이너당 하나의 스레드가 델타 파일을 읽고 델타 맵 필터를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-123">One thread per container reads the delta files and creates a delta map filter.</span></span> <span data-ttu-id="ca98e-124">메모리 액세스에 최적화된 데이터 파일 그룹에는 하나 이상의 컨테이너가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-124">(A memory optimized data filegroup can have one or more containers.)</span></span>

-   <span data-ttu-id="ca98e-125">데이터 파일 스트리밍.</span><span class="sxs-lookup"><span data-stu-id="ca98e-125">Streaming the data files.</span></span>  <span data-ttu-id="ca98e-126">델타 맵 필터가 생성되면 논리적 CPU와 같은 수의 스레드를 사용하여 데이터 파일을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-126">Once the delta-map filter is created, data files are read using as many threads as there are logical CPUs.</span></span> <span data-ttu-id="ca98e-127">데이터 파일을 읽는 각 스레드는 데이터 행을 읽고 연결된 델타 맵을 확인한 다음 이 행이 삭제됨으로 표시되지 않은 경우에만 테이블에 행을 삽입합니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-127">Each thread reading the data file reads the data rows, checks the associated delta map and only inserts the row into table if this row has not been marked deleted.</span></span> <span data-ttu-id="ca98e-128">복구의 이 부분은 아래 설명과 같이 일부 경우에 CPU 바인딩될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-128">This part of recovery can be CPU bound in some cases as noted below.</span></span>

 <span data-ttu-id="ca98e-129">![메모리 액세스에 최적화 된 테이블.](../../database-engine/media/memory-optimized-tables.gif "메모리 최적화 테이블.")</span><span class="sxs-lookup"><span data-stu-id="ca98e-129">![Memory-optimized tables.](../../database-engine/media/memory-optimized-tables.gif "Memory-optimized tables.")</span></span>

 <span data-ttu-id="ca98e-130">메모리 액세스에 최적화된 테이블은 일반적으로 I/O 속도로 메모리에 로드할 수 있지만 데이터 행을 메모리에 로드하는 것이 더 느린 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-130">Memory-optimized tables can generally be loaded into memory at the speed of I/O but there are cases when loading data rows into memory will be slower.</span></span> <span data-ttu-id="ca98e-131">구체적인 경우는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-131">Specific cases are:</span></span>

-   <span data-ttu-id="ca98e-132">해시 인덱스의 버킷 수가 적으면 과도한 충돌이 발생하여 데이터 행 삽입이 느려질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-132">Low bucket count for hash index can lead to excessive collision causing data row inserts to be slower.</span></span> <span data-ttu-id="ca98e-133">이 경우 일반적으로 전체 CPU 사용률이 매우 높아지며 복구가 거의 끝날 때 특히 높아집니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-133">This generally results in very high CPU utilization throughout, and especially towards the end of recovery.</span></span> <span data-ttu-id="ca98e-134">해시 인덱스를 올바르게 구성한 경우 복구 시간에 영향을 미치지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-134">If you configured the hash index correctly, it should not impact the recovery time.</span></span>

-   <span data-ttu-id="ca98e-135">하나 이상의 비클러스터형 인덱스가 있는 대규모 메모리 최적화 테이블의 경우 생성 시간에 버킷 수가 조정되는 해시 인덱스와는 달리 비클러스터형 인덱스가 동적으로 증가하여 결과적으로 CPU 사용률이 높아집니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-135">Large memory-optimized tables with one or more nonclustered indexes, unlike a hash index whose bucket count is sized at create time, the nonclustered indexes grow dynamically, resulting in high CPU utilization.</span></span>

## <a name="restoring-a-database-with-memory-optimized-tables"></a><span data-ttu-id="ca98e-136">메모리 액세스에 최적화된 테이블이 포함된 데이터베이스 복원</span><span class="sxs-lookup"><span data-stu-id="ca98e-136">Restoring a Database with Memory-optimized tables</span></span>
 <span data-ttu-id="ca98e-137">서버에 데이터베이스 복원에 충분한 메모리가 있음을 알고 있지만, 데이터베이스에서 필요한 메모리는 기존 리소스 풀의 일부분을 담당하게 되는 요구 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-137">You know that you have sufficient memory on the server to restore a database, but there's a requirement  that the memory needed by the database is accounted for as part of an existing Resource Pool.</span></span>  <span data-ttu-id="ca98e-138">데이터베이스가 있어야 리소스 풀에 바인딩을 만들 수 있음을 알고 있으므로  RESTORE WITH RECOVERY를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-138">You know that you cannot create the binding to the resource pool before the database exists, so you perform the restore WITH NORECOVERY.</span></span>  <span data-ttu-id="ca98e-139">이렇게 하면 복원을 위한 데이터베이스 디스크 이미지와 데이터베이스가 생성되지만 데이터베이스를 온라인으로 불러올 수 없으므로 메모리 내 OLTP 메모리가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-139">This causes the disk image of the database to be restored and the database to be created, but no In-Memory OLTP memory is consumed because the database is not brought online.</span></span>

 <span data-ttu-id="ca98e-140">이 시점에서 데이터베이스 바인딩에 대한 리소스 풀을 만들고 RESTORE WITH RECOVERY를 사용하여 복원된 데이터베이스를 온라인으로 불러옵니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-140">At this point, you can create the Resource Pool to Database binding, and then use RESTORE WITH RECOVERY to bring the restored database online.</span></span>  <span data-ttu-id="ca98e-141">데이터베이스를 온라인으로 불러오기 전에 바인딩이 존재하므로 메모리 내 OLTP 메모리 사용이 적절하게 설명됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-141">Since the binding is in place before the database is brought online, its In-Memory OLTP memory consumption is properly accounted for.</span></span> <span data-ttu-id="ca98e-142">이렇게 하려면 데이터베이스를 한 번만 복원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-142">This requires restoring the database only once.</span></span> <span data-ttu-id="ca98e-143">첫번째 RESTORE 명령은 백업 헤더를 읽기만 하는 정보 제공 명령이며 마지막 명령은 실제 비트 복원 없이 단순히 복구를 트리거합니다.</span><span class="sxs-lookup"><span data-stu-id="ca98e-143">The first RESTORE command is an informational command that only reads the backup header, and the last command simply triggers recovery without actually restoring any bits.</span></span>

## <a name="see-also"></a><span data-ttu-id="ca98e-144">참고 항목</span><span class="sxs-lookup"><span data-stu-id="ca98e-144">See Also</span></span>
 [<span data-ttu-id="ca98e-145">메모리 액세스에 최적화된 테이블의 백업, 복원 및 복구</span><span class="sxs-lookup"><span data-stu-id="ca98e-145">Backup, Restore, and Recovery of Memory-Optimized Tables</span></span>](memory-optimized-tables.md)


