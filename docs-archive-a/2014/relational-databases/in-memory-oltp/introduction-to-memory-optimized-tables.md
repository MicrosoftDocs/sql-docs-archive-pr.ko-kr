---
title: 메모리 액세스에 최적화된 테이블 소개 | Microsoft 문서
ms.custom: ''
ms.date: 07/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: ef1cc7de-63be-4fa3-a622-6d93b440e3ac
author: rothja
ms.author: jroth
ms.openlocfilehash: edcdea9d266cf0ef231b1e16be4da7009372dcd6
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87742103"
---
# <a name="introduction-to-memory-optimized-tables"></a><span data-ttu-id="10957-102">메모리 액세스에 최적화된 테이블 소개</span><span class="sxs-lookup"><span data-stu-id="10957-102">Introduction to Memory-Optimized Tables</span></span>
  <span data-ttu-id="10957-103">메모리 액세스에 최적화된 테이블은 [CREATE TABLE&#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql)을 사용하여 만드는 테이블입니다.</span><span class="sxs-lookup"><span data-stu-id="10957-103">Memory-optimized tables are tables, created using [CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql).</span></span>  
  
 <span data-ttu-id="10957-104">메모리 액세스에 최적화된 테이블은 메모리에 상주합니다.</span><span class="sxs-lookup"><span data-stu-id="10957-104">Memory-optimized tables reside in memory.</span></span> <span data-ttu-id="10957-105">테이블의 행은 메모리에서 읽고 메모리에 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="10957-105">Rows in the table are read from and written to memory.</span></span> <span data-ttu-id="10957-106">전체 테이블은 메모리에 상주합니다.</span><span class="sxs-lookup"><span data-stu-id="10957-106">The entire table resides in memory.</span></span> <span data-ttu-id="10957-107">테이블 데이터의 보조 복사본이 디스크에서 유지 관리되는데, 이는 내구성 목적입니다.</span><span class="sxs-lookup"><span data-stu-id="10957-107">A second copy of the table data is maintained on disk, but only for durability purposes.</span></span>  
  
 <span data-ttu-id="10957-108">메모리 내 OLTP는 개발, 배포, 관리 효율성 및 지원 가능성과 같은 모든 영역에서 원활한 환경을 제공하기 위해 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 와 통합되었습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-108">In-Memory OLTP is integrated with [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to provide a seamless experience in all areas such as development, deployment, manageability, and supportability.</span></span> <span data-ttu-id="10957-109">데이터베이스는 메모리 내 개체뿐만 아니라 디스크 기반 개체를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-109">A database can contain in-memory as well as disk-based objects.</span></span>  
  
 <span data-ttu-id="10957-110">메모리 최적화 테이블의 행에는 버전이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-110">Rows in memory-optimized tables are versioned.</span></span> <span data-ttu-id="10957-111">즉, 테이블의 각 행에 여러 버전이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-111">This means that each row in the table potentially has multiple versions.</span></span> <span data-ttu-id="10957-112">모든 행 버전은 동일한 테이블 데이터 구조에서 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="10957-112">All row versions are maintained in the same table data structure.</span></span> <span data-ttu-id="10957-113">행 버전 관리는 동일한 행에 대한 동시 읽기 및 쓰기를 가능하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="10957-113">Row versioning is used to allow concurrent reads and writes on the same row.</span></span> <span data-ttu-id="10957-114">동일한 행에 대한 동시 읽기 및 쓰기에 대한 자세한 내용은 [Transactions in Memory-Optimized Tables](memory-optimized-tables.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="10957-114">For more information about concurrent reads and writes on the same row, see [Transactions in Memory-Optimized Tables](memory-optimized-tables.md).</span></span>  
  
 <span data-ttu-id="10957-115">다음 그림에서는 다중 버전 관리를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="10957-115">The following figure illustrates multi-versioning.</span></span> <span data-ttu-id="10957-116">이 그림에서는 세 개의 행이 있고 각 행에 서로 다른 버전이 있는 테이블을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="10957-116">The figure shows a table with three rows and each row has different versions.</span></span>  
  
 <span data-ttu-id="10957-117">![다중 버전 관리](../../database-engine/media/hekaton-tables-1.gif "다중 버전 관리")</span><span class="sxs-lookup"><span data-stu-id="10957-117">![Multi-versioning.](../../database-engine/media/hekaton-tables-1.gif "Multi-versioning.")</span></span>  
  
 <span data-ttu-id="10957-118">테이블에 3개의 행 즉, r1, r2, r3이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-118">The table has three rows: r1, r2, and r3.</span></span> <span data-ttu-id="10957-119">r1에는 세 개의 버전, r2에는 두 개의 버전, r3에는 네 개의 버전이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-119">r1 has three versions, r2 has two versions, and r3 has four versions.</span></span> <span data-ttu-id="10957-120">동일한 행의 서로 다른 버전은 반드시 연속된 메모리 위치에 배치하지 않아도 되며,</span><span class="sxs-lookup"><span data-stu-id="10957-120">Note that different versions of the same row do not necessarily occupy consecutive memory locations.</span></span> <span data-ttu-id="10957-121">테이블 데이터 구조의 여러 위치에 분산하여 배치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-121">The different row versions can be dispersed throughout the table data structure.</span></span>  
  
 <span data-ttu-id="10957-122">메모리 최적화 테이블 데이터 구조는 행 버전의 컬렉션처럼 보일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-122">The memory-optimized table data structure can be seen as a collection of row versions.</span></span> <span data-ttu-id="10957-123">디스크 기반 테이블의 행은 페이지 및 익스텐트에 구성되고 개별 행은 페이지 번호 및 페이지 오프셋을 사용하여 지정되는 반면 메모리 최적화 테이블의 행 버전은 8바이트 메모리 포인터를 사용하여 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="10957-123">Rows in disk-based tables are organized in pages and extents, and individual rows addressed using page number and page offset, row versions in memory-optimized tables are addressed using 8-byte memory pointers.</span></span>  
  
## <a name="durability"></a><span data-ttu-id="10957-124">내구성</span><span class="sxs-lookup"><span data-stu-id="10957-124">Durability</span></span>  
 <span data-ttu-id="10957-125">메모리 최적화 테이블은 기본적으로 완전한 영속성을 가지며, 메모리 최적화 테이블의 완전한 영구 트랜잭션은 (기존) 디스크 기반 테이블의 트랜잭션과 같이 완전한 ACID(원자성, 일관성, 격리성 및 영속성)를 가집니다.</span><span class="sxs-lookup"><span data-stu-id="10957-125">Memory-optimized tables are fully durable by default, and, like transactions on (traditional) disk-based tables, fully durable transactions on memory-optimized tables are fully atomic, consistent, isolated, and durable (ACID).</span></span> <span data-ttu-id="10957-126">메모리 액세스에 최적화된 테이블과 고유하게 컴파일된 저장 프로시저는 [!INCLUDE[tsql](../../../includes/tsql-md.md)]의 하위 집합을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="10957-126">Memory-optimized tables and natively compiled stored procedures support a subset of [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span>  
  
 <span data-ttu-id="10957-127">메모리 내 OLTP는 트랜잭션 내구성이 지연된 영구 테이블을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="10957-127">In-Memory OLTP supports durable tables with transaction durability delayed.</span></span> <span data-ttu-id="10957-128">지연된 영구적 트랜잭션은 트랜잭션이 커밋된 후 곧바로 디스크에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="10957-128">Delayed durable transactions are saved to disk soon after the transaction has committed.</span></span> <span data-ttu-id="10957-129">성능이 향상되는 대신 디스크에 저장되지 않은 커밋된 트랜잭션이 서버 충돌 또는 장애 조치(Failover)에서 손실됩니다.</span><span class="sxs-lookup"><span data-stu-id="10957-129">In exchange for the increased performance, committed transactions that have not saved to disk are lost in a server crash or failover.</span></span>  
  
 <span data-ttu-id="10957-130">기본 내구성 메모리 최적화 테이블 외에도 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]는 기록되지 않고 데이터가 디스크에 지속되지 않는 비 내구성 메모리 최적화 테이블도 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="10957-130">Besides the default durable memory-optimized tables, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] also supports non-durable memory-optimized tables, which are not logged and their data is not persisted on disk.</span></span> <span data-ttu-id="10957-131">따라서 이러한 테이블의 트랜잭션에는 디스크 IO가 필요하지 않지만 서버 충돌이나 장애 조치가 있는 경우 데이터가 복구되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-131">This means that transactions on these tables do not require any disk IO, but the data will not be recovered if there is a server crash or failover.</span></span>  
  
## <a name="accessing-data-in-memory-optimized-tables"></a><span data-ttu-id="10957-132">메모리 액세스에 최적화된 테이블에서 데이터 액세스</span><span class="sxs-lookup"><span data-stu-id="10957-132">Accessing Data in Memory-Optimized Tables</span></span>  
 <span data-ttu-id="10957-133">메모리 최적화 테이블의 데이터는 다음 두 가지 방법으로 액세스됩니다.</span><span class="sxs-lookup"><span data-stu-id="10957-133">Data in memory-optimized tables is accessed in two ways:</span></span>  
  
-   <span data-ttu-id="10957-134">해석된 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 을 통해(고유하게 컴파일된 저장 프로시저 외부)</span><span class="sxs-lookup"><span data-stu-id="10957-134">Through interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] (outside of a natively-compiled stored procedure).</span></span> <span data-ttu-id="10957-135">이러한 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 문은 해석된 저장 프로시저 내부에 있거나 임시 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 문이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-135">These [!INCLUDE[tsql](../../../includes/tsql-md.md)] statements may be either inside interpreted stored procedures or they may be ad-hoc [!INCLUDE[tsql](../../../includes/tsql-md.md)] statements.</span></span>  
  
-   <span data-ttu-id="10957-136">고유하게 컴파일된 저장 프로시저를 통해</span><span class="sxs-lookup"><span data-stu-id="10957-136">Through natively compiled stored procedures.</span></span>  
  
 <span data-ttu-id="10957-137">메모리 액세스에 최적화된 테이블은 고유하게 컴파일된 저장 프로시저([고유하게 컴파일된 저장 프로시저](natively-compiled-stored-procedures.md))에서 가장 효율적으로 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-137">Memory-optimized tables can be accessed most efficiently from natively compiled stored procedures ([Natively Compiled Stored Procedures](natively-compiled-stored-procedures.md)).</span></span> <span data-ttu-id="10957-138">(기존의) 해석된 [!INCLUDE[tsql](../../../includes/tsql-md.md)]로 메모리 액세스에 최적화된 테이블에 액세스할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-138">Memory-optimized tables can also be accessed with (traditional) interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="10957-139">해석된 [!INCLUDE[tsql](../../../includes/tsql-md.md)]은 고유하게 컴파일된 저장 프로시저를 사용하지 않고 메모리 최적화 테이블에 액세스함을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="10957-139">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] refers to accessing memory-optimized tables without a natively compiled stored procedure.</span></span> <span data-ttu-id="10957-140">해석된 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 액세스의 예로는 DML 트리거, 임시 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 일괄 처리, 뷰 및 테이블 반환 함수에서 메모리 최적화 테이블에 액세스 등이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-140">Some examples of interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access include accessing a memory-optimized table from a DML trigger, ad hoc [!INCLUDE[tsql](../../../includes/tsql-md.md)] batch, view, and table-valued function.</span></span>  
  
 <span data-ttu-id="10957-141">다음 표에서는 다양한 개체에 대한 고유 및 해석된 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 액세스를 요약하여 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="10957-141">The following table summarizes native and interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access for various objects.</span></span>  
  
|<span data-ttu-id="10957-142">기능</span><span class="sxs-lookup"><span data-stu-id="10957-142">Feature</span></span>|<span data-ttu-id="10957-143">고유하게 컴파일된 저장 프로시저를 통한 액세스</span><span class="sxs-lookup"><span data-stu-id="10957-143">Access Using a Natively Compiled Stored Procedure</span></span>|<span data-ttu-id="10957-144">해석된 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 액세스</span><span class="sxs-lookup"><span data-stu-id="10957-144">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] Access</span></span>|<span data-ttu-id="10957-145">CLR 액세스</span><span class="sxs-lookup"><span data-stu-id="10957-145">CLR Access</span></span>|  
|-------------|-------------------------------------------------------|-------------------------------------------|----------------|  
|<span data-ttu-id="10957-146">메모리 최적화 테이블</span><span class="sxs-lookup"><span data-stu-id="10957-146">Memory-optimized tables</span></span>|<span data-ttu-id="10957-147">예</span><span class="sxs-lookup"><span data-stu-id="10957-147">Yes</span></span>|<span data-ttu-id="10957-148">예</span><span class="sxs-lookup"><span data-stu-id="10957-148">Yes</span></span>|<span data-ttu-id="10957-149">아니요 <sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="10957-149">No <sup>1</sup></span></span>|  
|[<span data-ttu-id="10957-150">메모리 액세스에 최적화된 테이블 변수</span><span class="sxs-lookup"><span data-stu-id="10957-150">Memory-Optimized Table Variables</span></span>](../../database-engine/memory-optimized-table-variables.md)|<span data-ttu-id="10957-151">예</span><span class="sxs-lookup"><span data-stu-id="10957-151">Yes</span></span>|<span data-ttu-id="10957-152">예</span><span class="sxs-lookup"><span data-stu-id="10957-152">Yes</span></span>|<span data-ttu-id="10957-153">아니요</span><span class="sxs-lookup"><span data-stu-id="10957-153">No</span></span>|  
|[<span data-ttu-id="10957-154">고유하게 컴파일된 저장 프로시저</span><span class="sxs-lookup"><span data-stu-id="10957-154">Natively Compiled Stored Procedures</span></span>](https://msdn.microsoft.com/library/dn133184.aspx)|<span data-ttu-id="10957-155">EXECUTE 문으로는 고유하게 컴파일된 저장 프로시저에서 저장 프로시저를 실행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-155">You cannot use the EXECUTE statement to execute any stored procedure from a natively compiled stored procedure.</span></span>|<span data-ttu-id="10957-156">예</span><span class="sxs-lookup"><span data-stu-id="10957-156">Yes</span></span>|<span data-ttu-id="10957-157">아니요 <sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="10957-157">No <sup>1</sup></span></span>|  
  
 <span data-ttu-id="10957-158"><sup>1</sup> 컨텍스트 연결 ( [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] CLR 모듈을 실행 하는 경우의 연결)에서 메모리 최적화 테이블 또는 고유 하 게 컴파일된 저장 프로시저에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-158"><sup>1</sup> You cannot access a memory-optimized table or natively compiled stored procedure from the context connection (the connection from [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] when executing a CLR module).</span></span> <span data-ttu-id="10957-159">하지만 메모리 최적화 테이블과 고유하게 컴파일된 저장 프로시저에 액세스할 수 있는 다른 연결을 만들어서 열 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-159">You can, however, create and open another connection from which you can access memory-optimized tables and natively compiled stored procedures.</span></span> <span data-ttu-id="10957-160">자세한 내용은 [일반 연결 및 컨텍스트 연결](../clr-integration/data-access/context-connections-vs-regular-connections.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="10957-160">For more information, see [Regular vs. Context Connections](../clr-integration/data-access/context-connections-vs-regular-connections.md).</span></span>  
  
## <a name="performance-and-scalability"></a><span data-ttu-id="10957-161">성능 및 확장성</span><span class="sxs-lookup"><span data-stu-id="10957-161">Performance and Scalability</span></span>  
 <span data-ttu-id="10957-162">다음과 같은 요인이 메모리 내 OLTP에서 얻을 수 있는 성능 향상에 영향을 미칩니다.</span><span class="sxs-lookup"><span data-stu-id="10957-162">The following factors will affect the performance gains that can be achieved with In-Memory OLTP:</span></span>  
  
 <span data-ttu-id="10957-163">커뮤니케이션</span><span class="sxs-lookup"><span data-stu-id="10957-163">Communication</span></span>  
 <span data-ttu-id="10957-164">짧은 저장 프로시저에 대해 여러 번 호출을 하는 애플리케이션은 적은 호출을 하고 각 저장 프로시저에 더 많은 기능이 구현된 애플리케이션이 비해 성능 향상이 적을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-164">An application with many calls to short stored procedures may see a smaller performance gain compared to an application with fewer calls and more functionality implemented in each stored procedure.</span></span>  
  
 [!INCLUDE[tsql](../../../includes/tsql-md.md)] <span data-ttu-id="10957-165">실행</span><span class="sxs-lookup"><span data-stu-id="10957-165">Execution</span></span>  
 <span data-ttu-id="10957-166">메모리 내 OLTP는 해석된 저장 프로시저 또는 쿼리 실행보다는 고유하게 컴파일된 저장 프로시저를 사용할 때 최상의 성능을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-166">In-Memory OLTP achieves the best performance when using natively compiled stored procedures rather than interpreted stored procedures or query execution.</span></span> <span data-ttu-id="10957-167">다른 저장 프로시저를 실행하는 저장 프로시저는 고유하게 컴파일될 수 없지만 그러한 저장 프로시저에서 메모리 최적화 테이블에 액세스하면 이점을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-167">Stored procedures that execute other stored procedures cannot be natively compiled, but there can be a benefit to accessing memory-optimized tables from such stored procedures.</span></span>  
  
 <span data-ttu-id="10957-168">범위 검색 및 포인트 조회</span><span class="sxs-lookup"><span data-stu-id="10957-168">Range Scan vs Point Lookup</span></span>  
 <span data-ttu-id="10957-169">메모리 액세스에 최적화된 비클러스터형 인덱스는 범위 검색 및 정렬된 검색을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="10957-169">Memory-optimized nonclustered indexes support range scans and ordered scans.</span></span> <span data-ttu-id="10957-170">메모리 최적화 비클러스터형 인덱스보다 메모리 최적화 해시 인덱스를 사용할 경우 포인트 조회 성능이 개선됩니다.</span><span class="sxs-lookup"><span data-stu-id="10957-170">For point lookups, memory-optimized hash indexes have better performance than memory-optimized nonclustered indexes.</span></span> <span data-ttu-id="10957-171">메모리 액세스에 최적화된 비클러스터형 인덱스는 디스크 기반 인덱스보다 성능이 우수합니다.</span><span class="sxs-lookup"><span data-stu-id="10957-171">Memory-optimized nonclustered indexes have better performance than disk-based indexes.</span></span>  
  
 <span data-ttu-id="10957-172">인덱스 작업은 기록되지 않으며 메모리에만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-172">Index operations are not logged and they exist only in memory.</span></span>  
  
 <span data-ttu-id="10957-173">동시성</span><span class="sxs-lookup"><span data-stu-id="10957-173">Concurrency</span></span>  
 <span data-ttu-id="10957-174">성능이 래치 경합 또는 차단과 같은 엔진 수준 동시성의 영향을 받는 애플리케이션은 애플리케이션이 메모리 내 OLTP로 이동하면 성능이 크게 개선됩니다.</span><span class="sxs-lookup"><span data-stu-id="10957-174">Applications whose performance is affected by engine-level concurrency, such as latch contention or blocking, improves significantly when the application moves to In-Memory OLTP.</span></span>  
  
 <span data-ttu-id="10957-175">다음 표에서는 관계형 데이터베이스에서 일반적으로 발견되는 성능 및 확장성 문제와 메모리 내 OLTP를 사용하여 성능을 개선할 수 있는 방법을 나열합니다.</span><span class="sxs-lookup"><span data-stu-id="10957-175">The following table lists the performance and scalability issues that are commonly found in relational databases and how In-Memory OLTP can improve performance.</span></span>  
  
|<span data-ttu-id="10957-176">문제</span><span class="sxs-lookup"><span data-stu-id="10957-176">Issue</span></span>|<span data-ttu-id="10957-177">메모리 내 OLTP 영향</span><span class="sxs-lookup"><span data-stu-id="10957-177">In-Memory OLTP Impact</span></span>|  
|-----------|----------------------------|  
|<span data-ttu-id="10957-178">성능</span><span class="sxs-lookup"><span data-stu-id="10957-178">Performance</span></span><br /><br /> <span data-ttu-id="10957-179">많은 리소스(CPU, I/O, 네트워크 또는 메모리) 사용량</span><span class="sxs-lookup"><span data-stu-id="10957-179">High resource (CPU, I/O, network or memory) usage.</span></span>|<span data-ttu-id="10957-180">CPU</span><span class="sxs-lookup"><span data-stu-id="10957-180">CPU</span></span><br /> <span data-ttu-id="10957-181">고유하게 컴파일된 저장 프로시저를 사용할 경우 [!INCLUDE[tsql](../../../includes/tsql-md.md)] 문을 실행하는 데 필요한 명령이 해석된 저장 프로시저에 비해 매우 적기 때문에 CPU 사용량도 크게 줄어들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-181">Natively compiled stored procedures can lower CPU usage significantly because they require significantly fewer instructions to execute a [!INCLUDE[tsql](../../../includes/tsql-md.md)] statement compared to interpreted stored procedures.</span></span><br /><br /> <span data-ttu-id="10957-182">메모리 내 OLTP는 서버 한 대가 서버 5 - 10대의 처리량을 발휘할 수 있기 때문에 확장된 작업에서 하드웨어 투자를 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-182">In-Memory OLTP can help reduce the hardware investment in scaled-out workloads because one server can potentially deliver the throughput of five to ten servers.</span></span><br /><br /> <span data-ttu-id="10957-183">I/O</span><span class="sxs-lookup"><span data-stu-id="10957-183">I/O</span></span><br /> <span data-ttu-id="10957-184">데이터 또는 인덱스 페이지 처리에 I/O 병목 현상이 발생하는 경우 메모리 내 OLTP를 사용하면 병목 현상을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-184">If you encounter an I/O bottleneck from processing to data or index pages, In-Memory OLTP may reduce the bottleneck.</span></span> <span data-ttu-id="10957-185">또한 메모리 내 OLTP 개체의 검사점은 연속되며 I/O 작업의 갑작스러운 증가를 초래하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-185">Additionally, the checkpointing of In-Memory OLTP objects is continuous and does not lead to sudden increases in I/O operations.</span></span> <span data-ttu-id="10957-186">그러나 성능에 중요한 영향을 미치는 테이블의 작업 집합이 메모리에 맞지 않을 경우 데이터가 메모리에 상주할 필요가 없기 때문에 메모리 내 OLTP는 성능을 개선하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-186">However, if the working set of the performance critical tables does not fit in memory, In-Memory OLTP will not improve performance because it requires data to be memory resident.</span></span> <span data-ttu-id="10957-187">로깅에서 I/O 병목 현상이 발생하는 경우 메모리 내 OLTP를 사용하면 로깅이 적게 수행되므로 병목 현상을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-187">If you encounter an I/O bottleneck in logging, In-Memory OLTP can reduce the bottleneck because it does less logging.</span></span> <span data-ttu-id="10957-188">하나 이상의 메모리 최적화 테이블을 비내구성 테이블로 구성한 경우 데이터에 대한 로깅을 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-188">If one or more memory-optimized tables are configured as non-durable tables, you can eliminate logging for data.</span></span><br /><br /> <span data-ttu-id="10957-189">메모리</span><span class="sxs-lookup"><span data-stu-id="10957-189">Memory</span></span><br /> <span data-ttu-id="10957-190">메모리 내 OLTP는 성능 이점을 제공하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-190">In-Memory OLTP does not offer any performance benefit.</span></span> <span data-ttu-id="10957-191">개체가 메모리에 상주해야 하기 때문에 메모리 내 OLTP는 메모리에 추가 부담을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-191">In-Memory OLTP can put extra pressure on memory as the objects need to be memory resident.</span></span><br /><br /> <span data-ttu-id="10957-192">네트워크</span><span class="sxs-lookup"><span data-stu-id="10957-192">Network</span></span><br /> <span data-ttu-id="10957-193">메모리 내 OLTP는 성능 이점을 제공하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-193">In-Memory OLTP does not offer any performance benefit.</span></span> <span data-ttu-id="10957-194">데이터는 데이터 계층에서 애플리케이션 계층으로 통신해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="10957-194">The data needs to be communicated from data tier to application tier.</span></span>|  
|<span data-ttu-id="10957-195">확장성</span><span class="sxs-lookup"><span data-stu-id="10957-195">Scalability</span></span><br /><br /> <span data-ttu-id="10957-196">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 애플리케이션에서 발생하는 대부분의 확장 문제는 잠금, 래치 및 spinlock의 경합 같은 동시성 문제로 인한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="10957-196">Most scaling issues in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] applications are caused by concurrency issues such as contention in locks, latches, and spinlocks.</span></span>|<span data-ttu-id="10957-197">래치 경합</span><span class="sxs-lookup"><span data-stu-id="10957-197">Latch Contention</span></span><br /> <span data-ttu-id="10957-198">일반적인 시나리오는 키 순서로 행을 동시에 삽입할 때 인덱스의 마지막 페이지에서의 경합입니다.</span><span class="sxs-lookup"><span data-stu-id="10957-198">A typical scenario is contention on the last page of an index when inserting rows concurrently in key order.</span></span> <span data-ttu-id="10957-199">메모리 내 OLTP는 데이터에 액세스할 때 래치를 수행하지 않으므로 래치 경합과 관련한 확장성 문제가 완전히 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="10957-199">Because In-Memory OLTP does not take latches when accessing data, the scalability issues related to latch contentions are fully removed.</span></span><br /><br /> <span data-ttu-id="10957-200">Spinlock 경합</span><span class="sxs-lookup"><span data-stu-id="10957-200">Spinlock Contention</span></span><br /> <span data-ttu-id="10957-201">메모리 내 OLTP는 데이터에 액세스할 때 래치를 수행하지 않으므로 spinlock 경합과 관련한 확장성 문제가 완전히 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="10957-201">Because In-Memory OLTP does not take latches when accessing data, the scalability issues related to spinlock contentions are fully removed.</span></span><br /><br /> <span data-ttu-id="10957-202">잠금 관련 경합</span><span class="sxs-lookup"><span data-stu-id="10957-202">Locking Related Contention</span></span><br /> <span data-ttu-id="10957-203">데이터베이스 애플리케이션의 읽기와 쓰기 작업 간에 잠금 문제가 발생하는 경우 새로운 형태의 낙관적 동시성 제어를 사용하여 모든 트랜잭션 격리 수준을 구현하기 때문에 메모리 내 OLTP는 차단 문제를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="10957-203">If your database application encounters blocking issues between read and write operations, In-Memory OLTP removes the blocking issues because it uses a new form of optimistic concurrency control to implement all transaction isolation levels.</span></span> <span data-ttu-id="10957-204">메모리 내 OLTP는 행 버전을 저장하는 데 TempDB를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-204">In-Memory OLTP does not use TempDB to store row versions.</span></span><br /><br /> <span data-ttu-id="10957-205">같은 행을 업데이트하려는 두 동시 트랜잭션 같이 두 쓰기 작업 간의 충돌로 인해 확장 문제가 발생하는 경우 메모리 내 OLTP를 사용하면 한 트랜잭션은 성공하고 다른 트랜잭션은 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="10957-205">If the scaling issue is caused by conflict between two write operations, such as two concurrent transactions trying to update the same row, In-Memory OLTP lets one transaction succeed and fails the other transaction.</span></span> <span data-ttu-id="10957-206">실패한 트랜잭션은 명시적으로 또는 암시적으로 다시 제출해야 하며 트랜잭션을 다시 시도해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="10957-206">The failed transaction must be re-submitted either explicitly or implicitly, re-trying the transaction.</span></span> <span data-ttu-id="10957-207">어느 경우나 애플리케이션을 변경해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="10957-207">In either case, you need to make changes to the application.</span></span><br /><br /> <span data-ttu-id="10957-208">애플리케이션의 두 쓰기 작업 간에 충돌이 자주 발생하는 경우 낙관적 잠금 값이 감소합니다.</span><span class="sxs-lookup"><span data-stu-id="10957-208">If your application experiences frequent conflicts between two write operations, the value of optimistic locking is diminished.</span></span> <span data-ttu-id="10957-209">애플리케이션은 메모리 내 OLTP에 적합하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-209">The application is not suitable for In-Memory OLTP.</span></span> <span data-ttu-id="10957-210">충돌이 잠금 에스컬레이션으로 인해 발생하지 않는다면 대부분의 OLTP 애플리케이션에는 쓰기 충돌이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="10957-210">Most OLTP applications don't have a write conflicts unless the conflict is induced by lock escalation.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="10957-211">참고 항목</span><span class="sxs-lookup"><span data-stu-id="10957-211">See Also</span></span>  
 [<span data-ttu-id="10957-212">메모리 내 OLTP&#40;메모리 내 최적화&#41;</span><span class="sxs-lookup"><span data-stu-id="10957-212">In-Memory OLTP &#40;In-Memory Optimization&#41;</span></span>](in-memory-oltp-in-memory-optimization.md)  
  
  
