---
title: 메모리 액세스에 최적화된 테이블에 대한 내구성 | Microsoft 문서
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: d304c94d-3ab4-47b0-905d-3c8c2aba9db6
author: CarlRabeler
ms.author: carlrab
ms.openlocfilehash: 1d48d671b23d7b7b17557e7829d6f2522c375acd
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87738404"
---
# <a name="durability-for-memory-optimized-tables"></a><span data-ttu-id="30d1a-102">메모리 액세스에 최적화된 테이블에 대한 내구성</span><span class="sxs-lookup"><span data-stu-id="30d1a-102">Durability for Memory-Optimized Tables</span></span>
  [!INCLUDE[hek_2](../../../includes/hek-2-md.md)]<span data-ttu-id="30d1a-103">는 메모리 최적화 테이블에 대한 완전한 내구성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-103">provides full durability for memory-optimized tables.</span></span> <span data-ttu-id="30d1a-104">메모리 최적화 테이블을 변경한 트랜잭션을 커밋할 때 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]를 사용하면 (디스크 기반 테이블과 마찬가지로) 기본 스토리지를 사용할 수 있는 경우 변경 내용이 영구적이 됩니다(데이터베이스 다시 시작 유지).</span><span class="sxs-lookup"><span data-stu-id="30d1a-104">When a transaction that changed a memory-optimized table commits, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] (as it does for disk-based tables), guarantees that the changes are permanent (will survive a database restart), provided the underlying storage is available.</span></span> <span data-ttu-id="30d1a-105">내구성의 두 가지 주요 구성 요소는 트랜잭션 로깅 및 디스크상 스토리지에 데이터 변경 내용 저장입니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-105">There are two key components of durability: transaction logging and persisting data changes to on-disk storage.</span></span>

## <a name="transaction-log"></a><span data-ttu-id="30d1a-106">트랜잭션 로그</span><span class="sxs-lookup"><span data-stu-id="30d1a-106">Transaction Log</span></span>
 <span data-ttu-id="30d1a-107">디스크 기반 테이블 또는 메모리 최적화 내구성이 있는 테이블에 대한 모든 변경은 하나 이상의 트랜잭션 로그 레코드에 캡처됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-107">All changes made to disk-based tables or durable memory-optimized tables are captured in one or more transaction log records.</span></span> <span data-ttu-id="30d1a-108">트랜잭션이 커밋될 때 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 는 트랜잭션이 커밋된 애플리케이션 또는 사용자 세션과 통신하기 전에 디스크에 트랜잭션과 관련된 로그 레코드를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-108">When a transaction commits, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] writes the log records associated with the transaction to disk before communicating to the application or user session that the transaction has committed.</span></span> <span data-ttu-id="30d1a-109">이렇게 하면 트랜잭션에 의한 변경 사항이 내구성을 가집니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-109">This guarantees that changes made by the transaction are durable.</span></span> <span data-ttu-id="30d1a-110">메모리 최적화 테이블에 대한 트랜잭션 로그는 디스크 기반 테이블에서 사용되는 동일한 로그 스트림과 완전히 통합되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-110">The transaction log for memory-optimized tables is fully integrated with the same log stream used by disk-based tables.</span></span> <span data-ttu-id="30d1a-111">이러한 통합에 따라 기존 트랜잭션 로그 백업, 복구 및 복원 작업이 추가 단계를 필요로 하지 않고 계속 수행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-111">This integration allows existing transaction log backup, recover, and restore operations to continue to work without requiring any additional steps.</span></span> <span data-ttu-id="30d1a-112">그러나 [!INCLUDE[hek_2](../../../includes/hek-2-md.md)]가 작업의 트랜잭션 처리량을 크게 증가시킬 수 있으므로 트랜잭션 로그 스토리지가 증가한 IO 요구 사항을 처리할 수 있도록 적절하게 구성되어 있는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-112">However, since [!INCLUDE[hek_2](../../../includes/hek-2-md.md)] can increase transaction throughput of your workload significantly, you need to make sure that transaction log storage is configured appropriately to handle the increased IO requirements.</span></span>

## <a name="data-and-delta-files"></a><span data-ttu-id="30d1a-113">데이터 및 델타 파일</span><span class="sxs-lookup"><span data-stu-id="30d1a-113">Data and Delta Files</span></span>
 <span data-ttu-id="30d1a-114">메모리 최적화 테이블의 데이터는 하나 이상의 메모리 내 인덱스를 통해 연결된 자유 형식 데이터 행으로 메모리에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-114">The data in memory-optimized tables is stored as free-form data rows that are linked through one or more in-memory indexes, in memory.</span></span> <span data-ttu-id="30d1a-115">디스크 기반 테이블에 사용되는 페이지 구조와 같이 데이터 행에 대한 페이지 구조는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-115">There are no page structures for data rows, such as those used for disk-based tables.</span></span> <span data-ttu-id="30d1a-116">애플리케이션이 트랜잭션을 커밋할 준비가 되면 [!INCLUDE[hek_2](../../../includes/hek-2-md.md)]는 트랜잭션에 대한 로그 레코드를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-116">When the application is ready to commit the transaction, the [!INCLUDE[hek_2](../../../includes/hek-2-md.md)] generates the log records for the transaction.</span></span> <span data-ttu-id="30d1a-117">메모리 최적화 테이블의 지속성은 백그라운드 스레드를 사용하여 데이터 집합 및 델타 파일로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-117">The persistence of memory-optimized tables is done with a set of data and delta files using a background thread.</span></span> <span data-ttu-id="30d1a-118">데이터 및 델타 파일은 (FILESTREAM 데이터에 사용되는 동일한 메커니즘을 사용하는) 하나 이상의 컨테이너에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-118">The data and delta files are located in one or more containers (using the same mechanism used for FILESTREAM data).</span></span> <span data-ttu-id="30d1a-119">이러한 컨테이너는 메모리 최적화 파일 그룹이라는 파일 그룹의 새 형식에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-119">These containers are mapped to a new type of filegroup, called a memory-optimized filegroup.</span></span>

 <span data-ttu-id="30d1a-120">데이터는 이 파일에 기록될 때 회전 미디어의 디스크 대기 시간을 최소화하는 엄격한 순차적 방식으로 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-120">Data is written to these files in a strictly sequential fashion, which minimizes disk latency for spinning media.</span></span> <span data-ttu-id="30d1a-121">서로 다른 디스크의 여러 컨테이너를 사용하여 I/O 작업을 분산할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-121">You can use multiple containers on different disks to distribute the I/O activity.</span></span> <span data-ttu-id="30d1a-122">서로 다른 디스크의 여러 컨테이너에 있는 데이터 및 델타 파일은 디스크의 데이터 및 델타 파일에서 메모리로 데이터를 읽을 때 복구 성능을 향상시킵니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-122">Data and delta files in multiple containers on different disks will increase recovery performance when data is read from the data and delta files on disk, into memory.</span></span>

 <span data-ttu-id="30d1a-123">애플리케이션은 데이터 및 델타 파일에 직접 액세스하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-123">An application does not directly access data and delta files.</span></span> <span data-ttu-id="30d1a-124">모든 데이터 읽기 및 쓰기에서는 메모리 내 데이터를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-124">All data reads and writes use in-memory data.</span></span>

### <a name="the-data-file"></a><span data-ttu-id="30d1a-125">데이터 파일</span><span class="sxs-lookup"><span data-stu-id="30d1a-125">The Data File</span></span>
 <span data-ttu-id="30d1a-126">데이터 파일에는 여러 트랜잭션에서 삽입 또는 업데이트 작업 중에 삽입된 하나 이상의 메모리 최적화 테이블에서 가져온 행이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-126">A data file contains rows from one or more memory-optimized tables that were inserted by multiple transactions as part of INSERT or UPDATE operations.</span></span> <span data-ttu-id="30d1a-127">예를 들어, 메모리 최적화 테이블 T1에서 한 행을 가져오고 메모리 최적화 테이블 T2에서 다음 행을 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-127">For example, one row can be from memory-optimized table T1 and the next row can be from memory-optimized table T2.</span></span> <span data-ttu-id="30d1a-128">트랜잭션 로그의 트랜잭션 순서로 데이터 파일에 행을 추가하여 데이터 액세스를 순차적으로 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-128">The rows are appended to the data file in the order of transactions in the transaction log, making data access sequential.</span></span> <span data-ttu-id="30d1a-129">이렇게 하면 임의 I/O와 비교할 때 상당히 나은 I/O 처리량이 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-129">This enables an order of magnitude better I/O throughput compared to random I/O.</span></span> <span data-ttu-id="30d1a-130">각 데이터 파일의 크기는 16GB보다 메모리가 더 큰 컴퓨터의 경우 약 128MB, 16GB보다 메모리가 더 작거나 같은 컴퓨터의 경우 약 16MB입니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-130">Each data file is sized approximately to 128MB for computers with memory greater than 16GB, and 16MB for computers with less than or equal to 16GB.</span></span> <span data-ttu-id="30d1a-131">데이터 파일이 꽉 차면 새 트랜잭션에서 삽입되는 행은 다른 데이터 파일에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-131">Once the data file is full, the rows inserted by new transactions are stored in another data file.</span></span> <span data-ttu-id="30d1a-132">시간이 지날수록 메모리 최적화 영구 테이블의 행은 많은 데이터 파일 중 하나에 저장되고 결합되지 않았지만 연속하는 트랜잭션 범위에서 가져온 행이 각 데이터 파일에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-132">Over time, the rows from durable memory-optimized tables are stored in one of more data files and each data file containing rows from a disjoint but contiguous range of transactions.</span></span> <span data-ttu-id="30d1a-133">예를 들어, 트랜잭션 커밋 타임스탬프 범위가 (100, 200)인 데이터 파일에는 커밋 타임스탬프가 100보다 크고 200보다 작거나 같은 트랜잭션에 의해 삽입된 모든 행이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-133">For example a data file with transaction commit timestamp in the range of (100, 200) has all the rows inserted by transactions that have commit timestamp greater than 100 and less than or equal to 200.</span></span> <span data-ttu-id="30d1a-134">커밋 타임스탬프는 커밋 준비가 되면 트랜잭션에 할당되는 단순하게 증가하는 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-134">The commit timestamp is a monotonically increasing number assigned to a transaction when it is ready to commit.</span></span> <span data-ttu-id="30d1a-135">각 트랜잭션에는 고유한 커밋 타임스탬프가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-135">Each transaction has a unique commit timestamp.</span></span>

 <span data-ttu-id="30d1a-136">행을 삭제하거나 업데이트해도 해당 행은 데이터 파일에서 제거되거나 변경되지 않지만 삭제된 행은 다른 파일 형식인 델타 파일로 추적됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-136">When a row is deleted or updated, the row is not removed or changed in-place in the data file but the deleted rows are tracked in another type of file: the delta file.</span></span> <span data-ttu-id="30d1a-137">업데이트 작업은 각 행에 대한 삭제 및 삽입 작업의 튜플로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-137">Update operations are processed as a tuple of delete and insert operations for each row.</span></span> <span data-ttu-id="30d1a-138">따라서 데이터 파일에서 임의의 IO가 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-138">This eliminates random IO on the data file.</span></span>

### <a name="the-delta-file"></a><span data-ttu-id="30d1a-139">델타 파일</span><span class="sxs-lookup"><span data-stu-id="30d1a-139">The Delta File</span></span>
 <span data-ttu-id="30d1a-140">각 데이터 파일은 트랜잭션 범위가 동일하고 해당 트랜잭션 범위에서 트랜잭션에 의해 삽입된 삭제된 행을 추적하는 델타 파일과 쌍을 이룹니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-140">Each data file is paired with a delta file that has the same transaction range and tracks the deleted rows inserted by transactions in the transaction range.</span></span> <span data-ttu-id="30d1a-141">이 데이터 및 델타 파일은 CFP(검사점 파일 쌍)이라고 하며, 병합 작업을 위한 단위는 물론 할당 및 할당 취소 작업의 단위이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-141">This data and delta file is referred to as a Checkpoint File Pair (CFP) and it is the unit of allocation and deallocation as well as the unit for Merge operations.</span></span> <span data-ttu-id="30d1a-142">예를 들어, 트랜잭션 범위 (100, 200)에 해당하는 델타 파일은 범위 (100, 200)의 트랜잭션에 의해 삽입된 삭제된 행을 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-142">For example, a delta file corresponding to transaction range (100, 200) will store deleted rows that were inserted by transactions in the range (100, 200).</span></span> <span data-ttu-id="30d1a-143">데이터 파일과 마찬가지로 델타 파일은 순차적으로 액세스됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-143">Like data files, the delta file is accessed sequentially.</span></span>

 <span data-ttu-id="30d1a-144">행이 삭제되면 해당 행은 데이터 파일에서 제거되지 않지만 이 데이터 행이 삽입된 트랜잭션 범위에 연결된 델타 파일에 행에 대한 참조가 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-144">When a row is deleted, the row is not removed from the data file but a reference to the row is appended to the delta file associated with the transaction range where this data row was inserted.</span></span> <span data-ttu-id="30d1a-145">삭제할 행이 데이터 파일에 이미 있기 때문에 델타 파일은 참조 정보 `{inserting_tx_id, row_id, deleting_tx_id }` 만 원래 삭제 또는 업데이트 작업의 트랜잭션 로그 순서에 따라 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-145">Since the row to be deleted already exists in the data file, the delta file only stores the reference information `{inserting_tx_id, row_id, deleting_tx_id }` and it follows the transactional log order of the originating delete or update operations.</span></span>

## <a name="populating-data-and-delta-files"></a><span data-ttu-id="30d1a-146">데이터 및 델타 파일 채우기</span><span class="sxs-lookup"><span data-stu-id="30d1a-146">Populating Data and Delta Files</span></span>
 <span data-ttu-id="30d1a-147">데이터 및 델타 파일은 오프 라인 검사점이라는 백그라운드 스레드에 의해 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-147">Data and delta file are populated by a background thread called offline checkpoint.</span></span> <span data-ttu-id="30d1a-148">이 스레드는 메모리 최적화 테이블에서 커밋된 트랜잭션에 의해 생성되는 트랜잭션 로그 레코드를 읽고 삽입된 행과 삭제된 행에 대한 정보를 해당 데이터 및 델타 파일에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-148">This thread reads the transaction log records generated by committed transactions on memory-optimized tables and appends information about the inserted and deleted rows into appropriate data and delta files.</span></span> <span data-ttu-id="30d1a-149">검사점이 완료되면 데이터/인덱스 페이지가 임의 I/O로 플러시되는 디스크 기반 테이블과 달리 메모리 최적화 테이블은 계속해서 백그라운드 작업으로 지속됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-149">Unlike disk-based tables where data/index pages are flushed with random I/O when checkpoint is done, the persistence of memory-optimized table is continuous background operation.</span></span> <span data-ttu-id="30d1a-150">트랜잭션을 삭제하거나 이전 트랜잭션에 의해 삽입된 모든 행을 업데이트하기 때문에 여러 개의 델타 파일이 액세스됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-150">Multiple delta files are accessed because a transaction can delete or update any row that was inserted by any previous transaction.</span></span> <span data-ttu-id="30d1a-151">삭제 정보는 항상 델타 파일의 끝에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-151">Deletion information is always appended at the end of the delta file.</span></span> <span data-ttu-id="30d1a-152">예를 들어, 커밋 타임스탬프가 600인 트랜잭션은 한 행을 삽입하고 아래 그림처럼 150, 250 및 450의 커밋 타임스탬프를 갖는 트랜잭션에 의해 삽입된 행을 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-152">For example, a transaction with a commit timestamp of 600 inserts one new row and deletes rows inserted by transactions with a commit timestamp of 150, 250 and 450 as shown in the picture below.</span></span> <span data-ttu-id="30d1a-153">모두 4번의 파일 I/O 작업(삭제된 행에 3번, 새로 삽입된 행에 1번)이 해당 델타 및 데이터 파일에 대한 추가 전용 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-153">All 4 file I/O operations (three for deleted rows and 1 for the newly inserted rows), are append-only operations to the corresponding delta and data files.</span></span>

 <span data-ttu-id="30d1a-154">![메모리 최적화 테이블에 대한 로그 레코드를 읽습니다.](../../database-engine/media/read-logs-hekaton.gif "메모리 최적화 테이블에 대한 로그 레코드를 읽습니다.")</span><span class="sxs-lookup"><span data-stu-id="30d1a-154">![Read log records for memory-optimized tables.](../../database-engine/media/read-logs-hekaton.gif "Read log records for memory-optimized tables.")</span></span>

## <a name="accessing-data-and-delta-files"></a><span data-ttu-id="30d1a-155">데이터 및 델타 파일 액세스</span><span class="sxs-lookup"><span data-stu-id="30d1a-155">Accessing Data and Delta Files</span></span>
 <span data-ttu-id="30d1a-156">데이터 및 델타 파일 쌍은 다음이 발생할 때 액세스됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-156">Data and delta file pairs are accessed when the following occurs.</span></span>

 <span data-ttu-id="30d1a-157">오프 라인 검사점 스레드이 스레드는 메모리 최적화 데이터 행에 대 한 삽입 및 삭제를 해당 데이터 및 델타 파일 쌍에 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-157">Offline checkpoint thread This thread appends inserts and deletes to memory-optimized data rows, to the corresponding data and delta file pairs.</span></span>

 <span data-ttu-id="30d1a-158">Merge 작업 작업은 하나 이상의 데이터 및 델타 파일 쌍을 병합 하 고 새 데이터 및 델타 파일 쌍을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-158">Merge operation The operation merges one or more data and delta file pairs and creates a new data and delta file pair.</span></span>

 <span data-ttu-id="30d1a-159">가 다시 시작 되거나 데이터베이스가 다시 온라인 상태가 될 때 충돌 복구 중에는 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 데이터 및 델타 파일 쌍을 사용 하 여 메모리 최적화 데이터가 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-159">During crash recovery When [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] is restarted or the database is brought back online, the memory-optimized data is populated using the data and delta file pairs.</span></span> <span data-ttu-id="30d1a-160">델타 파일은 해당 데이터 파일에서 행을 읽을 때 삭제된 행에 대한 필터의 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-160">The delta file acts as a filter for the deleted rows when reading the rows from the corresponding data file.</span></span> <span data-ttu-id="30d1a-161">각 데이터 및 델타 파일 쌍은 서로 독립적이기 때문에 이러한 파일은 메모리에 데이터를 채우는 데 걸리는 시간을 줄이기 위해 병렬로 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-161">Because each data and delta file pair is independent, these files are loaded in parallel to reduce the time taken to populate data into memory.</span></span> <span data-ttu-id="30d1a-162">데이터가 메모리로 로드되면 메모리 내 OLTP 엔진은 메모리 최적화 데이터가 완전하도록 검사점 파일에 아직 포함되지 않은 활성 트랜잭션 로그 레코드를 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-162">Once the data has been loaded into memory, the In-Memory OLTP engine applies the active transaction log records not yet covered by the checkpoint files so that the memory-optimized data is complete.</span></span>

 <span data-ttu-id="30d1a-163">복원 작업 중에는 메모리 내 OLTP 검사점 파일이 데이터베이스 백업에서 만들어진 다음 하나 이상의 트랜잭션 로그 백업이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-163">During restore operation The In-Memory OLTP checkpoint files are created from the database backup, and then one or more transaction log backups are applied.</span></span> <span data-ttu-id="30d1a-164">충돌 복구와 마찬가지로 메모리 내 OLTP 엔진은 데이터를 병렬로 메모리로 로드하여 복구 시간에 미치는 영향을 최소화합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-164">As with crash recovery, the In-Memory OLTP engine loads data into memory in parallel, to minimize the impact on recovery time.</span></span>

## <a name="merging-data-and-delta-files"></a><span data-ttu-id="30d1a-165">데이터 및 델타 파일 병합</span><span class="sxs-lookup"><span data-stu-id="30d1a-165">Merging Data and Delta Files</span></span>
 <span data-ttu-id="30d1a-166">메모리 액세스에 최적화된 테이블에 대한 데이터는 하나 이상의 데이터 및 델타 파일 쌍(검사점 파일 쌍 또는 CFP 라고도 함)에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-166">The data for memory optimized tables is stored in one or more data and delta file pairs (also called a checkpoint file pair, or CFP).</span></span> <span data-ttu-id="30d1a-167">데이터 파일에는 삽입된 행이 저장되고 델타 파일은 삭제된 행을 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-167">Data files store inserted rows and delta files reference deleted rows.</span></span> <span data-ttu-id="30d1a-168">OLTP 작업을 실행하는 동안 DML 작업에서는 행을 업데이트, 삽입 및 삭제하고, 새 행을 유지하기 위한 새 CFP가 만들어지고, 삭제된 행에 대한 참조가 델타 파일에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-168">During the execution of an OLTP workload, as the DML operations update, insert, and delete rows, new CFPs are created to persist the new rows, and the reference to the deleted rows is appended to delta files.</span></span>

 <span data-ttu-id="30d1a-169">모든 이전에 닫은 CFP와 현재 활성화된 CFP의 메타데이터가 스토리지 배열이라는 내부 배열 구조에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-169">The metadata of all previously-closed and currently active CFPs is stored in an internal array structure referred to as the storage array.</span></span> <span data-ttu-id="30d1a-170">유한 크기(8,192개 항목)의 CFP 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-170">It is a finitely sized (8,192 entries) array of CFPs.</span></span> <span data-ttu-id="30d1a-171">스토리지 배열의 항목은 트랜잭션 범위순으로 정렬됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-171">The entries in the storage array are ordered by transaction range.</span></span> <span data-ttu-id="30d1a-172">스토리지 배열의 CFP는 비상 로그와 함께 메모리 최적화 테이블로 데이터베이스를 복구하는 데 필요한 모든 디스크 상태를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-172">The CFPs in the storage array (along with the tail of the log) represent all the on-disk state required to recover a database with memory-optimized tables.</span></span>

 <span data-ttu-id="30d1a-173">시간이 지날수록 DML 작업으로 CFP 수가 늘어나 스토리지 배열이 용량에 도달하여 다음과 같은 문제가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-173">Over time, with DML operations, the number of CFPs grow causing the storage array to reach capacity, which introduces the following challenges:</span></span>

-   <span data-ttu-id="30d1a-174">삭제된 행.</span><span class="sxs-lookup"><span data-stu-id="30d1a-174">Deleted rows.</span></span>  <span data-ttu-id="30d1a-175">삭제된 행은 데이터 파일에서는 유지되지만 해당 델타 파일에서는 삭제된 것으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-175">Deleted rows remain in the data file but are marked as deleted in the corresponding delta file.</span></span> <span data-ttu-id="30d1a-176">이러한 행은 더 이상 필요하지 않으므로 스토리지에서 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-176">These rows are no longer needed and will be removed from the storage.</span></span> <span data-ttu-id="30d1a-177">삭제된 행은 CPF에서 제거되지 않은 경우 불필요한 공간을 차지하여 복구 시간이 느려집니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-177">If deleted rows were not removed from CFPs, they would use space unnecessarily and make recovery time slower.</span></span>

-   <span data-ttu-id="30d1a-178">스토리지 배열이 꽉 찼습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-178">Storage array full.</span></span> <span data-ttu-id="30d1a-179">스토리지 배열에 8000개 항목이 할당된 경우(수동 병합을 완료하거나 수동 병합을 수행할 수 있도록 배열의 192개 항목이 기존 병합에 예약된 경우) 메모리 최적화 영구 테이블에서 새로운 DML 트랜잭션을 실행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-179">When there 8,000 entries in the storage array are allocated (192 entries in the array are reserved for existing merges to compete or to allow you to do manual merges), no new DML transactions can be executed on durable memory-optimized tables.</span></span> <span data-ttu-id="30d1a-180">검사점 및 병합 작업에서만 나머지 항목을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-180">Only checkpoint and merge operations are allowed to consume the remaining entries.</span></span> <span data-ttu-id="30d1a-181">이렇게 하면 DML 트랜잭션은 배열을 채우지 않고 배열의 일부 항목이 기존 파일을 병합하고 배열의 공간 확보를 위해 예약됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-181">This ensures that DML transactions do not fill the array and that some entries in the array are reserved to merge existing files and to reclaim space in the array.</span></span>

-   <span data-ttu-id="30d1a-182">스토리지 배열 조작 오버헤드입니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-182">Storage array manipulation overhead.</span></span> <span data-ttu-id="30d1a-183">내부 프로세스는 스토리지 배열에서 작업(예: 삭제된 행에 대한 정보를 추가할 델타 파일 찾기)을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-183">Internal processes search the storage array for operations such as finding the delta file to append information about a deleted row.</span></span> <span data-ttu-id="30d1a-184">이러한 작업은 항목의 수에 따라 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-184">The cost of these operations increases with the number of entries.</span></span>

 <span data-ttu-id="30d1a-185">이러한 비효율성을 방지하려면 아래에 설명된 병합 정책에 따라 오래된 닫힌 CFP를 병합하여 더 적은 수의 CFP로 동일한 데이터 세트을 나타내도록 스토리지 배열을 압축합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-185">To help prevent these inefficiencies, the older closed CFPs are merged, based on a merge policy described below, so the storage array is compacted to represent the same set of data, with a reduced number of CFPs.</span></span>

 <span data-ttu-id="30d1a-186">데이터베이스에 있는 모든 영구 테이블의 총 메모리 내 크기는 250GB를 초과할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-186">The total in-memory size of all durable tables in a database should not exceed 250 GB.</span></span> <span data-ttu-id="30d1a-187">최대 250GB의 메모리를 사용하는 영구 테이블은 작업을 삽입, 삭제 및 업데이트할 것을 고려할 때 평균 500GB의 스토리지 공간이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-187">Durable tables that use up to 250 GB of memory will, assuming insert, delete, and update operations, require on average 500 GB of storage space.</span></span> <span data-ttu-id="30d1a-188">메모리 최적화 파일 그룹의 데이터 및 델타 파일 4000쌍은 500GB의 스토리지 공간을 지원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-188">4,000 data and delta file pairs in the memory-optimized file group are required to support the 500 GB of storage space.</span></span>

 <span data-ttu-id="30d1a-189">데이터베이스 작업의 단기 급증으로 검사점 및 병합 작업이 지연될 수 있으며, 이로 인해 필요한 데이터 및 델타 파일 쌍의 수가 늘어납니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-189">Short-term surges in database activity may cause checkpoint and merge operations lag, which will increase the number of required data and delta file pairs.</span></span> <span data-ttu-id="30d1a-190">데이터베이스 작업의 단기 급증을 수용하기 위해 스토리지 시스템은 최대 1TB 저장소당 최대 데이터 및 델타 파일 8000쌍을 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-190">To accommodate short-term surges spikes in database activity, the storage system can allocate up to 8,000 data and delta file pairs up to a total of 1TB of storage.</span></span> <span data-ttu-id="30d1a-191">해당 한계에 도달하면 검사점 작업이 따라잡을 때까지 데이터베이스에서 허용되는 새 트랜잭션이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-191">When that limit is reached, there will be no new transactions allowed on the database until checkpoint operations catch up.</span></span> <span data-ttu-id="30d1a-192">메모리에 있는 영구 테이블의 크기가 오랜 시간 동안 250GB를 초과하면 8000개 파일 쌍 제한에 도달하는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-192">If the size of durable tables in memory exceeds 250GB for long periods of time, there is a chance of reaching the 8,000 file pair limit.</span></span>

 <span data-ttu-id="30d1a-193">병합 작업에서는 내부적으로 정의된 병합 정책에 따라 하나 이상의 인접한 닫힌 CFP(병합 원본)를 입력으로 사용하여 병합 대상이라는 단일 결과 CFP를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-193">The merge operation takes as input one or more adjacent closed CFPs (called merge source) based on an internally defined merge policy, and produces one resultant CFP, called the merge target.</span></span> <span data-ttu-id="30d1a-194">원본 CFP의 각 델타 파일에 있는 항목은 해당 데이터 파일에서 행을 필터링하여 필요 없는 데이터 행을 제거하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-194">The entries in each delta file of the source CFPs are used to filter rows from the corresponding data file to remove the data rows that are not needed.</span></span> <span data-ttu-id="30d1a-195">원본 CFP의 나머지 행은 하나의 대상 CFP로 통합됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-195">The remaining rows in the source CFPs are consolidated into one target CFP.</span></span> <span data-ttu-id="30d1a-196">병합이 완료되면 원본 CFP(병합 원본)가 결과 병합 대상 CFP로 대체됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-196">After the merge is complete, the resultant merge-target CFP replaces the source CFPs (merge sources).</span></span> <span data-ttu-id="30d1a-197">병합 원본 CFP는 전환 단계를 완료한 후 스토리지에서 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-197">The merge-source CFPs go through a transition phase before they are removed from storage.</span></span>

 <span data-ttu-id="30d1a-198">아래 예제에서 메모리 최적화 테이블 파일 그룹에는 이전 트랜잭션의 데이터를 포함하는 타임스탬프 500에 4개의 데이터와 델타 파일 쌍이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-198">In the example below, the memory-optimized table file group has four data and delta file pairs at timestamp 500 containing data from previous transactions.</span></span> <span data-ttu-id="30d1a-199">예를 들어, 첫 번째 데이터 파일의 행은 타임스탬프가 100보다 크고 200보다 작거나 같은 트랜잭션에 해당하며 (100, 200]으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-199">For example, the rows in the first data file correspond to transactions with timestamp greater than 100 and less than or equal to 200; alternatively represented as (100, 200].</span></span> <span data-ttu-id="30d1a-200">두 번째 및 세 번째 데이터 파일은 삭제된 것으로 표시된 행이 채워진 비율이 50% 미만으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-200">The second and third data files are shown to be less than 50 percent full after accounting for the rows marked as deleted.</span></span> <span data-ttu-id="30d1a-201">병합 작업에서는 이 두 CFP를 결합하고 타임스탬프가 200보다 크고 400보다 작거나 같은(이 두 CFP의 결합 범위) 트랜잭션을 포함하는 새 CFP를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-201">The merge operation combines these two CFPs and creates a new CFP containing transactions with timestamp greater than 200 and less than or equal to 400, which is the combined range of these two CFPs.</span></span> <span data-ttu-id="30d1a-202">범위가 CFP (500, 600]인 다른 CFP가 표시되고 트랜잭션 범위 (200, 400]에 대한 비어 있지 않은 델타 파일은 원본 CFP에서 여러 행 삭제와 같은 트랜잭션 활동과 병합 작업을 동시에 수행할 수 있음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-202">You see another CFP with range (500, 600] and non-empty delta file for transaction range (200, 400] shows that merge operation can be done concurrently with transactional activity including deleting more rows from the source CFPs.</span></span>

 <span data-ttu-id="30d1a-203">![다이어그램에서는 메모리 최적화 테이블 파일 그룹을 보여 줍니다.](../../database-engine/media/storagediagram-hekaton.png "다이어그램에서는 메모리 최적화 테이블 파일 그룹을 보여 줍니다.")</span><span class="sxs-lookup"><span data-stu-id="30d1a-203">![Diagram shows memory optimized table file group](../../database-engine/media/storagediagram-hekaton.png "Diagram shows memory optimized table file group")</span></span>

 <span data-ttu-id="30d1a-204">백그라운드 스레드는 병합 정책에 따라 모든 닫힌 CFP를 평가한 다음 조건에 맞는 CFP에 대한 하나 이상의 병합 요청을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-204">A background thread evaluates all closed CFPs using a merge policy and then initiates one or more merge requests for the qualifying CFPs.</span></span> <span data-ttu-id="30d1a-205">이러한 병합 요청은 오프라인 검사점 스레드에서 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-205">These merge requests are processed by the offline checkpoint thread.</span></span> <span data-ttu-id="30d1a-206">병합 정책 평가는 주기적으로 수행되며 검사점을 닫을 때에도 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-206">The evaluation of merge policy is done periodically and also when a checkpoint is closed.</span></span>

### <a name="sssql14-merge-policy"></a>[!INCLUDE[ssSQL14](../../../includes/sssql14-md.md)] <span data-ttu-id="30d1a-207">병합 정책</span><span class="sxs-lookup"><span data-stu-id="30d1a-207">Merge Policy</span></span>
 [!INCLUDE[ssSQL14](../../../includes/sssql14-md.md)] <span data-ttu-id="30d1a-208">에서는 다음과 같은 병합 정책을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-208">implements the following merge policy:</span></span>

-   <span data-ttu-id="30d1a-209">두 개 이상의 연속하는 CFP를 통합할 수 있는 경우 삭제된 행을 고려한 후 이상적인 크기의 CFP 하나에 결과 행을 모두 넣을 수 있도록 병합을 예약합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-209">A merge is scheduled if 2 or more consecutive CFPs can be consolidated, after accounting for deleted rows, such that the resultant rows can fit into 1 CFP of ideal size.</span></span> <span data-ttu-id="30d1a-210">CFP의 이상적인 크기는 다음과 같이 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-210">The ideal size of CFP is determined as follows:</span></span>

    -   <span data-ttu-id="30d1a-211">컴퓨터에 16GB 이하의 메모리가 있는 경우 데이터 파일은 16MB이고 델타 파일은 1MB입니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-211">If a computer has less than or equal to 16GB of memory, the data file is 16MB and delta file is 1MB.</span></span>

    -   <span data-ttu-id="30d1a-212">컴퓨터에 16GB를 초과하는 메모리가 있는 경우 데이터 파일은 128MB이고 델타 파일은 16MB입니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-212">If a computer has greater than 16GB of memory, the data file is 128MB and delta file is 16MB.</span></span>

-   <span data-ttu-id="30d1a-213">데이터 파일이 256MB를 초과하고 행이 절반 넘게 삭제된 경우 단일 CFP가 자체적으로 병합될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-213">A single CFP can be self-merged if the data file exceeds 256 MB and more than half of the rows are deleted.</span></span> <span data-ttu-id="30d1a-214">예를 들어 단일 트랜잭션 또는 여러 동시 트랜잭션이 많은 양의 데이터를 삽입하거나 업데이트하는 경우 트랜잭션이 여러 CFP에 걸쳐 있을 수 없기 때문에 데이터 파일이 이상적인 크기를 초과하게 되면 데이터 파일이 128MB보다 커질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-214">A data file can grow larger than 128MB if, for example, a single transaction or multiple concurrent transactions inserts or updates large amount of data, forcing the data file to grow beyond its ideal size because a transaction cannot span multiple CFPs.</span></span>

 <span data-ttu-id="30d1a-215">다음은 병합 정책에 따라 병합될 CFP를 보여 주는 몇 가지 예입니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-215">Here are some examples that show the CFPs that will be merged under the merge policy:</span></span>

|<span data-ttu-id="30d1a-216">인접한 CFP 원본 파일 (채워진 비율)</span><span class="sxs-lookup"><span data-stu-id="30d1a-216">Adjacent CFPs Source Files (% full)</span></span>|<span data-ttu-id="30d1a-217">병합 선택</span><span class="sxs-lookup"><span data-stu-id="30d1a-217">Merge Selection</span></span>|
|-------------------------------------------|---------------------|
|<span data-ttu-id="30d1a-218">CFP0 (30%), CFP1 (50%), CFP2 (50%), CFP3 (90%)</span><span class="sxs-lookup"><span data-stu-id="30d1a-218">CFP0 (30%), CFP1 (50%), CFP2 (50%), CFP3 (90%)</span></span>|<span data-ttu-id="30d1a-219">(CFP0, CFP1)</span><span class="sxs-lookup"><span data-stu-id="30d1a-219">(CFP0, CFP1)</span></span><br /><br /> <span data-ttu-id="30d1a-220">CFP2는 결과 데이터 파일을 이성적인 크기의 100%를 초과하게 만들므로 선택되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-220">CFP2 is not chosen as it will make resultant data file greater than 100% of the ideal size.</span></span>|
|<span data-ttu-id="30d1a-221">CFP0 (30%), CFP1 (20%), CFP2 (50%), CFP3 (10%)</span><span class="sxs-lookup"><span data-stu-id="30d1a-221">CFP0 (30%), CFP1 (20%), CFP2 (50%), CFP3 (10%)</span></span>|<span data-ttu-id="30d1a-222">(CFP0, CFP1, CFP2)</span><span class="sxs-lookup"><span data-stu-id="30d1a-222">(CFP0, CFP1, CFP2).</span></span> <span data-ttu-id="30d1a-223">파일은 왼쪽부터 선택됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-223">Files are chosen starting from left.</span></span><br /><br /> <span data-ttu-id="30d1a-224">CTP3는 결과 데이터 파일을 이성적인 크기의 100%를 초과하게 만들므로 선택되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-224">CTP3 is not chosen as it will make resultant data file greater than 100% of the ideal size.</span></span>|
|<span data-ttu-id="30d1a-225">CFP0 (80%), CFP1 (30%), CFP2 (10%), CFP3 (40%)</span><span class="sxs-lookup"><span data-stu-id="30d1a-225">CFP0 (80%), CFP1 (30%), CFP2 (10%), CFP3 (40%)</span></span>|<span data-ttu-id="30d1a-226">(CFP1, CFP2, CFP3).</span><span class="sxs-lookup"><span data-stu-id="30d1a-226">(CFP1, CFP2, CFP3).</span></span> <span data-ttu-id="30d1a-227">파일은 왼쪽부터 선택됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-227">Files are chosen starting from left.</span></span><br /><br /> <span data-ttu-id="30d1a-228">CFP0는 CFP1과 결합할 경우 결과 데이터 파일이 이상적인 크기의 100%를 초과하게 되므로 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-228">CFP0 is skipped because if combined with CFP1, the resultant data file will be greater than 100% of the ideal size.</span></span>|

 <span data-ttu-id="30d1a-229">사용 가능한 공간이 있는 CFP 중 일부는 병합할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-229">Not all CFPs with available space qualify for merge.</span></span> <span data-ttu-id="30d1a-230">예를 들어, 두 개의 인접한 CFP가 60% 채워진 경우 해당 CFP는 병합되지 않고 각 CFP의 스토리지 중 40%는 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-230">For example, if two adjacent CFPs are 60% full, they will not qualify for merge and each of these CFPs will have 40% storage unused.</span></span> <span data-ttu-id="30d1a-231">최악의 경우 모든 CFP가 50% 채워진 경우 스토리지의 50%만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-231">In the worst case, all CFPs will be 50% full, a storage utilization of only 50%.</span></span> <span data-ttu-id="30d1a-232">CFP가 병합되지 않아 삭제된 행이 스토리지에 존재할 수 있지만 삭제된 행은 메모리 내 가비지 수집에 의해 메모리에서 이미 제거되었을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-232">While the deleted rows may exist in storage because the CFPs don't qualify for merge, the deleted rows may have already been removed from memory by in-memory garbage collection.</span></span> <span data-ttu-id="30d1a-233">스토리지 관리와 메모리는 가비지 수집에 종속되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-233">The management of storage and the memory is independent from garbage collection.</span></span> <span data-ttu-id="30d1a-234">활성 CFP가 차지하는 스토리지(일부 CFP는 업데이트되지 않음)는 메모리 내 영구 테이블 크기보다 최대 2배 더 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-234">Storage taken by active CFPs (not all CFPs are being updated) can be up to 2 times larger than the size of durable tables in memory.</span></span>

 <span data-ttu-id="30d1a-235">필요한 경우 [sp_xtp_merge_checkpoint_files &#40;transact-sql&#41;](/sql/relational-databases/system-stored-procedures/sys-sp-xtp-merge-checkpoint-files-transact-sql)를 호출 하 여 수동 병합을 명시적으로 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-235">If needed, a manual merge can be explicitly performed by calling [sys.sp_xtp_merge_checkpoint_files &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sys-sp-xtp-merge-checkpoint-files-transact-sql).</span></span>

### <a name="life-cycle-of-a-cfp"></a><span data-ttu-id="30d1a-236">CFP의 수명 주기</span><span class="sxs-lookup"><span data-stu-id="30d1a-236">Life Cycle of a CFP</span></span>
 <span data-ttu-id="30d1a-237">CPF 할당을 취소하려면 여러 상태를 전환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-237">CPFs transition through several states before they can be deallocated.</span></span> <span data-ttu-id="30d1a-238">언제든지 CFP는 PRECREATED, UNDER CONSTRUCTION, ACTIVE, MERGE TARGET, MERGED SOURCE, REQUIRED FOR BACKUP/HA, IN TRANSITION TO TOMBSTONE 및 TOMBSTONE 단계 중 하나에 속합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-238">At any given time, the CFPs are in one of the following phases: PRECREATED, UNDER CONSTRUCTION, ACTIVE, MERGE TARGET, MERGED SOURCE, REQUIRED FOR BACKUP/HA, IN TRANSITION TO TOMBSTONE, and TOMBSTONE.</span></span> <span data-ttu-id="30d1a-239">이러한 단계에 대한 자세한 내용은 [sys.dm_db_xtp_checkpoint_files&#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-checkpoint-files-transact-sql)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="30d1a-239">For a description of these phases, see [sys.dm_db_xtp_checkpoint_files &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-checkpoint-files-transact-sql).</span></span>

 <span data-ttu-id="30d1a-240">다양한 상태의 CFP가 차지하는 스토리지를 고려한 후 메모리 최적화 영구 테이블이 차지하는 전체 스토리지는 메모리 내 해당 테이블 크기의 2배보다 훨씬 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-240">After accounting for the storage taken by CFPs in various states, the overall storage taken by durable memory-optimized tables can be much larger than 2 times the size of the tables in memory.</span></span> <span data-ttu-id="30d1a-241">해당 단계를 포함 하 여 메모리 최적화 파일 그룹의 CFPs를 모두 나열 하도록 [transact-sql&#41;&#40;DM_DB_XTP_CHECKPOINT_FILES](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-checkpoint-files-transact-sql) DMV를 쿼리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-241">The DMV [sys.dm_db_xtp_checkpoint_files &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-checkpoint-files-transact-sql) can be queried to list all the CFPs in the memory-optimized filegroup, including their phase.</span></span> <span data-ttu-id="30d1a-242">MERGE SOURCE 상태의 CFP를 TOMBSTONE으로 전환하면 결국 가비지 수집에서 최대 5개의 검사점을 사용할 수 있으며, 데이터베이스가 전체 또는 대량 로그 복구 모델에 대해 구성된 경우 각 검사점 뒤에는 트랜잭션 로그 백업이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-242">Transitioning CFPs from MERGE SOURCE state to TOMBSTONE and ultimately garbage collection can take up five checkpoints, with each checkpoint followed by a transaction log backup, if the database is configured for full or bulk-logged recovery model.</span></span>

 <span data-ttu-id="30d1a-243">검사점 후에 강제 로그 백업을 수동으로 수행하여 가비지를 빠르게 수집할 수 있지만 그러면 5개의 빈 CFP(데이터 파일의 크기가 각각 128MB인 5개의 데이터/델타 파일 쌍)가 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-243">You can manually force the checkpoint followed by log backup to expedite the garbage collection but then this will add 5 empty CFPs (5 data/delta file pairs with data file of size 128MB each).</span></span> <span data-ttu-id="30d1a-244">프로덕션 시나리오에서 백업 전략의 일부로 수행되는 자동 검사점 및 로그 백업에서는 수동 작업을 수행할 필요 없이 이러한 단계에서 CFP를 완벽하게 전환합니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-244">In production scenarios, the automatic checkpoints and log backups taken as part of backup strategy will seamlessly transition CFPs through these phases without requiring any manual intervention.</span></span> <span data-ttu-id="30d1a-245">가비지 수집 프로세스의 영향으로 메모리 최적화 테이블을 포함하는 데이터베이스에 메모리 내 크기에 비해 큰 스토리지가 존재할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-245">The impact of the garbage collection process is that databases with memory-optimized tables may have a larger storage size compared to its size in memory.</span></span> <span data-ttu-id="30d1a-246">CFP가 메모리에 있는 메모리 최적화 영구 테이블 크기의 최대 4배인 경우도 드물지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="30d1a-246">It is not uncommon for CFPs to be up to four times the size of the durable memory-optimized tables in memory.</span></span>

## <a name="see-also"></a><span data-ttu-id="30d1a-247">참고 항목</span><span class="sxs-lookup"><span data-stu-id="30d1a-247">See Also</span></span>
 [<span data-ttu-id="30d1a-248">메모리 최적화 개체에 대한 스토리지 만들기 및 관리</span><span class="sxs-lookup"><span data-stu-id="30d1a-248">Creating and Managing Storage for Memory-Optimized Objects</span></span>](creating-and-managing-storage-for-memory-optimized-objects.md)


