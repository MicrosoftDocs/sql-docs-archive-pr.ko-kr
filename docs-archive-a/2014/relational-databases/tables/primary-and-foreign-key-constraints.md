---
title: 기본 및 외래 키 제약 조건 | Microsoft 문서
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: table-view-index
ms.topic: conceptual
helpviewer_keywords:
- foreign keys [SQL Server], cascading referential integrity
- FOREIGN KEY constraints
- foreign keys [SQL Server]
- foreign keys [SQL Server], about foreign key constraints
ms.assetid: 31fbcc9f-2dc5-4bf9-aa50-ed70ec7b5bcd
author: stevestein
ms.author: sstein
ms.openlocfilehash: b6e7b88de880348fabb00cb46d3028716441bc2b
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87653758"
---
# <a name="primary-and-foreign-key-constraints"></a><span data-ttu-id="20fee-102">PRIMARY KEY 및 FOREIGN KEY 제약 조건</span><span class="sxs-lookup"><span data-stu-id="20fee-102">Primary and Foreign Key Constraints</span></span>
  <span data-ttu-id="20fee-103">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 테이블에서 데이터 무결성을 강제 적용하는 데 사용할 수 있는 두 가지 유형의 제약 조건으로 기본 키와 외래 키가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-103">Primary keys and foreign keys are two types of constraints that can be used to enforce data integrity in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] tables.</span></span> <span data-ttu-id="20fee-104">이들 키는 중요한 데이터베이스 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-104">These are important database objects.</span></span>

 <span data-ttu-id="20fee-105">이 항목에는 다음과 같은 섹션이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-105">This topic contains the following sections.</span></span>

 [<span data-ttu-id="20fee-106">기본 키 제약 조건</span><span class="sxs-lookup"><span data-stu-id="20fee-106">Primary Key Constraints</span></span>](../tables/primary-and-foreign-key-constraints.md#PKeys)

 [<span data-ttu-id="20fee-107">Foreign Key Constraints</span><span class="sxs-lookup"><span data-stu-id="20fee-107">Foreign Key Constraints</span></span>](../tables/primary-and-foreign-key-constraints.md#FKeys)

 [<span data-ttu-id="20fee-108">관련 작업</span><span class="sxs-lookup"><span data-stu-id="20fee-108">Related Tasks</span></span>](../tables/primary-and-foreign-key-constraints.md#Tasks)

##  <a name="primary-key-constraints"></a><a name="PKeys"></a> <span data-ttu-id="20fee-109">기본 키 제약 조건</span><span class="sxs-lookup"><span data-stu-id="20fee-109">Primary Key Constraints</span></span>
 <span data-ttu-id="20fee-110">테이블에는 일반적으로 테이블의 각 행을 고유하게 식별하는 값을 가진 열 또는 열 조합이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-110">A table typically has a column or combination of columns that contain values that uniquely identify each row in the table.</span></span> <span data-ttu-id="20fee-111">이러한 열이나 열 조합은 테이블의 PK(기본 키)라고 하며 테이블에 엔터티 무결성을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-111">This column, or columns, is called the primary key (PK) of the table and enforces the entity integrity of the table.</span></span> <span data-ttu-id="20fee-112">기본 키 제약 조건은 데이터의 고유성을 보장하므로 자주 ID 열에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-112">Because primary key constraints guarantee unique data, they are frequently defined on an identity column.</span></span>

 <span data-ttu-id="20fee-113">테이블에 대해 기본 키 제약 조건을 지정하면 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 은 기본 키 열에 대해 고유 인덱스를 자동으로 만들어 데이터 고유성을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-113">When you specify a primary key constraint for a table, the [!INCLUDE[ssDE](../../includes/ssde-md.md)] enforces data uniqueness by automatically creating a unique index for the primary key columns.</span></span> <span data-ttu-id="20fee-114">또한 쿼리에서 기본 키가 사용되는 경우 이 인덱스를 사용하여 데이터에 빠르게 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-114">This index also permits fast access to data when the primary key is used in queries.</span></span> <span data-ttu-id="20fee-115">기본 키 제약 조건이 두 개 이상의 열에 정의되는 경우 한 열에 중복된 값이 있을 수 있지만 기본 키 제약 조건 정의에 있는 모든 열의 값 조합은 각각 고유해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-115">If a primary key constraint is defined on more than one column, values may be duplicated within one column, but each combination of values from all the columns in the primary key constraint definition must be unique.</span></span>

 <span data-ttu-id="20fee-116">다음 그림에서와 같이 **Purchasing.ProductVendor** 테이블의 **ProductID** 및 **VendorID** 열은 이 테이블에 대한 복합 기본 키 제약 조건을 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-116">As shown in the following illustration, the **ProductID** and **VendorID** columns in the **Purchasing.ProductVendor** table form a composite primary key constraint for this table.</span></span> <span data-ttu-id="20fee-117">그 결과 **ProductVendor** 테이블의 모든 열에서 **ProductID**와 **VendorID**의 조합은 고유합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-117">This makes sure that every row in the **ProductVendor** table has a unique combination of **ProductID** and **VendorID**.</span></span> <span data-ttu-id="20fee-118">따라서 중복 행을 삽입할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-118">This prevents the insertion of duplicate rows.</span></span>

 <span data-ttu-id="20fee-119">![복합 PRIMARY KEY 제약 조건](../../database-engine/media/fund04.gif "복합 PRIMARY KEY 제약 조건")</span><span class="sxs-lookup"><span data-stu-id="20fee-119">![Composite PRIMARY KEY constraint](../../database-engine/media/fund04.gif "Composite PRIMARY KEY constraint")</span></span>

-   <span data-ttu-id="20fee-120">테이블은 하나의 기본 키 제약 조건만 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-120">A table can contain only one primary key constraint.</span></span>

-   <span data-ttu-id="20fee-121">기본 키는 16개 열을 초과할 수 없으며 총 키 길이가 900바이트를 넘을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-121">A primary key cannot exceed 16 columns and a total key length of 900 bytes.</span></span>

-   <span data-ttu-id="20fee-122">기본 키 제약 조건에 의해 생성된 인덱스 수는 비클러스터형 인덱스 999개, 클러스터형 인덱스 1개인 테이블의 인덱스 수 제한을 초과할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-122">The index generated by a primary key constraint cannot cause the number of indexes on the table to exceed 999 nonclustered indexes and 1 clustered index.</span></span>

-   <span data-ttu-id="20fee-123">기본 키 제약 조건에 대해 클러스터형 또는 비클러스터형을 지정하지 않은 경우 테이블에 클러스터형 인덱스가 없으면 클러스터형이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-123">If clustered or nonclustered is not specified for a primary key constraint, clustered is used if there no clustered index on the table.</span></span>

-   <span data-ttu-id="20fee-124">기본 키 제약 조건 내에서 정의된 모든 열은 NOT NULL로 정의되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-124">All columns defined within a primary key constraint must be defined as not null.</span></span> <span data-ttu-id="20fee-125">NULL 허용 여부를 지정하지 않은 경우에는 기본 키 제약 조건에 참여하는 모든 열의 NULL 허용 여부가 NOT NULL로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-125">If nullability is not specified, all columns participating in a primary key constraint have their nullability set to not null.</span></span>

-   <span data-ttu-id="20fee-126">CLR 사용자 정의 형식 열에 기본 키를 정의하는 경우 형식 구현이 이진 순서를 지원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-126">If a primary key is defined on a CLR user-defined type column, the implementation of the type must support binary ordering.</span></span>

##  <a name="foreign-key-constraints"></a><a name="FKeys"></a> <span data-ttu-id="20fee-127">Foreign Key Constraints</span><span class="sxs-lookup"><span data-stu-id="20fee-127">Foreign Key Constraints</span></span>
 <span data-ttu-id="20fee-128">외래 키(FK)는 두 테이블의 데이터 간 연결을 설정하고 강제 적용하여 외래 키 테이블에 저장될 수 있는 데이터를 제어하는 데 사용되는 열입니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-128">A foreign key (FK) is a column or combination of columns that is used to establish and enforce a link between the data in two tables to control the data that can be stored in the foreign key table.</span></span> <span data-ttu-id="20fee-129">외래 키 참조에서는 한 테이블의 기본 키 값을 가지고 있는 열을 다른 테이블의 열이 참조할 때 두 테이블 간에 연결이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-129">In a foreign key reference, a link is created between two tables when the column or columns that hold the primary key value for one table are referenced by the column or columns in another table.</span></span> <span data-ttu-id="20fee-130">이때 두 번째 테이블에 추가되는 열이 외래 키가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-130">This column becomes a foreign key in the second table.</span></span>

 <span data-ttu-id="20fee-131">예를 들어 **Sales.SalesOrderHeader** 테이블에는 **Sales.SalesPerson** 테이블에 대한 외래 키 연결이 생성되는데 이는 판매 주문과 영업 사원 간에 논리적 관계가 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-131">For example, the **Sales.SalesOrderHeader** table has a foreign key link to the **Sales.SalesPerson** table because there is a logical relationship between sales orders and salespeople.</span></span> <span data-ttu-id="20fee-132">**SalesOrderHeader** 테이블의 **SalesPersonID** 열은 **SalesPerson** 테이블의 기본 키 열과 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-132">The **SalesPersonID** column in the **SalesOrderHeader** table matches the primary key column of the **SalesPerson** table.</span></span> <span data-ttu-id="20fee-133">**SalesOrderHeader** 테이블의 **SalesPersonID** 열은 **SalesPerson** 테이블에 대한 외래 키입니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-133">The **SalesPersonID** column in the **SalesOrderHeader** table is the foreign key to the **SalesPerson** table.</span></span> <span data-ttu-id="20fee-134">이 외래 키 관계를 만들면 **SalesPerson** 테이블에 **SalesPersonID** 값이 없을 경우 **SalesOrderHeader** 테이블에 이 값을 삽입할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-134">By creating this foreign key relationship, a value for **SalesPersonID** cannot be inserted into the **SalesOrderHeader** table if it does not already exist in the **SalesPerson** table.</span></span>

### <a name="indexes-on-foreign-key-constraints"></a><span data-ttu-id="20fee-135">FOREIGN KEY 제약 조건에 대한 인덱스</span><span class="sxs-lookup"><span data-stu-id="20fee-135">Indexes on Foreign Key Constraints</span></span>
 <span data-ttu-id="20fee-136">기본 키 제약 조건과 달리 외래 키 제약 조건을 만들어도 해당 인덱스가 자동으로 생성되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-136">Unlike primary key constraints, creating a foreign key constraint does not automatically create a corresponding index.</span></span> <span data-ttu-id="20fee-137">그러나 외래 키에 대해 인덱스를 수동으로 만들면 다음과 같은 경우 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-137">However, manually creating an index on a foreign key is often useful for the following reasons:</span></span>

-   <span data-ttu-id="20fee-138">외래 키 열은 쿼리에서 한 테이블의 외래 키 제약 조건 열을 다른 테이블의 기본 또는 고유 키 열과 연결하여 테이블의 데이터를 병합하는 조인에서 자주 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-138">Foreign key columns are frequently used in join criteria when the data from related tables is combined in queries by matching the column or columns in the foreign key constraint of one table with the primary or unique key column or columns in the other table.</span></span> <span data-ttu-id="20fee-139">[!INCLUDE[ssDE](../../includes/ssde-md.md)] 에서는 인덱스를 만들어 외래 키 테이블에 있는 관련 데이터를 빠르게 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-139">An index enables the [!INCLUDE[ssDE](../../includes/ssde-md.md)] to quickly find related data in the foreign key table.</span></span> <span data-ttu-id="20fee-140">그러나 반드시 인덱스를 만들 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-140">However, creating this index is not required.</span></span> <span data-ttu-id="20fee-141">테이블 간에 기본 키 또는 외래 키 제약 조건이 정의되지 않더라도 관련된 두 테이블의 데이터를 결합할 수 있습니다. 그러나 두 테이블 간 외래 키 관계가 설정되면 키를 기준으로 하는 쿼리에서 결합할 때 최적화될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-141">Data from two related tables can be combined even if no primary key or foreign key constraints are defined between the tables, but a foreign key relationship between two tables indicates that the two tables have been optimized to be combined in a query that uses the keys as its criteria.</span></span>

-   <span data-ttu-id="20fee-142">기본 키 제약 조건이 변경되면 연결된 테이블의 외래 키 제약 조건도 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-142">Changes to primary key constraints are checked with foreign key constraints in related tables.</span></span>

### <a name="referential-integrity"></a><span data-ttu-id="20fee-143">참조 무결성</span><span class="sxs-lookup"><span data-stu-id="20fee-143">Referential Integrity</span></span>
 <span data-ttu-id="20fee-144">외래 키 제약 조건의 기본 목적이 외래 키 테이블에 저장되는 데이터를 제어하는 것이지만 기본 키 테이블의 데이터 변경 사항도 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-144">Although the main purpose of a foreign key constraint is to control the data that can be stored in the foreign key table, it also controls changes to data in the primary key table.</span></span> <span data-ttu-id="20fee-145">예를 들어 한 영업 사원에 대한 행이 **Sales.SalesPerson** 테이블에서 삭제되었는데 이 영업 사원의 ID가 **Sales.SalesOrderHeader** 테이블의 판매 주문에 사용된 경우 두 테이블 간의 관계 무결성이 손상됩니다. **SalesPerson** 테이블의 데이터에 대한 연결이 끊어졌으므로 삭제된 영업 사원의 판매 주문은 **SalesOrderHeader** 테이블에서 고아 항목이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-145">For example, if the row for a salesperson is deleted from the **Sales.SalesPerson** table, and the salesperson's ID is used for sales orders in the **Sales.SalesOrderHeader** table, the relational integrity between the two tables is broken; the deleted salesperson's sales orders are orphaned in the **SalesOrderHeader** table without a link to the data in the **SalesPerson** table.</span></span>

 <span data-ttu-id="20fee-146">외래 키 제약 조건은 이런 상황이 발생되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-146">A foreign key constraint prevents this situation.</span></span> <span data-ttu-id="20fee-147">이 제약 조건은 기본 키 테이블의 데이터를 변경할 때 외래 키 테이블에 있는 데이터로의 연결이 무효화될 가능성이 있으면 그 데이터를 변경하지 못하도록 하여 참조 무결성을 강제 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-147">The constraint enforces referential integrity by guaranteeing that changes cannot be made to data in the primary key table if those changes invalidate the link to data in the foreign key table.</span></span> <span data-ttu-id="20fee-148">삭제되거나 변경되는 기본 키 값이 다른 테이블의 외래 키 제약 조건 값과 연결되어 있으면 기본 키 테이블의 행을 삭제하거나 기본 키 값을 변경하려는 동작이 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-148">If an attempt is made to delete the row in a primary key table or to change a primary key value, the action will fail when the deleted or changed primary key value corresponds to a value in the foreign key constraint of another table.</span></span> <span data-ttu-id="20fee-149">외래 키 제약 조건의 행을 제대로 변경하거나 삭제하려면 먼저 외래 키 테이블에 있는 외래 키 데이터를 삭제하거나 변경하여 외래 키를 다른 기본 키 데이터에 연결해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-149">To successfully change or delete a row in a foreign key constraint, you must first either delete the foreign key data in the foreign key table or change the foreign key data in the foreign key table, which links the foreign key to different primary key data.</span></span>

#### <a name="cascading-referential-integrity"></a><span data-ttu-id="20fee-150">연계 참조 무결성</span><span class="sxs-lookup"><span data-stu-id="20fee-150">Cascading Referential Integrity</span></span>
 <span data-ttu-id="20fee-151">연계 참조 무결성 제약 조건을 사용하면 기존 외래 키가 가리키는 키를 사용자가 삭제 또는 업데이트하려 할 때 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 에서 수행할 동작을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-151">By using cascading referential integrity constraints, you can define the actions that the [!INCLUDE[ssDE](../../includes/ssde-md.md)] takes when a user tries to delete or update a key to which existing foreign keys point.</span></span> <span data-ttu-id="20fee-152">다음과 같은 연계 동작을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-152">The following cascading actions can be defined.</span></span>

 <span data-ttu-id="20fee-153">NO ACTION은 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 오류를 발생 시키고 부모 테이블의 행에 대 한 삭제 또는 업데이트 작업을 롤백합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-153">NO ACTION The [!INCLUDE[ssDE](../../includes/ssde-md.md)] raises an error and the delete or update action on the row in the parent table is rolled back.</span></span>

 <span data-ttu-id="20fee-154">부모 테이블에서 해당 행이 업데이트 되거나 삭제 되 면 참조 테이블에서 CASCADE 해당 행이 업데이트 되거나 삭제 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-154">CASCADE Corresponding rows are updated or deleted in the referencing table when that row is updated or deleted in the parent table.</span></span> <span data-ttu-id="20fee-155">`timestamp` 열이 외래 키 또는 참조되는 키의 일부인 경우에는 CASCADE를 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-155">CASCADE cannot be specified if a `timestamp` column is part of either the foreign key or the referenced key.</span></span> <span data-ttu-id="20fee-156">INSTEAD OF DELETE 트리거가 있는 테이블에는 ON DELETE CASCADE를 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-156">ON DELETE CASCADE cannot be specified for a table that has an INSTEAD OF DELETE trigger.</span></span> <span data-ttu-id="20fee-157">INSTEAD OF UPDATE 트리거가 있는 테이블에 대해서는 ON UPDATE CASCADE를 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-157">ON UPDATE CASCADE cannot be specified for tables that have INSTEAD OF UPDATE triggers.</span></span>

 <span data-ttu-id="20fee-158">NULL 설정 부모 테이블의 해당 행이 업데이트 되거나 삭제 될 때 외래 키를 구성 하는 모든 값이 NULL로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-158">SET NULL All the values that make up the foreign key are set to NULL when the corresponding row in the parent table is updated or deleted.</span></span> <span data-ttu-id="20fee-159">이 제약 조건을 실행하려면 외래 키 열이 Null을 허용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-159">For this constraint to execute, the foreign key columns must be nullable.</span></span> <span data-ttu-id="20fee-160">INSTEAD OF UPDATE 트리거가 있는 테이블에 대해서는 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-160">Cannot be specified for tables that have INSTEAD OF UPDATE triggers.</span></span>

 <span data-ttu-id="20fee-161">기본 설정 부모 테이블의 해당 행을 업데이트 하거나 삭제 하는 경우 외래 키를 구성 하는 모든 값이 기본값으로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-161">SET DEFAULT All the values that make up the foreign key are set to their default values if the corresponding row in the parent table is updated or deleted.</span></span> <span data-ttu-id="20fee-162">이 제약 조건을 실행하려면 모든 외래 키 열에 기본 정의가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-162">For this constraint to execute, all foreign key columns must have default definitions.</span></span> <span data-ttu-id="20fee-163">열이 Null을 허용하고 명시적 기본값이 설정되어 있지 않은 경우 NULL은 해당 열의 암시적 기본값이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-163">If a column is nullable, and there is no explicit default value set, NULL becomes the implicit default value of the column.</span></span> <span data-ttu-id="20fee-164">INSTEAD OF UPDATE 트리거가 있는 테이블에 대해서는 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-164">Cannot be specified for tables that have INSTEAD OF UPDATE triggers.</span></span>

 <span data-ttu-id="20fee-165">CASCADE, SET NULL, SET DEFAULT 및 NO ACTION은 서로 참조 관계를 가진 테이블에서 결합될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-165">CASCADE, SET NULL, SET DEFAULT and NO ACTION can be combined on tables that have referential relationships with each other.</span></span> <span data-ttu-id="20fee-166">[!INCLUDE[ssDE](../../includes/ssde-md.md)] 이 NO ACTION을 발견하면 관련된 CASCADE, SET NULL 및 SET DEFAULT 동작을 멈추고 롤백합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-166">If the [!INCLUDE[ssDE](../../includes/ssde-md.md)] encounters NO ACTION, it stops and rolls back related CASCADE, SET NULL and SET DEFAULT actions.</span></span> <span data-ttu-id="20fee-167">DELETE 문으로 CASCADE, SET NULL, SET DEFAULT 및 NO ACTION 동작을 결합하면 [!INCLUDE[ssDE](../../includes/ssde-md.md)] 이 NO ACTION을 확인하기 전에 모든 CASCADE, SET NULL 및 SET DEFAULT 동작을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-167">When a DELETE statement causes a combination of CASCADE, SET NULL, SET DEFAULT and NO ACTION actions, all the CASCADE, SET NULL and SET DEFAULT actions are applied before the [!INCLUDE[ssDE](../../includes/ssde-md.md)] checks for any NO ACTION.</span></span>

### <a name="triggers-and-cascading-referential-actions"></a><span data-ttu-id="20fee-168">트리거 및 연계 참조 동작</span><span class="sxs-lookup"><span data-stu-id="20fee-168">Triggers and Cascading Referential Actions</span></span>
 <span data-ttu-id="20fee-169">연계 참조 동작은 다음과 같은 방식으로 AFTER UPDATE 또는 AFTER DELETE 트리거를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-169">Cascading referential actions fire the AFTER UPDATE or AFTER DELETE triggers in the following manner:</span></span>

-   <span data-ttu-id="20fee-170">원래 DELETE 또는 UPDATE 문에 의해 직접적으로 시작된 모든 연계 참조 동작이 먼저 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-170">All the cascading referential actions directly caused by the original DELETE or UPDATE are performed first.</span></span>

-   <span data-ttu-id="20fee-171">영향을 받는 테이블에 AFTER 트리거가 정의되어 있는 경우 해당 트리거는 모든 연계 동작이 수행된 후에 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-171">If there are any AFTER triggers defined on the affected tables, these triggers fire after all cascading actions are performed.</span></span> <span data-ttu-id="20fee-172">이 트리거는 연계 동작 순서와 반대로 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-172">These triggers fire in opposite order of the cascading action.</span></span> <span data-ttu-id="20fee-173">단일 테이블에 여러 트리거가 있는 경우 이 테이블에 첫 번째 또는 마지막으로 지정된 트리거가 없다면 임의의 순서로 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-173">If there are multiple triggers on a single table, they fire in random order, unless there is a dedicated first or last trigger for the table.</span></span> <span data-ttu-id="20fee-174">이 시작 순서는 [sp_settriggerorder](/sql/relational-databases/system-stored-procedures/sp-settriggerorder-transact-sql)를 사용하여 지정한 대로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-174">This order is as specified by using [sp_settriggerorder](/sql/relational-databases/system-stored-procedures/sp-settriggerorder-transact-sql).</span></span>

-   <span data-ttu-id="20fee-175">UPDATE 또는 DELETE 동작의 직접적인 대상인 테이블로부터 여러 연계 체인이 시작되는 경우 이 체인이 각 트리거를 시작하는 순서는 지정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-175">If multiple cascading chains originate from the table that was the direct target of an UPDATE or DELETE action, the order in which these chains fire their respective triggers is unspecified.</span></span> <span data-ttu-id="20fee-176">그러나 항상 한 체인이 해당 트리거를 모두 시작한 후에 다른 체인이 해당 트리거를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-176">However, one chain always fires all its triggers before another chain starts firing.</span></span>

-   <span data-ttu-id="20fee-177">UPDATE 또는 DELETE 동작의 직접적인 대상인 테이블에 대한 AFTER 트리거는 영향을 받는 행이 있는지 여부에 관계 없이 항상 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-177">An AFTER trigger on the table that is the direct target of an UPDATE or DELETE action fires regardless of whether any rows are affected.</span></span> <span data-ttu-id="20fee-178">이 경우 다른 테이블은 연계 작업에 영향을 받지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-178">There are no other tables affected by cascading in this case.</span></span>

-   <span data-ttu-id="20fee-179">이전 트리거 중 하나가 다른 테이블에 대해 UPDATE 또는 DELETE 작업을 수행하는 경우 이 동작에 의해 보조 연계 체인이 시작될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-179">If any one of the previous triggers perform UPDATE or DELETE operations on other tables, these actions can start secondary cascading chains.</span></span> <span data-ttu-id="20fee-180">이러한 보조 체인은 기본 체인의 모든 트리거가 시작된 후에 각 UPDATE 또는 DELETE 작업에서 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-180">These secondary chains are processed for each UPDATE or DELETE operation at a time after all triggers on all primary chains fire.</span></span> <span data-ttu-id="20fee-181">이러한 과정은 나중에 수행되는 UPDATE 또는 DELETE 작업에서 재귀적으로 반복될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-181">This process may be recursively repeated for subsequent UPDATE or DELETE operations.</span></span>

-   <span data-ttu-id="20fee-182">트리거 내에서 CREATE, ALTER, DELETE 또는 기타 DDL(데이터 정의 언어) 작업이 수행되면 DDL 트리거가 시작될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-182">Performing CREATE, ALTER, DELETE, or other data definition language (DDL) operations inside the triggers may cause DDL triggers to fire.</span></span> <span data-ttu-id="20fee-183">그리고 추가 연계 체인과 트리거를 시작하는 DELETE 또는 UPDATE 작업이 뒤이어 수행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-183">This may subsequently perform DELETE or UPDATE operations that start additional cascading chains and triggers.</span></span>

-   <span data-ttu-id="20fee-184">특정 연계 참조 동작 체인 내에서 오류가 생성되면 오류가 발생하고 해당 체인에서 AFTER 트리거가 시작되지 않으며 체인을 만든 DELETE 또는 UPDATE 작업이 롤백됩니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-184">If an error is generated inside any particular cascading referential action chain, an error is raised, no AFTER triggers are fired in that chain, and the DELETE or UPDATE operation that created the chain is rolled back.</span></span>

-   <span data-ttu-id="20fee-185">INSTEAD OF 트리거가 있는 테이블은 연계 동작을 지정하는 REFERENCES 절도 가질 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-185">A table that has an INSTEAD OF trigger cannot also have a REFERENCES clause that specifies a cascading action.</span></span> <span data-ttu-id="20fee-186">그러나 연계 동작의 대상이 되는 테이블의 AFTER 트리거는 다른 테이블 또는 그 개체에 정의된 INSTEAD OF 트리거를 시작하는 뷰에서 INSERT, UPDATE 또는 DELETE 문을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-186">However, an AFTER trigger on a table targeted by a cascading action can execute an INSERT, UPDATE, or DELETE statement on another table or view that fires an INSTEAD OF trigger defined on that object.</span></span>

##  <a name="related-tasks"></a><a name="Tasks"></a> <span data-ttu-id="20fee-187">관련 작업</span><span class="sxs-lookup"><span data-stu-id="20fee-187">Related Tasks</span></span>
 <span data-ttu-id="20fee-188">다음 표에서는 기본 키 및 외래 키 제약 조건과 연관된 일반 태스크를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-188">The following table lists the common tasks associated with primary key and foreign key constraints.</span></span>

|<span data-ttu-id="20fee-189">Task</span><span class="sxs-lookup"><span data-stu-id="20fee-189">Task</span></span>|<span data-ttu-id="20fee-190">항목</span><span class="sxs-lookup"><span data-stu-id="20fee-190">Topic</span></span>|
|----------|-----------|
|<span data-ttu-id="20fee-191">기본 키를 만드는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-191">Describes how to create a primary key.</span></span>|[<span data-ttu-id="20fee-192">기본 키 만들기</span><span class="sxs-lookup"><span data-stu-id="20fee-192">Create Primary Keys</span></span>](../tables/create-primary-keys.md)|
|<span data-ttu-id="20fee-193">기본 키를 삭제하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-193">Describes how to delete a primary key.</span></span>|[<span data-ttu-id="20fee-194">기본 키 삭제</span><span class="sxs-lookup"><span data-stu-id="20fee-194">Delete Primary Keys</span></span>](../tables/delete-primary-keys.md)|
|<span data-ttu-id="20fee-195">기본 키를 수정하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-195">Describes how to modify a primary key.</span></span>|[<span data-ttu-id="20fee-196">기본 키 수정</span><span class="sxs-lookup"><span data-stu-id="20fee-196">Modify Primary Keys</span></span>](../tables/modify-primary-keys.md)|
|<span data-ttu-id="20fee-197">외래 키 관계를 만드는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-197">Describes how to create foreign key relationships</span></span>|[<span data-ttu-id="20fee-198">외래 키 관계 만들기</span><span class="sxs-lookup"><span data-stu-id="20fee-198">Create Foreign Key Relationships</span></span>](../tables/create-foreign-key-relationships.md)|
|<span data-ttu-id="20fee-199">외래 키 관계를 수정하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-199">Describes how to modify foreign key relationships.</span></span>|[<span data-ttu-id="20fee-200">외래 키 관계 수정</span><span class="sxs-lookup"><span data-stu-id="20fee-200">Modify Foreign Key Relationships</span></span>](../tables/modify-foreign-key-relationships.md)|
|<span data-ttu-id="20fee-201">외래 키 관계를 삭제하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-201">Describes how to delete foreign key relationships.</span></span>|[<span data-ttu-id="20fee-202">외래 키 관계 삭제</span><span class="sxs-lookup"><span data-stu-id="20fee-202">Delete Foreign Key Relationships</span></span>](../tables/delete-foreign-key-relationships.md)|
|<span data-ttu-id="20fee-203">외래 키 속성을 보는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-203">Describes how to view foreign key properties.</span></span>|[<span data-ttu-id="20fee-204">외래 키 속성 보기</span><span class="sxs-lookup"><span data-stu-id="20fee-204">View Foreign Key Properties</span></span>](../tables/view-foreign-key-properties.md)|
|<span data-ttu-id="20fee-205">복제에 대한 외래 키 제약 조건을 사용하지 않도록 설정하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-205">Describes how to disable foreign key constraints for replication.</span></span>|[<span data-ttu-id="20fee-206">복제할 때 FOREIGN KEY 제약 조건 비활성화</span><span class="sxs-lookup"><span data-stu-id="20fee-206">Disable Foreign Key Constraints for Replication</span></span>](../tables/disable-foreign-key-constraints-for-replication.md)|
|<span data-ttu-id="20fee-207">INSERT 또는 UPDATE 문 중에 외래 키 제약 조건을 사용하지 않도록 설정하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="20fee-207">Describes how to disable foreign key constraints during an INSERT or UPDATE statement.</span></span>|[<span data-ttu-id="20fee-208">INSERT 및 UPDATE 문에서 FOREIGN KEY 제약 조건 사용 안 함</span><span class="sxs-lookup"><span data-stu-id="20fee-208">Disable Foreign Key Constraints with INSERT and UPDATE Statements</span></span>](../tables/disable-foreign-key-constraints-with-insert-and-update-statements.md)|


