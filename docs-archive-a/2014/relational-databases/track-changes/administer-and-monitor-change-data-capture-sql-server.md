---
title: 변경 데이터 캡처 관리 및 모니터링(SQL Server) | Microsoft 문서
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
helpviewer_keywords:
- change data capture [SQL Server], monitoring
- change data capture [SQL Server], administering
- change data capture [SQL Server], jobs
ms.assetid: 23bda497-67b2-4e7b-8e4d-f1f9a2236685
author: rothja
ms.author: jroth
ms.openlocfilehash: 8d97929ead145d1b0de1a1f83becb15ade397683
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87652684"
---
# <a name="administer-and-monitor-change-data-capture-sql-server"></a><span data-ttu-id="9b859-102">변경 데이터 캡처 관리 및 모니터링(SQL Server)</span><span class="sxs-lookup"><span data-stu-id="9b859-102">Administer and Monitor Change Data Capture (SQL Server)</span></span>
  <span data-ttu-id="9b859-103">이 항목에서는 변경 데이터 캡처를 관리 및 모니터링하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-103">This topic describes how to administer and monitor change data capture.</span></span>  
  
##  <a name="capture-job"></a><a name="Capture"></a> <span data-ttu-id="9b859-104">캡처 작업</span><span class="sxs-lookup"><span data-stu-id="9b859-104">Capture Job</span></span>  
 <span data-ttu-id="9b859-105">캡처 작업은 매개 변수가 없는 저장 프로시저인 `sp_MScdc_capture_job`을 실행하여 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-105">The capture job is initiated by running the parameterless stored procedure `sp_MScdc_capture_job`.</span></span> <span data-ttu-id="9b859-106">이 저장 프로시저는 먼저 msdb.dbo.cdc_jobs의 캡처 작업을 위해 *maxtrans*, *maxscans*, *continuous*및 *pollinginterval* 의 구성 값을 추출합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-106">This stored procedure starts by extracting the configured values for *maxtrans*, *maxscans*, *continuous*, and *pollinginterval* for the capture job from msdb.dbo.cdc_jobs.</span></span> <span data-ttu-id="9b859-107">그런 다음 이러한 구성 값은 `sp_cdc_scan` 저장 프로시저에 매개 변수로 전달되고</span><span class="sxs-lookup"><span data-stu-id="9b859-107">These configured values are then passed as parameters to the stored procedure `sp_cdc_scan`.</span></span> <span data-ttu-id="9b859-108">로그 검색을 수행하기 위해 `sp_replcmds`를 호출하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-108">This is used to invoke `sp_replcmds` to perform the log scan.</span></span>  
  
### <a name="capture-job-parameters"></a><span data-ttu-id="9b859-109">캡처 작업 매개 변수</span><span class="sxs-lookup"><span data-stu-id="9b859-109">Capture Job Parameters</span></span>  
 <span data-ttu-id="9b859-110">캡처 작업의 동작을 이해하려면 구성 가능한 매개 변수가 `sp_cdc_scan`에서 어떻게 사용되는지 알아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-110">To understand capture job behavior, you must understand how the configurable parameters are used by `sp_cdc_scan`.</span></span>  
  
#### <a name="maxtrans-parameter"></a><span data-ttu-id="9b859-111">maxtrans 매개 변수</span><span class="sxs-lookup"><span data-stu-id="9b859-111">maxtrans Parameter</span></span>  
 <span data-ttu-id="9b859-112">*maxtrans* 매개 변수는 단일 로그 검색 주기에서 처리할 수 있는 트랜잭션의 최대 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-112">The *maxtrans* parameter specifies the maximum number of transactions that can be processed in a single scan cycle of the log.</span></span> <span data-ttu-id="9b859-113">검색 중에 처리할 트랜잭션 수가 이 한도에 도달하면 현재 검색에 추가 트랜잭션이 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-113">If, during the scan, the number of transactions to be processed reaches this limit, no additional transactions are included in the current scan.</span></span> <span data-ttu-id="9b859-114">검색 주기가 완료된 후에는 처리된 트랜잭션의 수가 항상 *maxtrans*보다 작거나 같습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-114">After a scan cycle is complete, the number of transactions that were processed will always be less than or equal to *maxtrans*.</span></span>  
  
#### <a name="maxscans-parameter"></a><span data-ttu-id="9b859-115">maxscans 매개 변수</span><span class="sxs-lookup"><span data-stu-id="9b859-115">maxscans Parameter</span></span>  
 <span data-ttu-id="9b859-116">*maxscans* 매개 변수는 반환(continuous = 0) 또는 waitfor 실행(continuous = 1) 전에 로그를 비우기 위해 시도되는 검색 주기의 최대 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-116">The *maxscans* parameter specifies the maximum number of scan cycles that are attempted to drain the log before either returning (continuous = 0) or executing a waitfor (continuous = 1).</span></span>  
  
#### <a name="continuous-parameter"></a><span data-ttu-id="9b859-117">continuous 매개 변수</span><span class="sxs-lookup"><span data-stu-id="9b859-117">continuous Parameter</span></span>  
 <span data-ttu-id="9b859-118">*연속* 매개 변수는 `sp_cdc_scan` 로그를 드레이닝 하거나 최대 검색 주기 수 (하나의 샷 모드)를 실행 한 후에의 내어 줍니다 제어 하는지 여부를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-118">The *continuous* parameter controls whether `sp_cdc_scan` relinquishes control in after either draining the log or executing the maximum number of scan cycles (one shot mode).</span></span> <span data-ttu-id="9b859-119">또한 명시적으로 중지될 때까지 `sp_cdc_scan`을 계속 실행할지도 지정합니다(연속 모드).</span><span class="sxs-lookup"><span data-stu-id="9b859-119">It also controles whether `sp_cdc_scan` continues to run until explicitly stopped (continuous mode).</span></span>  
  
##### <a name="one-shot-mode"></a><span data-ttu-id="9b859-120">단발 모드</span><span class="sxs-lookup"><span data-stu-id="9b859-120">One Shot Mode</span></span>  
 <span data-ttu-id="9b859-121">단일 샷 모드에서 캡처 작업은 `sp_cdc_scan` *maxtrans* 검색을 수행 하 여 로그를 비우고 반환 하도록 요청 합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-121">In one shot mode, the capture job requests `sp_cdc_scan` to perform up to *maxtrans* scans to try to drain the log and return.</span></span> <span data-ttu-id="9b859-122">로그에 있는 *maxtrans* 와 모든 트랜잭션은 이후 검색에서 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-122">Any transactions in addition to *maxtrans* that are present in the log will be processed in later scans.</span></span>  
  
 <span data-ttu-id="9b859-123">단발 모드는 처리할 트랜잭션 양이 알려져 있고 작업이 종료된 후 자동으로 닫히면 이점을 얻을 수 있는 제어된 테스트 환경에서 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-123">One shot mode is used in controlled tests, where the volume of transactions to be processed is known, and there are advantages to the fact that the job closes automatically on when it is finished.</span></span> <span data-ttu-id="9b859-124">프로덕션 환경에서는 단발 모드를 사용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-124">One shot mode is not recommended for production use.</span></span> <span data-ttu-id="9b859-125">프로덕션 환경은 검색 주기의 실행 빈도를 관리하는 작업 일정에 의존하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-125">This is because t relies on the job schedule to manage how frequently the scan cycle is run.</span></span>  
  
 <span data-ttu-id="9b859-126">단발 모드로 실행될 때는 다음과 같은 공식을 사용하여 초당 트랜잭션의 단위로 캡처 작업의 예상 처리량에 대한 상한 값을 계산할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-126">When running in one shot mode, you can compute an upper bound on expected throughput of the capture job, expressed in transactions per second by using the following computation:</span></span>  
  
 `(maxtrans * maxscans) / number of seconds between scans`  
  
 <span data-ttu-id="9b859-127">로그 검색 및 변경 테이블 채우기를 위해 필요한 시간이 0과 크게 차이 나지 않더라도 평균 작업 처리량은 단일 검색에 대해 허용되는 최대 트랜잭션 수와 최대 허용 검색 수를 곱한 값을 로그 처리 분할 시간(초)으로 나눈 값을 초과할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-127">Even if the time that is required to scan the log and populate the change tables were not significantly different from 0, the average throughput of the job could not exceed the value obtained by dividing the maximum allowed transactions for a single scan multiplied by the maximum allowed scans by the number of seconds separating log processing.</span></span>  
  
 <span data-ttu-id="9b859-128">로그 검색을 제어하는 데 단발 모드를 사용하는 경우에는 로그 처리 간격(초)이 작업 일정에 의해 제어됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-128">If one shot mode were to be used to regulate log scanning, the number of seconds between log processing would have to be governed by the job schedule.</span></span> <span data-ttu-id="9b859-129">이러한 유형의 동작이 필요한 경우 캡처 작업을 연속 모드에서 실행하여 로그 검색의 일정 조정을 관리하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-129">When this kind of behavior is desired, running the capture job in continuous mode is a better way to manage rescheduling the log scan.</span></span>  
  
##### <a name="continuous-mode-and-the-polling-interval"></a><span data-ttu-id="9b859-130">연속 모드 및 폴링 간격</span><span class="sxs-lookup"><span data-stu-id="9b859-130">Continuous Mode and the Polling Interval</span></span>  
 <span data-ttu-id="9b859-131">연속 모드에서 캡처 작업은 `sp_cdc_scan`이 연속으로 실행되도록 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-131">In continuous mode, the capture job requests that `sp_cdc_scan` run continuously.</span></span> <span data-ttu-id="9b859-132">이렇게 하면 저장 프로시저에서 maxtrans 및 maxscans뿐만 아니라 로그 처리 간격(초)(폴링 간격)에 대한 값을 제공함으로써 고유한 대기 루프를 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-132">This lets the stored procedure manage its own wait loop by providing not only for maxtrans and maxscans but also a value for the number of seconds between log processing (the polling interval).</span></span> <span data-ttu-id="9b859-133">이 모드에서 실행될 때 캡처 작업은 활성 상태로 유지되고 로그 검색 사이에 `WAITFOR`를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-133">Running in this mode, the capture job remains active, executing a `WAITFOR` between log scanning.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9b859-134">폴링 간격 값이 0보다 큰 경우 연속 모드에서 실행되는 작업에도 되풀이되는 단발 작업의 처리량과 동일한 상한 값이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-134">When the value of the polling interval is greater than 0, the same upper limit on throughput for the recurring one shot job also applies to the job operation in continuous mode.</span></span> <span data-ttu-id="9b859-135">따라서 (*maxtrans* \* *maxscans*)를 0이 아닌 폴링 간격으로 나누면 캡처 작업에서 처리할 수 있는 트랜잭션의 평균 수에 대한 상한 값이 나옵니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-135">That is, (*maxtrans* \* *maxscans*) divided by a nonzero polling interval will put an upper bound on the average number of transactions that can be processed by the capture job.</span></span>  
  
### <a name="capture-job-customization"></a><span data-ttu-id="9b859-136">캡처 작업 사용자 지정</span><span class="sxs-lookup"><span data-stu-id="9b859-136">Capture Job Customization</span></span>  
 <span data-ttu-id="9b859-137">캡처 작업에서 새 검색을 즉시 시작할지, 아니면 고정된 폴링 간격을 사용하지 않고 새 검색을 시작하기 전에 대기 시간을 사용할지를 결정하는 추가 논리를 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-137">For the capture job, you can apply additional logic to determine whether a new scan begins immediately or whether a sleep is imposed before it starts a new scan instead of rely on a fixed polling interval.</span></span> <span data-ttu-id="9b859-138">이러한 옵션을 사용하면 단순히 하루 일과를 기준으로 업무량이 많을 때는 대기 시간을 매우 길게 적용하고, 주간 업무를 완료하고 야간 업무를 준비해야 하는 마감 시간에는 폴링 간격을 0으로 설정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-138">The choice could be based merely on time of the day, perhaps enforcing very long sleeps during peak activity times, and even moving to a polling interval of 0 at close of day when it is important to complete the days processing and prepare for nightly runs.</span></span> <span data-ttu-id="9b859-139">캡처 프로세스 진행 상황을 모니터링하여 자정에 커밋된 모든 트랜잭션이 검색되고 변경 테이블에 보관된 시간을 확인할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-139">Capture process progress could also be monitored to determine when all transactions committed by mid-night had been scanned and deposited in change tables.</span></span> <span data-ttu-id="9b859-140">이렇게 하면 캡처 작업이 종료된 후 예약된 일일 재시작 시간에 다시 시작되도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-140">This lets the capture job end, to be restarted by a scheduled daily restart.</span></span> <span data-ttu-id="9b859-141">`sp_cdc_scan`을 호출하는 배달된 작업 단계를 사용자가 작성한 `sp_cdc_scan`용 래퍼 호출로 바꾸면 최소한의 노력으로도 고도로 사용자 지정된 동작을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-141">By replacing the delivered job step calling `sp_cdc_scan` with a call to a user written wrapper for `sp_cdc_scan`, highly customized behavior can be obtained with little additional effort.</span></span>  
  
##  <a name="cleanup-job"></a><a name="Cleanup"></a> <span data-ttu-id="9b859-142">정리 작업</span><span class="sxs-lookup"><span data-stu-id="9b859-142">Cleanup Job</span></span>  
 <span data-ttu-id="9b859-143">이 섹션에서는 변경 데이터 캡처 정리 작업의 작동 방식에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-143">This section provides information about how the change data capture cleanup job works.</span></span>  
  
### <a name="structure-of-the-cleanup-job"></a><span data-ttu-id="9b859-144">정리 작업의 구조</span><span class="sxs-lookup"><span data-stu-id="9b859-144">Structure of the Cleanup Job</span></span>  
 <span data-ttu-id="9b859-145">변경 데이터 캡처는 보존 기반 정리 전략을 사용하여 변경 테이블 크기를 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-145">Change data capture uses a retention based cleanup strategy to manage change table size.</span></span> <span data-ttu-id="9b859-146">정리 메커니즘은 첫 번째 데이터베이스 테이블이 설정될 때 생성되는 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 에이전트 [!INCLUDE[tsql](../../includes/tsql-md.md)] 작업으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-146">The cleanup mechanism consists of a [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Agent [!INCLUDE[tsql](../../includes/tsql-md.md)] job that is created when the first database table is enabled.</span></span> <span data-ttu-id="9b859-147">단일 정리 작업은 모든 데이터베이스 변경 테이블의 정리를 처리하며 정의된 모든 캡처 인스턴스에 대해 동일한 보존 값을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-147">A single cleanup job handles cleanup for all database change tables and applies the same retention value to all defined capture instances.</span></span>  
  
 <span data-ttu-id="9b859-148">정리 작업은 매개 변수가 없는 저장 프로시저인 `sp_MScdc_cleanup_job`을 실행하여 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-148">The cleanup job is initiated by running the parameterless stored procedure `sp_MScdc_cleanup_job`.</span></span> <span data-ttu-id="9b859-149">이 저장 프로시저는 먼저 `msdb.dbo.cdc_jobs`에서 정리 작업에 대해 구성된 보존 값 및 임계값을 추출합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-149">This stored procedure starts by extracting the configured retention and threshold values for the cleanup job from `msdb.dbo.cdc_jobs`.</span></span> <span data-ttu-id="9b859-150">보존 값은 변경 테이블의 새로운 하위 워터마크를 컴퓨팅하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-150">The retention value is used to compute a new low watermark for the change tables.</span></span> <span data-ttu-id="9b859-151">지정 된 시간 (분)을 테이블의 최대 *tran_end_time* 값에서 빼서 `cdc.lsn_time_mapping` datetime 값으로 표현 된 새 하위 워터 마크를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-151">The specified number of minutes is subtracted from the maximum *tran_end_time* value from the `cdc.lsn_time_mapping` table to obtain the new low water mark expressed as a datetime value.</span></span> <span data-ttu-id="9b859-152">그런 다음 CDC.lsn_time_mapping 테이블을 사용하여 이 datetime 값을 해당 `lsn` 값으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-152">The CDC.lsn_time_mapping table is then used to convert this datetime value to a corresponding `lsn` value.</span></span> <span data-ttu-id="9b859-153">테이블의 여러 항목에서 동일한 커밋 시간을 공유하는 경우에는 최소 `lsn`이 있는 항목에 해당하는 `lsn`을 새로운 하위 워터마크로 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-153">If the same commit time is shared by multiple entries in the table, the `lsn` that corresponds to the entry that has the smallest `lsn` is chosen as the new low watermark.</span></span> <span data-ttu-id="9b859-154">이 `lsn` 값을 `sp_cdc_cleanup_change_tables`로 전달하여 데이터베이스 변경 테이블에서 변경 테이블 항목을 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-154">This `lsn` value is passed to `sp_cdc_cleanup_change_tables` to remove change table entries from the database change tables.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9b859-155">최근 트랜잭션의 커밋 시간을 기반으로 새로운 하위 워터마크를 계산하는 방법은 지정된 시간 동안 변경 테이블에 변경 내용을 보관할 수 있는 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-155">The advantage of using the commit time of the recent transaction as the base for computing the new low watermark is that it lets the changes remain in change tables for the specified time.</span></span> <span data-ttu-id="9b859-156">이는 캡처 프로세스가 실행 중인 경우에도 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-156">This happens even when the capture process is running behind.</span></span> <span data-ttu-id="9b859-157">실제 하위 워터마크와 커밋 시간을 공유하는 최소 `lsn`을 선택하면 현재 하위 워터마크와 커밋 시간이 동일한 모든 항목이 변경 테이블 내에 계속 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-157">All entries that have the same commit time as the current low watermark continue to be represented within the change tables by choosing the smallest `lsn` that has the shared commit time for the actual low watermark.</span></span>  
  
 <span data-ttu-id="9b859-158">정리 작업을 수행하면 모든 캡처 인스턴스의 하위 워터마크가 단일 트랜잭션 내에서 처음으로 업데이트됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-158">When a cleanup is performed, the low watermark for all capture instances is initially updated in a single transaction.</span></span> <span data-ttu-id="9b859-159">그런 다음 변경 테이블과 cdc.lsn_time_mapping 테이블에서 오래된 항목을 제거하려고 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-159">It then tries to remove obsolete entries from the change tables and the cdc.lsn_time_mapping table.</span></span> <span data-ttu-id="9b859-160">구성 가능한 임계값은 모든 단일 문에서 삭제할 수 있는 항목의 개수를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-160">The configurable threshold value limits how many entries are deleted in any single statement.</span></span> <span data-ttu-id="9b859-161">모든 개별 테이블에서 삭제 작업을 수행하지 못한 경우에도 남은 테이블에서 작업을 계속 시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-161">Failure to perform the delete on any individual table will not prevent the operation from being attempted on the remaining tables.</span></span>  
  
### <a name="cleanup-job-customization"></a><span data-ttu-id="9b859-162">정리 작업 사용자 지정</span><span class="sxs-lookup"><span data-stu-id="9b859-162">Cleanup Job Customization</span></span>  
 <span data-ttu-id="9b859-163">정리 작업에서 삭제할 변경 테이블 항목을 결정하는 데 사용되는 전략을 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-163">For the cleanup job, the possibility for customization is in the strategy used to determine which change table entries are to be discarded.</span></span> <span data-ttu-id="9b859-164">배달된 정리 작업에서 지원되는 유일한 전략은 시간 기반 전략입니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-164">The only supported strategy in the delivered cleanup job is a time-based one.</span></span> <span data-ttu-id="9b859-165">이 경우 마지막으로 처리된 트랜잭션의 커밋 시간에서 허용되는 보존 기간을 빼는 방식으로 새로운 하위 워터마크가 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-165">In that situation, the new low watermark is computed by subtracting the allowed retention period from the commit time of the last transaction processed.</span></span> <span data-ttu-id="9b859-166">기본 정리 프로시저는 시간 대신 `lsn`에 기반을 두므로 원하는 만큼의 전략을 사용하여 변경 테이블에 보관할 최소 `lsn`을 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-166">Because the underlying cleanup procedures are based on `lsn` instead of time, any number of strategies can be used to determine the smallest `lsn` to keep in the change tables.</span></span> <span data-ttu-id="9b859-167">이들 중 일부만 엄격히 시간에 기반을 둡니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-167">Only some of these are strictly time-based.</span></span> <span data-ttu-id="9b859-168">예를 들어 변경 테이블에 액세스해야 하는 다운스트림 프로세스를 실행할 수 없는 경우 클라이언트에 대한 지식을 사용하여 장애 조치를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-168">Knowledge about the clients, for example, could be used to provide a failsafe if downstream processes that require access to the change tables cannot run.</span></span> <span data-ttu-id="9b859-169">또한 기본 전략은 동일한 `lsn`을 사용하여 데이터베이스의 모든 변경 테이블을 정리하지만 기본 정리 프로시저를 호출하여 캡처 인스턴스 수준에서 정리를 수행할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-169">Also, although the default strategy applies the same `lsn` to clean up all the databases' change tables, the underlying cleanup procedure, can also be called to clean up at the capture instance level.</span></span>  
  
##  <a name="monitor-the-change-data-capture-process"></a><a name="Monitor"></a> <span data-ttu-id="9b859-170">변경 데이터 캡처 프로세스 모니터링</span><span class="sxs-lookup"><span data-stu-id="9b859-170">Monitor the Change Data Capture Process</span></span>  
 <span data-ttu-id="9b859-171">변경 데이터 캡처 프로세스 모니터링을 통해 변경 내용이 올바르게 기록되고 있고 변경 테이블에 대한 대기 시간이 적절한지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-171">Monitoring the change data capture process lets you determine if changes are being written correctly and with a reasonable latency to the change tables.</span></span> <span data-ttu-id="9b859-172">모니터링을 사용하면 발생할 수 있는 오류를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-172">Monitoring can also help you to identify any errors that might occur.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="9b859-173">에는 변경 데이터 캡처를 모니터링하는 데 도움이 되는 두 가지 동적 관리 뷰인 [sys.dm_cdc_log_scan_sessions](../native-client-ole-db-data-source-objects/sessions.md) 및 [sys.dm_cdc_errors](../native-client-ole-db-errors/errors.md)가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-173">includes two dynamic management views to help you monitor change data capture: [sys.dm_cdc_log_scan_sessions](../native-client-ole-db-data-source-objects/sessions.md) and [sys.dm_cdc_errors](../native-client-ole-db-errors/errors.md).</span></span>  
  
### <a name="identify-sessions-with-empty-result-sets"></a><span data-ttu-id="9b859-174">빈 결과 집합이 포함된 세션 확인</span><span class="sxs-lookup"><span data-stu-id="9b859-174">Identify Sessions with Empty Result Sets</span></span>  
 <span data-ttu-id="9b859-175">sys.dm_cdc_log_scan_sessions의 각 행은 로그 검색 세션을 나타냅니다(ID가 0인 행은 제외).</span><span class="sxs-lookup"><span data-stu-id="9b859-175">Every row in sys.dm_cdc_log_scan_sessions represents a log scan session (except the row with an ID of 0).</span></span> <span data-ttu-id="9b859-176">로그 검색 세션은 [sp_cdc_scan](/sql/relational-databases/system-stored-procedures/sys-sp-cdc-scan-transact-sql)을 한 번 실행하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-176">A log scan session is equivalent to one execution of [sp_cdc_scan](/sql/relational-databases/system-stored-procedures/sys-sp-cdc-scan-transact-sql).</span></span> <span data-ttu-id="9b859-177">세션 중에 검색을 수행하면 변경 내용이나 빈 결과가 반환될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-177">During a session, the scan can either return changes or return an empty result.</span></span> <span data-ttu-id="9b859-178">결과 집합이 비어 있으면 sys.dm_cdc_log_scan_sessions의 empty_scan_count 열이 1로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-178">If the result set is empty, the empty_scan_count column in sys.dm_cdc_log_scan_sessions is set to 1.</span></span> <span data-ttu-id="9b859-179">캡처 작업이 계속해서 실행될 때와 같이 연속된 빈 결과 집합이 반환되면 마지막 남은 행에 있는 empty_scan_count가 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-179">If there are consecutive empty result sets, such as if the capture job is running continuously, the empty_scan_count in the last existing row is incremented.</span></span> <span data-ttu-id="9b859-180">예를 들어 sys.dm_cdc_log_scan_sessions에 검색 후 이미 변경 내용이 반환된 10개의 행이 있고 하나의 행에 5개의 빈 결과가 있는 경우 뷰에는 총 11개의 행이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-180">For example, if sys.dm_cdc_log_scan_sessions already contains 10 rows for scans that returned changes and there are five empty results in a row, the view contains 11 rows.</span></span> <span data-ttu-id="9b859-181">empty_scan_count 열에서 마지막 행의 값은 5입니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-181">The last row has a value of 5 in the empty_scan_count column.</span></span> <span data-ttu-id="9b859-182">검색 결과가 비어 있는 세션을 확인하려면 다음과 같은 쿼리를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-182">To determine sessions that had an empty scan, run the following query:</span></span>  
  
```sql
SELECT * from sys.dm_cdc_log_scan_sessions where empty_scan_count <> 0
```
  
### <a name="determine-latency"></a><span data-ttu-id="9b859-183">대기 시간 확인</span><span class="sxs-lookup"><span data-stu-id="9b859-183">Determine Latency</span></span>  
 <span data-ttu-id="9b859-184">sys.dm_cdc_log_scan_sessions 관리 뷰에는 각 캡처 세션에 대한 대기 시간을 기록하는 열이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-184">The sys.dm_cdc_log_scan_sessions management view includes a column that records the latency for each capture session.</span></span> <span data-ttu-id="9b859-185">대기 시간이란 원본 테이블에서 커밋되고 있는 트랜잭션과 변경 테이블에서 커밋되고 있는 마지막으로 캡처된 트랜잭션 사이의 경과 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-185">Latency is defined as the elapsed time between a transaction being committed on a source table and the last captured transaction being committed on the change table.</span></span> <span data-ttu-id="9b859-186">대기 시간 열은 활성 세션에 대해서만 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-186">The latency column is populated only for active sessions.</span></span> <span data-ttu-id="9b859-187">empty_scan_count 열에서 값이 0보다 큰 세션의 경우 대기 시간 열은 0으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-187">For sessions with a value greater than 0 in the empty_scan_count column, the latency column is set to 0.</span></span> <span data-ttu-id="9b859-188">다음 쿼리는 가장 최근의 세션에 대한 평균 대기 시간을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-188">The following query returns the average latency for the most recent sessions:</span></span>  
  
```sql
SELECT latency FROM sys.dm_cdc_log_scan_sessions WHERE session_id = 0
```
  
 <span data-ttu-id="9b859-189">대기 시간 데이터를 사용하여 캡처 프로세스에서 트랜잭션을 처리하는 속도가 빠르거나 느린지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-189">You can use latency data to determine how fast or slow the capture process is processing transactions.</span></span> <span data-ttu-id="9b859-190">이 데이터는 캡처 프로세스가 계속해서 실행되는 경우에 가장 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-190">This data is most useful when the capture process is running continuously.</span></span> <span data-ttu-id="9b859-191">캡처 프로세스가 예약 일정에 따라 실행되는 경우 원본 테이블에서 커밋되고 있는 트랜잭션과 예약 시간에 실행되는 캡처 프로세스 사이의 시간 간격으로 인해 대기 시간이 길어질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-191">If the capture process is running on a schedule, latency can be high because of the lag between transactions being committed on the source table and the capture process running at its scheduled time.</span></span>  
  
 <span data-ttu-id="9b859-192">캡처 프로세스 효율성에 대한 또 다른 중요한 측정값은 처리량입니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-192">Another important measure of capture process efficiency is throughput.</span></span> <span data-ttu-id="9b859-193">이 수치는 각 세션 중에 처리되는 초당 평균 명령 수를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-193">This is the average number of commands per second that are processed during each session.</span></span> <span data-ttu-id="9b859-194">세션의 처리량을 확인하려면 command_count 열에 있는 값을 duration 열에 있는 값으로 나눕니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-194">To determine the throughput of a session, divide the value in the command_count column by the value in the duration column.</span></span> <span data-ttu-id="9b859-195">다음 쿼리는 가장 최근의 세션에 대한 평균 처리량을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-195">The following query returns the average throughput for the most recent sessions:</span></span>  
  
```sql
SELECT command_count/duration AS [Throughput] FROM sys.dm_cdc_log_scan_sessions WHERE session_id = 0
```
  
### <a name="use-data-collector-to-collect-sampling-data"></a><span data-ttu-id="9b859-196">데이터 수집기를 사용하여 샘플링 데이터 수집</span><span class="sxs-lookup"><span data-stu-id="9b859-196">Use Data Collector to Collect Sampling Data</span></span>  
 <span data-ttu-id="9b859-197">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 데이터 수집기를 사용하면 모든 테이블 또는 동적 관리 뷰에서 데이터에 대한 스냅샷을 수집하고 성능 데이터 웨어하우스를 구축할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-197">The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] data collector lets you collect snapshots of data from any table or dynamic management view and build a performance data warehouse.</span></span> <span data-ttu-id="9b859-198">데이터베이스에 변경 데이터 캡처가 설정된 경우 나중에 분석할 수 있도록 sys.dm_cdc_log_scan_sessions 뷰 및 sys.dm_cdc_errors 뷰의 스냅샷을 정기적으로 수집하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-198">When change data capture is enabled on a database, it is useful to take snapshots of the sys.dm_cdc_log_scan_sessions view and the sys.dm_cdc_errors view at regular intervals for later analysis.</span></span> <span data-ttu-id="9b859-199">다음 절차에서는 sys.dm_cdc_log_scan_sessions 관리 뷰에서 샘플 데이터를 수집하도록 데이터 수집기를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-199">The following procedure sets up a data collector for collecting sample data from the sys.dm_cdc_log_scan_sessions management view.</span></span>  
  
 <span data-ttu-id="9b859-200">**데이터 수집 구성**</span><span class="sxs-lookup"><span data-stu-id="9b859-200">**Configuring Data Collection**</span></span>  
  
1.  <span data-ttu-id="9b859-201">데이터 수집기를 설정하고 및 관리 데이터 웨어하우스를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-201">Enable data collector and configure a management data warehouse.</span></span> <span data-ttu-id="9b859-202">자세한 내용은 [데이터 컬렉션 관리](../data-collection/data-collection.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9b859-202">For more information, see [Manage Data Collection](../data-collection/data-collection.md).</span></span>  
  
2.  <span data-ttu-id="9b859-203">다음 코드를 실행하여 변경 데이터 캡처에 대한 사용자 지정 수집기를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-203">Execute the following code to create a custom collector for change data capture.</span></span>  
  
    ```sql  
    USE msdb;  
  
    DECLARE @schedule_uid uniqueidentifier;  
  
    -- Collect and upload data every 5 minutes  
    SELECT @schedule_uid = (  
    SELECT schedule_uid from sysschedules_localserver_view   
    WHERE name = N'CollectorSchedule_Every_5min')  
  
    DECLARE @collection_set_id int;  
  
    EXEC dbo.sp_syscollector_create_collection_set  
    @name = N' CDC Performance Data Collector',  
    @schedule_uid = @schedule_uid,          
    @collection_mode = 0,                   
    @days_until_expiration = 30,                
    @description = N'This collection set collects CDC metadata',  
    @collection_set_id = @collection_set_id output;  
  
    -- Create a collection item using statistics from   
    -- the change data capture dynamic management view.  
    DECLARE @parameters xml;  
    DECLARE @collection_item_id int;  
  
    SELECT @parameters = CONVERT(xml,   
        N'<TSQLQueryCollector>  
            <Query>  
              <Value>SELECT * FROM sys.dm_cdc_log_scan_sessions</Value>  
              <OutputTable>cdc_log_scan_data</OutputTable>  
            </Query>  
          </TSQLQueryCollector>');  
  
    EXEC dbo.sp_syscollector_create_collection_item  
    @collection_set_id = @collection_set_id,  
    @collector_type_uid = N'302E93D1-3424-4BE7-AA8E-84813ECF2419',  
    @name = ' CDC Performance Data Collector',  
    @frequency = 5,   
    @parameters = @parameters,  
    @collection_item_id = @collection_item_id output;  
  
    GO  
    ```  
  
3.  <span data-ttu-id="9b859-204">[!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)]에서 **관리**, **데이터 컬렉션**을 차례로 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-204">In [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)], expand **Management**, and then expand **Data Collection**.</span></span> <span data-ttu-id="9b859-205">**CDC Performance Data Collector**를 마우스 오른쪽 단추로 클릭한 다음 **데이터 컬렉션 집합을 시작합니다**를 클릭합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-205">Right click **CDC Performance Data Collector**, and then click **Start Data Collection Set**.</span></span>  
  
4.  <span data-ttu-id="9b859-206">1단계에서 구성한 데이터 웨어하우스에서 custom_snapshots.cdc_log_scan_data 테이블을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-206">In the data warehouse you configured in step 1, locate the table custom_snapshots.cdc_log_scan_data.</span></span> <span data-ttu-id="9b859-207">이 테이블은 로그 검색 세션의 데이터 스냅샷 기록을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-207">This table provides a historical snapshot of data from log scan sessions.</span></span> <span data-ttu-id="9b859-208">이 데이터를 사용하여 시간에 따른 대기 시간, 처리량 및 기타 성능 측정값을 분석할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b859-208">This data can be used to analyze latency, throughput, and other performance measures over time.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9b859-209">참고 항목</span><span class="sxs-lookup"><span data-stu-id="9b859-209">See Also</span></span>  
 <span data-ttu-id="9b859-210">[데이터 변경 내용 추적&#40;SQL Server&#41;](track-data-changes-sql-server.md) </span><span class="sxs-lookup"><span data-stu-id="9b859-210">[Track Data Changes &#40;SQL Server&#41;](track-data-changes-sql-server.md) </span></span>  
 <span data-ttu-id="9b859-211">[변경 데이터 캡처 정보&#40;SQL Server&#41;](../track-changes/about-change-data-capture-sql-server.md) </span><span class="sxs-lookup"><span data-stu-id="9b859-211">[About Change Data Capture &#40;SQL Server&#41;](../track-changes/about-change-data-capture-sql-server.md) </span></span>  
 <span data-ttu-id="9b859-212">[변경 데이터 캡처 설정 및 해제&#40;SQL Server&#41;](enable-and-disable-change-data-capture-sql-server.md) </span><span class="sxs-lookup"><span data-stu-id="9b859-212">[Enable and Disable Change Data Capture &#40;SQL Server&#41;](enable-and-disable-change-data-capture-sql-server.md) </span></span>  
 [<span data-ttu-id="9b859-213">변경 데이터 작업&#40;SQL Server&#41;</span><span class="sxs-lookup"><span data-stu-id="9b859-213">Work with Change Data &#40;SQL Server&#41;</span></span>](work-with-change-data-sql-server.md)  
  
  
