---
title: SQL Server 인덱스 디자인 가이드 | Microsoft 문서
ms.custom: ''
ms.date: 06/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
ms.assetid: b856ee9a-49e7-4fab-a88d-48a633fce269
author: rothja
ms.author: jroth
ms.openlocfilehash: 1f5ad72413fe71004fb1c5f125969b984db815d3
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87646747"
---
# <a name="sql-server-index-design-guide"></a><span data-ttu-id="4ee79-102">SQL Server 인덱스 디자인 가이드</span><span class="sxs-lookup"><span data-stu-id="4ee79-102">SQL Server Index Design Guide</span></span>

  <span data-ttu-id="4ee79-103">데이터베이스 애플리케이션 병목 상태는 주로 잘못 디자인된 인덱스와 인덱스의 부족으로 인해 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-103">Poorly designed indexes and a lack of indexes are primary sources of database application bottlenecks.</span></span> <span data-ttu-id="4ee79-104">최적의 데이터베이스와 최상의 애플리케이션 성능을 위해서는 효율적인 인덱스를 디자인하는 것이 가장 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-104">Designing efficient indexes is paramount to achieving good database and application performance.</span></span> <span data-ttu-id="4ee79-105">이 SQL Server 인덱스 디자인 가이드에서는 애플리케이션 요구 사항을 충족하는 효율적인 인덱스를 디자인하는 데 도움이 되는 정보와 최선의 구현 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-105">This SQL Server index design guide contains information and best practices to help you design effective indexes to meet the needs of your application.</span></span>  
  
<span data-ttu-id="4ee79-106">**적용 대상**: [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] 별도로 언급 하지 않는 한부터까지</span><span class="sxs-lookup"><span data-stu-id="4ee79-106">**Applies to**: [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] through [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] unless noted otherwise.</span></span>  
  
 <span data-ttu-id="4ee79-107">이 가이드에서는 사용자가 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]에서 사용할 수 있는 인덱스 유형에 대한 기본적인 지식이 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-107">This guide assumes the reader has a general understanding of the index types available in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="4ee79-108">인덱스 형식에 대한 일반적인 설명은 [인덱스 유형](../relational-databases/indexes/indexes.md)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="4ee79-108">For a general description of index types, see [Index Types](../relational-databases/indexes/indexes.md).</span></span>  
  
##  <a name="in-this-guide"></a><a name="Top"></a><span data-ttu-id="4ee79-109">이 가이드의</span><span class="sxs-lookup"><span data-stu-id="4ee79-109">In This Guide</span></span>  

 [<span data-ttu-id="4ee79-110">인덱스 디자인 기본 사항</span><span class="sxs-lookup"><span data-stu-id="4ee79-110">Index Design Basics</span></span>](#Basics)  
  
 [<span data-ttu-id="4ee79-111">일반 인덱스 디자인 지침</span><span class="sxs-lookup"><span data-stu-id="4ee79-111">General Index Design Guidelines</span></span>](#General_Design)  
  
 [<span data-ttu-id="4ee79-112">클러스터형 인덱스 디자인 지침</span><span class="sxs-lookup"><span data-stu-id="4ee79-112">Clustered Index Design Guidelines</span></span>](#Clustered)  
  
 [<span data-ttu-id="4ee79-113">비클러스터형 인덱스 디자인 지침</span><span class="sxs-lookup"><span data-stu-id="4ee79-113">Nonclustered Index Design Guidelines</span></span>](#Nonclustered)  
  
 [<span data-ttu-id="4ee79-114">고유 인덱스 디자인 지침</span><span class="sxs-lookup"><span data-stu-id="4ee79-114">Unique Index Design Guidelines</span></span>](#Unique)  
  
 [<span data-ttu-id="4ee79-115">필터링 된 인덱스 디자인 지침</span><span class="sxs-lookup"><span data-stu-id="4ee79-115">Filtered Index Design Guidelines</span></span>](#Filtered)  
  
 [<span data-ttu-id="4ee79-116">추가 참고 자료</span><span class="sxs-lookup"><span data-stu-id="4ee79-116">Additional Reading</span></span>](#Additional_Reading)  
  
##  <a name="index-design-basics"></a><a name="Basics"></a> <span data-ttu-id="4ee79-117">인덱스 디자인 기본 사항</span><span class="sxs-lookup"><span data-stu-id="4ee79-117">Index Design Basics</span></span>  

 <span data-ttu-id="4ee79-118">인덱스는 테이블이나 뷰와 관련된 디스크상 구조로서 테이블이나 뷰의 행 검색 속도를 향상시킵니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-118">An index is an on-disk structure associated with a table or view that speeds retrieval of rows from the table or view.</span></span> <span data-ttu-id="4ee79-119">인덱스에는 테이블이나 뷰에 있는 하나 이상의 열로 작성되는 키가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-119">An index contains keys built from one or more columns in the table or view.</span></span> <span data-ttu-id="4ee79-120">이러한 키는 SQL Server에서 키 값과 연결된 행을 빠르고 효율적으로 찾을 수 있는 구조(B-트리)에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-120">These keys are stored in a structure (B-tree) that enables SQL Server to find the row or rows associated with the key values quickly and efficiently.</span></span>  
  
 <span data-ttu-id="4ee79-121">데이터베이스에 적합한 인덱스를 선택하는 것은 쿼리 속도와 업데이트 비용 간의 균형을 조정해야 하는 복잡한 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-121">The selection of the right indexes for a database and its workload is a complex balancing act between query speed and update cost.</span></span> <span data-ttu-id="4ee79-122">좁은 인덱스나 인덱스 키의 열이 적은 인덱스는 디스크 공간과 유지 관리 오버헤드를 덜 요구합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-122">Narrow indexes, or indexes with few columns in the index key, require less disk space and maintenance overhead.</span></span> <span data-ttu-id="4ee79-123">반대로 넓은 인덱스는 더 많은 쿼리를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-123">Wide indexes, on the other hand, cover more queries.</span></span> <span data-ttu-id="4ee79-124">가장 효율적인 인덱스를 찾기 위해 여러 디자인을 시험해 봐야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-124">You may have to experiment with several different designs before finding the most efficient index.</span></span> <span data-ttu-id="4ee79-125">데이터베이스 스키마나 애플리케이션에 영향을 주지 않고 인덱스를 추가, 수정 및 삭제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-125">Indexes can be added, modified, and dropped without affecting the database schema or application design.</span></span> <span data-ttu-id="4ee79-126">따라서 원하는 대로 여러 인덱스를 시험해 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-126">Therefore, you should not hesitate to experiment with different indexes.</span></span>  
  
 <span data-ttu-id="4ee79-127">[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 의 쿼리 최적화 프로그램은 대부분의 경우 가장 효율적인 인덱스를 제대로 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-127">The query optimizer in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] reliably chooses the most effective index in the vast majority of cases.</span></span> <span data-ttu-id="4ee79-128">전체 인덱스 디자인 전략에서는 쿼리 최적화 프로그램이 가장 효율적인 인덱스를 찾을 수 있도록 다양한 인덱스를 제공하고 쿼리 최적화 프로그램의 선택을 신뢰해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-128">Your overall index design strategy should provide a variety of indexes for the query optimizer to choose from and trust it to make the right decision.</span></span> <span data-ttu-id="4ee79-129">이렇게 하면 분석 시간이 줄어들고 다양한 상황에서 좋은 성능을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-129">This reduces analysis time and produces good performance over a variety of situations.</span></span> <span data-ttu-id="4ee79-130">특정 쿼리에 대해 쿼리 최적화 프로그램이 사용하는 인덱스를 확인하려면 [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]의 **쿼리** 메뉴에서 **실제 실행 계획 포함**을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-130">To see which indexes the query optimizer uses for a specific query, in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], on the **Query** menu, select **Include Actual Execution Plan**.</span></span>  
  
 <span data-ttu-id="4ee79-131">인덱스 사용이 항상 좋은 성능을 의미하지 않으며 마찬가지로 좋은 성능이 항상 효율적인 인덱스 사용을 나타내는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-131">Do not always equate index usage with good performance, and good performance with efficient index use.</span></span> <span data-ttu-id="4ee79-132">인덱스 사용이 최상의 성능을 내는 데 항상 도움이 된다면 쿼리 최적화 프로그램의 작업은 간단할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-132">If using an index always helped produce the best performance, the job of the query optimizer would be simple.</span></span> <span data-ttu-id="4ee79-133">실제로 인덱스를 잘못 선택하면 최상의 성능을 얻지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-133">In reality, an incorrect index choice can cause less than optimal performance.</span></span> <span data-ttu-id="4ee79-134">따라서 쿼리 최적화 프로그램에서는 성능을 향상시킬 경우에만 인덱스나 인덱스 조합을 선택하고 성능을 저하시킬 경우에는 인덱싱된 검색을 피해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-134">Therefore, the task of the query optimizer is to select an index, or combination of indexes, only when it will improve performance, and to avoid indexed retrieval when it will hinder performance.</span></span>  
  
### <a name="index-design-tasks"></a><span data-ttu-id="4ee79-135">인덱스 디자인 태스크</span><span class="sxs-lookup"><span data-stu-id="4ee79-135">Index Design Tasks</span></span>  

 <span data-ttu-id="4ee79-136">권장되는 인덱스 디자인 전략은 다음과 같은 태스크로 이루어집니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-136">The follow tasks make up our recommended strategy for designing indexes:</span></span>  
  
1.  <span data-ttu-id="4ee79-137">데이터베이스의 특징을 이해합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-137">Understand the characteristics of the database itself.</span></span> <span data-ttu-id="4ee79-138">예를 들어 데이터베이스가 데이터 수정이 잦은 OLTP(온라인 트랜잭션 처리) 데이터베이스인지, DSS(의사 결정 지원 시스템)인지, 주로 읽기 전용 데이터를 포함하고 매우 많은 데이터 집합을 빠르게 처리해야 하는 OLAP(데이터 웨어하우징) 데이터베이스인지를 파악해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-138">For example, is it an online transaction processing (OLTP) database with frequent data modifications, or a Decision Support System (DSS) or data warehousing (OLAP) database that contains primarily read-only data and must process very large data sets quickly.</span></span> <span data-ttu-id="4ee79-139">[!INCLUDE[ssSQL11](../includes/sssql11-md.md)]에서 *xVelocity memory optimized columnstore* 인덱스는 일반 데이터 웨어하우징 데이터 집합에 특히 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-139">In [!INCLUDE[ssSQL11](../includes/sssql11-md.md)], *xVelocity memory optimized columnstore* index is especially appropriate for typical data warehousing data sets.</span></span> <span data-ttu-id="4ee79-140">Columnstore 인덱스는 필터링, 집계, 그룹화, 스타 조인 쿼리 등 일반 데이터 웨어하우징 쿼리에 대한 성능을 개선하여 사용자의 데이터 웨어하우징 환경을 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-140">Columnstore indexes can transform the data warehousing experience for users by enabling faster performance for common data warehousing queries such as filtering, aggregating, grouping, and star-join queries.</span></span> <span data-ttu-id="4ee79-141">자세한 내용은 [설명 된 Columnstore 인덱스](../relational-databases/indexes/columnstore-indexes-described.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="4ee79-141">For more information, see [Columnstore Indexes Described](../relational-databases/indexes/columnstore-indexes-described.md).</span></span>  
  
2.  <span data-ttu-id="4ee79-142">가장 자주 사용하는 쿼리의 특성을 이해합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-142">Understand the characteristics of the most frequently used queries.</span></span> <span data-ttu-id="4ee79-143">예를 들어 두 개 이상의 테이블을 조인하는 쿼리를 자주 사용한다는 것을 알면 가장 적절한 인덱스 유형을 결정하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-143">For example, knowing that a frequently used query joins two or more tables will help you determine the best type of indexes to use.</span></span>  
  
3.  <span data-ttu-id="4ee79-144">쿼리에 사용되는 열의 특성을 이해합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-144">Understand the characteristics of the columns used in the queries.</span></span> <span data-ttu-id="4ee79-145">예를 들어 인덱스는 정수 데이터 형식을 사용하는 고유 열이나 Null이 아닌 열에 이상적입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-145">For example, an index is ideal for columns that have an integer data type and are also unique or nonnull columns.</span></span> <span data-ttu-id="4ee79-146">열에 데이터의 잘 정의된 하위 집합이 있는 경우 [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] 이상 버전에서 필터링된 인덱스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-146">For columns that have well-defined subsets of data, you can use a filtered index in [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] and higher versions.</span></span> <span data-ttu-id="4ee79-147">자세한 내용은 이 가이드의 [필터링된 인덱스 디자인 지침](#Filtered) 을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="4ee79-147">For more information, see [Filtered Index Design Guidelines](#Filtered) in this guide.</span></span>  
  
4.  <span data-ttu-id="4ee79-148">인덱스를 만들거나 유지 관리할 때 성능을 향상시킬 수 있는 인덱스 옵션을 파악합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-148">Determine which index options might enhance performance when the index is created or maintained.</span></span> <span data-ttu-id="4ee79-149">예를 들어 기존의 큰 테이블에 클러스터형 인덱스를 만들 때 ONLINE 인덱스 옵션을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-149">For example, creating a clustered index on an existing large table would benefit from the ONLINE index option.</span></span> <span data-ttu-id="4ee79-150">ONLINE 옵션을 사용하면 인덱스를 만들거나 새로 작성하는 동안 기본 데이터를 작업할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-150">The ONLINE option allows for concurrent activity on the underlying data to continue while the index is being created or rebuilt.</span></span> <span data-ttu-id="4ee79-151">자세한 내용은 [인덱스 옵션 설정](../relational-databases/indexes/set-index-options.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4ee79-151">For more information, see [Set Index Options](../relational-databases/indexes/set-index-options.md).</span></span>  
  
5.  <span data-ttu-id="4ee79-152">인덱스에 가장 적합한 스토리지 위치를 파악합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-152">Determine the optimal storage location for the index.</span></span> <span data-ttu-id="4ee79-153">비클러스터형 인덱스는 기본 테이블과 같은 파일 그룹이나 다른 파일 그룹에 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-153">A nonclustered index can be stored in the same filegroup as the underlying table, or on a different filegroup.</span></span> <span data-ttu-id="4ee79-154">인덱스의 스토리지 위치는 디스크 I/O 성능을 높여 쿼리 성능을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-154">The storage location of indexes can improve query performance by increasing disk I/O performance.</span></span> <span data-ttu-id="4ee79-155">예를 들어 테이블 파일 그룹과 다른 디스크에 있는 파일 그룹에 비클러스터형 인덱스를 저장하면 동시에 여러 디스크를 읽을 수 있으므로 성능이 향상될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-155">For example, storing a nonclustered index on a filegroup that is on a different disk than the table filegroup can improve performance because multiple disks can be read at the same time.</span></span>  
  
     <span data-ttu-id="4ee79-156">또는 클러스터형 인덱스와 비클러스터형 인덱스가 여러 파일 그룹에 하나의 파티션 구성표를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-156">Alternatively, clustered and nonclustered indexes can use a partition scheme across multiple filegroups.</span></span> <span data-ttu-id="4ee79-157">분할을 사용하면 데이터 하위 집합을 빠르고 효율적으로 액세스하고 관리하는 동시에 전체 컬렉션의 무결성을 유지할 수 있으므로 큰 테이블이나 인덱스를 보다 쉽게 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-157">Partitioning makes large tables or indexes more manageable by letting you access or manage subsets of data quickly and efficiently, while maintaining the integrity of the overall collection.</span></span> <span data-ttu-id="4ee79-158">자세한 내용은 [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4ee79-158">For more information, see [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span></span> <span data-ttu-id="4ee79-159">분할을 고려할 때 인덱스를 맞춰야 하는지, 즉 본질적으로 테이블과 같은 방식으로 분할해야 하는지 또는 독립적으로 분할해야 하는지 파악합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-159">When you consider partitioning, determine whether the index should be aligned, that is, partitioned in essentially the same manner as the table, or partitioned independently.</span></span>  
  
##  <a name="general-index-design-guidelines"></a><a name="General_Design"></a> <span data-ttu-id="4ee79-160">일반 인덱스 디자인 지침</span><span class="sxs-lookup"><span data-stu-id="4ee79-160">General Index Design Guidelines</span></span>  

 <span data-ttu-id="4ee79-161">경험이 많은 데이터베이스 관리자는 인덱스를 잘 디자인할 수 있습니다. 그러나 데이터베이스와 작업이 조금만 복잡해져도 이 태스크는 복잡하고 시간이 많이 걸리며 오류가 쉽게 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-161">Experienced database administrators can design a good set of indexes, but this task is very complex, time-consuming, and error-prone even for moderately complex databases and workloads.</span></span> <span data-ttu-id="4ee79-162">데이터베이스, 쿼리 및 데이터 열의 특성을 이해하면 최적의 인덱스를 디자인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-162">Understanding the characteristics of your database, queries, and data columns can help you design optimal indexes.</span></span>  
  
### <a name="database-considerations"></a><span data-ttu-id="4ee79-163">데이터베이스 고려 사항</span><span class="sxs-lookup"><span data-stu-id="4ee79-163">Database Considerations</span></span>  

 <span data-ttu-id="4ee79-164">인덱스를 디자인할 때 다음과 같은 데이터 베이스 지침을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-164">When you design an index, consider the following database guidelines:</span></span>  
  
-   <span data-ttu-id="4ee79-165">테이블에 대한 인덱스를 많이 만들면 테이블의 데이터가 변경될 경우 인덱스도 모두 적절하게 조정되어야 하므로 INSERT, UPDATE, DELETE 및 MERGE 문의 성능이 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-165">Large numbers of indexes on a table affect the performance of INSERT, UPDATE, DELETE, and MERGE statements because all indexes must be adjusted appropriately as data in the table changes.</span></span> <span data-ttu-id="4ee79-166">예를 들어 열이 여러 인덱스에서 사용되고 열 데이터를 수정하는 UPDATE 문을 실행하는 경우 열을 포함하는 각 인덱스뿐만 아니라 기본 테이블(힙 또는 클러스터형 인덱스)에 있는 열도 업데이트되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-166">For example, if a column is used in several indexes and you execute an UPDATE statement that modifies that column's data, each index that contains that column must be updated as well as the column in the underlying base table (heap or clustered index).</span></span>  
  
    -   <span data-ttu-id="4ee79-167">과도하게 업데이트되는 테이블에 대한 인덱스를 너무 많이 만들지 말고 가능한 열 수가 적은 좁은 인덱스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-167">Avoid over-indexing heavily updated tables and keep indexes narrow, that is, with as few columns as possible.</span></span>  
  
    -   <span data-ttu-id="4ee79-168">많은 인덱스를 사용하면 업데이트 요구는 적지만 데이터 양이 많은 테이블의 쿼리 성능이 향상될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-168">Use many indexes to improve query performance on tables with low update requirements, but large volumes of data.</span></span> <span data-ttu-id="4ee79-169">인덱스 수가 많으면 SELECT 문과 같이 데이터를 수정하지 않는 쿼리의 성능이 향상될 수 있습니다. 이는 쿼리 최적화 프로그램이 가장 빠른 액세스 방법을 결정할 때 선택할 수 있는 인덱스가 더 많기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-169">Large numbers of indexes can help the performance of queries that do not modify data, such as SELECT statements, because the query optimizer has more indexes to choose from to determine the fastest access method.</span></span>  
  
-   <span data-ttu-id="4ee79-170">작은 테이블에 대한 인덱스를 만들면 비효율적일 수 있습니다. 이는 쿼리 최적화 프로그램이 간단한 테이블 스캔을 수행하는 시간보다 데이터를 검색하기 위해 인덱스를 통과하는 시간이 더 길 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-170">Indexing small tables may not be optimal because it can take the query optimizer longer to traverse the index searching for data than to perform a simple table scan.</span></span> <span data-ttu-id="4ee79-171">따라서 작은 테이블에 대한 인덱스는 전혀 사용되지 않을 수도 있지만 테이블의 데이터가 변경될 때마다 유지 관리되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-171">Therefore, indexes on small tables might never be used, but must still be maintained as data in the table changes.</span></span>  
  
-   <span data-ttu-id="4ee79-172">뷰에 집계, 테이블 조인 또는 집계와 조인의 조합이 포함되어 있으면 뷰에 대한 인덱스 성능이 크게 향상될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-172">Indexes on views can provide significant performance gains when the view contains aggregations, table joins, or a combination of aggregations and joins.</span></span> <span data-ttu-id="4ee79-173">쿼리 최적화 프로그램은 뷰를 사용하기 위해 쿼리에 뷰를 명시적으로 참조할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-173">The view does not have to be explicitly referenced in the query for the query optimizer to use it.</span></span>  
  
-   <span data-ttu-id="4ee79-174">데이터베이스 엔진 튜닝 관리자를 사용하여 데이터베이스를 분석하고 인덱스 권장 구성을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-174">Use the Database Engine Tuning Advisor to analyze your database and make index recommendations.</span></span> <span data-ttu-id="4ee79-175">자세한 내용은 [Database Engine Tuning Advisor](../relational-databases/performance/database-engine-tuning-advisor.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4ee79-175">For more information, see [Database Engine Tuning Advisor](../relational-databases/performance/database-engine-tuning-advisor.md).</span></span>  
  
### <a name="query-considerations"></a><span data-ttu-id="4ee79-176">쿼리 고려 사항</span><span class="sxs-lookup"><span data-stu-id="4ee79-176">Query Considerations</span></span>  

 <span data-ttu-id="4ee79-177">인덱스를 디자인할 때 다음과 같은 쿼리 지침을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-177">When you design an index, consider the following query guidelines:</span></span>  
  
-   <span data-ttu-id="4ee79-178">쿼리의 조건자 및 조인 조건에서 자주 사용되는 열에 대해 비클러스터형 인덱스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-178">Create nonclustered indexes on the columns that are frequently used in predicates and join conditions in queries.</span></span> <span data-ttu-id="4ee79-179">불필요한 열은 추가하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="4ee79-179">However, you should avoid adding unnecessary columns.</span></span> <span data-ttu-id="4ee79-180">인덱스 열을 너무 많이 추가하면 디스크 공간 및 인덱스 유지 관리 성능이 떨어질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-180">Adding too many index columns can adversely affect disk space and index maintenance performance.</span></span>  
  
-   <span data-ttu-id="4ee79-181">인덱스를 포함하면 쿼리의 요구 사항을 만족시키는 데 필요한 모든 데이터가 인덱스 자체 내에 있기 때문에 쿼리 성능이 향상될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-181">Covering indexes can improve query performance because all the data needed to meet the requirements of the query exists within the index itself.</span></span> <span data-ttu-id="4ee79-182">즉, 테이블이나 클러스터형 인덱스의 데이터 페이지가 아니라 인덱스 페이지만 있으면 요청된 데이터를 검색할 수 있으므로 전체적인 디스크 I/O가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-182">That is, only the index pages, and not the data pages of the table or clustered index, are required to retrieve the requested data; therefore, reducing overall disk I/O.</span></span> <span data-ttu-id="4ee79-183">예를 들어 **a** , **b** 및 **c**열에 대해 만든 복합 인덱스가 포함된 테이블에서 **a**와 **b** 열을 쿼리하면 지정된 데이터를 인덱스 자체에서만 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-183">For example, a query of columns **a** and **b** on a table that has a composite index created on columns **a**, **b**, and **c** can retrieve the specified data from the index alone.</span></span>  
  
-   <span data-ttu-id="4ee79-184">여러 개의 쿼리를 사용하여 동일한 여러 행을 업데이트하는 대신 단일 문에 가능한 많은 행을 삽입하거나 수정하는 쿼리를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-184">Write queries that insert or modify as many rows as possible in a single statement, instead of using multiple queries to update the same rows.</span></span> <span data-ttu-id="4ee79-185">문을 하나만 사용하면 최적화된 인덱스 유지 관리가 수행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-185">By using only one statement, optimized index maintenance could be exploited.</span></span>  
  
-   <span data-ttu-id="4ee79-186">쿼리 유형 및 쿼리에서 열이 사용되는 방법을 평가합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-186">Evaluate the query type and how columns are used in the query.</span></span> <span data-ttu-id="4ee79-187">예를 들어 정확히 일치하는 쿼리 유형에서 사용되는 열은 비클러스터형 또는 클러스터형 인덱스로 만들면 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-187">For example, a column used in an exact-match query type would be a good candidate for a nonclustered or clustered index.</span></span>  
  
### <a name="column-considerations"></a><span data-ttu-id="4ee79-188">열 고려 사항</span><span class="sxs-lookup"><span data-stu-id="4ee79-188">Column Considerations</span></span>  

 <span data-ttu-id="4ee79-189">인덱스를 디자인할 때 다음과 같은 열 지침을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-189">When you design an index consider the following column guidelines:</span></span>  
  
-   <span data-ttu-id="4ee79-190">클러스터형 인덱스의 인덱스 키 길이는 짧게 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-190">Keep the length of the index key short for clustered indexes.</span></span> <span data-ttu-id="4ee79-191">또한 클러스터형 인덱스는 고유하거나 Null이 아닌 열에 만들어지는 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-191">Additionally, clustered indexes benefit from being created on unique or nonnull columns.</span></span>  
  
-   <span data-ttu-id="4ee79-192">`ntext`, `text`, `image`, `varchar(max)`, `nvarchar(max)` 및 `varbinary(max)` 데이터 형식으로 되어 있는 열은 인덱스 키 열로 지정될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-192">Columns that are of the `ntext`, `text`, `image`, `varchar(max)`, `nvarchar(max)`, and `varbinary(max)` data types cannot be specified as index key columns.</span></span> <span data-ttu-id="4ee79-193">하지만 `varchar(max)`, `nvarchar(max)`, `varbinary(max)` 및 `xml` 데이터 형식은 비클러스터형 인덱스에 키가 아닌 인덱스 열로 참여할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-193">However, `varchar(max)`, `nvarchar(max)`, `varbinary(max)`, and `xml` data types can participate in a nonclustered index as nonkey index columns.</span></span> <span data-ttu-id="4ee79-194">자세한 내용은 이 지침에서 ['포괄 열이 있는 인덱스](#Included_Columns)' 섹션을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="4ee79-194">For more information, see the section ['Index with Included Columns](#Included_Columns)' in this guide.</span></span>  
  
-   <span data-ttu-id="4ee79-195">`xml` 데이터 형식은 XML 인덱스의 키 열만 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-195">An `xml` data type can only be a key column only in an XML index.</span></span> <span data-ttu-id="4ee79-196">자세한 내용은 [XML 인덱스&#40;SQL Server&#41;](../relational-databases/xml/xml-indexes-sql-server.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4ee79-196">For more information, see [XML Indexes &#40;SQL Server&#41;](../relational-databases/xml/xml-indexes-sql-server.md).</span></span> <span data-ttu-id="4ee79-197">SQL Server 2012 SP1에서는 선택적 XML 인덱스라고 하는 새로운 유형의 XML 인덱스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-197">SQL Server 2012 SP1 introduces a new type of XML index known as a Selective XML Index.</span></span> <span data-ttu-id="4ee79-198">이 새 인덱스를 통해 SQL Server에서 XML로 저장된 데이터에 대해 쿼리 성능을 향상시킬 수 있어 대량의 XML 데이터 작업의 인덱싱을 훨씬 빠르게 하고 인덱스 자체의 스토리지 비용을 감소시켜 확장성을 향상할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-198">This new index can improve querying performance over data stored as XML in SQL Server, allow for much faster indexing of large XML data workloads, and improve scalability by reducing storage costs of the index itself.</span></span> <span data-ttu-id="4ee79-199">자세한 내용은 [SXI&#40;선택적 XML 인덱스&#41;](../relational-databases/xml/selective-xml-indexes-sxi.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4ee79-199">For more information, see [Selective XML Indexes &#40;SXI&#41;](../relational-databases/xml/selective-xml-indexes-sxi.md).</span></span>  
  
-   <span data-ttu-id="4ee79-200">열이 고유한지 조사합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-200">Examine column uniqueness.</span></span> <span data-ttu-id="4ee79-201">동일한 열 조합에서 고유하지 않은 인덱스 대신 고유한 인덱스를 만들면 인덱스를 보다 유용하게 만드는 추가 정보가 쿼리 최적화 프로그램에 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-201">A unique index instead of a nonunique index on the same combination of columns provides additional information for the query optimizer that makes the index more useful.</span></span> <span data-ttu-id="4ee79-202">자세한 내용은 이 가이드의 [고유 인덱스 디자인 지침](#Unique) 을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="4ee79-202">For more information, see [Unique Index Design Guidelines](#Unique) in this guide.</span></span>  
  
-   <span data-ttu-id="4ee79-203">열의 데이터 분산을 조사합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-203">Examine data distribution in the column.</span></span> <span data-ttu-id="4ee79-204">고유한 값이 거의 없는 열을 인덱싱하거나 그러한 열에 대해 조인을 수행하면 쿼리 실행 시간이 길어지는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-204">Frequently, a long-running query is caused by indexing a column with few unique values, or by performing a join on such a column.</span></span> <span data-ttu-id="4ee79-205">이는 데이터와 쿼리의 근본 문제이므로 일반적으로 이러한 상황을 확인하지 않고는 해결할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-205">This is a fundamental problem with the data and query, and generally cannot be resolved without identifying this situation.</span></span> <span data-ttu-id="4ee79-206">예를 들어 이름이 알파벳순으로 정렬된 실제 전화 번호부에서 해당 도시의 모든 사람 이름이 Smith 또는 Jones이면 특정 사람을 신속하게 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-206">For example, a physical telephone directory sorted alphabetically on last name will not expedite locating a person if all people in the city are named Smith or Jones.</span></span> <span data-ttu-id="4ee79-207">데이터 분산에 대한 자세한 내용은 [Statistics](../relational-databases/statistics/statistics.md)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="4ee79-207">For more information about data distribution, see [Statistics](../relational-databases/statistics/statistics.md).</span></span>  
  
-   <span data-ttu-id="4ee79-208">잘 정의된 하위 집합이 포함된 열(예: 스파스 열, 값이 대부분 NULL인 열, 특정 범주의 값이 있는 열 및 특정 범위의 값이 있는 열)에 필터링된 인덱스를 사용해 보십시오.</span><span class="sxs-lookup"><span data-stu-id="4ee79-208">Consider using filtered indexes on columns that have well-defined subsets, for example sparse columns, columns with mostly NULL values, columns with categories of values, and columns with distinct ranges of values.</span></span> <span data-ttu-id="4ee79-209">잘 디자인된 필터링된 인덱스는 쿼리 성능을 개선하고 인덱스 유지 관리 비용과 스토리지 비용을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-209">A well-designed filtered index can improve query performance, reduce index maintenance costs, and reduce storage costs.</span></span>  
  
-   <span data-ttu-id="4ee79-210">인덱스에 여러 개의 열이 포함될 경우 열 순서를 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-210">Consider the order of the columns if the index will contain multiple columns.</span></span> <span data-ttu-id="4ee79-211">같음(=), 보다 큼(>), 보다 작음(<) 또는 BETWEEN 검색 조건의 WHERE 절에서 사용되거나 조인에 참여하는 열은 맨 앞에 배치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-211">The column that is used in the WHERE clause in an equal to (=), greater than (>), less than (<), or BETWEEN search condition, or participates in a join, should be placed first.</span></span> <span data-ttu-id="4ee79-212">추가 열은 고유성 수준에 따라 가장 고유한 열에서 가장 고유하지 않은 열의 순서로 정렬되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-212">Additional columns should be ordered based on their level of distinctness, that is, from the most distinct to the least distinct.</span></span>  
  
     <span data-ttu-id="4ee79-213">예를 들어 인덱스가 `LastName`, `FirstName` 으로 정의되는 경우 이 인덱스는 검색 조건이 `WHERE LastName = 'Smith'` 또는 `WHERE LastName = Smith AND FirstName LIKE 'J%'`인 경우 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-213">For example, if the index is defined as `LastName`, `FirstName` the index will be useful when the search criterion is `WHERE LastName = 'Smith'` or `WHERE LastName = Smith AND FirstName LIKE 'J%'`.</span></span> <span data-ttu-id="4ee79-214">그러나 쿼리 최적화 프로그램은 `FirstName (WHERE FirstName = 'Jane')`에 대해서만 검색한 쿼리에는 인덱스를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-214">However, the query optimizer would not use the index for a query that searched only on `FirstName (WHERE FirstName = 'Jane')`.</span></span>  
  
-   <span data-ttu-id="4ee79-215">계산 열의 인덱싱을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-215">Consider indexing computed columns.</span></span> <span data-ttu-id="4ee79-216">자세한 내용은 [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4ee79-216">For more information, see [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md).</span></span>  
  
### <a name="index-characteristics"></a><span data-ttu-id="4ee79-217">인덱스 특성</span><span class="sxs-lookup"><span data-stu-id="4ee79-217">Index Characteristics</span></span>  

 <span data-ttu-id="4ee79-218">인덱스가 쿼리에 적합하다고 판단되면 사용자의 상황에 가장 잘 맞는 인덱스 형식을 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-218">After you have determined that an index is appropriate for a query, you can select the type of index that best fits your situation.</span></span> <span data-ttu-id="4ee79-219">인덱스 특성은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-219">Index characteristics include the following:</span></span>  
  
-   <span data-ttu-id="4ee79-220">클러스터형 인덱스와 비클러스터형 인덱스</span><span class="sxs-lookup"><span data-stu-id="4ee79-220">Clustered versus nonclustered</span></span>  
  
-   <span data-ttu-id="4ee79-221">고유한 인덱스와 고유하지 않은 인덱스</span><span class="sxs-lookup"><span data-stu-id="4ee79-221">Unique versus nonunique</span></span>  
  
-   <span data-ttu-id="4ee79-222">하나의 열로 구성된 인덱스와 여러 열로 구성된 인덱스</span><span class="sxs-lookup"><span data-stu-id="4ee79-222">Single column versus multicolumn</span></span>  
  
-   <span data-ttu-id="4ee79-223">인덱스의 열에서 오름차순 또는 내림차순</span><span class="sxs-lookup"><span data-stu-id="4ee79-223">Ascending or descending order on the columns in the index</span></span>  
  
-   <span data-ttu-id="4ee79-224">전체 테이블과 비클러스터형 인덱스 필터링</span><span class="sxs-lookup"><span data-stu-id="4ee79-224">Full-table versus filtered for nonclustered indexes</span></span>  
  
 <span data-ttu-id="4ee79-225">FILLFACTOR 같은 옵션을 설정하면 인덱스의 초기 스토리지 특성을 사용자 지정하여 성능이나 유지 관리를 최적화할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-225">You can also customize the initial storage characteristics of the index to optimize its performance or maintenance by setting an option such as FILLFACTOR.</span></span> <span data-ttu-id="4ee79-226">또한 파일 그룹이나 파티션 구성표를 사용하면 인덱스 스토리지 위치를 확인하여 성능을 최적화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-226">Also, you can determine the index storage location by using filegroups or partition schemes to optimize performance.</span></span>  
  
###  <a name="index-placement-on-filegroups-or-partitions-schemes"></a><a name="Index_placement"></a> <span data-ttu-id="4ee79-227">파일 그룹의 인덱스 배치 또는 파티션 구성표</span><span class="sxs-lookup"><span data-stu-id="4ee79-227">Index Placement on Filegroups or Partitions Schemes</span></span>  

 <span data-ttu-id="4ee79-228">인덱스 디자인 전략을 개발할 때는 데이터베이스와 관련된 파일 그룹에 인덱스를 배치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-228">As you develop your index design strategy, you should consider the placement of the indexes on the filegroups associated with the database.</span></span> <span data-ttu-id="4ee79-229">파일 그룹이나 파티션 구성표를 주의 깊게 선택하면 쿼리 성능을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-229">Careful selection of the filegroup or partition scheme can improve query performance.</span></span>  
  
 <span data-ttu-id="4ee79-230">기본적으로 인덱스는 인덱스가 생성된 기본 테이블과 동일한 파일 그룹에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-230">By default, indexes are stored in the same filegroup as the base table on which the index is created.</span></span> <span data-ttu-id="4ee79-231">분할되지 않은 클러스터형 인덱스와 기본 테이블은 항상 동일한 파일 그룹 내에 위치합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-231">A nonpartitioned clustered index and the base table always reside in the same filegroup.</span></span> <span data-ttu-id="4ee79-232">그러나 다음과 같은 작업도 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-232">However, you can do the following:</span></span>  
  
-   <span data-ttu-id="4ee79-233">기본 테이블 또는 클러스터형 인덱스의 파일 그룹이 아닌 파일 그룹에 비클러스터형 인덱스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-233">Create nonclustered indexes on a filegroup other than the filegroup of the base table or clustered index.</span></span>  
  
-   <span data-ttu-id="4ee79-234">여러 파일 그룹에 걸쳐 클러스터형 및 비클러스터형 인덱스를 분할합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-234">Partition clustered and nonclustered indexes to span multiple filegroups.</span></span>  
  
-   <span data-ttu-id="4ee79-235">클러스터형 인덱스를 삭제한 후 새 파일 그룹이나 파티션 구성표를 DROP INDEX 문의 MOVE TO 절에 지정하거나 CREATE INDEX 문에 DROP_EXISTING 절을 사용하여 한 파일 그룹에서 다른 파일 그룹으로 테이블을 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-235">Move a table from one filegroup to another by dropping the clustered index and specifying a new filegroup or partition scheme in the MOVE TO clause of the DROP INDEX statement or by using the CREATE INDEX statement with the DROP_EXISTING clause.</span></span>  
  
 <span data-ttu-id="4ee79-236">다른 파일 그룹에서 자체의 컨트롤러를 가진 여러 개의 물리적 드라이브를 사용하는 경우에는 파일 그룹에 비클러스터형 인덱스를 만들어 성능 향상을 이룰 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-236">By creating the nonclustered index on a different filegroup, you can achieve performance gains if the filegroups are using different physical drives with their own controllers.</span></span> <span data-ttu-id="4ee79-237">그러면 데이터와 인덱스 정보를 여러 개의 디스크 헤드로 병렬로 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-237">Data and index information can then be read in parallel by the multiple disk heads.</span></span> <span data-ttu-id="4ee79-238">예를 들어 `Table_A` 파일 그룹의 `f1` 와 `Index_A` 파일 그룹의 `f2` 가 모두 같은 쿼리에서 사용되는 경우에는 두 파일 그룹이 모두 경합 없이 충분히 활용되므로 성능 향상이 이루어질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-238">For example, if `Table_A` on filegroup `f1` and `Index_A` on filegroup `f2` are both being used by the same query, performance gains can be achieved because both filegroups are being fully used without contention.</span></span> <span data-ttu-id="4ee79-239">하지만 `Table_A` 가 쿼리에서 검색되지만 `Index_A` 가 참조되지 않으면 `f1` 파일 그룹만 사용되므로</span><span class="sxs-lookup"><span data-stu-id="4ee79-239">However, if `Table_A` is scanned by the query but `Index_A` is not referenced, only filegroup `f1` is used.</span></span> <span data-ttu-id="4ee79-240">성능이 향상되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-240">This creates no performance gain.</span></span>  
  
 <span data-ttu-id="4ee79-241">앞으로 있을 액세스의 유형과 시점을 정확히 예측할 수는 없으므로 테이블과 인덱스를 모든 파일 그룹에 걸쳐 분산시키는 것이 더 안전합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-241">Because you cannot predict what type of access will occur and when it will occur, it could be a better decision to spread your tables and indexes across all filegroups.</span></span> <span data-ttu-id="4ee79-242">이렇게 하면 모든 데이터와 인덱스가 모든 디스크에 동일하게 분산되기 때문에 어떤 방식으로 데이터에 액세스하든지 모든 디스크에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-242">This would guarantee that all disks are being accessed because all data and indexes are spread evenly across all disks, regardless of which way the data is accessed.</span></span> <span data-ttu-id="4ee79-243">이는 시스템 관리자에게 더욱 간단한 방법이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-243">This is also a simpler approach for system administrators.</span></span>  
  
#### <a name="partitions-across-multiple-filegroups"></a><span data-ttu-id="4ee79-244">여러 파일 그룹에 걸친 파티션</span><span class="sxs-lookup"><span data-stu-id="4ee79-244">Partitions Across Multiple Filegroups</span></span>  

 <span data-ttu-id="4ee79-245">여러 파일 그룹에 걸쳐 클러스터형 및 비클러스터형 인덱스를 분할하는 것을 고려할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-245">You can also consider partitioning clustered and nonclustered indexes across multiple filegroups.</span></span> <span data-ttu-id="4ee79-246">분할된 인덱스는 파티션 함수를 기준으로 가로 또는 행으로 분할됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-246">Partitioned indexes are partitioned horizontally, or by row, based on a partition function.</span></span> <span data-ttu-id="4ee79-247">파티션 함수는 분할 열이라는 특정 열의 값을 기준으로 각 행이 파티션 집합에 매핑되는 방식을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-247">The partition function defines how each row is mapped to a set of partitions based on the values of certain columns, called partitioning columns.</span></span> <span data-ttu-id="4ee79-248">파티션 구성표는 파티션과 파일 그룹 간의 매핑을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-248">A partition scheme specifies the mapping of the partitions to a set of filegroups.</span></span>  
  
 <span data-ttu-id="4ee79-249">인덱스를 분할하면 다음 이점이 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-249">Partitioning an index can provide the following benefits:</span></span>  
  
-   <span data-ttu-id="4ee79-250">큰 인덱스를 보다 잘 관리할 수 있는 확장 가능한 시스템을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-250">Provide scalable systems that make large indexes more manageable.</span></span> <span data-ttu-id="4ee79-251">예를 들어 OLTP 시스템에서 파티션을 인식하며 큰 인덱스를 처리하는 애플리케이션을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-251">OLTP systems, for example, can implement partition-aware applications that deal with large indexes.</span></span>  
  
-   <span data-ttu-id="4ee79-252">쿼리가 보다 빠르고 효율적으로 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-252">Make queries run faster and more efficiently.</span></span> <span data-ttu-id="4ee79-253">쿼리가 인덱스의 여러 파티션을 액세스할 때 쿼리 최적화 프로그램은 동시에 여러 파티션을 처리하고 쿼리의 영향을 받지 않는 파티션을 제외할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-253">When queries access several partitions of an index, the query optimizer can process individual partitions at the same time and exclude partitions that are not affected by the query.</span></span>  
  
 <span data-ttu-id="4ee79-254">자세한 내용은 [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4ee79-254">For more information, see [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span></span>  
  
###  <a name="index-sort-order-design-guidelines"></a><a name="Sort_Order"></a> <span data-ttu-id="4ee79-255">인덱스 정렬 순서 디자인 지침</span><span class="sxs-lookup"><span data-stu-id="4ee79-255">Index Sort Order Design Guidelines</span></span>  

 <span data-ttu-id="4ee79-256">인덱스를 정의할 때 인덱스 키 열의 데이터를 오름차순으로 저장할지 또는 내림차순으로 저장할지 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-256">When defining indexes, you should consider whether the data for the index key column should be stored in ascending or descending order.</span></span> <span data-ttu-id="4ee79-257">오름차순이 기본값이며 이전 버전의 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]와의 호환성을 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-257">Ascending is the default and maintains compatibility with earlier versions of [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="4ee79-258">CREATE INDEX, CREATE TABLE 및 ALTER TABLE 문의 구문은 인덱스와 제약 조건의 개별 열에서 ASC(오름차순) 및 DESC(내림차순) 키워드를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-258">The syntax of the CREATE INDEX, CREATE TABLE, and ALTER TABLE statements supports the keywords ASC (ascending) and DESC (descending) on individual columns in indexes and constraints.</span></span>  
  
 <span data-ttu-id="4ee79-259">인덱스의 키 값 저장 순서를 지정하는 기능은 테이블을 참조하는 쿼리에 해당 인덱스에서 키 열의 다른 방향을 지정하는 ORDER BY 절이 포함된 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-259">Specifying the order in which key values are stored in an index is useful when queries referencing the table have ORDER BY clauses that specify different directions for the key column or columns in that index.</span></span> <span data-ttu-id="4ee79-260">이러한 경우 쿼리 계획에서 SORT 연산자를 사용할 필요가 없어지므로 쿼리의 효율성이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-260">In these cases, the index can remove the need for a SORT operator in the query plan; therefore, this makes the query more efficient.</span></span> <span data-ttu-id="4ee79-261">예를 들어 [!INCLUDE[ssSampleDBCoFull](../includes/sssampledbcofull-md.md)] 구매 부서의 구매자가 공급업체로부터 구입하는 제품 품질을 평가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-261">For example, the buyers in the [!INCLUDE[ssSampleDBCoFull](../includes/sssampledbcofull-md.md)] purchasing department have to evaluate the quality of products they purchase from vendors.</span></span> <span data-ttu-id="4ee79-262">구매자는 대부분 해당 공급업체에서 보낸 제품 중 거부율이 높은 제품을 찾으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-262">The buyers are most interested in finding products sent by these vendors with a high rejection rate.</span></span> <span data-ttu-id="4ee79-263">다음 쿼리와 같이 이 조건에 맞는 데이터를 검색하려면 `RejectedQty` 테이블의 `Purchasing.PurchaseOrderDetail` 열을 내림차순(큰 데이터부터 작은 데이터 순서)으로 정렬하고 `ProductID` 열은 오름차순(작은 데이터부터 큰 데이터 순서)으로 정렬해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-263">As shown in the following query, retrieving the data to meet this criteria requires the `RejectedQty` column in the `Purchasing.PurchaseOrderDetail` table to be sorted in descending order (large to small) and the `ProductID` column to be sorted in ascending order (small to large).</span></span>  
  
```sql
SELECT RejectedQty, ((RejectedQty/OrderQty)*100) AS RejectionRate,  
    ProductID, DueDate  
FROM Purchasing.PurchaseOrderDetail  
ORDER BY RejectedQty DESC, ProductID ASC;  
```  
  
 <span data-ttu-id="4ee79-264">이 쿼리에 대한 다음 실행 계획은 쿼리 최적화 프로그램에서 SORT 연산자를 사용하여 ORDER BY 절로 지정된 순서로 결과 집합을 반환했음을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-264">The following execution plan for this query shows that the query optimizer used a SORT operator to return the result set in the order specified by the ORDER BY clause.</span></span>  
  
 <span data-ttu-id="4ee79-265">![SORT 연산자가 사용됨을 보여 주는 실행 계획](media/indexsort1.gif "SORT 연산자가 사용됨을 보여 주는 실행 계획")</span><span class="sxs-lookup"><span data-stu-id="4ee79-265">![Execution plan shows a SORT operator is used.](media/indexsort1.gif "Execution plan shows a SORT operator is used.")</span></span>  
  
 <span data-ttu-id="4ee79-266">쿼리의 ORDER BY 절에 있는 것과 일치하는 키 열로 인덱스가 생성되는 경우 쿼리 계획에서 SORT 연산자를 제거하여 쿼리 계획의 효율성을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-266">If an index is created with key columns that match those in the ORDER BY clause in the query, the SORT operator can be eliminated in the query plan and the query plan is more efficient.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX IX_PurchaseOrderDetail_RejectedQty  
ON Purchasing.PurchaseOrderDetail  
    (RejectedQty DESC, ProductID ASC, DueDate, OrderQty);  
```  
  
 <span data-ttu-id="4ee79-267">쿼리가 다시 실행된 후 다음 실행 계획은 SORT 연산자가 제거되어 새로 생성된 비클러스터형 인덱스가 사용됨을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-267">After the query is executed again, the following execution plan shows that the SORT operator has been eliminated and the newly created nonclustered index is used.</span></span>  
  
 <span data-ttu-id="4ee79-268">![SORT 연산자가 사용되지 않음을 보여 주는 실행 계획](media/insertsort2.gif "SORT 연산자가 사용되지 않음을 보여 주는 실행 계획")</span><span class="sxs-lookup"><span data-stu-id="4ee79-268">![Execution plan shows a SORT operator is not used](media/insertsort2.gif "Execution plan shows a SORT operator is not used")</span></span>  
  
 <span data-ttu-id="4ee79-269">[!INCLUDE[ssDE](../includes/ssde-md.md)] 은 어느 방향으로든 동일하게 효율적으로 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-269">The [!INCLUDE[ssDE](../includes/ssde-md.md)] can move equally efficiently in either direction.</span></span> <span data-ttu-id="4ee79-270">ORDER BY 절에 있는 열의 정렬 방향이 반대가 되는 쿼리에도 `(RejectedQty DESC, ProductID ASC)` 로 정의된 인덱스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-270">An index defined as `(RejectedQty DESC, ProductID ASC)` can still be used for a query in which the sort direction of the columns in the ORDER BY clause are reversed.</span></span> <span data-ttu-id="4ee79-271">예를 들어 ORDER BY 절 `ORDER BY RejectedQty ASC, ProductID DESC` 를 포함하는 쿼리에 인덱스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-271">For example, a query with the ORDER BY clause `ORDER BY RejectedQty ASC, ProductID DESC` can use the index.</span></span>  
  
 <span data-ttu-id="4ee79-272">정렬 순서는 키 열에 대해서만 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-272">Sort order can be specified only for key columns.</span></span> <span data-ttu-id="4ee79-273">[sys.index_columns](/sql/relational-databases/system-catalog-views/sys-indexes-transact-sql) 카탈로그 뷰와 INDEXKEY_PROPERTY 함수는 인덱스 열이 오름차순으로 저장되는지 또는 내림차순으로 저장되는지 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-273">The [sys.index_columns](/sql/relational-databases/system-catalog-views/sys-indexes-transact-sql) catalog view and the INDEXKEY_PROPERTY function report whether an index column is stored in ascending or descending order.</span></span>  
  
 <span data-ttu-id="4ee79-274">[이 가이드의](#Top) ![맨 위 링크와 함께 사용 되는 화살표 아이콘](media/uparrow16x16.gif "맨 위로 이동 링크와 함께 사용되는 화살표 아이콘")</span><span class="sxs-lookup"><span data-stu-id="4ee79-274">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="clustered-index-design-guidelines"></a><a name="Clustered"></a> <span data-ttu-id="4ee79-275">클러스터형 인덱스 디자인 지침</span><span class="sxs-lookup"><span data-stu-id="4ee79-275">Clustered Index Design Guidelines</span></span>  

 <span data-ttu-id="4ee79-276">클러스터형 인덱스는 그 키 값에 기반하여 테이블에 데이터 행을 정렬하고 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-276">Clustered indexes sort and store the data rows in the table based on their key values.</span></span> <span data-ttu-id="4ee79-277">데이터 행은 자체적으로 하나의 순서로만 정렬될 수 있으므로 테이블당 클러스터형 인덱스가 하나만 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-277">There can only be one clustered index per table, because the data rows themselves can only be sorted in one order.</span></span> <span data-ttu-id="4ee79-278">일부 예외를 제외하고는 각 테이블에서 클러스터형 인덱스가 정의된 열은 다음과 같은 특성을 가져야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-278">With few exceptions, every table should have a clustered index defined on the column, or columns, that offer the following:</span></span>  
  
-   <span data-ttu-id="4ee79-279">자주 사용하는 쿼리에 대해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-279">Can be used for frequently used queries.</span></span>  
  
-   <span data-ttu-id="4ee79-280">높은 수준의 고유성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-280">Provide a high degree of uniqueness.</span></span>  
  
    > [!NOTE]  
    >  <span data-ttu-id="4ee79-281">PRIMARY KEY 제약 조건을 만들 때는 열에 고유 인덱스가 자동으로 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-281">When you create a PRIMARY KEY constraint, a unique index on the column, or columns, is automatically created.</span></span> <span data-ttu-id="4ee79-282">기본적으로 이 인덱스는 클러스터링되지만 제약 조건을 만들 때 비클러스터형 인덱스로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-282">By default, this index is clustered; however, you can specify a nonclustered index when you create the constraint.</span></span>  
  
-   <span data-ttu-id="4ee79-283">범위 쿼리에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-283">Can be used in range queries.</span></span>  
  
 <span data-ttu-id="4ee79-284">고유 속성을 사용 하 여 클러스터형 인덱스를 만들지 않은 경우는 [!INCLUDE[ssDE](../includes/ssde-md.md)] 테이블에 4 바이트 uniquifier 열을 자동으로 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-284">If the clustered index is not created with the UNIQUE property, the [!INCLUDE[ssDE](../includes/ssde-md.md)] automatically adds a 4-byte uniquifier column to the table.</span></span> <span data-ttu-id="4ee79-285">필요한 경우는 [!INCLUDE[ssDE](../includes/ssde-md.md)] 자동으로 uniquifier 값을 행에 추가 하 여 각 키를 고유 하 게 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-285">When it is required, the [!INCLUDE[ssDE](../includes/ssde-md.md)] automatically adds a uniquifier value to a row to make each key unique.</span></span> <span data-ttu-id="4ee79-286">이 열과 해당 값은 내부적으로 사용되며 사용자는 보거나 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-286">This column and its values are used internally and cannot be seen or accessed by users.</span></span>  
  
### <a name="clustered-index-architecture"></a><span data-ttu-id="4ee79-287">클러스터형 인덱스 아키텍처</span><span class="sxs-lookup"><span data-stu-id="4ee79-287">Clustered Index Architecture</span></span>  

 <span data-ttu-id="4ee79-288">[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]에서 인덱스는 B-트리로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-288">In [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], indexes are organized as B-trees.</span></span> <span data-ttu-id="4ee79-289">인덱스 B-트리의 각 페이지를 인덱스 노드라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-289">Each page in an index B-tree is called an index node.</span></span> <span data-ttu-id="4ee79-290">B-트리 맨 위 노드를 루트 노드라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-290">The top node of the B-tree is called the root node.</span></span> <span data-ttu-id="4ee79-291">인덱스의 최하위 노드를 리프 노드라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-291">The bottom nodes in the index are called the leaf nodes.</span></span> <span data-ttu-id="4ee79-292">루트 노드와 리프 노드 사이의 인덱스 수준을 통틀어 중간 수준이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-292">Any index levels between the root and the leaf nodes are collectively known as intermediate levels.</span></span> <span data-ttu-id="4ee79-293">클러스터형 인덱스의 리프 노드에는 기본 테이블의 데이터 페이지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-293">In a clustered index, the leaf nodes contain the data pages of the underlying table.</span></span> <span data-ttu-id="4ee79-294">루트 노드와 중간 수준 노드에는 인덱스 행을 포함하는 인덱스 페이지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-294">The root and intermediate level nodes contain index pages holding index rows.</span></span> <span data-ttu-id="4ee79-295">각 인덱스 행에는 키 값과 함께 B-트리의 중간 수준 페이지에 대한 포인터나 인덱스 리프 수준의 데이터 행에 대한 포인터가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-295">Each index row contains a key value and a pointer to either an intermediate level page in the B-tree, or a data row in the leaf level of the index.</span></span> <span data-ttu-id="4ee79-296">인덱스의 각 수준의 페이지는 이중 연결 목록에서 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-296">The pages in each level of the index are linked in a doubly-linked list.</span></span>  
  
 <span data-ttu-id="4ee79-297">클러스터형 인덱스에는 인덱스에서 사용하는 각 파티션에 대해 [index_id](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql)가 1인 **sys.partitions** 행이 하나 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-297">Clustered indexes have one row in [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql), with **index_id** = 1 for each partition used by the index.</span></span> <span data-ttu-id="4ee79-298">기본적으로 클러스터형 인덱스는 단일 파티션을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-298">By default, a clustered index has a single partition.</span></span> <span data-ttu-id="4ee79-299">클러스터형 인덱스가 다중 파티션을 사용하는 경우 각 파티션은 해당 특정 파티션에 대한 데이터를 포함하는 B-트리 구조를 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-299">When a clustered index has multiple partitions, each partition has a B-tree structure that contains the data for that specific partition.</span></span> <span data-ttu-id="4ee79-300">예를 들어 클러스터형 인덱스가 4개의 파티션을 사용하면 파티션마다 하나씩 총 4개의 B-트리 구조가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-300">For example, if a clustered index has four partitions, there are four B-tree structures; one in each partition.</span></span>  
  
 <span data-ttu-id="4ee79-301">클러스터형 인덱스의 데이터 형식에 따라 각 클러스터형 인덱스 구조에는 특정 파티션에 대한 데이터를 저장하고 관리하는 할당 단위가 하나 이상 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-301">Depending on the data types in the clustered index, each clustered index structure will have one or more allocation units in which to store and manage the data for a specific partition.</span></span> <span data-ttu-id="4ee79-302">최소한 각 클러스터형 인덱스에는 파티션당 하나의 IN_ROW_DATA 할당 단위가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-302">At a minimum, each clustered index will have one IN_ROW_DATA allocation unit per partition.</span></span> <span data-ttu-id="4ee79-303">또한 클러스터형 인덱스에는 LOB(Large Object) 열이 포함된 경우 파티션당 하나의 LOB_DATA 할당 단위가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-303">The clustered index will also have one LOB_DATA allocation unit per partition if it contains large object (LOB) columns.</span></span> <span data-ttu-id="4ee79-304">8,060바이트 행 크기 제한을 초과하는 가변 길이 열이 포함된 경우 파티션당 하나의 ROW_OVERFLOW_DATA 할당 단위도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-304">It will also have one ROW_OVERFLOW_DATA allocation unit per partition if it contains variable length columns that exceed the 8,060 byte row size limit.</span></span>  
  
 <span data-ttu-id="4ee79-305">데이터 체인의 페이지와 페이지 행은 클러스터형 인덱스 키의 값에 따라 정렬됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-305">The pages in the data chain and the rows in them are ordered on the value of the clustered index key.</span></span> <span data-ttu-id="4ee79-306">삽입된 행의 키 값이 기존 행 간의 순서대로 정렬될 때 모든 삽입이 끝납니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-306">All inserts are made at the point where the key value in the inserted row fits in the ordering sequence among existing rows.</span></span>  
  
 <span data-ttu-id="4ee79-307">이 그림에서는 단일 파티션의 클러스터형 인덱스 구조를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-307">This illustration shows the structure of a clustered index in a single partition.</span></span>  
  
 <span data-ttu-id="4ee79-308">![클러스터형 인덱스의 수준](media/bokind2.gif "클러스터형 인덱스의 수준")</span><span class="sxs-lookup"><span data-stu-id="4ee79-308">![Levels of a clustered index](media/bokind2.gif "Levels of a clustered index")</span></span>  
  
### <a name="query-considerations"></a><span data-ttu-id="4ee79-309">쿼리 고려 사항</span><span class="sxs-lookup"><span data-stu-id="4ee79-309">Query Considerations</span></span>  

 <span data-ttu-id="4ee79-310">클러스터형 인덱스를 만들기 전에 데이터가 액세스되는 방식을 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-310">Before you create clustered indexes, understand how your data will be accessed.</span></span> <span data-ttu-id="4ee79-311">다음을 수행하는 쿼리에는 클러스터형 인덱스를 사용하십시오.</span><span class="sxs-lookup"><span data-stu-id="4ee79-311">Consider using a clustered index for queries that do the following:</span></span>  
  
-   <span data-ttu-id="4ee79-312">BETWEEN, >, >=, < 및 <= 등의 연산자를 사용하여 일정한 범위의 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-312">Return a range of values by using operators such as BETWEEN, >, >=, <, and <=.</span></span>  
  
     <span data-ttu-id="4ee79-313">클러스터형 인덱스를 사용하여 첫 번째 값을 가진 행을 찾으면 다음의 인덱싱된 값은 반드시 물리적으로 인접해 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-313">After the row with the first value is found by using the clustered index, rows with subsequent indexed values are guaranteed to be physically adjacent.</span></span> <span data-ttu-id="4ee79-314">예를 들어 쿼리가 일정한 범위의 판매 주문 번호 간의 레코드를 검색하는 경우 `SalesOrderNumber` 열의 클러스터형 인덱스는 시작 판매 주문 번호가 포함된 행을 빠르게 찾은 후 마지막 판매 주문 번호에 도달할 때까지 테이블의 모든 연속된 행을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-314">For example, if a query retrieves records between a range of sales order numbers, a clustered index on the column `SalesOrderNumber` can quickly locate the row that contains the starting sales order number, and then retrieve all successive rows in the table until the last sales order number is reached.</span></span>  
  
-   <span data-ttu-id="4ee79-315">큰 결과 집합을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-315">Return large result sets.</span></span>  
  
-   <span data-ttu-id="4ee79-316">JOIN 절을 사용하며 일반적으로 외래 키 열입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-316">Use JOIN clauses; typically these are foreign key columns.</span></span>  
  
-   <span data-ttu-id="4ee79-317">ORDER BY 또는 GROUP BY 절을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-317">Use ORDER BY, or GROUP BY clauses.</span></span>  
  
     <span data-ttu-id="4ee79-318">ORDER BY 또는 GROUP BY 절에 지정된 열에서 인덱스를 만들면 행이 이미 정렬되어 있기 때문에 [!INCLUDE[ssDE](../includes/ssde-md.md)] 이 데이터를 정렬할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-318">An index on the columns specified in the ORDER BY or GROUP BY clause may remove the need for the [!INCLUDE[ssDE](../includes/ssde-md.md)] to sort the data, because the rows are already sorted.</span></span> <span data-ttu-id="4ee79-319">따라서 쿼리 성능도 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-319">This improves query performance.</span></span>  
  
### <a name="column-considerations"></a><span data-ttu-id="4ee79-320">열 고려 사항</span><span class="sxs-lookup"><span data-stu-id="4ee79-320">Column Considerations</span></span>  

 <span data-ttu-id="4ee79-321">특별한 상황이 아니라면 클러스터형 인덱스 키를 가능한 적은 열로 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-321">Generally, you should define the clustered index key with as few columns as possible.</span></span> <span data-ttu-id="4ee79-322">다음 중 하나 이상의 특성이 있는 열을 고려하십시오.</span><span class="sxs-lookup"><span data-stu-id="4ee79-322">Consider columns that have one or more of the following attributes:</span></span>  
  
-   <span data-ttu-id="4ee79-323">고유한 열이거나 고유한 값이 많음</span><span class="sxs-lookup"><span data-stu-id="4ee79-323">Are unique or contain many distinct values</span></span>  
  
     <span data-ttu-id="4ee79-324">예를 들어 직원 ID는 직원을 고유하게 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-324">For example, an employee ID uniquely identifies employees.</span></span> <span data-ttu-id="4ee79-325">`EmployeeID` 열에 클러스터형 인덱스나 PRIMARY KEY 제약 조건을 적용하면 직원 ID 번호로 직원 정보를 검색하는 쿼리 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-325">A clustered index or PRIMARY KEY constraint on the `EmployeeID` column would improve the performance of queries that search for employee information based on the employee ID number.</span></span> <span data-ttu-id="4ee79-326">또는 `LastName`, `FirstName`, `MiddleName` 에 클러스터형 인덱스를 생성할 수 있는데 이는 직원 레코드가 이러한 방법으로 자주 그룹화 및 쿼리되기 때문이며, 이러한 열을 결합하더라도 높은 수준의 고유성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-326">Alternatively, a clustered index could be created on `LastName`, `FirstName`, `MiddleName` because employee records are frequently grouped and queried in this way, and the combination of these columns would still provide a high degree of difference.</span></span>  
  
-   <span data-ttu-id="4ee79-327">순차적인 액세스</span><span class="sxs-lookup"><span data-stu-id="4ee79-327">Are accessed sequentially</span></span>  
  
     <span data-ttu-id="4ee79-328">예를 들어 `Production.Product` 데이터베이스에서 제품 ID는 [!INCLUDE[ssSampleDBobject](../includes/sssampledbobject-md.md)] 테이블의 제품을 고유하게 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-328">For example, a product ID uniquely identifies products in the `Production.Product` table in the [!INCLUDE[ssSampleDBobject](../includes/sssampledbobject-md.md)] database.</span></span> <span data-ttu-id="4ee79-329">`WHERE ProductID BETWEEN 980 and 999`와 같이 순차 검색이 지정된 쿼리라면 `ProductID`에 클러스터형 인덱스를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-329">Queries in which a sequential search is specified, such as `WHERE ProductID BETWEEN 980 and 999`, would benefit from a clustered index on `ProductID`.</span></span> <span data-ttu-id="4ee79-330">이는 해당 키 열에 행이 정렬되어 저장되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-330">This is because the rows would be stored in sorted order on that key column.</span></span>  
  
-   <span data-ttu-id="4ee79-331">IDENTITY로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-331">Defined as IDENTITY.</span></span>  
  
-   <span data-ttu-id="4ee79-332">테이블에서 검색된 데이터를 정렬하는 데 자주 사용됨</span><span class="sxs-lookup"><span data-stu-id="4ee79-332">Used frequently to sort the data retrieved from a table.</span></span>  
  
     <span data-ttu-id="4ee79-333">해당 열의 테이블을 클러스터링, 즉 물리적으로 정렬하면 열을 쿼리할 때마다 정렬 작업 비용을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-333">It can be a good idea to cluster, that is physically sort, the table on that column to save the cost of a sort operation every time the column is queried.</span></span>  
  
 <span data-ttu-id="4ee79-334">다음과 같은 특성에는 클러스터형 인덱스를 사용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-334">Clustered indexes are not a good choice for the following attributes:</span></span>  
  
-   <span data-ttu-id="4ee79-335">자주 변경되는 열</span><span class="sxs-lookup"><span data-stu-id="4ee79-335">Columns that undergo frequent changes</span></span>  
  
     <span data-ttu-id="4ee79-336">이렇게 하면에서 [!INCLUDE[ssDE](../includes/ssde-md.md)] 행의 데이터 값을 실제 순서로 유지 해야 하기 때문에 전체 행이 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-336">This causes the whole row to move, because the [!INCLUDE[ssDE](../includes/ssde-md.md)] must keep the data values of a row in physical order.</span></span> <span data-ttu-id="4ee79-337">다음은 일반적으로 데이터가 불안정한 대량 트랜잭션 처리 시스템에서 고려해야 할 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-337">This is an important consideration in high-volume transaction processing systems in which data is typically volatile.</span></span>  
  
-   <span data-ttu-id="4ee79-338">다양한 키</span><span class="sxs-lookup"><span data-stu-id="4ee79-338">Wide keys</span></span>  
  
     <span data-ttu-id="4ee79-339">다양한 키는 여러 열 또는 크기가 큰 여러 열이 합쳐진 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-339">Wide keys are a composite of several columns or several large-size columns.</span></span> <span data-ttu-id="4ee79-340">클러스터형 인덱스로 구한 키 값은 모든 비클러스터형 인덱스에 의해 조회 키로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-340">The key values from the clustered index are used by all nonclustered indexes as lookup keys.</span></span> <span data-ttu-id="4ee79-341">비클러스터형 인덱스 항목에는 클러스터링 키와 함께 해당 비클러스터형 인덱스에 대해 정의된 키 열도 포함되기 때문에 동일한 테이블에 정의된 비클러스터형 인덱스가 훨씬 큽니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-341">Any nonclustered indexes defined on the same table will be significantly larger because the nonclustered index entries contain the clustering key and also the key columns defined for that nonclustered index.</span></span>  
  
 <span data-ttu-id="4ee79-342">[이 가이드의](#Top) ![맨 위 링크와 함께 사용 되는 화살표 아이콘](media/uparrow16x16.gif "맨 위로 이동 링크와 함께 사용되는 화살표 아이콘")</span><span class="sxs-lookup"><span data-stu-id="4ee79-342">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="nonclustered-index-design-guidelines"></a><a name="Nonclustered"></a> <span data-ttu-id="4ee79-343">비클러스터형 인덱스 디자인 지침</span><span class="sxs-lookup"><span data-stu-id="4ee79-343">Nonclustered Index Design Guidelines</span></span>  

 <span data-ttu-id="4ee79-344">비클러스터형 인덱스에는 테이블 데이터의 스토리지 위치를 가리키는 행 로케이터와 인덱스 키 값이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-344">A nonclustered index contains the index key values and row locators that point to the storage location of the table data.</span></span> <span data-ttu-id="4ee79-345">테이블 또는 인덱싱된 뷰에 비클러스터형 인덱스를 여러 개 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-345">You can create multiple nonclustered indexes on a table or indexed view.</span></span> <span data-ttu-id="4ee79-346">일반적으로 클러스터형 인덱스를 적용할 수 없고 자주 사용되는 쿼리의 성능을 개선하도록 비클러스터형 인덱스를 디자인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-346">Generally, nonclustered indexes should be designed to improve the performance of frequently used queries that are not covered by the clustered index.</span></span>  
  
 <span data-ttu-id="4ee79-347">책에서 색인을 사용하는 것처럼 쿼리 최적화 프로그램은 비클러스터형 인덱스를 검색하여 테이블에서 데이터 값의 위치를 찾고 해당 위치에서 데이터를 직접 검색하는 방식으로 데이터 값을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-347">Similar to the way you use an index in a book, the query optimizer searches for a data value by searching the nonclustered index to find the location of the data value in the table and then retrieves the data directly from that location.</span></span> <span data-ttu-id="4ee79-348">비클러스터형 인덱스에는 쿼리에서 검색하는 데이터 값에 대한 테이블의 정확한 위치를 설명하는 항목이 있기 때문에 정확히 일치하는 값을 찾는 쿼리에는 비클러스터형 인덱스가 가장 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-348">This makes nonclustered indexes the optimal choice for exact match queries because the index contains entries describing the exact location in the table of the data values being searched for in the queries.</span></span> <span data-ttu-id="4ee79-349">예를 들어 `HumanResources. Employee` 테이블에서 특정 관리자에게 보고하는 모든 직원을 쿼리하면 쿼리 최적화 프로그램은 `IX_Employee_ManagerID`가 키 열인 비클러스터형 인덱스 `ManagerID` 를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-349">For example, to query the `HumanResources. Employee` table for all employees that report to a specific manager, the query optimizer might use the nonclustered index `IX_Employee_ManagerID`; this has `ManagerID` as its key column.</span></span> <span data-ttu-id="4ee79-350">쿼리 최적화 프로그램은 인덱스에서 지정된 `ManagerID`와 일치하는 모든 항목을 빠르게 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-350">The query optimizer can quickly find all entries in the index that match the specified `ManagerID`.</span></span> <span data-ttu-id="4ee79-351">각 인덱스 항목은 해당 데이터를 찾을 수 있는 클러스터형 인덱스나 테이블의 정확한 페이지와 행을 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-351">Each index entry points to the exact page and row in the table, or clustered index, in which the corresponding data can be found.</span></span> <span data-ttu-id="4ee79-352">쿼리 최적화 프로그램은 인덱스에서 모든 항목을 찾은 후 정확한 페이지와 행으로 직접 이동하여 데이터를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-352">After the query optimizer finds all entries in the index, it can go directly to the exact page and row to retrieve the data.</span></span>  
  
### <a name="nonclustered-index-architecture"></a><span data-ttu-id="4ee79-353">비클러스터형 인덱스 아키텍처</span><span class="sxs-lookup"><span data-stu-id="4ee79-353">Nonclustered Index Architecture</span></span>  

 <span data-ttu-id="4ee79-354">비클러스터형 인덱스는 다음의 두 가지 주요 차이점을 제외하고 클러스터형 인덱스와 동일한 B-트리 구조를 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-354">Nonclustered indexes have the same B-tree structure as clustered indexes, except for the following significant differences:</span></span>  
  
-   <span data-ttu-id="4ee79-355">기본 테이블의 데이터 행은 비클러스터형 키 기반의 순서대로 정렬되거나 저장되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-355">The data rows of the underlying table are not sorted and stored in order based on their nonclustered keys.</span></span>  
  
-   <span data-ttu-id="4ee79-356">비클러스터형 인덱스의 리프 계층은 데이터 페이지 대신 인덱스 페이지로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-356">The leaf layer of a nonclustered index is made up of index pages instead of data pages.</span></span>  
  
 <span data-ttu-id="4ee79-357">비클러스터형 인덱스 행의 행 로케이터는 다음과 같이 행에 대한 포인터이거나 행에 대한 클러스터형 인덱스 키입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-357">The row locators in nonclustered index rows are either a pointer to a row or are a clustered index key for a row, as described in the following:</span></span>  
  
-   <span data-ttu-id="4ee79-358">테이블이 힙인 경우, 즉 테이블에 클러스터형 인덱스가 없는 경우 행 로케이터는 행에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-358">If the table is a heap, which means it does not have a clustered index, the row locator is a pointer to the row.</span></span> <span data-ttu-id="4ee79-359">포인터는 파일 ID, 페이지 번호 및 페이지의 행 번호로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-359">The pointer is built from the file identifier (ID), page number, and number of the row on the page.</span></span> <span data-ttu-id="4ee79-360">전체 포인터를 RID(행 ID)라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-360">The whole pointer is known as a Row ID (RID).</span></span>  
  
-   <span data-ttu-id="4ee79-361">테이블에 클러스터형 인덱스가 있거나 인덱스가 인덱싱된 뷰에 있는 경우 행 로케이터는 행에 대한 클러스터형 인덱스 키입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-361">If the table has a clustered index, or the index is on an indexed view, the row locator is the clustered index key for the row.</span></span>  
  
 <span data-ttu-id="4ee79-362">비클러스터형 인덱스에는 인덱스에서 사용하는 각 파티션에 대해 **index_id** >1인 [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql) 행이 하나 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-362">Nonclustered indexes have one row in [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql) with **index_id** >1 for each partition used by the index.</span></span> <span data-ttu-id="4ee79-363">기본적으로 비클러스터형 인덱스는 단일 파티션을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-363">By default, a nonclustered index has a single partition.</span></span> <span data-ttu-id="4ee79-364">비클러스터형 인덱스가 다중 파티션을 사용하는 경우 각 파티션은 해당 특정 파티션에 대한 인덱스 행을 포함하는 B-트리 구조를 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-364">When a nonclustered index has multiple partitions, each partition has a B-tree structure that contains the index rows for that specific partition.</span></span> <span data-ttu-id="4ee79-365">예를 들어 비클러스터형 인덱스가 4개의 파티션을 사용하면 파티션마다 하나씩 총 4개의 B-트리 구조가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-365">For example, if a nonclustered index has four partitions, there are four B-tree structures, with one in each partition.</span></span>  
  
 <span data-ttu-id="4ee79-366">비클러스터형 인덱스의 데이터 형식에 따라 각 비클러스터형 인덱스 구조에는 특정 파티션에 대한 데이터를 저장하고 관리하는 할당 단위가 하나 이상 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-366">Depending on the data types in the nonclustered index, each nonclustered index structure will have one or more allocation units in which to store and manage the data for a specific partition.</span></span> <span data-ttu-id="4ee79-367">최소한 각 비클러스터형 인덱스에는 인덱스 B-트리 페이지를 저장하는 파티션당 하나의 IN_ROW_DATA 할당 단위가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-367">At a minimum, each nonclustered index will have one IN_ROW_DATA allocation unit per partition that stores the index B-tree pages.</span></span> <span data-ttu-id="4ee79-368">또한 비클러스터형 인덱스에는 LOB(Large Object) 열이 포함된 경우 파티션당 하나의 LOB_DATA 할당 단위가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-368">The nonclustered index will also have one LOB_DATA allocation unit per partition if it contains large object (LOB) columns .</span></span> <span data-ttu-id="4ee79-369">8,060바이트 행 크기 제한을 초과하는 가변 길이 열이 포함된 경우 파티션당 하나의 ROW_OVERFLOW_DATA 할당 단위도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-369">Additionally, it will have one ROW_OVERFLOW_DATA allocation unit per partition if it contains variable length columns that exceed the 8,060 byte row size limit.</span></span>  
  
 <span data-ttu-id="4ee79-370">다음 그림에서는 단일 파티션의 비클러스터형 인덱스 구조를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-370">The following illustration shows the structure of a nonclustered index in a single partition.</span></span>  
  
 <span data-ttu-id="4ee79-371">![비클러스터형 인덱스의 수준](media/bokind1.gif "비클러스터형 인덱스의 수준")</span><span class="sxs-lookup"><span data-stu-id="4ee79-371">![Levels of a nonclustered index](media/bokind1.gif "Levels of a nonclustered index")</span></span>  
  
### <a name="database-considerations"></a><span data-ttu-id="4ee79-372">데이터베이스 고려 사항</span><span class="sxs-lookup"><span data-stu-id="4ee79-372">Database Considerations</span></span>  

 <span data-ttu-id="4ee79-373">비클러스터형 인덱스를 디자인할 때 데이터베이스의 특징을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-373">Consider the characteristics of the database when designing nonclustered indexes.</span></span>  
  
-   <span data-ttu-id="4ee79-374">자주 업데이트하지는 않지만 데이터가 많은 데이터베이스나 테이블의 경우 비클러스터형 인덱스가 많으면 쿼리 성능이 향상될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-374">Databases or tables with low update requirements, but large volumes of data can benefit from many nonclustered indexes to improve query performance.</span></span> <span data-ttu-id="4ee79-375">전체 테이블 비클러스터형 인덱스에 비해 인덱스 유지 관리 비용을 줄이고, 인덱스 스토리지 비용을 줄이고, 쿼리 성능을 향상시킬 수 있도록 데이터의 잘 정의된 하위 집합에 대한 필터링된 인덱스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-375">Consider creating filtered indexes for well-defined subsets of data to improve query performance, reduce index storage costs, and reduce index maintenance costs compared with full-table nonclustered indexes.</span></span>  
  
     <span data-ttu-id="4ee79-376">읽기 전용 데이터를 주로 포함하는 의사 결정 지원 시스템 애플리케이션 및 데이터베이스의 경우에도 비클러스터형 인덱스가 많으면 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-376">Decision Support System applications and databases that contain primarily read-only data can benefit from many nonclustered indexes.</span></span> <span data-ttu-id="4ee79-377">쿼리 최적화 프로그램에서 가장 빠른 액세스 방법을 결정할 때 선택할 수 있는 인덱스가 늘어나며 데이터베이스가 자주 업데이트되지 않으므로 인덱스 유지 관리로 인해 성능이 저하되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-377">The query optimizer has more indexes to choose from to determine the fastest access method, and the low update characteristics of the database mean index maintenance will not impede performance.</span></span>  
  
-   <span data-ttu-id="4ee79-378">자주 업데이트되는 테이블을 포함하는 온라인 트랜잭션 처리 애플리케이션 및 데이터베이스의 경우에는 너무 많이 인덱싱하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-378">Online Transaction Processing applications and databases that contain heavily updated tables should avoid over-indexing.</span></span> <span data-ttu-id="4ee79-379">또한 인덱스는 가능한 적은 수의 열을 포함하는 좁은 인덱스여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-379">Additionally, indexes should be narrow, that is, with as few columns as possible.</span></span>  
  
     <span data-ttu-id="4ee79-380">테이블에 대한 인덱스를 많이 만들면 테이블의 데이터가 변경될 경우 인덱스도 모두 적절하게 조정되어야 하므로 INSERT, UPDATE, DELETE 및 MERGE 문의 성능이 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-380">Large numbers of indexes on a table affect the performance of INSERT, UPDATE, DELETE, and MERGE  statements because all indexes must be adjusted appropriately as data in the table changes.</span></span>  
  
### <a name="query-considerations"></a><span data-ttu-id="4ee79-381">쿼리 고려 사항</span><span class="sxs-lookup"><span data-stu-id="4ee79-381">Query Considerations</span></span>  

 <span data-ttu-id="4ee79-382">비클러스터형 인덱스를 만들기 전에 데이터가 액세스되는 방법을 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-382">Before you create nonclustered indexes, you should understand how your data will be accessed.</span></span> <span data-ttu-id="4ee79-383">다음과 같은 특성이 있는 쿼리의 경우 비클러스터형 인덱스 사용을 고려하십시오.</span><span class="sxs-lookup"><span data-stu-id="4ee79-383">Consider using a nonclustered index for queries that have the following attributes:</span></span>  
  
-   <span data-ttu-id="4ee79-384">JOIN 또는 GROUP BY 절을 사용하는 쿼리</span><span class="sxs-lookup"><span data-stu-id="4ee79-384">Use JOIN or GROUP BY clauses.</span></span>  
  
     <span data-ttu-id="4ee79-385">조인 및 그룹화 작업과 관련된 열에는 비클러스터형 인덱스를 여러 개 만들고 외래 키 열에는 클러스터형 인덱스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-385">Create multiple nonclustered indexes on columns involved in join and grouping operations, and a clustered index on any foreign key columns.</span></span>  
  
-   <span data-ttu-id="4ee79-386">큰 결과 집합을 반환하지 않는 쿼리</span><span class="sxs-lookup"><span data-stu-id="4ee79-386">Queries that do not return large result sets.</span></span>  
  
     <span data-ttu-id="4ee79-387">대형 테이블에서 행의 잘 정의된 하위 집합을 반환하는 쿼리를 처리하는 필터링된 인덱스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-387">Create filtered indexes to cover queries that return a well-defined subset of rows from a large table.</span></span>  
  
-   <span data-ttu-id="4ee79-388">WHERE 절과 같이 정확히 일치하는 값을 반환하는 쿼리의 검색 조건에 자주 사용되는 열을 포함하는 쿼리</span><span class="sxs-lookup"><span data-stu-id="4ee79-388">Contain columns frequently involved in search conditions of a query, such as WHERE clause, that return exact matches.</span></span>  
  
### <a name="column-considerations"></a><span data-ttu-id="4ee79-389">열 고려 사항</span><span class="sxs-lookup"><span data-stu-id="4ee79-389">Column Considerations</span></span>  

 <span data-ttu-id="4ee79-390">비클러스터형 인덱스를 만들 때 열에 대한 다음 특성을 고려하십시오.</span><span class="sxs-lookup"><span data-stu-id="4ee79-390">Consider columns that have one or more of these attributes:</span></span>  
  
-   <span data-ttu-id="4ee79-391">쿼리에 사용되는 열 모두 포함</span><span class="sxs-lookup"><span data-stu-id="4ee79-391">Cover the query.</span></span>  
  
     <span data-ttu-id="4ee79-392">인덱스에 쿼리의 모든 열이 포함되어 있으면 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-392">Performance gains are achieved when the index contains all columns in the query.</span></span> <span data-ttu-id="4ee79-393">쿼리 최적화 프로그램이 인덱스에서 모든 열 값을 찾을 수 있으므로 테이블이나 클러스터형 인덱스에 액세스하지 않아 디스크 I/O 작업이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-393">The query optimizer can locate all the column values within the index; table or clustered index data is not accessed resulting in fewer disk I/O operations.</span></span> <span data-ttu-id="4ee79-394">넓은 인덱스 키를 만드는 대신 포괄 열이 있는 인덱스를 사용하여 인덱스 범위에 해당하는 열을 늘립니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-394">Use index with included columns to add covering columns instead of creating a wide index key.</span></span>  
  
     <span data-ttu-id="4ee79-395">테이블에 클러스터형 인덱스가 있으면 클러스터형 인덱스에 정의된 열이 자동으로 테이블의 각 비클러스터형 인덱스 끝에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-395">If the table has a clustered index, the column or columns defined in the clustered index are automatically appended to the end of each nonclustered index on the table.</span></span> <span data-ttu-id="4ee79-396">이를 통해 비클러스터형 인덱스 정의에 클러스터형 인덱스 열을 지정하지 않고도 쿼리에 사용되는 열이 모두 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-396">This can produce a covered query without specifying the clustered index columns in the definition of the nonclustered index.</span></span> <span data-ttu-id="4ee79-397">예를 들어 테이블 `C`열에 대한 클러스터형 인덱스가 있을 경우 `B` 및 `A` 열에 대한 비클러스터형 인덱스의 키 값 열은 `B`, `A`, 및 `C`가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-397">For example, if a table has a clustered index on column `C`, a nonclustered index on columns `B` and `A` will have as its key values columns `B`, `A`, and `C`.</span></span>  
  
-   <span data-ttu-id="4ee79-398">클러스터형 인덱스가 다른 열에 사용되는 경우 성과 이름의 조합 같은 고유 값 많이 포함</span><span class="sxs-lookup"><span data-stu-id="4ee79-398">Lots of distinct values, such as a combination of last name and first name, if a clustered index is used for other columns.</span></span>  
  
     <span data-ttu-id="4ee79-399">1과 0만으로 구성되는 경우와 같이 고유 값이 매우 적으면 대개 테이블 검색이 더 효율적이므로 대부분의 쿼리에서 인덱스를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-399">If there are very few distinct values, such as only 1 and 0, most queries will not use the index because a table scan is generally more efficient.</span></span> <span data-ttu-id="4ee79-400">이 데이터 형식의 경우 적은 수의 행에서만 발생하는 고유 값에 필터링된 인덱스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-400">For this type of data, consider creating a filtered index on a distinct value that only occurs in a small number of rows.</span></span> <span data-ttu-id="4ee79-401">예를 들어 대부분의 값이 0인 경우 쿼리 최적화 프로그램에서는 1을 포함하는 데이터 행에 대해 필터링된 인덱스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-401">For example, if most of the values are 0, the query optimizer might use a filtered index for the data rows that contain 1.</span></span>  
  
####  <a name="use-included-columns-to-extend-nonclustered-indexes"></a><a name="Included_Columns"></a> <span data-ttu-id="4ee79-402">포괄 열을 사용하여 비클러스터형 인덱스 확장</span><span class="sxs-lookup"><span data-stu-id="4ee79-402">Use Included Columns to Extend Nonclustered Indexes</span></span>  

 <span data-ttu-id="4ee79-403">비클러스터형 인덱스의 리프 수준에 키가 아닌 열을 추가하여 비클러스터형 인덱스의 기능을 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-403">You can extend the functionality of nonclustered indexes by adding nonkey columns to the leaf level of the nonclustered index.</span></span> <span data-ttu-id="4ee79-404">키가 아닌 열을 포함하여 여러 쿼리를 처리하는 비클러스터형 인덱스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-404">By including nonkey columns, you can create nonclustered indexes that cover more queries.</span></span> <span data-ttu-id="4ee79-405">이는 키가 아닌 열에 다음과 같은 장점이 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-405">This is because the nonkey columns have the following benefits:</span></span>  
  
-   <span data-ttu-id="4ee79-406">키가 아닌 열은 인덱스 키 열로 사용할 수 없는 데이터 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-406">They can be data types not allowed as index key columns.</span></span>  
  
-   <span data-ttu-id="4ee79-407">인덱스 키 열의 수 또는 인덱스 키 크기를 계산할 때 [!INCLUDE[ssDE](../includes/ssde-md.md)] 은 키가 아닌 열을 고려하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-407">They are not considered by the [!INCLUDE[ssDE](../includes/ssde-md.md)] when calculating the number of index key columns or index key size.</span></span>  
  
 <span data-ttu-id="4ee79-408">쿼리의 모든 열이 키 또는 키가 아닌 열로 인덱스에 포함될 때 키가 아닌 포괄 열이 있는 인덱스는 쿼리 성능을 상당히 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-408">An index with included nonkey columns can significantly improve query performance when all columns in the query are included in the index either as key or nonkey columns.</span></span> <span data-ttu-id="4ee79-409">성능이 향상되는 이유는 쿼리 최적화 프로그램이 테이블 또는 클러스터형 인덱스 데이터에 액세스하지 않고 인덱스 내에서 모든 열 값을 찾을 수 있으므로 디스크 I/O 작업을 줄어들기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-409">Performance gains are achieved because the query optimizer can locate all the column values within the index; table or clustered index data is not accessed resulting in fewer disk I/O operations.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="4ee79-410">인덱스에 쿼리가 참조하는 모든 열이 들어 있으면 일반적으로 이 인덱스는 쿼리를 포함한다고 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-410">When an index contains all the columns referenced by the query it is typically referred to as covering the query.</span></span>  
  
 <span data-ttu-id="4ee79-411">키 열은 모든 수준의 인덱스에 저장되지만 키가 아닌 열은 리프 수준에만 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-411">While key columns are stored at all levels of the index, nonkey columns are stored only at the leaf level.</span></span>  
  
##### <a name="using-included-columns-to-avoid-size-limits"></a><span data-ttu-id="4ee79-412">크기 제한을 피하기 위한 포괄 열 사용</span><span class="sxs-lookup"><span data-stu-id="4ee79-412">Using Included Columns to Avoid Size Limits</span></span>  

 <span data-ttu-id="4ee79-413">비클러스터형 인덱스에 키가 아닌 열을 포함시키면 현재 인덱스 크기 제한인 최대 16개의 키 열 및 최대 900바이트의 인덱스 키 크기가 초과되는 것을 피할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-413">You can include nonkey columns in a nonclustered index to avoid exceeding the current index size limitations of a maximum of 16 key columns and a maximum index key size of 900 bytes.</span></span> <span data-ttu-id="4ee79-414">인덱스 키 열의 수 또는 인덱스 키 크기를 계산할 때 [!INCLUDE[ssDE](../includes/ssde-md.md)] 은 키가 아닌 열은 계산하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-414">The [!INCLUDE[ssDE](../includes/ssde-md.md)] does not consider nonkey columns when calculating the number of index key columns or index key size.</span></span>  
  
 <span data-ttu-id="4ee79-415">예를 들어 `Document` 테이블에서 다음 열을 인덱싱하려는 경우를 가정해 봅니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-415">For example, assume that you want to index the following columns in the `Document` table:</span></span>  
  
 `Title nvarchar(50)`  
  
 `Revision nchar(5)`  
  
 `FileName nvarchar(400)`  
  
 <span data-ttu-id="4ee79-416">`nchar` 및 `nvarchar` 데이터 형식은 각 문자에 대해 2바이트가 필요하므로 위의 3열이 포함된 인덱스는 900바이트의 크기 제한을 10바이트 초과하게 됩니다(455 \* 2).</span><span class="sxs-lookup"><span data-stu-id="4ee79-416">Because the `nchar` and `nvarchar` data types require 2 bytes for each character, an index that contains these three columns would exceed the 900 byte size limitation by 10 bytes (455 \* 2).</span></span> <span data-ttu-id="4ee79-417">`INCLUDE` 문의 `CREATE INDEX` 절을 사용하면 인덱스 키는 (`Title, Revision`)으로 정의되고 `FileName` 은 키가 아닌 열로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-417">By using the `INCLUDE` clause of the `CREATE INDEX` statement, the index key could be defined as (`Title, Revision`) and `FileName` defined as a nonkey column.</span></span> <span data-ttu-id="4ee79-418">이 방법으로 인덱스 키 크기는 110바이트(55 \* 2)가 되며 인덱스는 필요한 모든 열을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-418">In this way, the index key size would be 110 bytes (55 \* 2), and the index would still contain all the required columns.</span></span> <span data-ttu-id="4ee79-419">다음 문은 이와 같은 인덱스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-419">The following statement creates such an index.</span></span>  
  
```sql
CREATE INDEX IX_Document_Title   
ON Production.Document (Title, Revision)   
INCLUDE (FileName);   
```  
  
##### <a name="index-with-included-columns-guidelines"></a><span data-ttu-id="4ee79-420">포괄 열이 있는 인덱스 지침</span><span class="sxs-lookup"><span data-stu-id="4ee79-420">Index with Included Columns Guidelines</span></span>  

 <span data-ttu-id="4ee79-421">포괄 열이 있는 비클러스터형 인덱스를 디자인하는 경우 다음 지침을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-421">When you design nonclustered indexes with included columns consider the following guidelines:</span></span>  
  
-   <span data-ttu-id="4ee79-422">키가 아닌 열은 CREATE INDEX 문의 INCLUDE 절에서 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-422">Nonkey columns are defined in the INCLUDE clause of the CREATE INDEX statement.</span></span>  
  
-   <span data-ttu-id="4ee79-423">키가 아닌 열은 테이블 또는 인덱싱된 뷰의 비클러스터형 인덱스에서만 정의될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-423">Nonkey columns can only be defined on nonclustered indexes on tables or indexed views.</span></span>  
  
-   <span data-ttu-id="4ee79-424">`text`, `ntext` 및 `image`를 제외한 모든 데이터 형식을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-424">All data types are allowed except `text`, `ntext`, and `image`.</span></span>  
  
-   <span data-ttu-id="4ee79-425">결정적이면서 정확하거나 정확하지 않은 계산 열은 포괄 열이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-425">Computed columns that are deterministic and either precise or imprecise can be included columns.</span></span> <span data-ttu-id="4ee79-426">자세한 내용은 [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4ee79-426">For more information, see [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md).</span></span>  
  
-   <span data-ttu-id="4ee79-427">키 열과 마찬가지로 `image`, `ntext` 및 `text` 데이터 형식에서 파생된 계산 열은 계산 열 데이터 형식이 키가 아닌 인덱스 열로 허용되는 동안 키가 아닌 포괄 열이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-427">As with key columns, computed columns derived from `image`, `ntext`, and `text` data types can be nonkey (included) columns as long as the computed column data type is allowed as a nonkey index column.</span></span>  
  
-   <span data-ttu-id="4ee79-428">열 이름은 INCLUDE 목록 및 키 열 목록 모두에서 지정될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-428">Column names cannot be specified in both the INCLUDE list and in the key column list.</span></span>  
  
-   <span data-ttu-id="4ee79-429">열 이름은 INCLUDE 목록에서 반복될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-429">Column names cannot be repeated in the INCLUDE list.</span></span>  
  
##### <a name="column-size-guidelines"></a><span data-ttu-id="4ee79-430">열 크기 지침</span><span class="sxs-lookup"><span data-stu-id="4ee79-430">Column Size Guidelines</span></span>  
  
-   <span data-ttu-id="4ee79-431">적어도 하나의 키 열을 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-431">At least one key column must be defined.</span></span> <span data-ttu-id="4ee79-432">키가 아닌 열의 최대 수는 1023입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-432">The maximum number of nonkey columns is 1023 columns.</span></span> <span data-ttu-id="4ee79-433">이 값은 테이블 열의 최대 수보다 1이 적습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-433">This is the maximum number of table columns minus 1.</span></span>  
  
-   <span data-ttu-id="4ee79-434">키가 아닌 열을 제외한 인덱스 키 열은 최대 16개의 키 열 및 최대 900바이트의 전체 인덱스 키 크기인 기존 인덱스 크기 제한을 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-434">Index key columns, excluding nonkeys, must follow the existing index size restrictions of 16 key columns maximum, and a total index key size of 900 bytes.</span></span>  
  
-   <span data-ttu-id="4ee79-435">키가 아닌 모든 열의 전체 크기는 INCLUDE 절에 지정된 열의 크기에 의해서만 제한됩니다. 예를 들어 `varchar(max)` 열은 2GB로 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-435">The total size of all nonkey columns is limited only by the size of the columns specified in the INCLUDE clause; for example, `varchar(max)` columns are limited to 2 GB.</span></span>  
  
##### <a name="column-modification-guidelines"></a><span data-ttu-id="4ee79-436">열 수정 지침</span><span class="sxs-lookup"><span data-stu-id="4ee79-436">Column Modification Guidelines</span></span>  

 <span data-ttu-id="4ee79-437">포괄 열로 정의된 테이블 열을 수정하는 경우 다음 제한 사항이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-437">When you modify a table column that has been defined as an included column, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="4ee79-438">인덱스를 먼저 삭제하지 않으면 키가 아닌 열을 테이블에서 삭제할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-438">Nonkey columns cannot be dropped from the table unless the index is dropped first.</span></span>  
  
-   <span data-ttu-id="4ee79-439">다음 경우를 제외하고 키가 아닌 열은 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-439">Nonkey columns cannot be changed, except to do the following:</span></span>  
  
    -   <span data-ttu-id="4ee79-440">열의 Null 허용 여부를 NOT NULL에서 NULL로 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-440">Change the nullability of the column from NOT NULL to NULL.</span></span>  
  
    -   <span data-ttu-id="4ee79-441">`varchar`, `nvarchar` 또는 `varbinary` 열의 길이를 늘립니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-441">Increase the length of `varchar`, `nvarchar`, or `varbinary` columns.</span></span>  
  
        > [!NOTE]  
        >  <span data-ttu-id="4ee79-442">이러한 열 수정 제한도 인덱스 키 열에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-442">These column modification restrictions also apply to index key columns.</span></span>  
  
##### <a name="design-recommendations"></a><span data-ttu-id="4ee79-443">디자인 권장 구성</span><span class="sxs-lookup"><span data-stu-id="4ee79-443">Design Recommendations</span></span>  

 <span data-ttu-id="4ee79-444">검색 및 조회에 사용된 열만 키 열이 되도록 인덱스 키 크기가 큰 비클러스터형 인덱스를 다시 디자인합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-444">Redesign nonclustered indexes with a large index key size so that only columns used for searching and lookups are key columns.</span></span> <span data-ttu-id="4ee79-445">쿼리를 포함한 다른 모든 열을 키가 아닌 포괄 열로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-445">Make all other columns that cover the query included nonkey columns.</span></span> <span data-ttu-id="4ee79-446">이 방법을 통해 쿼리를 포함하는 데 필요한 모든 열을 가지게 되지만 인덱스 키 자체는 작으며 효과적입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-446">In this way, you will have all columns needed to cover the query, but the index key itself is small and efficient.</span></span>  
  
 <span data-ttu-id="4ee79-447">예를 들어 다음 쿼리를 포함하는 인덱스를 디자인하려는 경우를 가정해 봅니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-447">For example, assume that you want to design an index to cover the following query.</span></span>  
  
```sql
SELECT AddressLine1, AddressLine2, City, StateProvinceID, PostalCode  
FROM Person.Address  
WHERE PostalCode BETWEEN N'98000' and N'99999';  
```  
  
 <span data-ttu-id="4ee79-448">쿼리를 포함하려면 인덱스에서 각 열을 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-448">To cover the query, each column must be defined in the index.</span></span> <span data-ttu-id="4ee79-449">모든 열을 키 열로 정의할 수 있지만 키 크기는 334바이트가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-449">Although you could define all columns as key columns, the key size would be 334 bytes.</span></span> <span data-ttu-id="4ee79-450">실제 검색 조건으로 사용된 유일한 열은 길이가 30바이트인 `PostalCode` 열이므로 더 나은 인덱스 디자인은 `PostalCode` 를 키 열로 정의하고 다른 모든 열을 키가 아닌 열로 포함시킵니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-450">Because the only column actually used as search criteria is the `PostalCode` column, having a length of 30 bytes, a better index design would define `PostalCode` as the key column and include all other columns as nonkey columns.</span></span>  
  
 <span data-ttu-id="4ee79-451">다음 문은 포괄 열이 있는 인덱스를 만들어 쿼리를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-451">The following statement creates an index with included columns to cover the query.</span></span>  
  
```sql
CREATE INDEX IX_Address_PostalCode  
ON Person.Address (PostalCode)  
INCLUDE (AddressLine1, AddressLine2, City, StateProvinceID);  
```  
  
##### <a name="performance-considerations"></a><span data-ttu-id="4ee79-452">성능 고려 사항</span><span class="sxs-lookup"><span data-stu-id="4ee79-452">Performance Considerations</span></span>  

 <span data-ttu-id="4ee79-453">불필요한 열은 추가하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="4ee79-453">Avoid adding unnecessary columns.</span></span> <span data-ttu-id="4ee79-454">키 또는 키가 아닌 인덱스 열을 너무 많이 추가하면 다음과 같이 성능에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-454">Adding too many index columns, key or nonkey, can have the following performance implications:</span></span>  
  
-   <span data-ttu-id="4ee79-455">인덱스 행을 줄이면 한 페이지에 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-455">Fewer index rows will fit on a page.</span></span> <span data-ttu-id="4ee79-456">이로 인해 I/O가 증가되고 캐시 효율성이 떨어집니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-456">This could create I/O increases and reduced cache efficiency.</span></span>  
  
-   <span data-ttu-id="4ee79-457">인덱스를 저장할 디스크 공간이 더 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-457">More disk space will be required to store the index.</span></span> <span data-ttu-id="4ee79-458">특히 `varchar(max)`, `nvarchar(max)`, `varbinary(max)` 또는 `xml` 데이터 형식을 키가 아닌 인덱스 열로 추가하면 상당히 많은 디스크 공간이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-458">In particular, adding `varchar(max)`, `nvarchar(max)`, `varbinary(max)`, or `xml` data types as nonkey index columns may significantly increase disk space requirements.</span></span> <span data-ttu-id="4ee79-459">이는 열 값이 인덱스 리프 수준으로 복사되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-459">This is because the column values are copied into the index leaf level.</span></span> <span data-ttu-id="4ee79-460">따라서 열 값은 인덱스 및 기본 테이블 모두에 존재합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-460">Therefore, they reside in both the index and the base table.</span></span>  
  
-   <span data-ttu-id="4ee79-461">인덱스 유지 관리를 위해 기본 테이블 또는 인덱싱된 뷰에 대해 수정, 삽입, 업데이트 또는 삭제하는 시간이 늘어납니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-461">Index maintenance may increase the time that it takes to perform modifications, inserts, updates, or deletes, to the underlying table or indexed view.</span></span>  
  
 <span data-ttu-id="4ee79-462">데이터를 수정해야 할지, 디스크 공간을 추가할지 결정할 때 성능에 미치는 영향과 쿼리 성능 향상 중 어느 것이 더 중요한지를 결정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-462">You will have to determine whether the gains in query performance outweigh the affect to performance during data modification and in additional disk space requirements.</span></span>  
  
 <span data-ttu-id="4ee79-463">[이 가이드의](#Top) ![맨 위 링크와 함께 사용 되는 화살표 아이콘](media/uparrow16x16.gif "맨 위로 이동 링크와 함께 사용되는 화살표 아이콘")</span><span class="sxs-lookup"><span data-stu-id="4ee79-463">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="unique-index-design-guidelines"></a><a name="Unique"></a> <span data-ttu-id="4ee79-464">고유 인덱스 디자인 지침</span><span class="sxs-lookup"><span data-stu-id="4ee79-464">Unique Index Design Guidelines</span></span>  

 <span data-ttu-id="4ee79-465">고유 인덱스는 인덱스 키에 중복 값을 포함할 수 없으므로 테이블의 모든 행이 고유합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-465">A unique index guarantees that the index key contains no duplicate values and therefore every row in the table is in some way unique.</span></span> <span data-ttu-id="4ee79-466">고유 인덱스를 지정하는 것은 데이터 자체가 고유하다는 특성이 있을 때만 의미가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-466">Specifying a unique index makes sense only when uniqueness is a characteristic of the data itself.</span></span> <span data-ttu-id="4ee79-467">예를 들어 기본 키가 `NationalIDNumber` 인 경우 `HumanResources.Employee` 테이블의 `EmployeeID`열 값이 고유하도록 하려면 `NationalIDNumber` 열에 대해 UNIQUE 제약 조건을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-467">For example, if you want to make sure that the values in the `NationalIDNumber` column in the `HumanResources.Employee` table are unique, when the primary key is `EmployeeID`, create a UNIQUE constraint on the `NationalIDNumber` column.</span></span> <span data-ttu-id="4ee79-468">사용자가 이 열에서 두 명 이상의 직원에 대해 동일한 값을 입력하면 오류 메시지가 표시되고 중복된 값이 입력되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-468">If the user tries to enter the same value in that column for more than one employee, an error message is displayed and the duplicate value is not entered.</span></span>  
  
 <span data-ttu-id="4ee79-469">여러 열로 구성된 고유 인덱스를 사용하면 인덱스 키의 각 값 조합이 고유합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-469">With multicolumn unique indexes, the index guarantees that each combination of values in the index key is unique.</span></span> <span data-ttu-id="4ee79-470">예를 들어 `LastName`, `FirstName`및 `MiddleName` 열의 조합에 대해 고유 인덱스를 만들면 테이블에 있는 각 행에서 이러한 열의 값 조합이 모두 서로 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-470">For example, if a unique index is created on a combination of `LastName`, `FirstName`, and `MiddleName` columns, no two rows in the table could have the same combination of values for these columns.</span></span>  
  
 <span data-ttu-id="4ee79-471">클러스터형 인덱스와 비클러스터형 인덱스 모두 고유 인덱스가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-471">Both clustered and nonclustered indexes can be unique.</span></span> <span data-ttu-id="4ee79-472">따라서 열의 데이터가 고유하면 같은 테이블에서 하나의 고유 클러스터형 인덱스와 여러 개의 고유 비클러스터형 인덱스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-472">Provided that the data in the column is unique, you can create both a unique clustered index and multiple unique nonclustered indexes on the same table.</span></span>  
  
 <span data-ttu-id="4ee79-473">고유 인덱스의 장점은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-473">The benefits of unique indexes include the following:</span></span>  
  
-   <span data-ttu-id="4ee79-474">정의된 열의 데이터 무결성이 보장됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-474">Data integrity of the defined columns is ensured.</span></span>  
  
-   <span data-ttu-id="4ee79-475">쿼리 최적화 프로그램에 유용한 추가 정보가 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-475">Additional information helpful to the query optimizer is provided.</span></span>  
  
 <span data-ttu-id="4ee79-476">PRIMARY KEY 또는 UNIQUE 제약 조건을 만들면 지정된 열에서 고유 인덱스가 자동으로 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-476">Creating a PRIMARY KEY or UNIQUE constraint automatically creates a unique index on the specified columns.</span></span> <span data-ttu-id="4ee79-477">UNIQUE 제약 조건을 만드는 것과 제약 조건의 영향을 받지 않는 고유 인덱스를 만드는 것에는 큰 차이가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-477">There are no significant differences between creating a UNIQUE constraint and creating a unique index independent of a constraint.</span></span> <span data-ttu-id="4ee79-478">데이터 유효성 검사가 동일한 방식으로 수행되고 쿼리 최적화 프로그램에서는 제약 조건에 의해 생성된 고유 인덱스와 수동으로 만든 고유 인덱스를 동일하게 취급합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-478">Data validation occurs in the same manner and the query optimizer does not differentiate between a unique index created by a constraint or manually created.</span></span> <span data-ttu-id="4ee79-479">그러나 데이터 무결성을 유지하는 것이 목적일 때는 열에 UNIQUE 또는 PRIMARY KEY 제약 조건을 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-479">However, you should create a UNIQUE or PRIMARY KEY constraint on the column when data integrity is the objective.</span></span> <span data-ttu-id="4ee79-480">그렇게 함으로써 인덱스의 용도가 명확해집니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-480">By doing this the objective of the index will be clear.</span></span>  
  
### <a name="considerations"></a><span data-ttu-id="4ee79-481">고려 사항</span><span class="sxs-lookup"><span data-stu-id="4ee79-481">Considerations</span></span>  
  
-   <span data-ttu-id="4ee79-482">데이터에 중복된 키 값이 있으면 고유 인덱스, UNIQUE 제약 조건 또는 PRIMARY KEY 제약 조건을 만들 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-482">A unique index, UNIQUE constraint, or PRIMARY KEY constraint cannot be created if duplicate key values exist in the data.</span></span>  
  
-   <span data-ttu-id="4ee79-483">데이터가 고유한 경우 고유성을 강제로 적용하려면 같은 열 조합에 고유하지 않은 인덱스 대신 고유 인덱스를 만들면 쿼리 최적화 프로그램에 추가 정보가 제공되어 실행 계획의 효율성이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-483">If the data is unique and you want uniqueness enforced, creating a unique index instead of a nonunique index on the same combination of columns provides additional information for the query optimizer that can produce more efficient execution plans.</span></span> <span data-ttu-id="4ee79-484">이 경우 가급적 UNIQUE 제약 조건을 만들어 고유 인덱스를 만드는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-484">Creating a unique index (preferably by creating a UNIQUE constraint) is recommended in this case.</span></span>  
  
-   <span data-ttu-id="4ee79-485">고유 비클러스터형 인덱스에는 키가 아닌 포괄 열이 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-485">A unique nonclustered index can contain included nonkey columns.</span></span> <span data-ttu-id="4ee79-486">자세한 내용은 [포괄 열이 있는 인덱스](#Included_Columns)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="4ee79-486">For more information, see [Index with Included Columns](#Included_Columns).</span></span>  
  
 <span data-ttu-id="4ee79-487">[이 가이드의](#Top) ![맨 위 링크와 함께 사용 되는 화살표 아이콘](media/uparrow16x16.gif "맨 위로 이동 링크와 함께 사용되는 화살표 아이콘")</span><span class="sxs-lookup"><span data-stu-id="4ee79-487">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="filtered-index-design-guidelines"></a><a name="Filtered"></a> <span data-ttu-id="4ee79-488">필터링된 인덱스 디자인 지침</span><span class="sxs-lookup"><span data-stu-id="4ee79-488">Filtered Index Design Guidelines</span></span>  

 <span data-ttu-id="4ee79-489">필터링된 인덱스는 특히 데이터의 잘 정의된 하위 집합에서 선택하는 쿼리를 처리하는 데 적합한 최적화된 비클러스터형 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-489">A filtered index is an optimized nonclustered index, especially suited to cover queries that select from a well-defined subset of data.</span></span> <span data-ttu-id="4ee79-490">이 인덱스에서는 필터 조건자를 사용하여 테이블의 일부 행을 인덱싱합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-490">It uses a filter predicate to index a portion of rows in the table.</span></span> <span data-ttu-id="4ee79-491">잘 디자인된 필터링된 인덱스는 전체 테이블 인덱스에 비해 쿼리 성능을 개선하고 인덱스 유지 관리 비용과 인덱스 스토리지 비용을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-491">A well-designed filtered index can improve query performance, reduce index maintenance costs, and reduce index storage costs compared with full-table indexes.</span></span>  
  
||  
|-|  
|<span data-ttu-id="4ee79-492">**적용 대상**: [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] 부터 [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)]까지</span><span class="sxs-lookup"><span data-stu-id="4ee79-492">**Applies to**: [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] through [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span>|  
  
 <span data-ttu-id="4ee79-493">필터링된 인덱스는 전체 테이블 인덱스에 비해 다음과 같은 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-493">Filtered indexes can provide the following advantages over full-table indexes:</span></span>  
  
-   <span data-ttu-id="4ee79-494">**향상된 쿼리 성능 및 계획 품질**</span><span class="sxs-lookup"><span data-stu-id="4ee79-494">**Improved query performance and plan quality**</span></span>  
  
     <span data-ttu-id="4ee79-495">잘 디자인된 필터링된 인덱스는 전체 테이블 비클러스터형 인덱스보다 크기가 작고 필터링된 통계가 있기 때문에 쿼리 성능 및 실행 계획 품질이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-495">A well-designed filtered index improves query performance and execution plan quality because it is smaller than a full-table nonclustered index and has filtered statistics.</span></span> <span data-ttu-id="4ee79-496">필터링된 통계는 필터링된 인덱스의 행만 처리하기 때문에 전체 테이블 통계보다 정확합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-496">The filtered statistics are more accurate than full-table statistics because they cover only the rows in the filtered index.</span></span>  
  
-   <span data-ttu-id="4ee79-497">**줄어든 인덱스 유지 관리 비용**</span><span class="sxs-lookup"><span data-stu-id="4ee79-497">**Reduced index maintenance costs**</span></span>  
  
     <span data-ttu-id="4ee79-498">인덱스의 DML(데이터 조작 언어) 문이 데이터에 영향을 줄 때에만 인덱스가 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-498">An index is maintained only when data manipulation language (DML) statements affect the data in the index.</span></span> <span data-ttu-id="4ee79-499">필터링된 인덱스는 크기가 더 작고 인덱스의 데이터가 영향을 받을 때에만 유지 관리되기 때문에 전체 테이블 비클러스터형 인덱스에 비해 인덱스 유지 관리 비용이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-499">A filtered index reduces index maintenance costs compared with a full-table nonclustered index because it is smaller and is only maintained when the data in the index is affected.</span></span> <span data-ttu-id="4ee79-500">특히 영향을 자주 받지 않는 데이터를 포함하는 경우에는 수많은 필터링된 인덱스가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-500">It is possible to have a large number of filtered indexes, especially when they contain data that is affected infrequently.</span></span> <span data-ttu-id="4ee79-501">마찬가지로 필터링된 인덱스에는 자주 영향을 받는 데이터만 들어 있을 경우 보다 작은 크기의 인덱스가 통계를 업데이트하는 비용을 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-501">Similarly, if a filtered index contains only the frequently affected data, the smaller size of the index reduces the cost of updating the statistics.</span></span>  
  
-   <span data-ttu-id="4ee79-502">**줄어든 인덱스 스토리지 비용**</span><span class="sxs-lookup"><span data-stu-id="4ee79-502">**Reduced index storage costs**</span></span>  
  
     <span data-ttu-id="4ee79-503">필터링된 인덱스를 만들면 전체 테이블 인덱스가 필요하지 않은 경우 비클러스터형 인덱스의 디스크 스토리지를 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-503">Creating a filtered index can reduce disk storage for nonclustered indexes when a full-table index is not necessary.</span></span> <span data-ttu-id="4ee79-504">스토리지 요구 사항을 크게 증가시키지 않고 전체 테이블 비클러스터형 인덱스를 여러 필터링된 인덱스로 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-504">You can replace a full-table nonclustered index with multiple filtered indexes without significantly increasing the storage requirements.</span></span>  
  
 <span data-ttu-id="4ee79-505">필터링된 인덱스는 쿼리가 SELECT 문에서 참조하는 데이터의 잘 정의된 하위 집합이 열에 포함되는 경우 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-505">Filtered indexes are useful when columns contain well-defined subsets of data that queries reference in SELECT statements.</span></span> <span data-ttu-id="4ee79-506">예:</span><span class="sxs-lookup"><span data-stu-id="4ee79-506">Examples are:</span></span>  
  
-   <span data-ttu-id="4ee79-507">몇 개의 NULL이 아닌 값만 포함하는 스파스 열</span><span class="sxs-lookup"><span data-stu-id="4ee79-507">Sparse columns that contain only a few non-NULL values.</span></span>  
  
-   <span data-ttu-id="4ee79-508">포함하는 데이터의 범주가 서로 다른 열</span><span class="sxs-lookup"><span data-stu-id="4ee79-508">Heterogeneous columns that contain categories of data.</span></span>  
  
-   <span data-ttu-id="4ee79-509">달러 금액, 시간 및 날짜와 같은 값의 범위를 포함하는 열</span><span class="sxs-lookup"><span data-stu-id="4ee79-509">Columns that contain ranges of values such as dollar amounts, time, and dates.</span></span>  
  
-   <span data-ttu-id="4ee79-510">열 값에 대해 간단한 비교 논리로 정의되는 테이블 파티션</span><span class="sxs-lookup"><span data-stu-id="4ee79-510">Table partitions that are defined by simple comparison logic for column values.</span></span>  
  
 <span data-ttu-id="4ee79-511">필터링된 인덱스에 대해 줄어든 유지 관리 비용은 인덱스의 행 수가 전체 테이블 인덱스에 비해 적을 때 가장 분명하게 드러납니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-511">Reduced maintenance costs for filtered indexes are most noticeable when the number of rows in the index is small compared with a full-table index.</span></span> <span data-ttu-id="4ee79-512">필터링된 인덱스에 테이블의 열이 대부분 포함되어 있을 경우 전체 테이블 인덱스보다 유지 관리 비용이 더 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-512">If the filtered index includes most of the rows in the table, it could cost more to maintain than a full-table index.</span></span> <span data-ttu-id="4ee79-513">이런 경우 필터링된 인덱스 대신 전체 테이블 인덱스를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-513">In this case, you should use a full-table index instead of a filtered index.</span></span>  
  
 <span data-ttu-id="4ee79-514">필터링된 인덱스는 하나의 테이블에서 정의되고 간단한 비교 논리만 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-514">Filtered indexes are defined on one table and only support simple comparison operators.</span></span> <span data-ttu-id="4ee79-515">여러 테이블을 참조하거나 복잡한 논리를 사용하는 필터 식이 필요할 경우 뷰를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-515">If you need a filter expression that references multiple tables or has complex logic, you should create a view.</span></span>  
  
### <a name="design-considerations"></a><span data-ttu-id="4ee79-516">디자인 고려 사항</span><span class="sxs-lookup"><span data-stu-id="4ee79-516">Design Considerations</span></span>  

 <span data-ttu-id="4ee79-517">효과적인 필터링된 인덱스를 디자인하려면 애플리케이션이 사용하는 쿼리와 이 쿼리가 데이터의 하위 집합과 어떻게 연결되는지를 이해하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-517">In order to design effective filtered indexes, it is important to understand what queries your application uses and how they relate to subsets of your data.</span></span> <span data-ttu-id="4ee79-518">잘 정의된 하위 집합이 있는 데이터의 몇 가지 예로는 대개 NULL 값이 있는 열, 범주가 다른 값이 있는 열 및 특정 범위의 값이 있는 열이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-518">Some examples of data that have well-defined subsets are columns with mostly NULL values, columns with heterogeneous categories of values and columns with distinct ranges of values.</span></span> <span data-ttu-id="4ee79-519">다음의 디자인 고려 사항은 전체 테이블 인덱스에 비해 필터링된 인덱스가 이점이 있을 경우에 다양한 시나리오를 제공해 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-519">The following design considerations give a variety of scenarios for when a filtered index can provide advantages over full-table indexes.</span></span>  
  
#### <a name="filtered-indexes-for-subsets-of-data"></a><span data-ttu-id="4ee79-520">데이터의 하위 집합에 대한 필터링된 인덱스</span><span class="sxs-lookup"><span data-stu-id="4ee79-520">Filtered Indexes for Subsets of Data</span></span>  

 <span data-ttu-id="4ee79-521">열에 적은 수의 쿼리 관련 값만 있는 경우 값의 하위 집합에 필터링된 인덱스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-521">When a column only has a small number of relevant values for queries, you can create a filtered index on the subset of values.</span></span> <span data-ttu-id="4ee79-522">예를 들어 열에 있는 값이 대부분 NULL이고 쿼리는 NULL이 아닌 값에서만 선택하는 경우 NULL이 아닌 데이터 행에 대한 필터링된 인덱스를 만들 수 잇습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-522">For example, when the values in a column are mostly NULL and the query selects only from the non-NULL values, you can create a filtered index for the non-NULL data rows.</span></span> <span data-ttu-id="4ee79-523">결과 인덱스는 같은 키 열에서 정의된 전체 테이블 비클러스터형 인덱스에 비해 크기가 더 작고 유지 관리하는 비용이 더 적게 듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-523">The resulting index will be smaller and cost less to maintain than a full-table nonclustered index defined on the same key columns.</span></span>  
  
 <span data-ttu-id="4ee79-524">예를 들어 `AdventureWorks2012` 데이터베이스에는 2,679개의 행이 있는 `Production.BillOfMaterials` 테이블이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-524">For example, the `AdventureWorks2012` database has a `Production.BillOfMaterials` table with 2679 rows.</span></span> <span data-ttu-id="4ee79-525">`EndDate` 열에는 199개의 행만 NULL이 아닌 값이 들어 있고 나머지 2,480개의 행에는 NULL이 들어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-525">The `EndDate` column has only 199 rows that contain a non-NULL value and the other 2480 rows contain NULL.</span></span> <span data-ttu-id="4ee79-526">다음 필터링된 인덱스는 이 인덱스에서 정의된 열을 반환하고 `EndDate`에 필요한 NULL이 아닌 값이 있는 행만 선택하는 쿼리를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-526">The following filtered index would cover queries that return the columns defined in the index and that select only rows with a non-NULL value for `EndDate`.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX FIBillOfMaterialsWithEndDate  
    ON Production.BillOfMaterials (ComponentID, StartDate)  
    WHERE EndDate IS NOT NULL ;  
GO  
```  
  
 <span data-ttu-id="4ee79-527">필터링된 인덱스 `FIBillOfMaterialsWithEndDate` 는 다음 쿼리에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-527">The filtered index `FIBillOfMaterialsWithEndDate` is valid for the following query.</span></span> <span data-ttu-id="4ee79-528">이 필터링된 인덱스가 쿼리 최적화 프로그램에서 사용되는지 확인하기 위해 쿼리 실행 계획을 표시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-528">You can display the query execution plan to determine if the query optimizer used the filtered index.</span></span>  
  
```sql
SELECT ProductAssemblyID, ComponentID, StartDate   
FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL   
    AND ComponentID = 5   
    AND StartDate > '20080101' ;  
```  
  
 <span data-ttu-id="4ee79-529">필터링된 인덱스를 만드는 방법 및 필터링된 인덱스 조건자 식을 정의하는 방법은 [Create Filtered Indexes](../relational-databases/indexes/create-filtered-indexes.md)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="4ee79-529">For more information about how to create filtered indexes and how to define the filtered index predicate expression, see [Create Filtered Indexes](../relational-databases/indexes/create-filtered-indexes.md).</span></span>  
  
#### <a name="filtered-indexes-for-heterogeneous-data"></a><span data-ttu-id="4ee79-530">서로 다른 데이터에 대한 필터링된 인덱스</span><span class="sxs-lookup"><span data-stu-id="4ee79-530">Filtered Indexes for Heterogeneous Data</span></span>  

 <span data-ttu-id="4ee79-531">테이블에 다른 유형의 데이터 행이 있는 경우 하나 이상의 데이터 범주에 대한 필터링된 인덱스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-531">When a table has heterogeneous data rows, you can create a filtered index for one or more categories of data.</span></span>  
  
 <span data-ttu-id="4ee79-532">예를 들어 `Production.Product` 테이블에 나열된 제품은 각각 `ProductSubcategoryID`에 지정된 다음 제품 범주 Bikes, Components, Clothing 또는 Accessories 같은 제품 범주와 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-532">For example, the products listed in the `Production.Product` table are each assigned to a `ProductSubcategoryID`, which are in turn associated with the product categories Bikes, Components, Clothing, or Accessories.</span></span> <span data-ttu-id="4ee79-533">`Production.Product` 테이블에 있는 해당 열 값이 서로 유사하지 않기 때문에 이러한 범주는 서로 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-533">These categories are heterogeneous because their column values in the `Production.Product` table are not closely correlated.</span></span> <span data-ttu-id="4ee79-534">예를 들어 `Color`, `ReorderPoint`, `ListPrice`, `Weight`, `Class`및 `Style` 열에는 각 제품 범주에 대한 고유한 특징이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-534">For example, the columns `Color`, `ReorderPoint`, `ListPrice`, `Weight`, `Class`, and `Style` have unique characteristics for each product category.</span></span> <span data-ttu-id="4ee79-535">27개에서 36개의 하위 범주가 있는 Accessories에 쿼리가 자주 수행된다고 가정해 봅니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-535">Suppose that there are frequent queries for accessories which have subcategories between 27 and 36 inclusive.</span></span> <span data-ttu-id="4ee79-536">다음 예와 같이 Accessories 하위 범주에 필터링된 인덱스를 만들어 Accessories에 대한 쿼리의 성능을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-536">You can improve the performance of queries for accessories by creating a filtered index on the accessories subcategories as shown in the following example.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX FIProductAccessories  
    ON Production.Product (ProductSubcategoryID, ListPrice)   
        Include (Name)  
WHERE ProductSubcategoryID >= 27 AND ProductSubcategoryID <= 36;
```  
  
 <span data-ttu-id="4ee79-537">쿼리 결과는 인덱스에 포함되고 기본 테이블 조회는 쿼리 계획에 포함되지 않으므로 필터링된 인덱스 `FIProductAccessories` 는</span><span class="sxs-lookup"><span data-stu-id="4ee79-537">The filtered index `FIProductAccessories` covers the following query because the query</span></span>  
  
 <span data-ttu-id="4ee79-538">필터링된 인덱스 FIProductAccessories는 다음 쿼리에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-538">results are contained in the index and the query plan does not include a base table lookup.</span></span> <span data-ttu-id="4ee79-539">예를 들어 쿼리 조건자 식 `ProductSubcategoryID = 33` 은 필터링된 인덱스 조건자 `ProductSubcategoryID >= 27` 및 `ProductSubcategoryID <= 36`의 하위 집합이고 쿼리 조건자의 `ProductSubcategoryID` 및 `ListPrice` 열은 모두 인덱스의 키 열이며 이름은 인덱스의 리프 수준에 포괄 열로 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-539">For example, the query predicate expression `ProductSubcategoryID = 33` is a subset of the filtered index predicate `ProductSubcategoryID >= 27` and `ProductSubcategoryID <= 36`, the `ProductSubcategoryID` and `ListPrice` columns in the query predicate are both key columns in the index, and name is stored in the leaf level of the index as an included column.</span></span>  
  
```sql
SELECT Name, ProductSubcategoryID, ListPrice  
FROM Production.Product  
WHERE ProductSubcategoryID = 33 AND ListPrice > 25.00 ;  
```  
  
#### <a name="key-columns"></a><span data-ttu-id="4ee79-540">키 열</span><span class="sxs-lookup"><span data-stu-id="4ee79-540">Key Columns</span></span>  

 <span data-ttu-id="4ee79-541">적은 수의 키 또는 포괄 열을 필터링된 인덱스 정의에 포함하고 쿼리 최적화 프로그램에 필요한 열만 통합하여 쿼리 실행 계획에 대한 필터링된 인덱스를 선택하는 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-541">It is a best practice to include a small number of key or included columns in a filtered index definition, and to incorporate only the columns that are necessary for the query optimizer to choose the filtered index for the query execution plan.</span></span> <span data-ttu-id="4ee79-542">쿼리 최적화 프로그램에서는 필터링된 인덱스의 쿼리 처리 여부에 상관없이 쿼리에 대한 필터링된 인덱스를 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-542">The query optimizer can choose a filtered index for the query regardless of whether it does or does not cover the query.</span></span> <span data-ttu-id="4ee79-543">그러나 쿼리 최적화 프로그램에서는 필터링된 인덱스가 쿼리를 처리할 경우 필터링된 인덱스를 선택할 가능성이 커집니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-543">However, the query optimizer is more likely to choose a filtered index if it covers the query.</span></span>  
  
 <span data-ttu-id="4ee79-544">경우에 따라 필터링된 인덱스는 필터링된 인덱스 식에 필터링된 인덱스 정의의 포괄 열 또는 키로 열을 포함하지 않고 쿼리를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-544">In some cases, a filtered index covers the query without including the columns in the filtered index expression as key or included columns in the filtered index definition.</span></span> <span data-ttu-id="4ee79-545">다음 지침은 필터링된 인덱스 식의 열이 필터링된 인덱스 정의의 포괄 열 또는 키여야 하는 경우에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-545">The following guidelines explain when a column in the filtered index expression should be a key or included column in the filtered index definition.</span></span> <span data-ttu-id="4ee79-546">이 예에서는 앞에서 만든 필터링된 인덱스 `FIBillOfMaterialsWithEndDate` 를 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-546">The examples refer to the filtered index, `FIBillOfMaterialsWithEndDate` that was created previously.</span></span>  
  
 <span data-ttu-id="4ee79-547">필터링된 인덱스 식이 쿼리 조건자와 같고 쿼리가 쿼리 결과로 필터링된 인덱스 식의 열을 반환하지 않는다면 필터링된 인덱스 식의 열이 필터링된 인덱스 정의의 포괄 열 또는 키여야 할 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-547">A column in the filtered index expression does not need to be a key or included column in the filtered index definition if the filtered index expression is equivalent to the query predicate and the query does not return the column in the filtered index expression with the query results.</span></span> <span data-ttu-id="4ee79-548">예를 들어 다음 쿼리 조건자가 필터 식과 같고 `FIBillOfMaterialsWithEndDate` 가 쿼리 결과로 반환되지 않기 때문에 `EndDate` 는 이 쿼리를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-548">For example, `FIBillOfMaterialsWithEndDate` covers the following query because the query predicate is equivalent to the filter expression, and `EndDate` is not returned with the query results.</span></span> <span data-ttu-id="4ee79-549">`FIBillOfMaterialsWithEndDate` 는 필터링된 인덱스 정의의 포괄 열 또는 키로 `EndDate` 가 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-549">`FIBillOfMaterialsWithEndDate` does not need `EndDate` as a key or included column in the filtered index definition.</span></span>  
  
```sql
SELECT ComponentID, StartDate FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL;   
```  
  
 <span data-ttu-id="4ee79-550">쿼리 조건자가 필터링된 인덱스 식과 다른 비교에 필터링된 인덱스 식의 열을 사용하면 해당 열은 필터링된 인덱스 정의의 포괄 열 또는 키여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-550">A column in the filtered index expression should be a key or included column in the filtered index definition if the query predicate uses the column in a comparison that is not equivalent to the filtered index expression.</span></span> <span data-ttu-id="4ee79-551">예를 들어 다음 쿼리는 필터링된 인덱스에서 행의 하위 집합을 선택하기 때문에 `FIBillOfMaterialsWithEndDate` 는 이 쿼리에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-551">For example, `FIBillOfMaterialsWithEndDate` is valid for the following query because it selects a subset of rows from the filtered index.</span></span> <span data-ttu-id="4ee79-552">그러나 `EndDate` 가 필터링된 인덱스 식과 다른 `EndDate > '20040101'`비교에 사용되기 때문에 다음 쿼리를 처리하지는 못합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-552">However, it does not cover the following query because `EndDate` is used in the comparison `EndDate > '20040101'`, which is not equivalent to the filtered index expression.</span></span> <span data-ttu-id="4ee79-553">쿼리 프로세서는 `EndDate`값을 조회하지 않고 이 쿼리를 실행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-553">The query processor cannot execute this query without looking up the values of `EndDate`.</span></span> <span data-ttu-id="4ee79-554">따라서 `EndDate` 는 필터링된 인덱스 정의의 포괄 열 또는 키여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-554">Therefore, `EndDate` should be a key or included column in the filtered index definition.</span></span>  
  
```sql
SELECT ComponentID, StartDate FROM Production.BillOfMaterials  
WHERE EndDate > '20040101';   
```  
  
 <span data-ttu-id="4ee79-555">필터링된 인덱스 식의 열이 쿼리 결과 집합에 있으면 해당 열은 필터링된 인덱스 정의의 포괄 열 또는 키여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-555">A column in the filtered index expression should be a key or included column in the filtered index definition if the column is in the query result set.</span></span> <span data-ttu-id="4ee79-556">예를 들어 다음 쿼리가 쿼리 결과에 `FIBillOfMaterialsWithEndDate` 열을 반환하기 때문에 `EndDate` 는 다음 쿼리를 처리하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-556">For example, `FIBillOfMaterialsWithEndDate` does not cover the following query because it returns the `EndDate` column in the query results.</span></span> <span data-ttu-id="4ee79-557">따라서 `EndDate` 는 필터링된 인덱스 정의의 포괄 열 또는 키여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-557">Therefore, `EndDate` should be a key or included column in the filtered index definition.</span></span>  
  
```sql
SELECT ComponentID, StartDate, EndDate FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL;  
```  
  
 <span data-ttu-id="4ee79-558">테이블의 클러스터형 인덱스 키가 필터링된 인덱스 정의의 포괄 열 또는 키여야 할 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-558">The clustered index key of the table does not need to be a key or included column in the filtered index definition.</span></span> <span data-ttu-id="4ee79-559">클러스터형 인덱스 키는 필터링된 인덱스를 비롯하여 모든 비클러스터형 인덱스에 자동으로 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-559">The clustered index key is automatically included in all nonclustered indexes, including filtered indexes.</span></span>  
  
#### <a name="data-conversion-operators-in-the-filter-predicate"></a><span data-ttu-id="4ee79-560">필터 조건자의 데이터 변환 연산자</span><span class="sxs-lookup"><span data-stu-id="4ee79-560">Data Conversion Operators in the Filter Predicate</span></span>  

 <span data-ttu-id="4ee79-561">필터링된 인덱스의 필터링된 인덱스 식에 지정된 비교 연산자로 인해 암시적 또는 명시적 데이터 변환이 발생할 경우 비교 연산자의 왼쪽에서 변환이 일어나면 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-561">If the comparison operator specified in the filtered index expression of the filtered index results in an implicit or explicit data conversion, an error will occur if the conversion occurs on the left side of a comparison operator.</span></span> <span data-ttu-id="4ee79-562">이에 대한 해결 방법은 비교 연산자의 오른쪽에 데이터 변환 연산자(CAST 또는 CONVERT)를 사용하여 필터링된 인덱스 식을 작성하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-562">A solution is to write the filtered index expression with the data conversion operator (CAST or CONVERT) on the right side of the comparison operator.</span></span>  
  
 <span data-ttu-id="4ee79-563">다음 예에서는 여러 가지 데이터 형식이 있는 테이블을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-563">The following example creates a table with a variety of data types.</span></span>  
  
```sql
USE AdventureWorks2012;  
GO  
CREATE TABLE dbo.TestTable (a int, b varbinary(4));  
```  
  
 <span data-ttu-id="4ee79-564">다음 필터링된 인덱스 정의에서 상수 1과 비교하기 위해 `b` 열이 정수 데이터 형식으로 암시적으로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-564">In the following filtered index definition, column `b` is implicitly converted to an integer data type for the purpose of comparing it to the constant 1.</span></span> <span data-ttu-id="4ee79-565">이로 인해 오류 메시지 10611이 생성되며 그 이유는 필터링된 조건자에 있는 연산자의 왼쪽에서 변환이 발생하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-565">This generates error message 10611 because the conversion occurs on the left hand side of the operator in the filtered predicate.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX TestTabIndex ON dbo.TestTable(a,b)  
WHERE b = 1;  
```  
  
 <span data-ttu-id="4ee79-566">해결 방법은 다음 예에서와 같이 `b`열과 동일한 유형이 되도록 오른쪽에 있는 상수를 변환하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-566">The solution is to convert the constant on the right hand side to be of the same type as column `b`, as seen in the following example:</span></span>  
  
```sql
CREATE INDEX TestTabIndex ON dbo.TestTable(a,b)  
WHERE b = CONVERT(Varbinary(4), 1);  
```  
  
 <span data-ttu-id="4ee79-567">데이터 변환을 비교 연산자의 왼쪽에서 오른쪽으로 이동하면 변환 방법이 변경될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-567">Moving the data conversion from the left side to the right side of a comparison operator might change the meaning of the conversion.</span></span> <span data-ttu-id="4ee79-568">위의 예에서 CONVERT 연산자가 오른쪽에 추가될 때 정수 비교에서 `varbinary` 비교로 비교가 변경되었습니다.</span><span class="sxs-lookup"><span data-stu-id="4ee79-568">In the above example, when the CONVERT operator was added to the right side, the comparison changed from an integer comparison to a `varbinary` comparison.</span></span>  
  
 <span data-ttu-id="4ee79-569">[이 가이드의](#Top) ![맨 위 링크와 함께 사용 되는 화살표 아이콘](media/uparrow16x16.gif "맨 위로 이동 링크와 함께 사용되는 화살표 아이콘")</span><span class="sxs-lookup"><span data-stu-id="4ee79-569">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="additional-reading"></a><a name="Additional_Reading"></a> <span data-ttu-id="4ee79-570">더 보기</span><span class="sxs-lookup"><span data-stu-id="4ee79-570">Additional Reading</span></span>  

 <span data-ttu-id="4ee79-571">[SQL Server 2008 인덱싱된 뷰를 통해 성능 향상](https://msdn.microsoft.com/library/dd171921(v=sql.100).aspx)</span><span class="sxs-lookup"><span data-stu-id="4ee79-571">[Improving Performance with SQL Server 2008 Indexed Views](https://msdn.microsoft.com/library/dd171921(v=sql.100).aspx)</span></span>  
  
 [<span data-ttu-id="4ee79-572">Partitioned Tables and Indexes</span><span class="sxs-lookup"><span data-stu-id="4ee79-572">Partitioned Tables and Indexes</span></span>](../relational-databases/partitions/partitioned-tables-and-indexes.md)  
  
  
