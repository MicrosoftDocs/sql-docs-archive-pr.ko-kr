---
title: SQL Server 2014 트랜잭션 로그 아키텍처 및 관리 | Microsoft Docs
ms.custom: ''
ms.date: 06/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
ms.assetid: 4d1a4f97-3fe4-44af-9d4f-f884a6eaa457
author: rothja
ms.author: jroth
ms.openlocfilehash: 8d32950d94bff22d6549c468e8fe8db3f30fd09a
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87647351"
---
# <a name="sql-server-2014-transaction-log-architecture-and-management"></a><span data-ttu-id="8833e-102">SQL Server 2014 트랜잭션 로그 아키텍처 및 관리</span><span class="sxs-lookup"><span data-stu-id="8833e-102">SQL Server 2014 Transaction Log Architecture and Management</span></span>

<span data-ttu-id="8833e-103">**적용 대상:** SQL Server (2008부터 시작)</span><span class="sxs-lookup"><span data-stu-id="8833e-103">**Applies to:** SQL Server (starting with 2008)</span></span>

  <span data-ttu-id="8833e-104">각 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 데이터베이스에는 각 트랜잭션에 의해 적용된 모든 트랜잭션 및 데이터베이스 수정 내용을 기록하는 트랜잭션 로그가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-104">Every [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] database has a transaction log that records all transactions and the database modifications that are made by each transaction.</span></span> <span data-ttu-id="8833e-105">트랜잭션 로그는 데이터베이스의 주요 구성 요소이며 시스템 오류가 발생할 경우 데이터베이스를 다시 일관된 상태로 만들려면 트랜잭션 로그가 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-105">The transaction log is a critical component of the database and, if there is a system failure, the transaction log might be required to bring your database back to a consistent state.</span></span> <span data-ttu-id="8833e-106">이 지침에서는 트랜잭션 로그의 물리적 및 논리적 아키텍처에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-106">This guide provides information about the physical and logical architecture of the transaction log.</span></span> <span data-ttu-id="8833e-107">아키텍처를 이해하면 트랜잭션 로그를 보다 효율적으로 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-107">Understanding the architecture can improve your effectiveness in managing transaction logs.</span></span>  

  
##  <a name="transaction-log-logical-architecture"></a><a name="Logical_Arch"></a><span data-ttu-id="8833e-108">트랜잭션 로그 논리 아키텍처</span><span class="sxs-lookup"><span data-stu-id="8833e-108">Transaction Log Logical Architecture</span></span>  

 <span data-ttu-id="8833e-109">[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 트랜잭션 로그는 로그 레코드 문자열처럼 논리적으로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-109">The [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] transaction log operates logically as if the transaction log is a string of log records.</span></span> <span data-ttu-id="8833e-110">각 로그 레코드는 LSN(로그 시퀀스 번호)으로 식별됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-110">Each log record is identified by a log sequence number (LSN).</span></span> <span data-ttu-id="8833e-111">각 새 로그 레코드는 LSN과 함께 로그의 논리적 끝에 작성되며 이때 LSN은 오름차순입니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-111">Each new log record is written to the logical end of the log with an LSN that is higher than the LSN of the record before it.</span></span> <span data-ttu-id="8833e-112">로그 레코드는 작성된 순서대로 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-112">Log records are stored in a serial sequence as they are created.</span></span> <span data-ttu-id="8833e-113">각 로그 레코드에는 자신이 속한 트랜잭션의 ID가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-113">Each log record contains the ID of the transaction that it belongs to.</span></span> <span data-ttu-id="8833e-114">각 트랜잭션에서 트랜잭션과 관련된 모든 로그 레코드는 트랜잭션의 롤백 속도를 높이는 후방 포인터로 체인에 개별적으로 연결되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-114">For each transaction, all log records associated with the transaction are individually linked in a chain using backward pointers that speed the rollback of the transaction.</span></span>  
  
 <span data-ttu-id="8833e-115">데이터 수정에 대한 로그 레코드는 수행된 논리적 연산이나 수정된 데이터의 이전 이미지와 이후 이미지를 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-115">Log records for data modifications record either the logical operation performed or they record the before and after images of the modified data.</span></span> <span data-ttu-id="8833e-116">이전 이미지는 연산이 수행되기 전의 데이터 복사본이고 이후 이미지는 연산이 수행된 후의 데이터 복사본입니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-116">The before image is a copy of the data before the operation is performed; the after image is a copy of the data after the operation has been performed.</span></span>  
  
 <span data-ttu-id="8833e-117">연산을 복구하는 단계는 다음과 같이 로그 레코드의 유형에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-117">The steps to recover an operation depend on the type of log record:</span></span>  
  
-   <span data-ttu-id="8833e-118">기록된 논리적 연산</span><span class="sxs-lookup"><span data-stu-id="8833e-118">Logical operation logged</span></span>  
  
    -   <span data-ttu-id="8833e-119">논리적 연산을 롤포워드하기 위해 해당 연산이 다시 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-119">To roll the logical operation forward, the operation is performed again.</span></span>  
  
    -   <span data-ttu-id="8833e-120">논리적 연산을 롤백하기 위해 역 논리적 연산이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-120">To roll the logical operation back, the reverse logical operation is performed.</span></span>  
  
-   <span data-ttu-id="8833e-121">기록된 이전 및 이후 이미지</span><span class="sxs-lookup"><span data-stu-id="8833e-121">Before and after image logged</span></span>  
  
    -   <span data-ttu-id="8833e-122">연산을 롤포워드하기 위해 이후 이미지가 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-122">To roll the operation forward, the after image is applied.</span></span>  
  
    -   <span data-ttu-id="8833e-123">연산을 롤백하기 위해 이전 이미지가 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-123">To roll the operation back, the before image is applied.</span></span>  
  
 <span data-ttu-id="8833e-124">많은 유형의 작업이 트랜잭션 로그에 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-124">Many types of operations are recorded in the transaction log.</span></span> <span data-ttu-id="8833e-125">다음과 같은 작업이 여기에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-125">These operations include:</span></span>  
  
-   <span data-ttu-id="8833e-126">각 트랜잭션의 시작과 끝</span><span class="sxs-lookup"><span data-stu-id="8833e-126">The start and end of each transaction.</span></span>  
  
-   <span data-ttu-id="8833e-127">모든 데이터 수정 내용(삽입, 업데이트 또는 삭제).</span><span class="sxs-lookup"><span data-stu-id="8833e-127">Every data modification (insert, update, or delete).</span></span> <span data-ttu-id="8833e-128">여기에는 시스템 테이블을 비롯하여 모든 테이블에 대해 시스템 저장 프로시저 또는 DDL(데이터 정의 언어) 문에서 수행한 변경 내용이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-128">This includes changes by system stored procedures or data definition language (DDL) statements to any table, including system tables.</span></span>  
  
-   <span data-ttu-id="8833e-129">모든 익스텐트 및 페이지 할당 또는 할당 취소</span><span class="sxs-lookup"><span data-stu-id="8833e-129">Every extent and page allocation or deallocation.</span></span>  
  
-   <span data-ttu-id="8833e-130">테이블이나 인덱스 만들기 또는 삭제</span><span class="sxs-lookup"><span data-stu-id="8833e-130">Creating or dropping a table or index.</span></span>  
  
 <span data-ttu-id="8833e-131">롤백 작업도 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-131">Rollback operations are also logged.</span></span> <span data-ttu-id="8833e-132">각 트랜잭션은 트랜잭션 로그에 공간을 예약하여 명시적 롤백 문이나 오류로 인해 발생한 롤백을 지원하기에 충분한 로그 공간을 확보합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-132">Each transaction reserves space on the transaction log to make sure that enough log space exists to support a rollback that is caused by either an explicit rollback statement or if an error is encountered.</span></span> <span data-ttu-id="8833e-133">예약된 공간의 크기는 트랜잭션에서 수행되는 작업에 따라 다르지만 일반적으로 각 작업을 기록하는 데 사용되는 공간의 크기와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-133">The amount of space reserved depends on the operations performed in the transaction, but generally it is equal to the amount of space used to log each operation.</span></span> <span data-ttu-id="8833e-134">이렇게 예약된 공간은 트랜잭션 완료 시 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-134">This reserved space is freed when the transaction is completed.</span></span>  
  
 <span data-ttu-id="8833e-135">마지막으로 작성된 로그 레코드로의 성공적인 데이터베이스 차원의 롤백에 필요한 첫 번째 로그 레코드의 로그 파일 섹션을 로그의 활성 부분 또는 *활성 로그*라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-135">The section of the log file from the first log record that must be present for a successful database-wide rollback to the last-written log record is called the active part of the log, or the *active log*.</span></span> <span data-ttu-id="8833e-136">로그의 이 섹션은 데이터베이스의 전체 복구를 수행하는 데 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-136">This is the section of the log required to a full recovery of the database.</span></span> <span data-ttu-id="8833e-137">활성 로그는 어떤 부분도 잘라낼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-137">No part of the active log can ever be truncated.</span></span> <span data-ttu-id="8833e-138">이 첫 번째 로그 레코드의 LSN(로그 시퀀스 번호)은 최소 복구 LSN(*MinLSN*)이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-138">The log sequence number (LSN) of this first log record is known as the minimum recovery LSN (*MinLSN*).</span></span>  
  
##  <a name="transaction-log-physical-architecture"></a><a name="physical_arch"></a> <span data-ttu-id="8833e-139">트랜잭션 로그 물리 아키텍처</span><span class="sxs-lookup"><span data-stu-id="8833e-139">Transaction Log Physical Architecture</span></span>  

 <span data-ttu-id="8833e-140">데이터베이스의 트랜잭션 로그는 하나 이상의 물리 파일에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-140">The transaction log in a database maps over one or more physical files.</span></span> <span data-ttu-id="8833e-141">개념상으로 로그 파일은 로그 레코드의 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-141">Conceptually, the log file is a string of log records.</span></span> <span data-ttu-id="8833e-142">실제로 로그 레코드의 시퀀스는 트랜잭션 로그를 구현하는 물리적 파일 집합에 효율적으로 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-142">Physically, the sequence of log records is stored efficiently in the set of physical files that implement the transaction log.</span></span> <span data-ttu-id="8833e-143">데이터베이스마다 최소한 하나의 로그 파일이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-143">There must be at least one log file for each database.</span></span>  
  
 <span data-ttu-id="8833e-144">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 은 내부적으로 각 물리 로그 파일을 여러 개의 가상 로그 파일로 나눕니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-144">The [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] divides each physical log file internally into a number of virtual log files.</span></span> <span data-ttu-id="8833e-145">가상 로그 파일의 크기는 고정되어 있지 않으며 물리 로그 파일에 대해 고정된 수의 가상 로그 파일이 있는 것도 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-145">Virtual log files have no fixed size, and there is no fixed number of virtual log files for a physical log file.</span></span> <span data-ttu-id="8833e-146">[!INCLUDE[ssDE](../includes/ssde-md.md)] 은 로그 파일을 만들거나 확장할 때 동적으로 가상 로그 파일의 크기를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-146">The [!INCLUDE[ssDE](../includes/ssde-md.md)] chooses the size of the virtual log files dynamically while it is creating or extending log files.</span></span> <span data-ttu-id="8833e-147">[!INCLUDE[ssDE](../includes/ssde-md.md)] 은 적은 수의 가상 파일을 유지하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-147">The [!INCLUDE[ssDE](../includes/ssde-md.md)] tries to maintain a small number of virtual files.</span></span> <span data-ttu-id="8833e-148">로그 파일 확장 후 가상 파일 크기는 기존 로그 크기와 새 파일 증가 크기를 합한 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-148">The size of the virtual files after a log file has been extended is the sum of the size of the existing log and the size of the new file increment.</span></span> <span data-ttu-id="8833e-149">관리자가 가상 로그 파일의 크기 또는 수를 구성하거나 설정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-149">The size or number of virtual log files cannot be configured or set by administrators.</span></span>  
  
 <span data-ttu-id="8833e-150">작은 *size* 및 *growth_increment* 값으로 물리적 로그 파일을 정의하는 경우에만 가상 로그 파일이 시스템 성능에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-150">The only time virtual log files affect system performance is if the physical log files are defined by small *size* and *growth_increment* values.</span></span> <span data-ttu-id="8833e-151">*size* 값은 로그 파일의 처음 크기이며 *growth_increment* 값은 공간이 새로 필요할 때마다 파일에 추가되는 공간 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-151">The *size* value is the initial size for the log file and the *growth_increment* value is the amount of space added to the file every time new space is required.</span></span> <span data-ttu-id="8833e-152">수많은 작은 증가값으로 인해 로그 파일이 크게 증가하는 경우 가상 로그 파일이 많이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-152">If the log files grow to a large size because of many small increments, they will have many virtual log files.</span></span> <span data-ttu-id="8833e-153">이로 인해 데이터베이스 시작뿐 아니라 로그 백업 및 복원 작업이 느려질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-153">This can slow down database startup and also log backup and restore operations.</span></span> <span data-ttu-id="8833e-154">필요한 최종 크기에 가까운 *size* 값을 로그 파일에 할당하고 *growth_increment* 값을 비교적 크게 지정하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-154">We recommend that you assign log files a *size* value close to the final size required, and also have a relatively large *growth_increment* value.</span></span> <span data-ttu-id="8833e-155">이러한 매개 변수에 대한 자세한 내용은 [ALTER DATABASE 파일 및 파일 그룹 옵션&#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-database-transact-sql-file-and-filegroup-options)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8833e-155">For more information about these parameters, see [ALTER DATABASE File and Filegroup Options &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-database-transact-sql-file-and-filegroup-options).</span></span>  
  
 <span data-ttu-id="8833e-156">트랜잭션 로그는 순환 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-156">The transaction log is a wrap-around file.</span></span> <span data-ttu-id="8833e-157">예를 들어 데이터베이스에 4개의 가상 로그 파일로 나뉜 물리 로그 파일이 한 개 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-157">For example, consider a database with one physical log file divided into four virtual log files.</span></span> <span data-ttu-id="8833e-158">이 데이터베이스가 생성될 때 물리 로그 파일의 시작 부분에서 논리 로그 파일이 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-158">When the database is created, the logical log file begins at the start of the physical log file.</span></span> <span data-ttu-id="8833e-159">새 로그 레코드는 논리 로그의 끝 부분에 추가되며 물리 로그의 끝 방향으로 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-159">New log records are added at the end of the logical log and expand toward the end of the physical log.</span></span> <span data-ttu-id="8833e-160">로그 잘림을 수행하면 모든 레코드가 MinLSN(최소 복구 로그 시퀀스 번호) 앞에 있는 가상 로그에 대한 공간이 확보됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-160">Log truncation frees any virtual logs whose records all appear in front of the minimum recovery log sequence number (MinLSN).</span></span> <span data-ttu-id="8833e-161">*MinLSN* 은 성공적인 데이터베이스 차원의 롤백에 필요한 가장 오래된 로그 레코드의 로그 시퀀스 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-161">The *MinLSN* is the log sequence number of the oldest log record that is required for a successful database-wide rollback.</span></span> <span data-ttu-id="8833e-162">예제 데이터베이스의 트랜잭션 로그는 다음 그림의 로그와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-162">The transaction log in the example database would look similar to the one in the following illustration.</span></span>  
  
 <span data-ttu-id="8833e-163">![4개의 가상 로그 파일로 나뉘어진 로그 파일](media/tranlog3.gif "4개의 가상 로그 파일로 나뉘어진 로그 파일")</span><span class="sxs-lookup"><span data-stu-id="8833e-163">![Log file divided into four virtual log files](media/tranlog3.gif "Log file divided into four virtual log files")</span></span>  
  
 <span data-ttu-id="8833e-164">논리 로그의 끝 부분이 물리 로그 파일의 끝 부분에 도달하면 새 로그 레코드는 물리 로그 파일의 시작 부분으로 순환됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-164">When the end of the logical log reaches the end of the physical log file, the new log records wrap around to the start of the physical log file.</span></span>  
  
 <span data-ttu-id="8833e-165">![로그 파일 맨 처음으로 순환되는 로그 레코드](media/tranlog4.gif "로그 파일 맨 처음으로 순환되는 로그 레코드")</span><span class="sxs-lookup"><span data-stu-id="8833e-165">![Log records wrap around to start of log file](media/tranlog4.gif "Log records wrap around to start of log file")</span></span>  
  
 <span data-ttu-id="8833e-166">이러한 순환은 논리 로그 끝 부분이 논리 로그의 시작 부분에 도달하지 않는 한 계속 반복됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-166">This cycle repeats endlessly, as long as the end of the logical log never reaches the beginning of the logical log.</span></span> <span data-ttu-id="8833e-167">다음 검사점까지 생성되는 모든 새 로그 레코드를 위해 항상 충분한 공간이 남을 만큼 기존 로그 레코드가 자주 잘리면 로그는 가득 차지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-167">If the old log records are truncated frequently enough to always leave sufficient room for all the new log records created through the next checkpoint, the log never fills.</span></span> <span data-ttu-id="8833e-168">그러나 논리 로그의 끝 부분이 논리 로그의 시작 부분에 도달하면 다음 두 가지 상황 중 하나가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-168">However, if the end of the logical log does reach the start of the logical log, one of two things occurs:</span></span>  
  
-   <span data-ttu-id="8833e-169">로그에 대해 FILEGROWTH 설정이 사용하도록 설정되어 있고 디스크에 사용할 수 있는 공간이 있으면 파일은 *growth_increment* 매개 변수에 지정된 크기만큼 확장되며 새 로그 레코드가 확장 부분에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-169">If the FILEGROWTH setting is enabled for the log and space is available on the disk, the file is extended by the amount specified in the *growth_increment* parameter and the new log records are added to the extension.</span></span> <span data-ttu-id="8833e-170">FILEGROWTH 설정에 대한 자세한 내용은 [ALTER DATABASE 파일 및 파일 그룹 옵션&#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-database-transact-sql-file-and-filegroup-options)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8833e-170">For more information about the FILEGROWTH setting, see [ALTER DATABASE File and Filegroup Options &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-database-transact-sql-file-and-filegroup-options).</span></span>  
  
-   <span data-ttu-id="8833e-171">FILEGROWTH 설정이 사용하도록 설정되어 있지 않거나 로그 파일이 있는 디스크의 사용 가능한 공간이 *growth_increment*에 지정된 크기보다 적으면 9002 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-171">If the FILEGROWTH setting is not enabled, or the disk that is holding the log file has less free space than the amount specified in *growth_increment*, an 9002 error is generated.</span></span>  
  
 <span data-ttu-id="8833e-172">로그에 물리 로그 파일이 여러 개 있으면 논리 로그는 모든 물리 로그 파일을 거친 후 첫 번째 물리 로그 파일의 시작 부분으로 순환됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-172">If the log contains multiple physical log files, the logical log will move through all the physical log files before it wraps back to the start of the first physical log file.</span></span>  
  
### <a name="log-truncation"></a><span data-ttu-id="8833e-173">로그 잘림</span><span class="sxs-lookup"><span data-stu-id="8833e-173">Log Truncation</span></span>  

 <span data-ttu-id="8833e-174">로그가 가득 차지 않도록 하기 위해 로그 잘림은 필수적입니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-174">Log truncation is essential to keep the log from filling.</span></span> <span data-ttu-id="8833e-175">로그 잘림은 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 데이터베이스의 논리 트랜잭션 로그에서 비활성 가상 로그 파일을 삭제하여 물리적 트랜잭션 로그에서 다시 사용할 수 있도록 논리 로그의 공간을 확보합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-175">Log truncation deletes inactive virtual log files from the logical transaction log of a [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] database, freeing space in the logical log for reuse by the physical transaction log.</span></span> <span data-ttu-id="8833e-176">트랜잭션 로그가 잘리지 않으면 물리적 로그 파일에 할당된 디스크 공간이 모두 트랜잭션 로그로 채워지게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-176">If a transaction log were never truncated, it would eventually fill all the disk space that is allocated to its physical log files.</span></span> <span data-ttu-id="8833e-177">단, 로그를 자르기 전에 검사점 작업을 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-177">However, before the log can be truncated, a checkpoint operation must occur.</span></span> <span data-ttu-id="8833e-178">검사점은 현재 메모리 내의 수정된 페이지(더티 페이지라고 함)와 메모리의 트랜잭션 로그 정보를 디스크에 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-178">A checkpoint writes the current in-memory modified pages (known as dirty pages) and transaction log information from memory to disk.</span></span> <span data-ttu-id="8833e-179">검사점을 수행하면 트랜잭션 로그의 비활성 부분은 재사용 가능으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-179">When the checkpoint is performed, the inactive portion of the transaction log is marked as reusable.</span></span> <span data-ttu-id="8833e-180">그런 후에는 로그 잘림으로 비활성 부분에 대한 공간을 확보할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-180">Thereafter, the inactive portion can be freed by log truncation.</span></span> <span data-ttu-id="8833e-181">검사점에 대한 자세한 내용은 [데이터베이스 검사점&#40;SQL Server&#41;](../relational-databases/logs/database-checkpoints-sql-server.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8833e-181">For more information about checkpoints, see [Database Checkpoints &#40;SQL Server&#41;](../relational-databases/logs/database-checkpoints-sql-server.md).</span></span>  
  
 <span data-ttu-id="8833e-182">다음 그림에서는 잘림 전과 후의 트랜잭션 로그를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-182">The following illustrations show a transaction log before and after truncation.</span></span> <span data-ttu-id="8833e-183">첫 번째 그림은 잘림이 수행되지 않은 트랜잭션 로그를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-183">The first illustration shows a transaction log that has never been truncated.</span></span> <span data-ttu-id="8833e-184">현재 논리 로그에서 4개의 가상 로그 파일을 사용하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-184">Currently, four virtual log files are in use by the logical log.</span></span> <span data-ttu-id="8833e-185">논리 로그는 첫 번째 가상 로그 파일의 앞에서 시작하고 가상 로그 4에서 끝납니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-185">The logical log starts at the front of the first virtual log file and ends at virtual log 4.</span></span> <span data-ttu-id="8833e-186">MinLSN 레코드는 가상 로그 3에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-186">The MinLSN record is in virtual log 3.</span></span> <span data-ttu-id="8833e-187">가상 로그 1과 가상 로그 2에는 비활성 로그 레코드만 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-187">Virtual log 1 and virtual log 2 contain only inactive log records.</span></span> <span data-ttu-id="8833e-188">이러한 레코드는 자를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-188">These records can be truncated.</span></span> <span data-ttu-id="8833e-189">가상 로그 5는 사용하지 않았으며 현재 논리 로그에 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-189">Virtual log 5 is still unused and is not part of the current logical log.</span></span>  
  
 <span data-ttu-id="8833e-190">![4개의 가상 로그가 있는 트랜잭션 로그](media/tranlog2.gif "4개의 가상 로그가 있는 트랜잭션 로그")</span><span class="sxs-lookup"><span data-stu-id="8833e-190">![Transaction log with four virtual logs](media/tranlog2.gif "Transaction log with four virtual logs")</span></span>  
  
 <span data-ttu-id="8833e-191">두 번째 그림은 잘림 후의 로그 모습을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-191">The second illustration shows how the log appears after being truncated.</span></span> <span data-ttu-id="8833e-192">가상 로그 1과 가상 로그 2는 다시 사용할 수 있도록 공간이 확보되었습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-192">Virtual log 1 and virtual log 2 have been freed for reuse.</span></span> <span data-ttu-id="8833e-193">이제 논리 로그는 가상 로그 3의 시작 부분에서 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-193">The logical log now starts at the beginning of virtual log 3.</span></span> <span data-ttu-id="8833e-194">가상 로그 5는 아직 사용되지 않았으며 현재 논리 로그에 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-194">Virtual log 5 is still unused, and it is not part of the current logical log.</span></span>  
  
 <span data-ttu-id="8833e-195">![4개의 가상 로그 파일로 나뉘어진 로그 파일](media/tranlog3.gif "4개의 가상 로그 파일로 나뉘어진 로그 파일")</span><span class="sxs-lookup"><span data-stu-id="8833e-195">![Log file divided into four virtual log files](media/tranlog3.gif "Log file divided into four virtual log files")</span></span>  
  
 <span data-ttu-id="8833e-196">여타의 이유로 지연된 경우를 제외하고 로그 잘림은 다음과 같이 자동으로 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-196">Log truncation occurs automatically after the following events, except when delayed for some reason:</span></span>  
  
-   <span data-ttu-id="8833e-197">단순 복구 모델에서는 검사점 이후 잘림이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-197">Under the simple recovery model, after a checkpoint.</span></span>  
  
-   <span data-ttu-id="8833e-198">전체 복구 모델 또는 대량 로그 복구 모델에서 로그 백업 후(이전 백업 이후에 발생한 검사점이 있는 경우).</span><span class="sxs-lookup"><span data-stu-id="8833e-198">Under the full recovery model or bulk-logged recovery model, after a log backup, if a checkpoint has occurred since the previous backup.</span></span>  
  
 <span data-ttu-id="8833e-199">여러 요소로 인해 로그 잘림이 지연될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-199">Log truncation can be delayed by a variety of factors.</span></span> <span data-ttu-id="8833e-200">로그 잘림이 장시간 지연될 경우 트랜잭션 로그가 꽉 찰 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-200">In the event of a long delay in log truncation, the transaction log can fill up.</span></span> <span data-ttu-id="8833e-201">자세한 내용은 [로그 잘림을 지연 시킬 수 있는 요소](../relational-databases/logs/the-transaction-log-sql-server.md#FactorsThatDelayTruncation) 를 참조 하 고 [전체 트랜잭션 로그 &#40;문제를 해결 SQL Server 오류 9002&#41;](../relational-databases/logs/troubleshoot-a-full-transaction-log-sql-server-error-9002.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="8833e-201">For information, see [Factors That Can Delay Log Truncation](../relational-databases/logs/the-transaction-log-sql-server.md#FactorsThatDelayTruncation) and [Troubleshoot a Full Transaction Log &#40;SQL Server Error 9002&#41;](../relational-databases/logs/troubleshoot-a-full-transaction-log-sql-server-error-9002.md).</span></span>  
  
##  <a name="write-ahead-transaction-log"></a><a name="WAL"></a><span data-ttu-id="8833e-202">미리 쓰기 트랜잭션 로그</span><span class="sxs-lookup"><span data-stu-id="8833e-202">Write-Ahead Transaction Log</span></span>  

 <span data-ttu-id="8833e-203">이 섹션에서는 데이터 수정 내용을 디스크에 기록할 때 미리 쓰기 트랜잭션 로그의 역할에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-203">This section describes the role of the write-ahead transaction log in recording data modifications to disk.</span></span> [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] <span data-ttu-id="8833e-204">에서는 WAL(미리 쓰기 로그)을 사용하여 연결된 로그 레코드가 디스크에 기록되기 전에는 어떠한 데이터 수정 내용도 디스크에 기록되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-204">uses a write-ahead log (WAL), which guarantees that no data modifications are written to disk before the associated log record is written to disk.</span></span> <span data-ttu-id="8833e-205">따라서 트랜잭션의 ACID 속성이 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-205">This maintains the ACID properties for a transaction.</span></span>  
  
 <span data-ttu-id="8833e-206">미리 쓰기 로그 작동 방식을 이해하려면 수정된 데이터가 디스크에 기록되는 방법을 알아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-206">To understand how the write-ahead log works, it is important for you to know how modified data is written to disk.</span></span> [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] <span data-ttu-id="8833e-207">는 데이터를 검색해야 할 때 데이터 페이지를 읽어오는 버퍼 캐시를 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-207">maintains a buffer cache into which it reads data pages when data must be retrieved.</span></span> <span data-ttu-id="8833e-208">페이지가 버퍼 캐시에서 수정 되 면 디스크에 즉시 기록 되지 않습니다. 대신 페이지가 *더티*로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-208">When a page is modified in the buffer cache, it is not immediately written back to disk; instead, the page is marked as *dirty*.</span></span> <span data-ttu-id="8833e-209">데이터 페이지는 물리적으로 디스크에 기록되기 전에 두 개 이상의 논리적 쓰기를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-209">A data page can have more than one logical write made before it is physically written to disk.</span></span> <span data-ttu-id="8833e-210">각 논리적 쓰기의 경우 트랜잭션 로그 레코드는 수정 사항을 기록하는 로그 캐시에 삽입됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-210">For each logical write, a transaction log record is inserted in the log cache that records the modification.</span></span> <span data-ttu-id="8833e-211">로그 레코드는 관련된 더티 페이지가 버퍼 캐시에서 디스크로 제거되기 전에 디스크에 기록되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-211">The log records must be written to disk before the associated dirty page is removed from the buffer cache and written to disk.</span></span> <span data-ttu-id="8833e-212">검사점 프로세스는 주기적으로 버퍼 캐시에서 지정된 특정 데이터베이스의 페이지를 포함하는 버퍼를 검색한 다음 모든 더티 페이지를 디스크에 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-212">The checkpoint process periodically scans the buffer cache for buffers with pages from a specified database and writes all dirty pages to disk.</span></span> <span data-ttu-id="8833e-213">검사점은 모든 더티 페이지가 디스크에 기록되었음을 확인하는 지점을 만들어 나중에 복구하는 동안 시간을 절약할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-213">Checkpoints save time during a later recovery by creating a point at which all dirty pages are guaranteed to have been written to disk.</span></span>  
  
 <span data-ttu-id="8833e-214">버퍼 캐시에 있는 수정된 데이터 페이지를 디스크에 쓰는 작업을 페이지 플러시라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-214">Writing a modified data page from the buffer cache to disk is called flushing the page.</span></span> [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] <span data-ttu-id="8833e-215">에는 연결된 로그 레코드가 기록되기 전에 더티 페이지가 플러시되지 않도록 하는 논리가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-215">has logic that prevents a dirty page from being flushed before the associated log record is written.</span></span> <span data-ttu-id="8833e-216">로그 레코드는 트랜잭션이 커밋되면 디스크에 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-216">Log records are written to disk when the transactions are committed.</span></span>  
  
##  <a name="transaction-log-backups"></a><a name="Backups"></a><span data-ttu-id="8833e-217">트랜잭션 로그 백업</span><span class="sxs-lookup"><span data-stu-id="8833e-217">Transaction Log Backups</span></span>  

 <span data-ttu-id="8833e-218">이 섹션에서는 트랜잭션 로그를 백업 및 복원하거나 적용하는 방법에 대한 개념을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-218">This section presents concepts about how to back up and restore (apply) transaction logs.</span></span> <span data-ttu-id="8833e-219">전체 및 대량 로그 복원 모델에서 데이터를 복구하려면 트랜잭션 로그를 정기적으로 백업(*로그 백업*)해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-219">Under the full and bulk-logged recovery models, taking routine backups of transaction logs (*log backups*) is necessary for recovering data.</span></span> <span data-ttu-id="8833e-220">전체 백업이 실행되는 동안 로그를 백업할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-220">You can back up the log while any full backup is running.</span></span> <span data-ttu-id="8833e-221">복구 모델에 대한 자세한 내용은 [SQL Server 데이터베이스 백업 및 복원](../relational-databases/backup-restore/back-up-and-restore-of-sql-server-databases.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8833e-221">For more information about recovery models, see [Back Up and Restore of SQL Server Databases](../relational-databases/backup-restore/back-up-and-restore-of-sql-server-databases.md).</span></span>  
  
 <span data-ttu-id="8833e-222">첫 번째 로그 백업을 만들기 전에 데이터베이스 백업 또는 파일 백업 집합의 첫 번째 집합과 같은 전체 백업을 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-222">Before you can create the first log backup, you must create a full backup, such as a database backup or the first in a set of file backups.</span></span> <span data-ttu-id="8833e-223">파일 백업만 사용하여 데이터베이스를 복원하면 복잡해질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-223">Restoring a database by using only file backups can become complex.</span></span> <span data-ttu-id="8833e-224">따라서 가능하면 처음에 전체 데이터베이스 백업을 수행하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-224">Therefore, we recommend that you start with a full database backup when you can.</span></span> <span data-ttu-id="8833e-225">그런 후에 트랜잭션 로그를 정기적으로 백업할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-225">Thereafter, backing up the transaction log regularly is necessary.</span></span> <span data-ttu-id="8833e-226">이렇게 하면 작업 손실 위험이 최소화될 뿐만 아니라 트랜잭션 로그가 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-226">This not only minimizes work-loss exposure but also enables truncation of the transaction log.</span></span> <span data-ttu-id="8833e-227">일반적으로 기존 로그 백업 후에도 트랜잭션 로그가 잘리지만</span><span class="sxs-lookup"><span data-stu-id="8833e-227">Typically, the transaction log is truncated after every conventional log backup.</span></span>  
  
 <span data-ttu-id="8833e-228">비즈니스 요구 사항, 특히 손상된 로그 드라이브에 의해 발생될 수 있는 작업 손실에 대한 허용 범위를 지원하기 위해 로그 백업을 충분히 자주 수행하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-228">We recommend taking frequent enough log backups to support your business requirements, specifically your tolerance for work loss such as might be caused by a damaged log drive.</span></span> <span data-ttu-id="8833e-229">로그 백업의 적절한 수행 빈도는 저장 및 관리는 물론 복원까지 가능할 수 있는 로그 백업의 횟수에 의해 조정되는 작업 손실 위험에 대한 허용 범위에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-229">The appropriate frequency for taking log backups depends on your tolerance for work-loss exposure balanced by how many log backups you can store, manage, and, potentially, restore.</span></span> <span data-ttu-id="8833e-230">로그 백업에 걸리는 시간은 매 15분에서 30분이면 충분합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-230">Taking a log backup every 15 to 30 minutes might be enough.</span></span> <span data-ttu-id="8833e-231">비즈니스에서 작업 손실 위험을 최소화하려는 경우에는 로그 백업을 더 자주 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-231">If your business requires that you minimize work-loss exposure, consider taking log backups more frequently.</span></span> <span data-ttu-id="8833e-232">로그 백업 횟수가 많아지면 로그 잘림이 더 자주 발생하여 로그 파일의 크기가 작아지는 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-232">More frequent log backups have the added advantage of increasing the frequency of log truncation, resulting in smaller log files.</span></span>  
  
 <span data-ttu-id="8833e-233">복원해야 하는 로그 백업의 수를 제한하려면 데이터를 정기적으로 백업해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-233">To limit the number of log backups that you need to restore, it is essential to routinely back up your data.</span></span> <span data-ttu-id="8833e-234">예를 들어 주별 전체 데이터베이스 백업과 일별 차등 데이터베이스 백업을 예약할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-234">For example, you might schedule a weekly full database backup and daily differential database backups.</span></span>  
  
### <a name="the-log-chain"></a><span data-ttu-id="8833e-235">로그 체인</span><span class="sxs-lookup"><span data-stu-id="8833e-235">The Log Chain</span></span>  

 <span data-ttu-id="8833e-236">로그 백업의 연속 시퀀스를 *로그 체인*이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-236">A continuous sequence of log backups is called a *log chain*.</span></span> <span data-ttu-id="8833e-237">로그 체인은 데이터베이스의 전체 백업으로 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-237">A log chain starts with a full backup of the database.</span></span> <span data-ttu-id="8833e-238">일반적으로 데이터베이스를 처음 백업할 때나 단순 복구 모델에서 전체 또는 대량 로그 복구 모델로 전환한 후에만 새 로그 체인이 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-238">Usually, a new log chain is only started when the database is backed up for the first time or after the recovery model is switched from simple recovery to full or bulk-logged recovery.</span></span> <span data-ttu-id="8833e-239">전체 데이터베이스 백업을 만들 때 기존 백업 집합을 덮어쓰도록 선택하지 않으면 기존 로그 체인이 그대로 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-239">Unless you choose to overwrite existing backup sets when creating a full database backup, the existing log chain remains intact.</span></span> <span data-ttu-id="8833e-240">로그 체인이 그대로 유지되면 미디어 세트의 전체 데이터베이스 백업에서 데이터베이스를 복원한 후 모든 후속 로그 백업을 복구 지점까지 복원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-240">With the log chain intact, you can restore your database from any full database backup in the media set, followed by all subsequent log backups up through your recovery point.</span></span> <span data-ttu-id="8833e-241">복구 지점은 마지막 로그 백업의 끝이나 로그 백업의 특정 복구 지점일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-241">The recovery point could be the end of the last log backup or a specific recovery point in any of the log backups.</span></span> <span data-ttu-id="8833e-242">자세한 내용은 [트랜잭션 로그 백업&#40;SQL Server&#41;](../relational-databases/backup-restore/transaction-log-backups-sql-server.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8833e-242">For more information, see [Transaction Log Backups &#40;SQL Server&#41;](../relational-databases/backup-restore/transaction-log-backups-sql-server.md).</span></span>  
  
 <span data-ttu-id="8833e-243">데이터베이스를 오류 발생 시점까지 복원하려면 로그 체인이 온전해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-243">To restore a database up to the point of failure, the log chain must be intact.</span></span> <span data-ttu-id="8833e-244">즉 트랜잭션 로그 백업의 연속적인 시퀀스가 오류 발생 지점까지 이어져야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-244">That is, an unbroken sequence of transaction log backups must extend up to the point of failure.</span></span> <span data-ttu-id="8833e-245">이 로그 시퀀스가 시작되는 위치는 복원 중인 데이터 백업의 유형인 데이터베이스, 부분 또는 파일에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-245">Where this sequence of log must start depends on the type of data backups you are restoring: database, partial, or file.</span></span> <span data-ttu-id="8833e-246">데이터베이스 또는 부분 백업의 경우 로그 백업의 시퀀스는 데이터베이스 또는 부분 백업의 끝 지점에서 이어져야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-246">For a database or partial backup, the sequence of log backups must extend from the end of a database or partial backup.</span></span> <span data-ttu-id="8833e-247">파일 백업 집합의 경우 로그 백업의 시퀀스는 전체 파일 백업 집합의 시작 지점에서 이어져야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-247">For a set of file backups, the sequence of log backups must extend from the start of a full set of file backups.</span></span> <span data-ttu-id="8833e-248">자세한 내용은 [트랜잭션 로그 백업 적용&#40;SQL Server&#41;](../relational-databases/backup-restore/apply-transaction-log-backups-sql-server.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8833e-248">For more information, see [Apply Transaction Log Backups &#40;SQL Server&#41;](../relational-databases/backup-restore/apply-transaction-log-backups-sql-server.md).</span></span>  
  
### <a name="restore-log-backups"></a><span data-ttu-id="8833e-249">로그 백업을 복원하려면</span><span class="sxs-lookup"><span data-stu-id="8833e-249">Restore Log Backups</span></span>  

 <span data-ttu-id="8833e-250">로그 백업을 복원하면 현재 데이터베이스를 로그 백업 작업이 시작된 시점의 데이터베이스 상태와 정확히 일치하도록 다시 만들기 위해 트랜잭션 로그에 기록된 변경 내용을 롤포워드합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-250">Restoring a log backup rolls forward the changes that were recorded in the transaction log to re-create the exact state of the database at the time the log backup operation started.</span></span> <span data-ttu-id="8833e-251">데이터베이스를 복원하는 경우 복원하는 전체 데이터베이스 백업 이후 또는 복원하는 첫 번째 파일 백업의 시작 부분에서 만든 로그 백업을 복원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-251">When you restore a database, you will have to restore the log backups that were created after the full database backup that you restore, or from the start of the first file backup that you restore.</span></span> <span data-ttu-id="8833e-252">일반적으로 가장 최근의 데이터나 차등 백업을 복원하고 나면 복구 지점에 이를 때까지 일련의 로그 백업을 복원한 다음</span><span class="sxs-lookup"><span data-stu-id="8833e-252">Typically, after you restore the most recent data or differential backup, you must restore a series of log backups until you reach your recovery point.</span></span> <span data-ttu-id="8833e-253">데이터베이스를 복구해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-253">Then, you recover the database.</span></span> <span data-ttu-id="8833e-254">이때까지 완료되지 않은 트랜잭션은 모두 롤백되며 복구가 완료되면 데이터베이스는 온라인 상태가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-254">This rolls back all transactions that were incomplete when the recovery started and brings the database online.</span></span> <span data-ttu-id="8833e-255">데이터베이스가 복구된 후에는 더 이상의 백업을 복원할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8833e-255">After the database has been recovered, you cannot restore any more backups.</span></span> <span data-ttu-id="8833e-256">자세한 내용은 [트랜잭션 로그 백업 적용&#40;SQL Server&#41;](../relational-databases/backup-restore/apply-transaction-log-backups-sql-server.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8833e-256">For more information, see [Apply Transaction Log Backups &#40;SQL Server&#41;](../relational-databases/backup-restore/apply-transaction-log-backups-sql-server.md).</span></span>  
  
## <a name="additional-reading"></a><span data-ttu-id="8833e-257">추가 자료</span><span class="sxs-lookup"><span data-stu-id="8833e-257">Additional Reading</span></span>  

 <span data-ttu-id="8833e-258">트랜잭션 로그에 대한 자세한 내용은 다음 기사 및 책을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="8833e-258">We recommend the following articles and books for additional information about the transaction log.</span></span>  
  
 [<span data-ttu-id="8833e-259">Paul Randall, "SQL Server의 로깅 및 복구 이해"</span><span class="sxs-lookup"><span data-stu-id="8833e-259">Understanding Logging and Recovery in SQL Server by Paul Randall</span></span>](https://technet.microsoft.com/magazine/2009.02.logging.aspx)  
  
 [<span data-ttu-id="8833e-260">Tony Davis 및 Gail Shaw 공저, "SQL Server 트랜잭션 로그 관리"</span><span class="sxs-lookup"><span data-stu-id="8833e-260">SQL Server Transaction Log Management by Tony Davis and Gail Shaw</span></span>](http://www.simple-talk.com/books/sql-books/sql-server-transaction-log-management-by-tony-davis-and-gail-shaw/)  
  
  
