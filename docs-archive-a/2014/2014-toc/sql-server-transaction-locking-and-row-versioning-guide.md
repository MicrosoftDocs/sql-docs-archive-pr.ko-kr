---
title: SQL Server 트랜잭션 잠금 및 행 버전 관리 지침 | Microsoft 문서 도구
ms.custom: ''
ms.date: 01/24/2019
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
ms.assetid: c7757153-9697-4f01-881c-800e254918c9
author: rothja
ms.author: jroth
ms.openlocfilehash: c79f9997249568c88409394441d28c71da453d63
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87647399"
---
# <a name="sql-server-transaction-locking-and-row-versioning-guide"></a><span data-ttu-id="9951f-102">SQL Server 트랜잭션 잠금 및 행 버전 관리 지침</span><span class="sxs-lookup"><span data-stu-id="9951f-102">SQL Server Transaction Locking and Row Versioning Guide</span></span>

  <span data-ttu-id="9951f-103">어느 데이터베이스에서든 트랜잭션을 제대로 관리하지 않으면 사용자가 많은 시스템에 경합 및 성능 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-103">In any database, mismanagement of transactions often leads to contention and performance problems in systems that have many users.</span></span> <span data-ttu-id="9951f-104">데이터에 액세스하는 사용자 수가 늘어나면 애플리케이션에서 트랜잭션을 효율적으로 사용하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-104">As the number of users that access the data increases, it becomes important to have applications that use transactions efficiently.</span></span> <span data-ttu-id="9951f-105">이 지침에서는 [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]에서 각 트랜잭션의 물리적 무결성을 유지하는 데 사용하는 잠금 및 행 버전 관리 메커니즘과 애플리케이션에서 트랜잭션을 효율적으로 제어할 수 있는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-105">This guide describes the locking and row versioning mechanisms the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] uses to ensure the physical integrity of each transaction and provides information on how applications can control transactions efficiently.</span></span>  
  
<span data-ttu-id="9951f-106">**적용 대상**: [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] 별도로 언급 하지 않는 한부터까지</span><span class="sxs-lookup"><span data-stu-id="9951f-106">**Applies to**: [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] through [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] unless noted otherwise.</span></span>  
  
##  <a name="in-this-guide"></a><a name="Top"></a><span data-ttu-id="9951f-107">이 가이드의</span><span class="sxs-lookup"><span data-stu-id="9951f-107">In This Guide</span></span>  

 [<span data-ttu-id="9951f-108">트랜잭션 기본 사항</span><span class="sxs-lookup"><span data-stu-id="9951f-108">Transaction Basics</span></span>](#Basics)  
  
 [<span data-ttu-id="9951f-109">잠금 및 행 버전 관리 기본 사항</span><span class="sxs-lookup"><span data-stu-id="9951f-109">Locking and Row Versioning Basics</span></span>](#Lock_Basics)  
  
 [<span data-ttu-id="9951f-110">데이터베이스 엔진 잠금</span><span class="sxs-lookup"><span data-stu-id="9951f-110">Locking in the Database Engine</span></span>](#Lock_Engine)  
  
 [<span data-ttu-id="9951f-111">데이터베이스 엔진의 행 버전 관리 기반 격리 수준</span><span class="sxs-lookup"><span data-stu-id="9951f-111">Row Versioning-based Isolation Levels in the Database Engine</span></span>](#Row_versioning)  
  
 [<span data-ttu-id="9951f-112">인덱스에 대 한 잠금 사용자 지정</span><span class="sxs-lookup"><span data-stu-id="9951f-112">Customizing Locking for an Index</span></span>](#Customize)  
  
 [<span data-ttu-id="9951f-113">고급 트랜잭션 정보</span><span class="sxs-lookup"><span data-stu-id="9951f-113">Advanced Transaction Information</span></span>](#Advanced)  
  
##  <a name="transaction-basics"></a><a name="Basics"></a> <span data-ttu-id="9951f-114">트랜잭션 기본 사항</span><span class="sxs-lookup"><span data-stu-id="9951f-114">Transaction Basics</span></span>  

 <span data-ttu-id="9951f-115">트랜잭션은 하나의 논리적 작업 단위로 수행되는 일련의 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-115">A transaction is a sequence of operations performed as a single logical unit of work.</span></span> <span data-ttu-id="9951f-116">작업의 논리적 단위는 ACID(원자성, 일관성, 격리성 및 영속성) 속성이라고 하는 네 가지 속성을 통해 트랜잭션으로서의 자격을 부여합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-116">A logical unit of work must exhibit four properties, called the atomicity, consistency, isolation, and durability (ACID) properties, to qualify as a transaction.</span></span>  
  
 <span data-ttu-id="9951f-117">원자성</span><span class="sxs-lookup"><span data-stu-id="9951f-117">Atomicity</span></span>  
 <span data-ttu-id="9951f-118">트랜잭션은 더 이상 분류할 수 없는 작업 단위여야 하며 모든 데이터 수정 작업이 수행되거나 하나도 수행되지 말아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-118">A transaction must be an atomic unit of work; either all of its data modifications are performed, or none of them are performed.</span></span>  
  
 <span data-ttu-id="9951f-119">일관성</span><span class="sxs-lookup"><span data-stu-id="9951f-119">Consistency</span></span>  
 <span data-ttu-id="9951f-120">완료된 트랜잭션의 모든 데이터는 일관되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-120">When completed, a transaction must leave all data in a consistent state.</span></span> <span data-ttu-id="9951f-121">관계형 데이터베이스에서는 트랜잭션 수정에 모든 규칙을 적용하여 모든 데이터 무결성을 유지해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-121">In a relational database, all rules must be applied to the transaction's modifications to maintain all data integrity.</span></span> <span data-ttu-id="9951f-122">트랜잭션 마지막에는 B-tree 인덱스 또는 이중 연결 목록 등 모든 내부적 데이터 구조를 반드시 수정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-122">All internal data structures, such as B-tree indexes or doubly-linked lists, must be correct at the end of the transaction.</span></span>  
  
 <span data-ttu-id="9951f-123">격리</span><span class="sxs-lookup"><span data-stu-id="9951f-123">Isolation</span></span>  
 <span data-ttu-id="9951f-124">동시 트랜잭션에 의한 수정은 다른 동시 트랜잭션에 의한 수정과 격리되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-124">Modifications made by concurrent transactions must be isolated from the modifications made by any other concurrent transactions.</span></span> <span data-ttu-id="9951f-125">트랜잭션에서 다른 동시 트랜잭션이 수정하기 전 상태의 데이터를 보거나 두 번째 트랜잭션이 완료된 후의 데이터를 볼 수는 있지만 중간 상태는 볼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-125">A transaction either recognizes data in the state it was in before another concurrent transaction modified it, or it recognizes the data after the second transaction has completed, but it does not recognize an intermediate state.</span></span> <span data-ttu-id="9951f-126">결과적으로 시작 데이터를 다시 로드하고 일련의 트랜잭션을 재생하여 원래 트랜잭션이 수행된 후의 상태로 데이터를 되돌릴 수 있는데 이를 순차성이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-126">This is referred to as serializability because it results in the ability to reload the starting data and replay a series of transactions to end up with the data in the same state it was in after the original transactions were performed.</span></span>  
  
 <span data-ttu-id="9951f-127">내구성</span><span class="sxs-lookup"><span data-stu-id="9951f-127">Durability</span></span>  
 <span data-ttu-id="9951f-128">완전 내구성이 있는 트랜잭션이 완료되고 나면 그 영향이 영구적으로 시스템에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-128">After a fully durable transaction has completed, its effects are permanently in place in the system.</span></span> <span data-ttu-id="9951f-129">수정은 시스템에 오류가 발생한 경우에도 지속됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-129">The modifications persist even in the event of a system failure.</span></span> [!INCLUDE[ssSQL14](../includes/sssql14-md.md)] <span data-ttu-id="9951f-130">이상에서 지연된 영구 트랜잭션을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-130">and later enable delayed durable transactions.</span></span> <span data-ttu-id="9951f-131">지연된 영구적 트랜잭션은 트랜잭션 로그 레코드가 디스크에 유지되기 전에 커밋됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-131">Delayed durable transactions commit before the transaction log record is persisted to disk.</span></span> <span data-ttu-id="9951f-132">지연된 트랜잭션 내구성에 대한 자세한 내용은 [트랜잭션 내구성](../relational-databases/logs/control-transaction-durability.md) 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-132">For more information on delayed transaction durability see the topic [Transaction Durability](../relational-databases/logs/control-transaction-durability.md).</span></span>  
  
 <span data-ttu-id="9951f-133">SQL 프로그래머는 적시에 트랜잭션을 시작하고 끝내 데이터의 논리적 일관성을 유지하는 책임을 맡고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-133">SQL programmers are responsible for starting and ending transactions at points that enforce the logical consistency of the data.</span></span> <span data-ttu-id="9951f-134">프로그래머는 조직의 업무 규칙과 관련하여 데이터를 일관된 상태로 유지할 수 있도록 데이터 수정 순서를 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-134">The programmer must define the sequence of data modifications that leave the data in a consistent state relative to the organization's business rules.</span></span> <span data-ttu-id="9951f-135">그런 다음 이러한 수정 문을 하나의 트랜잭션에 포함하여 [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]가 트랜잭션의 물리적 무결성을 유지할 수 있게 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-135">The programmer includes these modification statements in a single transaction so that the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] can enforce the physical integrity of the transaction.</span></span>  
  
 <span data-ttu-id="9951f-136">각 트랜잭션의 물리적 무결성을 유지하는 메커니즘을 제공하는 것은 [!INCLUDE[ssDE](../includes/ssde-md.md)]과 같은 기업 데이터베이스 시스템의 책임입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-136">It is the responsibility of an enterprise database system, such as an instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)], to provide mechanisms ensuring the physical integrity of each transaction.</span></span> <span data-ttu-id="9951f-137">[!INCLUDE[ssDE](../includes/ssde-md.md)]은 다음을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-137">The [!INCLUDE[ssDE](../includes/ssde-md.md)] provides:</span></span>  
  
-   <span data-ttu-id="9951f-138">트랜잭션 격리성을 유지하는 잠금 기능</span><span class="sxs-lookup"><span data-stu-id="9951f-138">Locking facilities that preserve transaction isolation.</span></span>  
  
-   <span data-ttu-id="9951f-139">로깅 기능은 트랜잭션 내구성을 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-139">Logging facilities ensure transaction durability.</span></span> <span data-ttu-id="9951f-140">완전 내구성 있는 트랜잭션의 경우 트랜잭션이 커밋되기 전에 로그 레코드가 디스크에 확정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-140">For fully durable transactions the log record is hardened to disk before the transactions commits.</span></span> <span data-ttu-id="9951f-141">서버 하드웨어, 운영 체제 또는 [!INCLUDE[ssDE](../includes/ssde-md.md)]의 인스턴스 자체에 오류가 발생하더라도 인스턴스는 다시 시작할 때 트랜잭션 로그를 사용하여 완료되지 않은 모든 트랜잭션을 자동으로 시스템 오류 시점으로 롤백합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-141">Thus, even if the server hardware, operating system, or the instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] itself fails, the instance uses the transaction logs upon restart to automatically roll back any uncompleted transactions to the point of the system failure.</span></span> <span data-ttu-id="9951f-142">지연된 영구적 트랜잭션은 트랜잭션 로그 레코드가 디스크에 유지되기 전에 커밋됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-142">Delayed durable transactions commit before the transaction log record is hardened to disk.</span></span> <span data-ttu-id="9951f-143">이러한 트랜잭션은 로그 레코드가 디스크에 확정되기 전에 시스템 오류가 발생하면 손실될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-143">Such transactions may be lost if there is a system failure before the log record is hardened to disk.</span></span> <span data-ttu-id="9951f-144">지연된 트랜잭션 내구성에 대한 자세한 내용은 [트랜잭션 내구성](../relational-databases/logs/control-transaction-durability.md) 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-144">For more information on delayed transaction durability see the topic [Transaction Durability](../relational-databases/logs/control-transaction-durability.md).</span></span>  
  
-   <span data-ttu-id="9951f-145">트랜잭션 원자성 및 일관성을 유지하는 트랜잭션 관리 기능.</span><span class="sxs-lookup"><span data-stu-id="9951f-145">Transaction management features that enforce transaction atomicity and consistency.</span></span> <span data-ttu-id="9951f-146">트랜잭션이 일단 시작된 후에는 성공적으로 완료(커밋)되어야 합니다. 그렇지 않으면 [!INCLUDE[ssDE](../includes/ssde-md.md)]이 트랜잭션 시작 이후 만들어진 모든 데이터 수정 내용을 실행 취소합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-146">After a transaction has started, it must be successfully completed (committed), or the [!INCLUDE[ssDE](../includes/ssde-md.md)] undoes all of the data modifications made since the transaction started.</span></span> <span data-ttu-id="9951f-147">이 작업은 변경 전의 상태를 데이터에 반환하기 때문에 트랜잭션 롤백이라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-147">This operation is referred to as rolling back a transaction because it returns the data to the state it was prior to those changes.</span></span>  
  
### <a name="controlling-transactions"></a><span data-ttu-id="9951f-148">트랜잭션 제어</span><span class="sxs-lookup"><span data-stu-id="9951f-148">Controlling Transactions</span></span>  

 <span data-ttu-id="9951f-149">애플리케이션은 주로 트랜잭션 시작 및 종료 시기를 지정하여 트랜잭션을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-149">Applications control transactions mainly by specifying when a transaction starts and ends.</span></span> <span data-ttu-id="9951f-150">트랜잭션 시작 및 종료 시기는 [!INCLUDE[tsql](../includes/tsql-md.md)] 문 또는 데이터베이스 API(응용 프로그래밍 인터페이스) 함수를 사용하여 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-150">This can be specified by using either [!INCLUDE[tsql](../includes/tsql-md.md)] statements or database application programming interface (API) functions.</span></span> <span data-ttu-id="9951f-151">시스템은 트랜잭션을 불완전하게 종료하는 오류를 올바르게 처리할 수도 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-151">The system must also be able to correctly handle errors that terminate a transaction before it completes.</span></span> <span data-ttu-id="9951f-152">자세한 내용은 [트랜잭션 문 &#40;transact-sql&#41;](/sql/t-sql/language-elements/transactions-transact-sql), [ODBC의 트랜잭션](https://technet.microsoft.com/library/ms131281.aspx) 및 [OLEDB (SQL Server Native Client)의](https://msdn.microsoft.com/library/ms130918.aspx)트랜잭션을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-152">For more information, see [Transaction Statements &#40;Transact-SQL&#41;](/sql/t-sql/language-elements/transactions-transact-sql), [Transactions in ODBC](https://technet.microsoft.com/library/ms131281.aspx) and [Transactions in SQL Server Native Client (OLEDB)](https://msdn.microsoft.com/library/ms130918.aspx).</span></span>  
  
 <span data-ttu-id="9951f-153">기본적으로 트랜잭션은 연결 수준에서 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-153">By default, transactions are managed at the connection level.</span></span> <span data-ttu-id="9951f-154">한 연결에서 트랜잭션이 시작되면 트랜잭션이 끝날 때까지 해당 연결에서 실행되는 모든 [!INCLUDE[tsql](../includes/tsql-md.md)] 문은 트랜잭션의 일부가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-154">When a transaction is started on a connection, all [!INCLUDE[tsql](../includes/tsql-md.md)] statements executed on that connection are part of the transaction until the transaction ends.</span></span> <span data-ttu-id="9951f-155">그러나 MARS(Multiple Active Result Set) 세션에서는 [!INCLUDE[tsql](../includes/tsql-md.md)] 명시적 또는 암시적 트랜잭션이 일괄 처리 수준에서 관리되는 일괄 처리 범위의 트랜잭션이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-155">However, under a multiple active result set (MARS) session, a [!INCLUDE[tsql](../includes/tsql-md.md)] explicit or implicit transaction becomes a batch-scoped transaction that is managed at the batch level.</span></span> <span data-ttu-id="9951f-156">일괄 처리가 완료될 때 일괄 처리 범위의 트랜잭션이 커밋되거나 롤백되지 않으면 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]에서 해당 트랜잭션을 자동으로 롤백합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-156">When the batch completes, if the batch-scoped transaction is not committed or rolled back, it is automatically rolled back by [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="9951f-157">자세한 내용은 [SQL Server에서 MARS (Multiple Active Result Sets)](https://msdn.microsoft.com/library/ms345109(v=SQL.90).aspx)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-157">For more information, see [Multiple Active Result Sets (MARS) in SQL Server](https://msdn.microsoft.com/library/ms345109(v=SQL.90).aspx).</span></span>  
  
#### <a name="starting-transactions"></a><span data-ttu-id="9951f-158">트랜잭션 시작</span><span class="sxs-lookup"><span data-stu-id="9951f-158">Starting Transactions</span></span>  

 <span data-ttu-id="9951f-159">API 함수와 [!INCLUDE[tsql](../includes/tsql-md.md)] 문을 사용하여 [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 인스턴스에서 명시적, 자동 커밋 또는 암시적 트랜잭션을 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-159">Using API functions and [!INCLUDE[tsql](../includes/tsql-md.md)] statements, you can start transactions in an instance of the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] as explicit, autocommit, or implicit transactions.</span></span>  
  
 <span data-ttu-id="9951f-160">**명시적 트랜잭션**</span><span class="sxs-lookup"><span data-stu-id="9951f-160">**Explicit Transactions**</span></span>  
 <span data-ttu-id="9951f-161">명시적 트랜잭션은 API 함수를 통해 또는 [!INCLUDE[tsql](../includes/tsql-md.md)] BEGIN TRANSACTION, COMMIT TRANSACTION, COMMIT WORK, ROLLBACK TRANSACTION 또는 ROLLBACK WORK [!INCLUDE[tsql](../includes/tsql-md.md)] 문을 실행하여 트랜잭션 시작 및 완료를 모두 명시적으로 정의하는 트랜잭션입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-161">An explicit transaction is one in which you explicitly define both the start and end of the transaction through an API function or by issuing the [!INCLUDE[tsql](../includes/tsql-md.md)] BEGIN TRANSACTION, COMMIT TRANSACTION, COMMIT WORK, ROLLBACK TRANSACTION, or ROLLBACK WORK [!INCLUDE[tsql](../includes/tsql-md.md)] statements.</span></span> <span data-ttu-id="9951f-162">트랜잭션이 끝나면 명시적 트랜잭션이 시작된 시기의 트랜잭션 모드인 암시적 모드나 자동 커밋 모드로 되돌려집니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-162">When the transaction ends, the connection returns to the transaction mode it was in before the explicit transaction was started, either implicit or autocommit mode.</span></span>  
  
 <span data-ttu-id="9951f-163">명시적 트랜잭션에서는 다음 문을 제외한 모든 [!INCLUDE[tsql](../includes/tsql-md.md)] 문을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-163">You can use all [!INCLUDE[tsql](../includes/tsql-md.md)] statements in an explicit transaction, except for the following statements:</span></span>  
  
||||  
|-|-|-|  
|<span data-ttu-id="9951f-164">ALTER DATABASE</span><span class="sxs-lookup"><span data-stu-id="9951f-164">ALTER DATABASE</span></span>|<span data-ttu-id="9951f-165">CREATE DATABASE</span><span class="sxs-lookup"><span data-stu-id="9951f-165">CREATE DATABASE</span></span>|<span data-ttu-id="9951f-166">DROP FULLTEXT INDEX</span><span class="sxs-lookup"><span data-stu-id="9951f-166">DROP FULLTEXT INDEX</span></span>|  
|<span data-ttu-id="9951f-167">ALTER FULLTEXT CATALOG</span><span class="sxs-lookup"><span data-stu-id="9951f-167">ALTER FULLTEXT CATALOG</span></span>|<span data-ttu-id="9951f-168">CREATE FULLTEXT CATALOG</span><span class="sxs-lookup"><span data-stu-id="9951f-168">CREATE FULLTEXT CATALOG</span></span>|<span data-ttu-id="9951f-169">RECONFIGURE</span><span class="sxs-lookup"><span data-stu-id="9951f-169">RECONFIGURE</span></span>|  
|<span data-ttu-id="9951f-170">ALTER FULLTEXT INDEX</span><span class="sxs-lookup"><span data-stu-id="9951f-170">ALTER FULLTEXT INDEX</span></span>|<span data-ttu-id="9951f-171">CREATE FULLTEXT INDEX</span><span class="sxs-lookup"><span data-stu-id="9951f-171">CREATE FULLTEXT INDEX</span></span>|<span data-ttu-id="9951f-172">RESTORE</span><span class="sxs-lookup"><span data-stu-id="9951f-172">RESTORE</span></span>|  
|<span data-ttu-id="9951f-173">BACKUP</span><span class="sxs-lookup"><span data-stu-id="9951f-173">BACKUP</span></span>|<span data-ttu-id="9951f-174">DROP DATABASE</span><span class="sxs-lookup"><span data-stu-id="9951f-174">DROP DATABASE</span></span>|<span data-ttu-id="9951f-175">전체 텍스트 시스템 저장 프로시저</span><span class="sxs-lookup"><span data-stu-id="9951f-175">Full-text system stored procedures</span></span>|  
|<span data-ttu-id="9951f-176">CREATE DATABASE</span><span class="sxs-lookup"><span data-stu-id="9951f-176">CREATE DATABASE</span></span>|<span data-ttu-id="9951f-177">DROP FULLTEXT CATALOG</span><span class="sxs-lookup"><span data-stu-id="9951f-177">DROP FULLTEXT CATALOG</span></span>|<span data-ttu-id="9951f-178">데이터베이스 옵션을 설정하는 sp_dboption 또는 명시적/암시적 트랜잭션 내에서 master 데이터베이스를 수정하는 시스템 프로시저</span><span class="sxs-lookup"><span data-stu-id="9951f-178">sp_dboption to set database options or any system procedure that modifies the master database inside explicit or implicit transactions.</span></span>|  
  
> [!NOTE]  
>  <span data-ttu-id="9951f-179">UPDATE STATISTICS는 명시적 트랜잭션 내에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-179">UPDATE STATISTICS can be used inside an explicit transaction.</span></span> <span data-ttu-id="9951f-180">그러나 UPDATE STATISTICS는 포함하는 트랜잭션과 별개로 커밋하며 롤백할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-180">However, UPDATE STATISTICS commits independently of the enclosing transaction and cannot be rolled back.</span></span>  
  
 <span data-ttu-id="9951f-181">**자동 커밋 트랜잭션**</span><span class="sxs-lookup"><span data-stu-id="9951f-181">**Autocommit Transactions**</span></span>  
 <span data-ttu-id="9951f-182">자동 커밋 모드는 SQL Server 데이터베이스 엔진의 기본 트랜잭션 관리 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-182">Autocommit mode is the default transaction management mode of the SQL Server Database Engine.</span></span> <span data-ttu-id="9951f-183">모든 Transact-SQL 문은 완료 시 커밋되거나 롤백됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-183">Every Transact-SQL statement is committed or rolled back when it completes.</span></span> <span data-ttu-id="9951f-184">문이 성공적으로 완료되면 커밋되며 오류가 발생하면 롤백됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-184">If a statement completes successfully, it is committed; if it encounters any error, it is rolled back.</span></span> <span data-ttu-id="9951f-185">데이터베이스 엔진 인스턴스에 대한 연결은 명시적 트랜잭션이나 암시적 트랜잭션에 의해 이 기본 모드가 무시되지 않는 한 자동 커밋 모드로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-185">A connection to an instance of the Database Engine operates in autocommit mode whenever this default mode has not been overridden by either explicit or implicit transactions.</span></span> <span data-ttu-id="9951f-186">자동 커밋 모드는 또한 ADO, OLE DB, ODBC 및 DB-Library의 기본 모드이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-186">Autocommit mode is also the default mode for ADO, OLE DB, ODBC, and DB-Library.</span></span>  
  
 <span data-ttu-id="9951f-187">**암시적 트랜잭션**</span><span class="sxs-lookup"><span data-stu-id="9951f-187">**Implicit Transactions**</span></span>  
 <span data-ttu-id="9951f-188">연결이 암시적 트랜잭션 모드에서 작동할 때는 현재 트랜잭션이 커밋 또는 롤백된 후 데이터베이스 엔진 인스턴스에서 자동으로 새 트랜잭션을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-188">When a connection is operating in implicit transaction mode, the instance of the Database Engine automatically starts a new transaction after the current transaction is committed or rolled back.</span></span> <span data-ttu-id="9951f-189">트랜잭션 시작을 직접 지정할 필요 없이 각 트랜잭션을 커밋 또는 롤백하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-189">You do nothing to delineate the start of a transaction; you only commit or roll back each transaction.</span></span> <span data-ttu-id="9951f-190">암시적 트랜잭션 모드는 트랜잭션의 연속 체인을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-190">Implicit transaction mode generates a continuous chain of transactions.</span></span> <span data-ttu-id="9951f-191">API 함수나 [!INCLUDE[tsql](../includes/tsql-md.md)] SET IMPLICIT_TRANSACTIONS ON 문을 통해 암시적 트랜잭션 모드를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-191">Set implicit transaction mode on through either an API function or the [!INCLUDE[tsql](../includes/tsql-md.md)] SET IMPLICIT_TRANSACTIONS ON statement.</span></span>  
  
 <span data-ttu-id="9951f-192">연결에 대해 암시적 트랜잭션 모드를 설정하고 나면 이러한 문을 처음 실행할 때 [!INCLUDE[ssDE](../includes/ssde-md.md)] 인스턴스가 자동으로 트랜잭션을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-192">After implicit transaction mode has been set on for a connection, the instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] automatically starts a transaction when it first executes any of these statements:</span></span>  
  
||||  
|-|-|-|  
|<span data-ttu-id="9951f-193">ALTER TABLE</span><span class="sxs-lookup"><span data-stu-id="9951f-193">ALTER TABLE</span></span>|<span data-ttu-id="9951f-194">FETCH</span><span class="sxs-lookup"><span data-stu-id="9951f-194">FETCH</span></span>|<span data-ttu-id="9951f-195">REVOKE</span><span class="sxs-lookup"><span data-stu-id="9951f-195">REVOKE</span></span>|  
|<span data-ttu-id="9951f-196">CREATE</span><span class="sxs-lookup"><span data-stu-id="9951f-196">CREATE</span></span>|<span data-ttu-id="9951f-197">GRANT</span><span class="sxs-lookup"><span data-stu-id="9951f-197">GRANT</span></span>|<span data-ttu-id="9951f-198">SELECT</span><span class="sxs-lookup"><span data-stu-id="9951f-198">SELECT</span></span>|  
|<span data-ttu-id="9951f-199">Delete</span><span class="sxs-lookup"><span data-stu-id="9951f-199">DELETE</span></span>|<span data-ttu-id="9951f-200">INSERT</span><span class="sxs-lookup"><span data-stu-id="9951f-200">INSERT</span></span>|<span data-ttu-id="9951f-201">TRUNCATE TABLE</span><span class="sxs-lookup"><span data-stu-id="9951f-201">TRUNCATE TABLE</span></span>|  
|<span data-ttu-id="9951f-202">DROP</span><span class="sxs-lookup"><span data-stu-id="9951f-202">DROP</span></span>|<span data-ttu-id="9951f-203">OPEN</span><span class="sxs-lookup"><span data-stu-id="9951f-203">OPEN</span></span>|<span data-ttu-id="9951f-204">UPDATE</span><span class="sxs-lookup"><span data-stu-id="9951f-204">UPDATE</span></span>|  
  
 <span data-ttu-id="9951f-205">**일괄 처리 범위의 트랜잭션**</span><span class="sxs-lookup"><span data-stu-id="9951f-205">**Batch-scoped Transactions**</span></span>  
 <span data-ttu-id="9951f-206">MARS(Multiple Active Result Sets)에만 해당되며, MARS 세션에서 시작되는 [!INCLUDE[tsql](../includes/tsql-md.md)] 명시적 또는 암시적 트랜잭션이 일괄 처리 범위 트랜잭션이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-206">Applicable only to multiple active result sets (MARS), a [!INCLUDE[tsql](../includes/tsql-md.md)] explicit or implicit transaction that starts under a MARS session becomes a batch-scoped transaction.</span></span> <span data-ttu-id="9951f-207">일괄 처리가 완료될 때 커밋되거나 롤백되지 않은 일괄 처리 범위의 트랜잭션은 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]에서 자동으로 롤백합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-207">A batch-scoped transaction that is not committed or rolled back when a batch completes is automatically rolled back by [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span>  
  
 <span data-ttu-id="9951f-208">**분산 트랜잭션**</span><span class="sxs-lookup"><span data-stu-id="9951f-208">**Distributed Transactions**</span></span>  
 <span data-ttu-id="9951f-209">분산 트랜잭션은 리소스 관리자라고 하는 둘 이상의 서버에 분산됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-209">Distributed transactions span two or more servers known as resource managers.</span></span> <span data-ttu-id="9951f-210">트랜잭션 관리는 트랜잭션 관리자라고 하는 서버 구성 요소에 의해 리소스 관리자 간에 조정되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-210">The management of the transaction must be coordinated between the resource managers by a server component called a transaction manager.</span></span> <span data-ttu-id="9951f-211">MS DTC([!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]은 [!INCLUDE[msCoName](../includes/msconame-md.md)] Distributed Transaction Coordinator) 등의 트랜잭션 관리자 또는 분산 트랜잭션 처리용 Open Group XA 사양을 지원하는 기타 트랜잭션 관리자에 의해 조정되는 분산 트랜잭션에서 리소스 관리자 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-211">Each instance of the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] can operate as a resource manager in distributed transactions coordinated by transaction managers, such as [!INCLUDE[msCoName](../includes/msconame-md.md)] Distributed Transaction Coordinator (MS DTC), or other transaction managers that support the Open Group XA specification for distributed transaction processing.</span></span> <span data-ttu-id="9951f-212">자세한 내용은 MS DTC 설명서를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="9951f-212">For more information, see the MS DTC documentation.</span></span>  
  
 <span data-ttu-id="9951f-213">둘 이상의 데이터베이스에 분산된 [!INCLUDE[ssDE](../includes/ssde-md.md)]의 단일 인스턴스 내에 있는 트랜잭션은 실제로 분산 트랜잭션입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-213">A transaction within a single instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] that spans two or more databases is actually a distributed transaction.</span></span> <span data-ttu-id="9951f-214">인스턴스는 분산 트랜잭션을 내부적으로 관리하므로 사용자에게는 로컬 트랜잭션처럼 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-214">The instance manages the distributed transaction internally; to the user, it operates as a local transaction.</span></span>  
  
 <span data-ttu-id="9951f-215">애플리케이션에서의 분산 트랜잭션 관리 방법은 로컬 트랜잭션과 많은 부분이 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-215">At the application, a distributed transaction is managed much the same as a local transaction.</span></span> <span data-ttu-id="9951f-216">트랜잭션이 끝나면 애플리케이션이 트랜잭션을 커밋 또는 롤백하도록 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-216">At the end of the transaction, the application requests the transaction to be either committed or rolled back.</span></span> <span data-ttu-id="9951f-217">트랜잭션 관리자는 분산 커밋을 다른 방법으로 관리하여 일부 리소스 관리자는 성공적으로 커밋하고 일부는 트랜잭션을 롤백하는 네트워크 오류의 발생 가능성을 최소화해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-217">A distributed commit must be managed differently by the transaction manager to minimize the risk that a network failure may result in some resource managers successfully committing while others roll back the transaction.</span></span> <span data-ttu-id="9951f-218">이렇게 하려면 커밋 프로세스를 준비 단계와 커밋 단계로 관리해야 하는데 이러한 방법을 2단계 커밋(2PC)이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-218">This is achieved by managing the commit process in two phases (the prepare phase and the commit phase), which is known as a two-phase commit (2PC).</span></span>  
  
 <span data-ttu-id="9951f-219">준비 단계</span><span class="sxs-lookup"><span data-stu-id="9951f-219">Prepare phase</span></span>  
 <span data-ttu-id="9951f-220">트랜잭션 관리자가 커밋 요청을 수신하면 트랜잭션과 관련된 모든 리소스 관리자에게 준비 명령을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-220">When the transaction manager receives a commit request, it sends a prepare command to all of the resource managers involved in the transaction.</span></span> <span data-ttu-id="9951f-221">그런 다음 각 리소스 관리자는 트랜잭션을 지속적으로 만들고 트랜잭션에 대한 로그 이미지를 갖고 있는 버퍼를 디스크로 플러시하는 데 필요한 모든 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-221">Each resource manager then does everything required to make the transaction durable, and all buffers holding log images for the transaction are flushed to disk.</span></span> <span data-ttu-id="9951f-222">각 리소스 관리자가 준비 단계를 완료하면 준비 성공 또는 실패 여부를 트랜잭션 관리자에게 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-222">As each resource manager completes the prepare phase, it returns success or failure of the prepare to the transaction manager.</span></span> [!INCLUDE[ssSQL14](../includes/sssql14-md.md)]<span data-ttu-id="9951f-223">에서 지연된 트랜잭션 내구성이 도입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-223">introduced delayed transaction durability.</span></span> <span data-ttu-id="9951f-224">지연된 영구적 트랜잭션은 트랜잭션 로그 이미지가 디스크에 플러시되기 전에 커밋됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-224">Delayed durable transactions commit before log images for the transaction are flushed to disk.</span></span> <span data-ttu-id="9951f-225">지연된 트랜잭션 내구성에 대한 자세한 내용은 [트랜잭션 내구성](../relational-databases/logs/control-transaction-durability.md) 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-225">For more information on delayed transaction durability see the topic [Transaction Durability](../relational-databases/logs/control-transaction-durability.md).</span></span>  
  
 <span data-ttu-id="9951f-226">커밋 단계</span><span class="sxs-lookup"><span data-stu-id="9951f-226">Commit phase</span></span>  
 <span data-ttu-id="9951f-227">트랜잭션 관리자가 모든 리소스 관리자로부터 준비 성공 알림을 받으면 각 리소스 관리자에게 커밋 명령을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-227">If the transaction manager receives successful prepares from all of the resource managers, it sends commit commands to each resource manager.</span></span> <span data-ttu-id="9951f-228">그런 다음에는 리소스 관리자가 커밋을 완료할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-228">The resource managers can then complete the commit.</span></span> <span data-ttu-id="9951f-229">모든 리소스 관리자가 성공적인 커밋을 보고하면 트랜잭션 관리자가 애플리케이션에 성공을 알립니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-229">If all of the resource managers report a successful commit, the transaction manager then sends a success notification to the application.</span></span> <span data-ttu-id="9951f-230">준비 실패를 보고한 리소스 관리자가 있으면 트랜잭션 관리자가 각 리소스 관리자에게 롤백 명령을 보내서 애플리케이션에게 커밋 실패를 알립니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-230">If any resource manager reported a failure to prepare, the transaction manager sends a rollback command to each resource manager and indicates the failure of the commit to the application.</span></span>  
  
 [!INCLUDE[ssDE](../includes/ssde-md.md)] <span data-ttu-id="9951f-231">애플리케이션은 [!INCLUDE[tsql](../includes/tsql-md.md)] 또는 데이터베이스 API를 통해 분산 트랜잭션을 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-231">applications can manage distributed transactions either through [!INCLUDE[tsql](../includes/tsql-md.md)] or the database API.</span></span> <span data-ttu-id="9951f-232">자세한 내용은 [BEGIN DISTRIBUTED TRANSACTION&#40;Transact-SQL&#41;](/sql/t-sql/language-elements/begin-distributed-transaction-transact-sql)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-232">For more information, see [BEGIN DISTRIBUTED TRANSACTION &#40;Transact-SQL&#41;](/sql/t-sql/language-elements/begin-distributed-transaction-transact-sql).</span></span>  
  
#### <a name="ending-transactions"></a><span data-ttu-id="9951f-233">트랜잭션 종료</span><span class="sxs-lookup"><span data-stu-id="9951f-233">Ending Transactions</span></span>  

 <span data-ttu-id="9951f-234">COMMIT 또는 ROLLBACK 문을 사용하거나 해당 API 함수를 통해 트랜잭션을 종료할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-234">You can end transactions with either a COMMIT or ROLLBACK statement, or through a corresponding API function.</span></span>  
  
 <span data-ttu-id="9951f-235">COMMIT</span><span class="sxs-lookup"><span data-stu-id="9951f-235">COMMIT</span></span>  
 <span data-ttu-id="9951f-236">트랜잭션이 성공하면 커밋합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-236">If a transaction is successful, commit it.</span></span> <span data-ttu-id="9951f-237">COMMIT 문을 사용하면 모든 트랜잭션 수정이 영구적으로 데이터베이스의 일부로 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-237">A COMMIT statement guarantees all of the transaction's modifications are made a permanent part of the database.</span></span> <span data-ttu-id="9951f-238">COMMIT은 또한 트랜잭션에 사용된 잠금과 같은 리소스를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-238">A COMMIT also frees resources, such as locks, used by the transaction.</span></span>  
  
 <span data-ttu-id="9951f-239">ROLLBACK</span><span class="sxs-lookup"><span data-stu-id="9951f-239">ROLLBACK</span></span>  
 <span data-ttu-id="9951f-240">트랜잭션에서 오류가 발생하거나 사용자가 트랜잭션을 취소하려고 결정한 경우 트랜잭션을 롤백합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-240">If an error occurs in a transaction, or if the user decides to cancel the transaction, then roll the transaction back.</span></span> <span data-ttu-id="9951f-241">ROLLBACK 문은 데이터를 트랜잭션이 시작되기 전 상태로 되돌려서 트랜잭션 진행 중 수정된 모든 내용을 취소합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-241">A ROLLBACK statement backs out all modifications made in the transaction by returning the data to the state it was in at the start of the transaction.</span></span> <span data-ttu-id="9951f-242">ROLLBACK은 또한 트랜잭션에서 보유 중인 리소스를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-242">A ROLLBACK also frees resources held by the transaction.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9951f-243">MARS를 지원하도록 설정된 연결에서는 실행 보류 중인 요청이 있을 경우 API 함수를 통해 시작한 명시적 트랜잭션을 커밋할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-243">Under connections enabled to support multiple active result sets (MARS), an explicit transaction started through an API function cannot be committed while there are pending requests for execution.</span></span> <span data-ttu-id="9951f-244">보류 중인 작업이 있는 동안 이러한 유형의 트랜잭션을 커밋하려고 하면 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-244">Any attempt to commit this type of  transaction while there are outstanding operations running will result in an error.</span></span>  
  
#### <a name="errors-during-transaction-processing"></a><span data-ttu-id="9951f-245">트랜잭션 처리 중 오류</span><span class="sxs-lookup"><span data-stu-id="9951f-245">Errors During Transaction Processing</span></span>  

 <span data-ttu-id="9951f-246">오류로 인해 트랜잭션이 성공적으로 완료되지 않은 경우 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]에서는 자동으로 트랜잭션을 롤백하고 해당 트랜잭션에 보유 중인 모든 리소스를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-246">If an error prevents the successful completion of a transaction, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] automatically rolls back the transaction and frees all resources held by the transaction.</span></span> <span data-ttu-id="9951f-247">클라이언트와 [!INCLUDE[ssDE](../includes/ssde-md.md)] 인스턴스 간의 네트워크 연결이 끊어진 경우 네트워크에서 이 인스턴스에게 연결이 끊어진 것을 알릴 때 해당 연결에서 보류 중인 트랜잭션은 모두 롤백됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-247">If the client's network connection to an instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] is broken, any outstanding transactions for the connection are rolled back when the network notifies the instance of the break.</span></span> <span data-ttu-id="9951f-248">클라이언트 애플리케이션에 오류가 발생하거나 클라이언트 컴퓨터가 다운 또는 다시 시작되는 경우에도 네트워크 연결은 끊어지고 [!INCLUDE[ssDE](../includes/ssde-md.md)] 인스턴스는 네트워크에서 연결이 끊어진 것을 확인하면 보류 중인 트랜잭션을 모두 롤백합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-248">If the client application fails or if the client computer goes down or is restarted, this also breaks the connection, and the instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] rolls back any outstanding connections when the network notifies it of the break.</span></span> <span data-ttu-id="9951f-249">클라이언트가 애플리케이션에서 로그오프하면 보류 중인 트랜잭션은 모두 롤백됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-249">If the client logs off the application, any outstanding transactions are rolled back.</span></span>  
  
 <span data-ttu-id="9951f-250">일괄 처리에서 제약 조건 위반 등 런타임 문 오류가 발생하면 [!INCLUDE[ssDE](../includes/ssde-md.md)]에서는 기본적으로 오류를 발생시킨 문만 롤백합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-250">If a run-time statement error (such as a constraint violation) occurs in a batch, the default behavior in the [!INCLUDE[ssDE](../includes/ssde-md.md)] is to roll back only the statement that generated the error.</span></span> <span data-ttu-id="9951f-251">이 동작은 SET XACT_ABORT 문을 사용하여 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-251">You can change this behavior using the SET XACT_ABORT statement.</span></span> <span data-ttu-id="9951f-252">SET XACT_ABORT ON이 실행된 후에는 모든 런타임 문 오류 발생 시 자동으로 현재 트랜잭션이 롤백됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-252">After SET XACT_ABORT ON is executed, any run-time statement error causes an automatic rollback of the current transaction.</span></span> <span data-ttu-id="9951f-253">구문 오류와 같은 컴파일 오류는 SET XACT_ABORT 옵션 설정으로 영향을 받지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-253">Compile errors, such as syntax errors, are not affected by SET XACT_ABORT.</span></span> <span data-ttu-id="9951f-254">자세한 내용은 [SET XACT_ABORT&#40;Transact-SQL&#41;](/sql/t-sql/statements/set-xact-abort-transact-sql)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-254">For more information, see [SET XACT_ABORT &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-xact-abort-transact-sql).</span></span>  
  
 <span data-ttu-id="9951f-255">오류가 발생하면 수정 동작(COMMIT 또는 ROLLBACK)을 애플리케이션 코드에 포함해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-255">When errors occur, corrective action (COMMIT or ROLLBACK) should be included in application code.</span></span> <span data-ttu-id="9951f-256">트랜잭션 오류를 포함 하 여 오류를 처리 하는 효과적인 도구 중 하나는 [!INCLUDE[tsql](../includes/tsql-md.md)] TRY ... 구문을 CATCH 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-256">One effective tool for handling errors, including those in transactions, is the [!INCLUDE[tsql](../includes/tsql-md.md)] TRY...CATCH construct.</span></span> <span data-ttu-id="9951f-257">트랜잭션이 포함된 예를 보려면 [TRY...CATCH&#40;Transact-SQL&#41;](/sql/t-sql/language-elements/try-catch-transact-sql)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="9951f-257">For more information with examples that include transactions, see [TRY...CATCH &#40;Transact-SQL&#41;](/sql/t-sql/language-elements/try-catch-transact-sql).</span></span> <span data-ttu-id="9951f-258">부터는 [!INCLUDE[ssSQL11](../includes/sssql11-md.md)] THROW 문을 사용 하 여 예외를 발생 시키고 try ...의 CATCH 블록으로 실행을 전송할 수 있습니다. 구문을 CATCH 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-258">Beginning with [!INCLUDE[ssSQL11](../includes/sssql11-md.md)], you can use the THROW statement to raise an exception and transfers execution to a CATCH block of a TRY...CATCH construct.</span></span> <span data-ttu-id="9951f-259">자세한 내용은 [THROW&#40;Transact-SQL&#41;](/sql/t-sql/language-elements/throw-transact-sql)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-259">For more information, see [THROW &#40;Transact-SQL&#41;](/sql/t-sql/language-elements/throw-transact-sql).</span></span>  
  
##### <a name="compile-and-run-time-errors-in-autocommit-mode"></a><span data-ttu-id="9951f-260">자동 커밋 모드에서 컴파일 오류 및 런타임 오류</span><span class="sxs-lookup"><span data-stu-id="9951f-260">Compile and Run-time Errors in Autocommit mode</span></span>  

 <span data-ttu-id="9951f-261">자동 커밋 모드에서는 [!INCLUDE[ssDE](../includes/ssde-md.md)] 인스턴스가 한 SQL 문이 아니라 전체 일괄 처리를 롤백하는 것처럼 보일 때가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-261">In autocommit mode, it sometimes appears as if an instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] has rolled back an entire batch instead of just one SQL statement.</span></span> <span data-ttu-id="9951f-262">이러한 상황은 런타임 오류가 아니라 컴파일 오류가 발생했을 때 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-262">This happens if the error encountered is a compile error, not a run-time error.</span></span> <span data-ttu-id="9951f-263">컴파일 오류가 발생하면 [!INCLUDE[ssDE](../includes/ssde-md.md)]에서 실행 계획을 작성할 수 없으므로 일괄 처리가 실행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-263">A compile error prevents the [!INCLUDE[ssDE](../includes/ssde-md.md)] from building an execution plan, so nothing in the batch is executed.</span></span> <span data-ttu-id="9951f-264">오류를 생성한 문 이전의 모든 문이 롤백되는 것처럼 보이지만 오류가 발생하면 일괄 처리의 모든 문이 실행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-264">Although it appears that all of the statements before the one generating the error were rolled back, the error prevented anything in the batch from being executed.</span></span> <span data-ttu-id="9951f-265">다음 예에서는 컴파일 오류가 발생하여 세 번째 일괄 처리의 `INSERT` 문이 하나도 실행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-265">In the following example, none of the `INSERT` statements in the third batch are executed because of a compile error.</span></span> <span data-ttu-id="9951f-266">처음 두 `INSERT` 문이 롤백되는 것처럼 보이지만 전혀 실행되지 않은 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-266">It appears that the first two `INSERT` statements are rolled back when they are never executed.</span></span>  
  
```sql
CREATE TABLE TestBatch (Cola INT PRIMARY KEY, Colb CHAR(3));  
GO  
INSERT INTO TestBatch VALUES (1, 'aaa');  
INSERT INTO TestBatch VALUES (2, 'bbb');  
INSERT INTO TestBatch VALUSE (3, 'ccc');  -- Syntax error.  
GO  
SELECT * FROM TestBatch;  -- Returns no rows.  
GO  
```  
  
 <span data-ttu-id="9951f-267">다음 예에서는 세 번째 `INSERT` 문에서 런타임 기본 키 중복 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-267">In the following example, the third `INSERT` statement generates a run-time duplicate primary key error.</span></span> <span data-ttu-id="9951f-268">처음 두 `INSERT` 문은 성공하고 커밋되므로 런타임 오류 이후에도 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-268">The first two `INSERT` statements are successful and committed, so they remain after the run-time error.</span></span>  
  
```sql  
CREATE TABLE TestBatch (Cola INT PRIMARY KEY, Colb CHAR(3));  
GO  
INSERT INTO TestBatch VALUES (1, 'aaa');  
INSERT INTO TestBatch VALUES (2, 'bbb');  
INSERT INTO TestBatch VALUES (1, 'ccc');  -- Duplicate key error.  
GO  
SELECT * FROM TestBatch;  -- Returns rows 1 and 2.  
GO  
```  
  
 <span data-ttu-id="9951f-269">[!INCLUDE[ssDE](../includes/ssde-md.md)]에서는 실행 시간까지 개체 이름이 확인되지 않는 지연된 이름 확인 기능을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-269">The [!INCLUDE[ssDE](../includes/ssde-md.md)] uses deferred name resolution, in which object names are not resolved until execution time.</span></span> <span data-ttu-id="9951f-270">다음 예에서는 처음 두 `INSERT` 문이 실행되어 커밋되므로 세 번째 `TestBatch` 문이 존재하지 않는 테이블을 참조하여 런타임 오류를 생성한 후에도 처음 두 행은 `INSERT` 테이블에 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-270">In the following example, the first two `INSERT` statements are executed and committed, and those two rows remain in the `TestBatch` table after the third `INSERT` statement generates a run-time error by referring to a table that does not exist.</span></span>  
  
```sql
CREATE TABLE TestBatch (Cola INT PRIMARY KEY, Colb CHAR(3));  
GO  
INSERT INTO TestBatch VALUES (1, 'aaa');  
INSERT INTO TestBatch VALUES (2, 'bbb');  
INSERT INTO TestBch VALUES (3, 'ccc');  -- Table name error.  
GO  
SELECT * FROM TestBatch;  -- Returns rows 1 and 2.  
GO  
```  
  
 <span data-ttu-id="9951f-271">[이 가이드의](#Top) ![맨 위 링크와 함께 사용 되는 화살표 아이콘](media/uparrow16x16.gif "맨 위로 이동 링크와 함께 사용되는 화살표 아이콘")</span><span class="sxs-lookup"><span data-stu-id="9951f-271">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="locking-and-row-versioning-basics"></a><a name="Lock_Basics"></a> <span data-ttu-id="9951f-272">잠금 및 행 버전 관리 기본 사항</span><span class="sxs-lookup"><span data-stu-id="9951f-272">Locking and Row Versioning Basics</span></span>  

 <span data-ttu-id="9951f-273">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]에서는 여러 사용자가 동시에 데이터를 액세스하는 경우 다음 메커니즘을 사용하여 트랜잭션의 무결성을 확인하고 데이터베이스의 일관성을 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-273">The [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] uses the following mechanisms to ensure the integrity of transactions and maintain the consistency of databases when multiple users are accessing data at the same time:</span></span>  
  
-   <span data-ttu-id="9951f-274">잠금</span><span class="sxs-lookup"><span data-stu-id="9951f-274">Locking</span></span>  
  
     <span data-ttu-id="9951f-275">각 트랜잭션은 해당 트랜잭션이 종속되는 행, 페이지 또는 테이블 등의 리소스에 대해 서로 다른 유형의 잠금을 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-275">Each transaction requests locks of different types on the resources, such as rows, pages, or tables, on which the transaction is dependent.</span></span> <span data-ttu-id="9951f-276">잠금은 다른 트랜잭션의 리소스 수정을 차단하여 잠금을 요청하는 트랜잭션에 문제가 발생하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-276">The locks block other transactions from modifying the resources in a way that would cause problems for the transaction requesting the lock.</span></span> <span data-ttu-id="9951f-277">각 트랜잭션은 잠긴 리소스에 더 이상 종속되지 않게 되면 잠금을 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-277">Each transaction frees its locks when it no longer has a dependency on the locked resources.</span></span>  
  
-   <span data-ttu-id="9951f-278">행 버전 관리</span><span class="sxs-lookup"><span data-stu-id="9951f-278">Row versioning</span></span>  
  
     <span data-ttu-id="9951f-279">행 버전 관리 기반 격리 수준을 사용하면 [!INCLUDE[ssDE](../includes/ssde-md.md)]은 수정된 각 행의 버전을 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-279">When a row versioning-based isolation level is enabled, the [!INCLUDE[ssDE](../includes/ssde-md.md)] maintains versions of each row that is modified.</span></span> <span data-ttu-id="9951f-280">애플리케이션에서는 잠금을 사용하여 모든 읽기 작업을 보호하는 대신 트랜잭션이 해당 트랜잭션 또는 쿼리 시작 부분에 있는 행 버전을 사용하여 데이터를 확인하도록 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-280">Applications can specify that a transaction use the row versions to view data as it existed at the start of the transaction or query instead of protecting all reads with locks.</span></span> <span data-ttu-id="9951f-281">행 버전 관리를 사용하면 읽기 작업에 의해 다른 트랜잭션이 차단될 가능성이 크게 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-281">By using row versioning, the chance that a read operation will block other transactions is greatly reduced.</span></span>  
  
 <span data-ttu-id="9951f-282">잠금 및 행 버전 관리는 사용자가 커밋되지 않은 데이터를 읽을 수 없도록 하고 여러 사용자가 동일한 데이터를 동시에 변경하지 못하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-282">Locking and row versioning prevent users from reading uncommitted data and prevent multiple users from attempting to change the same data at the same time.</span></span> <span data-ttu-id="9951f-283">잠금 또는 행 버전 관리를 사용하지 않는 경우 데이터에 대해 쿼리를 실행하면 아직 데이터베이스에서 커밋되지 않은 데이터가 반환되어 예기치 않은 결과가 나타날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-283">Without locking or row versioning, queries executed against that data could produce unexpected results by returning data that has not yet been committed in the database.</span></span>  
  
 <span data-ttu-id="9951f-284">애플리케이션에서는 다른 트랜잭션에 의해 수정되지 않도록 트랜잭션을 보호하는 수준을 정의하는 트랜잭션 격리 수준을 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-284">Applications can choose transaction isolation levels, which define the level of protection for the transaction from modifications made by other transactions.</span></span> <span data-ttu-id="9951f-285">개별 [!INCLUDE[tsql](../includes/tsql-md.md)] 문에 대해 테이블 수준 힌트를 지정하여 애플리케이션의 요구 사항에 맞는 동작을 더 적절하게 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-285">Table-level hints can be specified for individual [!INCLUDE[tsql](../includes/tsql-md.md)] statements to further tailor behavior to fit the requirements of the application.</span></span>  
  
### <a name="managing-concurrent-data-access"></a><span data-ttu-id="9951f-286">동시 데이터 액세스 관리</span><span class="sxs-lookup"><span data-stu-id="9951f-286">Managing Concurrent Data Access</span></span>  

 <span data-ttu-id="9951f-287">특정 리소스에 여러 사용자가 동시에 액세스하는 것을 동시 액세스라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-287">Users who access a resource at the same time are said to be accessing the resource concurrently.</span></span> <span data-ttu-id="9951f-288">동시 데이터 액세스를 위해서는 다른 사용자가 현재 사용하고 있는 리소스를 여러 사용자가 수정하려 할 때 역효과가 발생하지 않도록 하는 메커니즘이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-288">Concurrent data access requires mechanisms to prevent adverse effects when multiple users try to modify resources that other users are actively using.</span></span>  
  
#### <a name="concurrency-effects"></a><span data-ttu-id="9951f-289">동시성 효과</span><span class="sxs-lookup"><span data-stu-id="9951f-289">Concurrency Effects</span></span>  

 <span data-ttu-id="9951f-290">사용자가 데이터를 수정하면 동시에 같은 데이터를 읽거나 수정 중인 다른 사용자에게 영향을 미칠 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-290">Users modifying data can affect other users who are reading or modifying the same data at the same time.</span></span> <span data-ttu-id="9951f-291">이러한 사용자들을 가리켜 데이터에 동시에 액세스한 사용자라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-291">These users are said to be accessing the data concurrently.</span></span> <span data-ttu-id="9951f-292">데이터 스토리지 시스템에 동시성 제어가 없으면 사용자가 다음과 같은 부작용을 겪을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-292">If a data storage system has no concurrency control, users could see the following side effects:</span></span>  
  
-   <span data-ttu-id="9951f-293">업데이트 손실</span><span class="sxs-lookup"><span data-stu-id="9951f-293">Lost updates</span></span>  
  
     <span data-ttu-id="9951f-294">업데이트 손실은 둘 이상의 트랜잭션이 같은 행을 선택한 다음 원래 선택한 값을 기준으로 행을 업데이트할 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-294">Lost updates occur when two or more transactions select the same row and then update the row based on the value originally selected.</span></span> <span data-ttu-id="9951f-295">이때 각 트랜잭션은 다른 트랜잭션을 인식하지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-295">Each transaction is unaware of the other transactions.</span></span> <span data-ttu-id="9951f-296">마지막 업데이트가 다른 트랜잭션의 업데이트를 덮어쓰므로 데이터가 손실됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-296">The last update overwrites updates made by the other transactions, which results in lost data.</span></span>  
  
     <span data-ttu-id="9951f-297">예를 들어 두 명의 편집자가 같은 문서를 복사한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-297">For example, two editors make an electronic copy of the same document.</span></span> <span data-ttu-id="9951f-298">각 편집자가 각자 복사본을 변경한 다음 변경된 복사본을 저장하면 원본 문서를 덮어쓰게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-298">Each editor changes the copy independently and then saves the changed copy thereby overwriting the original document.</span></span> <span data-ttu-id="9951f-299">변경된 복사본을 마지막으로 저장한 편집자가 다른 편집자의 변경 내용을 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-299">The editor who saves the changed copy last overwrites the changes made by the other editor.</span></span> <span data-ttu-id="9951f-300">한 편집자가 트랜잭션을 마치고 커밋할 때까지 다른 편집자가 파일에 액세스할 수 없도록 하면 이 문제를 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-300">This problem could be avoided if one editor could not access the file until the other editor had finished and committed the transaction.</span></span>  
  
-   <span data-ttu-id="9951f-301">커밋되지 않은 종속성(커밋되지 않은 읽기)</span><span class="sxs-lookup"><span data-stu-id="9951f-301">Uncommitted dependency (dirty read)</span></span>  
  
     <span data-ttu-id="9951f-302">커밋되지 않은 종속성은 다른 트랜잭션이 업데이트 중인 행을 두 번째 트랜잭션이 선택할 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-302">Uncommitted dependency occurs when a second transaction selects a row that is being updated by another transaction.</span></span> <span data-ttu-id="9951f-303">두 번째 트랜잭션이 읽고 있는 데이터는 아직 커밋되지 않았지만 현재 행을 업데이트 중인 트랜잭션에 의해 변경될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-303">The second transaction is reading data that has not been committed yet and may be changed by the transaction updating the row.</span></span>  
  
     <span data-ttu-id="9951f-304">예를 들어 한 편집자가 문서를 변경 중이라고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-304">For example, an editor is making changes to an electronic document.</span></span> <span data-ttu-id="9951f-305">변경하는 동안 다른 편집자가 그 시점까지 변경된 내용이 모두 포함된 문서를 복사한 다음 문서를 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-305">During the changes, a second editor takes a copy of the document that includes all the changes made so far, and distributes the document to the intended audience.</span></span> <span data-ttu-id="9951f-306">그런데 첫 번째 편집자가 그때까지 변경한 내용이 잘못되었다고 판단하여 편집 내용을 지우고 문서를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-306">The first editor then decides the changes made so far are wrong and removes the edits and saves the document.</span></span> <span data-ttu-id="9951f-307">이 경우 배포된 문서에는 더 이상 존재하지 않으며 무시해야 하는 내용이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-307">The distributed document contains edits that no longer exist and should be treated as if they never existed.</span></span> <span data-ttu-id="9951f-308">첫 번째 편집자가 수정 내용을 최종 저장하고 트랜잭션 커밋할 때까지 아무도 변경된 문서를 읽을 수 없도록 하면 이 문제를 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-308">This problem could be avoided if no one could read the changed document until the first editor does the final save of modifications and commits the transaction.</span></span>  
  
-   <span data-ttu-id="9951f-309">일관성 없는 분석(반복하지 않는 읽기)</span><span class="sxs-lookup"><span data-stu-id="9951f-309">Inconsistent analysis (nonrepeatable read)</span></span>  
  
     <span data-ttu-id="9951f-310">일관성 없는 분석은 두 번째 트랜잭션이 같은 행에 여러 번 액세스하며 이때마다 다른 데이터를 읽을 경우 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-310">Inconsistent analysis occurs when a second transaction accesses the same row several times and reads different data each time.</span></span> <span data-ttu-id="9951f-311">일관성 없는 분석은 두 번째 트랜잭션이 읽고 있는 데이터를 다른 트랜잭션이 변경하고 있다는 점에서 커밋되지 않은 종속성과 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-311">Inconsistent analysis is similar to uncommitted dependency in that another transaction is changing the data that a second transaction is reading.</span></span> <span data-ttu-id="9951f-312">그러나 일관성 없는 분석의 경우 두 번째 트랜잭션이 읽은 데이터는 내용을 변경한 트랜잭션에 의해 커밋된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-312">However, in inconsistent analysis, the data read by the second transaction was committed by the transaction that made the change.</span></span> <span data-ttu-id="9951f-313">또한 같은 행을 여러 번 읽어야 하고 매번 정보가 다른 트랜잭션에 의해 변경됩니다. 이를 반복하지 않는 읽기라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-313">Also, inconsistent analysis involves multiple reads (two or more) of the same row, and each time the information is changed by another transaction; thus, the term nonrepeatable read.</span></span>  
  
     <span data-ttu-id="9951f-314">예를 들어 한 편집자가 같은 문서를 두 번 읽는 동안 그 사이에 작성자가 문서를 다시 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-314">For example, an editor reads the same document twice, but between each reading the writer rewrites the document.</span></span> <span data-ttu-id="9951f-315">그러면 편집자가 같은 문서를 두 번째 읽을 때 문서가 변경되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-315">When the editor reads the document for the second time, it has changed.</span></span> <span data-ttu-id="9951f-316">원래의 읽기는 반복되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-316">The original read was not repeatable.</span></span> <span data-ttu-id="9951f-317">편집자가 마지막으로 문서 읽기를 마칠 때까지 작성자가 문서를 변경하지 못하게 하면 이 문제를 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-317">This problem could be avoided if the writer could not change the document until the editor has finished reading it for the last time.</span></span>  
  
-   <span data-ttu-id="9951f-318">가상 읽기</span><span class="sxs-lookup"><span data-stu-id="9951f-318">Phantom reads</span></span>  
  
     <span data-ttu-id="9951f-319">가상 읽기는 두 개의 동일한 쿼리가 실행되고 두 번째 쿼리에서 반환된 행 컬렉션이 다른 경우 발생하는 상황입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-319">A phantom read is a situation that occurs when two identical queries are executed and the collection of rows returned by the second query is different.</span></span> <span data-ttu-id="9951f-320">아래의 예에서는 이러한 상황이 발생하는 경우를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-320">The example below shows how this may occur.</span></span> <span data-ttu-id="9951f-321">아래의 두 트랜잭션이 동시에 실행되고 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-321">Assume the two transactions below are executing at the same time.</span></span> <span data-ttu-id="9951f-322">두 번째 트랜잭션의 INSERT 문이 두 트랜잭션에서 사용하는 데이터를 변경하기 때문에 첫 번째 트랜잭션의 두 SELECT 문에서 서로 다른 결과를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-322">The two SELECT statements in the first transaction may return different results because the INSERT statement in the second transaction changes the data used by both.</span></span>  
  
    ```sql  
    --Transaction 1  
    BEGIN TRAN;  
    SELECT ID FROM dbo.employee  
    WHERE ID > 5 and ID < 10;  
    --The INSERT statement from the second transaction occurs here.  
    SELECT ID FROM dbo.employee  
    WHERE ID > 5 and ID < 10;  
    COMMIT;  
    ```  
  
    ```sql  
    --Transaction 2  
    BEGIN TRAN;  
    INSERT INTO dbo.employee  
       SET name = 'New' WHERE ID = 5;  
    COMMIT;   
    ```  
  
-   <span data-ttu-id="9951f-323">행 업데이트로 인한 읽기 누락 및 두 번 읽기</span><span class="sxs-lookup"><span data-stu-id="9951f-323">Missing and double reads caused by row updates</span></span>  
  
    -   <span data-ttu-id="9951f-324">업데이트된 행이 누락되거나 업데이트된 행이 여러 번 표시됨</span><span class="sxs-lookup"><span data-stu-id="9951f-324">Missing a updated row or seeing an updated row multiple times</span></span>  
  
         <span data-ttu-id="9951f-325">READ UNCOMMITTED 수준에서 실행되는 트랜잭션은 현재 트랜잭션에서 읽은 데이터를 다른 트랜잭션에서 수정하지 못하도록 하는 공유 잠금을 실행하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-325">Transactions that are running at the READ UNCOMMITTED level do not issue shared locks to prevent other transactions from modifying data read by the current transaction.</span></span> <span data-ttu-id="9951f-326">READ COMMITTED 수준에서 실행되는 트랜잭션은 공유 잠금을 실행하지만 행을 읽은 후에는 행 또는 페이지 잠금을 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-326">Transactions that are running at the READ COMMITTED level do issue shared locks, but the row or page locks are released after the row is read.</span></span> <span data-ttu-id="9951f-327">어떤 경우든 인덱스를 검색할 때 사용자가 읽기 작업을 수행하는 동안 다른 사용자가 행의 인덱스 키 열을 변경하면 키 변경으로 인해 사용자가 아직 검색하지 않은 위치로 행이 이동될 경우 해당 행이 다시 나타날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-327">In either case, when you are scanning an index, if another user changes the index key column of the row during your read, the row might appear again if the key change moved the row to a position ahead of your scan.</span></span> <span data-ttu-id="9951f-328">마찬가지로 키 변경으로 인해 사용자가 이미 읽은 인덱스 위치로 행이 이동될 경우 해당 행이 나타나지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-328">Similarly, the row might not appear if the key change moved the row to a position in the index that you had already read.</span></span> <span data-ttu-id="9951f-329">이 문제를 방지하려면 SERIALIZABLE 또는 HOLDLOCK 힌트를 사용하거나 행 버전 관리를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-329">To avoid this, use the SERIALIZABLE or HOLDLOCK hint, or row versioning.</span></span> <span data-ttu-id="9951f-330">자세한 내용은 [테이블 힌트&#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-table)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-330">For more information, see [Table Hints &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-table).</span></span>  
  
    -   <span data-ttu-id="9951f-331">업데이트 대상이 아니었던 하나 이상의 행이 누락됨</span><span class="sxs-lookup"><span data-stu-id="9951f-331">Missing one or more rows that were not the target of update</span></span>  
  
         <span data-ttu-id="9951f-332">READ UNCOMMITTED를 사용할 때 사용자 쿼리에서 할당 순서 검색(IAM 페이지 사용)을 사용하여 행을 읽는 경우 다른 트랜잭션에 의해 페이지 분할이 발생하면 행이 누락될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-332">When you are using READ UNCOMMITTED, if your query reads rows using an allocation order scan (using IAM pages), you might miss rows if another transaction is causing a page split.</span></span> <span data-ttu-id="9951f-333">페이지 분할 중에 테이블 잠금이 유지되므로 커밋된 읽기를 사용할 때는 누락이 발생하지 않습니다. 또한 업데이트로 인해 페이지 분할이 발생하지 않으므로 테이블에 클러스터형 인덱스가 없는 경우 누락이 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-333">This cannot occur when you are using read committed because a table lock is held during a page split and does not happen if the table does not have a clustered index, because updates do not cause page splits.</span></span>  
  
#### <a name="types-of-concurrency"></a><span data-ttu-id="9951f-334">동시성 유형</span><span class="sxs-lookup"><span data-stu-id="9951f-334">Types of Concurrency</span></span>  

 <span data-ttu-id="9951f-335">여러 사용자가 동시에 데이터베이스의 데이터를 수정할 수 있도록 하려면 특정 사용자의 수정 내용이 다른 사용자의 수정 내용에 영향을 주지 않도록 제어 시스템을 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-335">When many people attempt to modify data in a database at the same time, a system of controls must be implemented so that modifications made by one person do not adversely affect those of another person.</span></span> <span data-ttu-id="9951f-336">이것을 동시성 제어라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-336">This is called concurrency control.</span></span>  
  
 <span data-ttu-id="9951f-337">동시성 제어는 동시성 제어 구현 방법에 따라 두 가지로 분류됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-337">Concurrency control theory has two classifications for the methods of instituting concurrency control:</span></span>  
  
-   <span data-ttu-id="9951f-338">비관적 동시성 제어</span><span class="sxs-lookup"><span data-stu-id="9951f-338">Pessimistic concurrency control</span></span>  
  
     <span data-ttu-id="9951f-339">다른 사용자에게 영향을 주는 데이터 수정은 수행할 수 없도록 하는 잠금 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-339">A system of locks prevents users from modifying data in a way that affects other users.</span></span> <span data-ttu-id="9951f-340">한 사용자가 잠금을 유발하는 동작을 수행하면 다른 사용자는 이 소유자가 잠금을 해제할 때까지 해당 잠금과 충돌하는 동작을 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-340">After a user performs an action that causes a lock to be applied, other users cannot perform actions that would conflict with the lock until the owner releases it.</span></span> <span data-ttu-id="9951f-341">이러한 방식은 동시성 충돌이 발생하는 경우 잠금을 사용하여 데이터를 보호하는 비용이 트랜잭션을 롤백하는 비용보다 작고 데이터에 대한 경합이 치열한 환경에 주로 사용되기 때문에 비관적 제어라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-341">This is called pessimistic control because it is mainly used in environments where there is high contention for data, where the cost of protecting data with locks is less than the cost of rolling back transactions if concurrency conflicts occur.</span></span>  
  
-   <span data-ttu-id="9951f-342">낙관적 동시성 제어</span><span class="sxs-lookup"><span data-stu-id="9951f-342">Optimistic concurrency control</span></span>  
  
     <span data-ttu-id="9951f-343">낙관적 동시성 제어에서는 사용자가 데이터를 읽을 때 해당 데이터를 잠그지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-343">In optimistic concurrency control, users do not lock data when they read it.</span></span> <span data-ttu-id="9951f-344">사용자가 데이터를 업데이트할 때는 다른 사용자가 해당 데이터를 읽은 후 변경하지 않았는지 검사가 진행됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-344">When a user updates data, the system checks to see if another user changed the data after it was read.</span></span> <span data-ttu-id="9951f-345">다른 사용자가 데이터를 업데이트한 경우에는 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-345">If another user updated the data, an error is raised.</span></span> <span data-ttu-id="9951f-346">일반적으로 오류를 수신한 사용자의 트랜잭션이 롤백되고 다시 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-346">Typically, the user receiving the error rolls back the transaction and starts over.</span></span> <span data-ttu-id="9951f-347">이러한 방식은 가끔씩 트랜잭션을 롤백하는 비용이 데이터를 읽을 때 잠그는 비용보다 작고 데이터에 대한 경합이 낮은 환경에 주로 사용되기 때문에 낙관적 제어라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-347">This is called optimistic because it is mainly used in environments where there is low contention for data, and where the cost of occasionally rolling back a transaction is lower than the cost of locking data when read.</span></span>  
  
 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]<span data-ttu-id="9951f-348">에서는 다양한 동시성 제어 유형을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-348">supports a range of concurrency control.</span></span> <span data-ttu-id="9951f-349">사용자는 연결에 대한 트랜잭션 격리 수준 또는 커서에 대한 동시성 옵션을 선택하여 동시성 제어 유형을 지정하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-349">Users specify the type of concurrency control by selecting transaction isolation levels for connections or concurrency options on cursors.</span></span> <span data-ttu-id="9951f-350">이러한 특성은 [!INCLUDE[tsql](../includes/tsql-md.md)] 문을 사용하거나 ADO, ADO.NET, OLE DB 및 ODBC 등의 데이터베이스 API(응용 프로그래밍 인터페이스) 속성과 특성을 통해 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-350">These attributes can be defined using [!INCLUDE[tsql](../includes/tsql-md.md)] statements, or through the properties and attributes of database application programming interfaces (APIs) such as ADO, ADO.NET, OLE DB, and ODBC.</span></span>  
  
#### <a name="isolation-levels-in-the-database-engine"></a><span data-ttu-id="9951f-351">데이터베이스 엔진의 격리 수준</span><span class="sxs-lookup"><span data-stu-id="9951f-351">Isolation Levels in the Database Engine</span></span>  

 <span data-ttu-id="9951f-352">한 트랜잭션을 리소스 또는 다른 트랜잭션에서 수정한 데이터 내용으로부터 격리하는 정도를 정의하는 격리 수준을 트랜잭션에 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-352">Transactions specify an isolation level that defines the degree to which one transaction must be isolated from resource or data modifications made by other transactions.</span></span> <span data-ttu-id="9951f-353">격리 수준은 허용되는 동시성 부작용(예: 커밋되지 않은 읽기 또는 가상 읽기)의 관점에서 설명됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-353">Isolation levels are described in terms of which concurrency side-effects, such as dirty reads or phantom reads, are allowed.</span></span>  
  
 <span data-ttu-id="9951f-354">트랜잭션 격리 수준으로 제어할 수 있는 사항은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-354">Transaction isolation levels control:</span></span>  
  
-   <span data-ttu-id="9951f-355">데이터를 읽을 때 잠금을 확보할지 여부 및 요청되는 잠금의 종류</span><span class="sxs-lookup"><span data-stu-id="9951f-355">Whether locks are taken when data is read, and what type of locks are requested.</span></span>  
  
-   <span data-ttu-id="9951f-356">읽기 잠금의 보유 기간</span><span class="sxs-lookup"><span data-stu-id="9951f-356">How long the read locks are held.</span></span>  
  
-   <span data-ttu-id="9951f-357">읽기 작업이 다른 트랜잭션에서 수정한 행을 참조할 경우 선택할 수 있는 다음과 같은 옵션</span><span class="sxs-lookup"><span data-stu-id="9951f-357">Whether a read operation referencing rows modified by another transaction:</span></span>  
  
    -   <span data-ttu-id="9951f-358">행에 대한 배타적 잠금이 해제될 때까지 차단</span><span class="sxs-lookup"><span data-stu-id="9951f-358">Blocks until the exclusive lock on the row is freed.</span></span>  
  
    -   <span data-ttu-id="9951f-359">문 또는 트랜잭션 시작 당시 커밋된 행 버전 검색</span><span class="sxs-lookup"><span data-stu-id="9951f-359">Retrieves the committed version of the row that existed at the time the statement or transaction started.</span></span>  
  
    -   <span data-ttu-id="9951f-360">커밋되지 않은 데이터 수정 내용 읽기</span><span class="sxs-lookup"><span data-stu-id="9951f-360">Reads the uncommitted data modification.</span></span>  
  
> [!IMPORTANT]  
>  <span data-ttu-id="9951f-361">트랜잭션 격리 수준을 선택해도 데이터 수정 내용을 보호하기 위해 획득된 잠금에는 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-361">Choosing a transaction isolation level does not affect the locks acquired to protect data modifications.</span></span> <span data-ttu-id="9951f-362">설정된 격리 수준에 관계없이 트랜잭션은 항상 수정하는 데이터에 대해 배타적 잠금을 얻고 해당 트랜잭션이 완료될 때까지 이 잠금을 보유합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-362">A transaction always gets an exclusive lock on any data it modifies, and holds that lock until the transaction completes, regardless of the isolation level set for that transaction.</span></span> <span data-ttu-id="9951f-363">읽기 작업의 경우 트랜잭션 격리 수준은 대개 다른 트랜잭션에서 수정한 내용의 영향을 받지 않도록 보호 수준을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-363">For read operations, transaction isolation levels primarily define the level of protection from the effects of modifications made by other transactions.</span></span>  
  
 <span data-ttu-id="9951f-364">격리 수준이 낮을수록 동시에 데이터를 액세스할 수 있는 사용자가 많아지지만 동시성 부작용(예: 커밋되지 않은 읽기 또는 업데이트 손실) 횟수도 늘어납니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-364">A lower isolation level increases the ability of many users to access data at the same time, but increases the number of concurrency effects (such as dirty reads or lost updates) users might encounter.</span></span> <span data-ttu-id="9951f-365">반대로 격리 수준이 높을수록 동시성 부작용 종류가 줄어들지만 시스템 리소스가 더 많이 필요하게 되고 한 트랜잭션이 다른 트랜잭션을 차단하게 될 확률도 높아집니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-365">Conversely, a higher isolation level reduces the types of concurrency effects that users may encounter, but requires more system resources and increases the chances that one transaction will block another.</span></span> <span data-ttu-id="9951f-366">적절한 격리 수준을 선택하려면 애플리케이션의 데이터 무결성 요구 사항과 각 격리 수준에 의해 야기되는 오버헤드를 신중하게 평가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-366">Choosing the appropriate isolation level depends on balancing the data integrity requirements of the application against the overhead of each isolation level.</span></span> <span data-ttu-id="9951f-367">최상위 격리 수준인 직렬화 가능의 경우 트랜잭션이 읽기 작업을 반복할 때마다 정확히 동일한 데이터를 검색하지만 다중 사용자 시스템에서 다른 사용자에게 영향을 줄 수 있는 수준의 잠금을 수행함으로써 이를 달성합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-367">The highest isolation level, serializable, guarantees that a transaction will retrieve exactly the same data every time it repeats a read operation, but it does this by performing a level of locking that is likely to impact other users in multi-user systems.</span></span> <span data-ttu-id="9951f-368">최하위 격리 수준인 커밋되지 않은 읽기의 경우 다른 트랜잭션에서 수정했지만 커밋되지 않은 데이터를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-368">The lowest isolation level, read uncommitted, may retrieve data that has been modified but not committed by other transactions.</span></span> <span data-ttu-id="9951f-369">커밋되지 않은 읽기에서는 모든 동시성 부작용이 발생할 수 있지만 읽기 잠금이나 버전 관리가 수행되지 않으므로 오버헤드가 최소화됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-369">All of the concurrency side effects can happen in read uncommitted, but there is no read locking or versioning, so overhead is minimized.</span></span>  
  
##### <a name="database-engine-isolation-levels"></a><span data-ttu-id="9951f-370">데이터베이스 엔진 격리 수준</span><span class="sxs-lookup"><span data-stu-id="9951f-370">Database Engine Isolation Levels</span></span>  

 <span data-ttu-id="9951f-371">ISO 표준은 다음 격리 수준을 정의합니다. 이 격리 수준은 모두 [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]에서 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-371">The ISO standard defines the following isolation levels, all of which are supported by the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]:</span></span>  
  
|<span data-ttu-id="9951f-372">격리 수준</span><span class="sxs-lookup"><span data-stu-id="9951f-372">Isolation Level</span></span>|<span data-ttu-id="9951f-373">정의</span><span class="sxs-lookup"><span data-stu-id="9951f-373">Definition</span></span>|  
|---------------------|----------------|  
|<span data-ttu-id="9951f-374">커밋되지 않은 읽기</span><span class="sxs-lookup"><span data-stu-id="9951f-374">Read uncommitted</span></span>|<span data-ttu-id="9951f-375">물리적으로 손상된 데이터만 읽지 않도록 트랜잭션을 격리하는 최하위 격리 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-375">The lowest isolation level where transactions are isolated only enough to ensure that physically corrupt data is not read.</span></span> <span data-ttu-id="9951f-376">이 수준에서는 더티 읽기가 허용되므로 한 트랜잭션에서 변경한 아직 커밋되지 않은 내용을 다른 트랜잭션에서 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-376">In this level, dirty reads are allowed, so one transaction may see not-yet-committed changes made by other transactions.</span></span>|  
|<span data-ttu-id="9951f-377">커밋된 읽기</span><span class="sxs-lookup"><span data-stu-id="9951f-377">Read committed</span></span>|<span data-ttu-id="9951f-378">트랜잭션에서는 처음 트랜잭션이 완료될 때까지 기다리지 않고 다른 트랜잭션에서 이전에 읽은 수정되지 않은 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-378">Allows a transaction to read data previously read (not modified) by another transaction without waiting for the first transaction to complete.</span></span> <span data-ttu-id="9951f-379">[!INCLUDE[ssDE](../includes/ssde-md.md)]에서는 트랜잭션이 끝날 때까지 쓰기 잠금이 유지되지만(일부 데이터에서 적용됨) 읽기 잠금은 SELECT 작업이 수행되는 즉시 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-379">The [!INCLUDE[ssDE](../includes/ssde-md.md)] keeps write locks (acquired on selected data) until the end of the transaction, but read locks are released as soon as the SELECT operation is performed.</span></span> <span data-ttu-id="9951f-380">이 값은 [!INCLUDE[ssDE](../includes/ssde-md.md)] 기본 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-380">This is the [!INCLUDE[ssDE](../includes/ssde-md.md)] default level.</span></span>|  
|<span data-ttu-id="9951f-381">반복 읽기</span><span class="sxs-lookup"><span data-stu-id="9951f-381">Repeatable read</span></span>|<span data-ttu-id="9951f-382">[!INCLUDE[ssDE](../includes/ssde-md.md)]에서는 트랜잭션이 끝날 때까지 일부 데이터에서 획득되는 읽기 잠금 및 쓰기 잠금이 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-382">The [!INCLUDE[ssDE](../includes/ssde-md.md)] keeps read and write locks that are acquired on selected data until the end of the transaction.</span></span> <span data-ttu-id="9951f-383">그러나 범위 잠금이 관리되지 않으므로 가상 읽기가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-383">However, because range-locks are not managed, phantom reads can occur.</span></span>|  
|<span data-ttu-id="9951f-384">직렬화 가능</span><span class="sxs-lookup"><span data-stu-id="9951f-384">Serializable</span></span>|<span data-ttu-id="9951f-385">트랜잭션이 서로 완전히 격리되는 최상위 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-385">The highest level where transactions are completely isolated from one another.</span></span> <span data-ttu-id="9951f-386">[!INCLUDE[ssDE](../includes/ssde-md.md)]에서는 일부 데이터에서 획득되는 읽기 잠금 및 쓰기 잠금이 유지되고 트랜잭션이 끝날 때 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-386">The [!INCLUDE[ssDE](../includes/ssde-md.md)] keeps read and write locks acquired on selected data to be released at the end of the transaction.</span></span> <span data-ttu-id="9951f-387">범위 잠금은 SELECT 작업에서 특히 가상 읽기를 방지하기 위해 범위가 지정된 WHERE 절을 사용할 때 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-387">Range-locks are acquired when a SELECT operation uses a ranged WHERE clause, especially to avoid phantom reads.</span></span><br /><br /> <span data-ttu-id="9951f-388">**참고:** 직렬화 가능 격리 수준이 요청된 경우 복제된 테이블에 대한 DDL 작업 및 트랜잭션이 실패할 수 있는데</span><span class="sxs-lookup"><span data-stu-id="9951f-388">**Note:** DDL operations and transactions on replicated tables may fail when serializable isolation level is requested.</span></span> <span data-ttu-id="9951f-389">이는 복제 쿼리가 직렬화 가능 격리 수준과 호환되지 않을 수 있는 힌트를 사용하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-389">This is because replication queries use hints that may be incompatible with serializable isolation level.</span></span>|  
  
 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]<span data-ttu-id="9951f-390">에서는 행 버전 관리를 사용하는 두 개의 추가 트랜잭션 격리 수준을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-390">also supports two additional transaction isolation levels that use row versioning.</span></span> <span data-ttu-id="9951f-391">하나는 커밋된 읽기 격리를 구현한 것이고 다른 하나는 트랜잭션 격리 수준인 스냅샷입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-391">One is an implementation of read committed isolation, and one is a transaction isolation level, snapshot.</span></span>  
  
|<span data-ttu-id="9951f-392">행 버전 관리 기반 격리</span><span class="sxs-lookup"><span data-stu-id="9951f-392">Row Versioning Isolation Level</span></span>|<span data-ttu-id="9951f-393">정의</span><span class="sxs-lookup"><span data-stu-id="9951f-393">Definition</span></span>|  
|------------------------------------|----------------|  
|<span data-ttu-id="9951f-394">커밋된 스냅샷 읽기</span><span class="sxs-lookup"><span data-stu-id="9951f-394">Read Committed Snapshot</span></span>|<span data-ttu-id="9951f-395">READ_COMMITTED_SNAPSHOT 데이터베이스 옵션을 ON으로 설정하면 커밋된 읽기 격리가 행 버전 관리를 통해 문 수준의 읽기 일관성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-395">When the READ_COMMITTED_SNAPSHOT database option is set ON, read committed isolation uses row versioning to provide statement-level read consistency.</span></span> <span data-ttu-id="9951f-396">읽기 작업에 SCH-S 테이블 수준 잠금만 필요하고 페이지 또는 행 잠금은 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-396">Read operations require only SCH-S table level locks and no page or row locks.</span></span> <span data-ttu-id="9951f-397">즉, 데이터베이스 엔진은 행 버전 관리를 사용하여 문 시작 시와 트랜잭션별로 데이터의 일관성이 유지된 스냅샷을 각 문에 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-397">That is, the Database Engine uses row versioning to present each statement with a transactionally consistent snapshot of the data as it existed at the start of the statement.</span></span> <span data-ttu-id="9951f-398">다른 트랜잭션에 의한 데이터 업데이트 차단을 위해 잠금이 사용되지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-398">Locks are not used to protect the data from updates by other transactions.</span></span> <span data-ttu-id="9951f-399">사용자 정의 함수는 UDF를 포함하는 구문 시간이 시작된 후에 커밋된 데이터를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-399">A user-defined function can return data that was committed after the time the statement containing the UDF began.</span></span><br /><br /> <span data-ttu-id="9951f-400">READ_COMMITTED_SNAPSHOT 데이터베이스 옵션을 기본값인 OFF로 설정하면 커밋된 격리 읽기는 공유 잠금을 사용하여 현재 트랜잭션이 읽기 작업을 실행하는 동안 다른 트랜잭션이 행을 수정하지 못하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-400">When the READ_COMMITTED_SNAPSHOT database option is set OFF, which is the default setting, read committed isolation uses shared locks to prevent other transactions from modifying rows while the current transaction is running a read operation.</span></span> <span data-ttu-id="9951f-401">또한 공유 잠금은 다른 트랜잭션이 완료될 때까지 해당 트랜잭션이 수정한 행을 문이 읽을 수 없도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-401">The shared locks also block the statement from reading rows modified by other transactions until the other transaction is completed.</span></span> <span data-ttu-id="9951f-402">두 구현 모두 커밋된 읽기 격리에 대한 ISO 정의를 충족합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-402">Both implementations meet the ISO definition of read committed isolation.</span></span>|  
|<span data-ttu-id="9951f-403">스냅샷</span><span class="sxs-lookup"><span data-stu-id="9951f-403">Snapshot</span></span>|<span data-ttu-id="9951f-404">스냅샷 격리 수준은 행 버전 관리를 통해 트랜잭션 수준의 읽기 일관성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-404">The snapshot isolation level uses row versioning to provide transaction-level read consistency.</span></span> <span data-ttu-id="9951f-405">읽기 작업에 SCH-S 테이블 잠금만 필요하고 페이지 또는 행 잠금은 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-405">Read operations acquire no page or row locks; only SCH-S table locks are acquired.</span></span> <span data-ttu-id="9951f-406">다른 트랜잭션에서 수정한 행을 읽을 때 트랜잭션 시작 당시의 행 버전을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-406">When reading rows modified by another transaction, they retrieve the version of the row that existed when the transaction started.</span></span> <span data-ttu-id="9951f-407">ALLOW_SNAPSHOT_ISOLATION 데이터베이스 옵션을 ON으로 설정하면 데이터베이스에 대해 스냅샷 격리만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-407">You can only use Snapshot isolation against a database when the ALLOW_SNAPSHOT_ISOLATION database option is set ON.</span></span> <span data-ttu-id="9951f-408">기본적으로 사용자 데이터베이스에 대해서는 이 옵션이 OFF로 설정되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-408">By default, this option is set OFF for user databases.</span></span><br /><br /> <span data-ttu-id="9951f-409">**참고:** [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]에서는 메타데이터의 버전 관리를 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-409">**Note:**  [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] does not support versioning of metadata.</span></span> <span data-ttu-id="9951f-410">따라서 스냅샷 격리에서 실행하는 명시적 트랜잭션에서 수행할 수 있는 DDL 작업에 대한 제한 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-410">For this reason, there are restrictions on what DDL operations can be performed in an explicit transaction that is running under snapshot isolation.</span></span> <span data-ttu-id="9951f-411">ALTER TABLE, CREATE INDEX, CREATE XML INDEX, ALTER INDEX, DROP INDEX, DBCC REINDEX, ALTER PARTITION FUNCTION, ALTER PARTITION SCHEME 또는 CLR(공용 언어 런타임) DDL 문과 같은 DDL 문은 BEGIN TRANSACTION 문 다음에 스냅샷 격리에서 허용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-411">The following DDL statements are not permitted under snapshot isolation after a BEGIN TRANSACTION statement: ALTER TABLE, CREATE INDEX, CREATE XML INDEX, ALTER INDEX, DROP INDEX, DBCC REINDEX, ALTER PARTITION FUNCTION, ALTER PARTITION SCHEME, or any common language runtime (CLR) DDL statement.</span></span> <span data-ttu-id="9951f-412">다음 명령문은 암시적 트랜잭션 내에서 스냅샷 격리를 사용하는 경우 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-412">These statements are permitted when you are using snapshot isolation within implicit transactions.</span></span> <span data-ttu-id="9951f-413">기본적으로 암시적 트랜잭션은 DDL 문에서도 스냅샷 격리의 의미 체계를 적용할 수 있게 하는 단일 문입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-413">An implicit transaction, by definition, is a single statement that makes it possible to enforce the semantics of snapshot isolation, even with DDL statements.</span></span> <span data-ttu-id="9951f-414">이 원칙을 위반하면 오류 3961이 발생할 수 있습니다. "문에서 액세스한 개체가 이 트랜잭션이 시작된 후 다른 동시 트랜잭션의 DDL 문에 의해 수정되어 데이터베이스 '%.\*ls'에서 스냅샷 격리 트랜잭션이 실패했습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-414">Violations of this principle can cause error 3961: "Snapshot isolation transaction failed in database '%.\*ls' because the object accessed by the statement has been modified by a DDL statement in another concurrent transaction since the start of this transaction.</span></span> <span data-ttu-id="9951f-415">메타데이터에 버전이 지정되지 않았으므로 이 트랜잭션은 허용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-415">It is not allowed because the metadata is not versioned.</span></span> <span data-ttu-id="9951f-416">스냅샷 격리를 함께 사용하여 메타데이터에 대해 동시 업데이트를 수행하면 일관되지 않은 결과가 발생할 수 있습니다."</span><span class="sxs-lookup"><span data-stu-id="9951f-416">A concurrent update to metadata could lead to inconsistency if mixed with snapshot isolation."</span></span>|  
  
 <span data-ttu-id="9951f-417">다음 표에서는 각 격리 수준에서 사용되는 동시성 부작용을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-417">The following table shows the concurrency side effects enabled by the different isolation levels.</span></span>  
  
|<span data-ttu-id="9951f-418">격리 수준</span><span class="sxs-lookup"><span data-stu-id="9951f-418">Isolation level</span></span>|<span data-ttu-id="9951f-419">커밋되지 않은 읽기</span><span class="sxs-lookup"><span data-stu-id="9951f-419">Dirty read</span></span>|<span data-ttu-id="9951f-420">반복되지 않는 읽기</span><span class="sxs-lookup"><span data-stu-id="9951f-420">Nonrepeatable read</span></span>|<span data-ttu-id="9951f-421">가상</span><span class="sxs-lookup"><span data-stu-id="9951f-421">Phantom</span></span>|  
|---------------------|----------------|------------------------|-------------|  
|<span data-ttu-id="9951f-422">**READ UNCOMMITTED**</span><span class="sxs-lookup"><span data-stu-id="9951f-422">**Read uncommitted**</span></span>|<span data-ttu-id="9951f-423">예</span><span class="sxs-lookup"><span data-stu-id="9951f-423">Yes</span></span>|<span data-ttu-id="9951f-424">예</span><span class="sxs-lookup"><span data-stu-id="9951f-424">Yes</span></span>|<span data-ttu-id="9951f-425">예</span><span class="sxs-lookup"><span data-stu-id="9951f-425">Yes</span></span>|  
|<span data-ttu-id="9951f-426">**READ COMMITTED**</span><span class="sxs-lookup"><span data-stu-id="9951f-426">**Read committed**</span></span>|<span data-ttu-id="9951f-427">예</span><span class="sxs-lookup"><span data-stu-id="9951f-427">No</span></span>|<span data-ttu-id="9951f-428">예</span><span class="sxs-lookup"><span data-stu-id="9951f-428">Yes</span></span>|<span data-ttu-id="9951f-429">예</span><span class="sxs-lookup"><span data-stu-id="9951f-429">Yes</span></span>|  
|<span data-ttu-id="9951f-430">**REPEATABLE READ**</span><span class="sxs-lookup"><span data-stu-id="9951f-430">**Repeatable read**</span></span>|<span data-ttu-id="9951f-431">예</span><span class="sxs-lookup"><span data-stu-id="9951f-431">No</span></span>|<span data-ttu-id="9951f-432">예</span><span class="sxs-lookup"><span data-stu-id="9951f-432">No</span></span>|<span data-ttu-id="9951f-433">예</span><span class="sxs-lookup"><span data-stu-id="9951f-433">Yes</span></span>|  
|<span data-ttu-id="9951f-434">**스냅샷**</span><span class="sxs-lookup"><span data-stu-id="9951f-434">**Snapshot**</span></span>|<span data-ttu-id="9951f-435">예</span><span class="sxs-lookup"><span data-stu-id="9951f-435">No</span></span>|<span data-ttu-id="9951f-436">아니요</span><span class="sxs-lookup"><span data-stu-id="9951f-436">No</span></span>|<span data-ttu-id="9951f-437">예</span><span class="sxs-lookup"><span data-stu-id="9951f-437">No</span></span>|  
|<span data-ttu-id="9951f-438">**직렬화 가능**</span><span class="sxs-lookup"><span data-stu-id="9951f-438">**Serializable**</span></span>|<span data-ttu-id="9951f-439">예</span><span class="sxs-lookup"><span data-stu-id="9951f-439">No</span></span>|<span data-ttu-id="9951f-440">아니요</span><span class="sxs-lookup"><span data-stu-id="9951f-440">No</span></span>|<span data-ttu-id="9951f-441">예</span><span class="sxs-lookup"><span data-stu-id="9951f-441">No</span></span>|  
  
 <span data-ttu-id="9951f-442">각 트랜잭션 격리 수준에서 제어하는 특정 종류의 잠금 또는 행 버전 관리에 대한 자세한 내용은 [SET TRANSACTION ISOLATION LEVEL&#40;Transact-SQL&#41;](/sql/t-sql/statements/set-transaction-isolation-level-transact-sql)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="9951f-442">For more information about the specific types of locking or row versioning controlled by each transaction isolation level, see [SET TRANSACTION ISOLATION LEVEL &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-transaction-isolation-level-transact-sql).</span></span>  
  
 <span data-ttu-id="9951f-443">트랜잭션 격리 수준은 [!INCLUDE[tsql](../includes/tsql-md.md)]이나 데이터베이스 API를 통해 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-443">Transaction isolation levels can be set using [!INCLUDE[tsql](../includes/tsql-md.md)] or through a database API.</span></span>  
  
 [!INCLUDE[tsql](../includes/tsql-md.md)]  
 [!INCLUDE[tsql](../includes/tsql-md.md)] <span data-ttu-id="9951f-444">스크립트는 SET TRANSACTION ISOLATION LEVEL 문을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-444">scripts use the SET TRANSACTION ISOLATION LEVEL statement.</span></span>  
  
 <span data-ttu-id="9951f-445">ADO</span><span class="sxs-lookup"><span data-stu-id="9951f-445">ADO</span></span>  
 <span data-ttu-id="9951f-446">ADO 애플리케이션은 **Connection** 개체의 `IsolationLevel` 속성을 adXactReadUncommitted, adXactReadCommitted, adXactRepeatableRead 또는 adXactReadSerializable로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-446">ADO applications set the `IsolationLevel` property of the **Connection** object to adXactReadUncommitted, adXactReadCommitted, adXactRepeatableRead, or adXactReadSerializable.</span></span>  
  
 <span data-ttu-id="9951f-447">ADO.NET</span><span class="sxs-lookup"><span data-stu-id="9951f-447">ADO.NET</span></span>  
 <span data-ttu-id="9951f-448">`System.Data.SqlClient` 관리 네임스페이스를 사용하는 ADO.NET 애플리케이션은 `SqlConnection.BeginTransaction` 메서드를 호출하고 *IsolationLevel* 옵션을 Unspecified, Chaos, ReadUncommitted, ReadCommitted, RepeatableRead, Serializable 및 Snapshot으로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-448">ADO.NET applications using the `System.Data.SqlClient` managed namespace can call the `SqlConnection.BeginTransaction` method and set the *IsolationLevel* option to Unspecified, Chaos, ReadUncommitted, ReadCommitted, RepeatableRead, Serializable, and Snapshot.</span></span>  
  
 <span data-ttu-id="9951f-449">OLE DB</span><span class="sxs-lookup"><span data-stu-id="9951f-449">OLE DB</span></span>  
 <span data-ttu-id="9951f-450">OLE DB를 사용하는 애플리케이션은 트랜잭션을 시작할 때 *isoLevel*을 ISOLATIONLEVEL_READUNCOMMITTED, ISOLATIONLEVEL_READCOMMITTED, ISOLATIONLEVEL_REPEATABLEREAD, ISOLATIONLEVEL_SNAPSHOT 또는 ISOLATIONLEVEL_SERIALIZABLE로 설정하고 `ITransactionLocal::StartTransaction`을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-450">When starting a transaction, applications using OLE DB call `ITransactionLocal::StartTransaction` with *isoLevel* set to ISOLATIONLEVEL_READUNCOMMITTED, ISOLATIONLEVEL_READCOMMITTED, ISOLATIONLEVEL_REPEATABLEREAD, ISOLATIONLEVEL_SNAPSHOT, or ISOLATIONLEVEL_SERIALIZABLE.</span></span>  
  
 <span data-ttu-id="9951f-451">OLE DB 애플리케이션은 자동 커밋 모드로 트랜잭션 격리 수준을 지정할 때 DBPROPSET_SESSION 속성인 DBPROP_SESS_AUTOCOMMITISOLEVELS를 DBPROPVAL_TI_CHAOS, DBPROPVAL_TI_READUNCOMMITTED, DBPROPVAL_TI_BROWSE, DBPROPVAL_TI_CURSORSTABILITY, DBPROPVAL_TI_READCOMMITTED, DBPROPVAL_TI_REPEATABLEREAD, DBPROPVAL_TI_SERIALIZABLE, DBPROPVAL_TI_ISOLATED 또는 DBPROPVAL_TI_SNAPSHOT으로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-451">When specifying the transaction isolation level in autocommit mode, OLE DB applications can set the DBPROPSET_SESSION property DBPROP_SESS_AUTOCOMMITISOLEVELS to DBPROPVAL_TI_CHAOS, DBPROPVAL_TI_READUNCOMMITTED, DBPROPVAL_TI_BROWSE, DBPROPVAL_TI_CURSORSTABILITY, DBPROPVAL_TI_READCOMMITTED, DBPROPVAL_TI_REPEATABLEREAD, DBPROPVAL_TI_SERIALIZABLE, DBPROPVAL_TI_ISOLATED, or DBPROPVAL_TI_SNAPSHOT.</span></span>  
  
 <span data-ttu-id="9951f-452">ODBC</span><span class="sxs-lookup"><span data-stu-id="9951f-452">ODBC</span></span>  
 <span data-ttu-id="9951f-453">ODBC 애플리케이션은 *Attribute*를 SQL_ATTR_TXN_ISOLATION으로 설정하고 *ValuePtr*을 SQL_TXN_READ_UNCOMMITTED, SQL_TXN_READ_COMMITTED, SQL_TXN_REPEATABLE_READ 또는 SQL_TXN_SERIALIZABLE로 설정하고 `SQLSetConnectAttr`을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-453">ODBC applications call `SQLSetConnectAttr` with *Attribute* set to SQL_ATTR_TXN_ISOLATION and *ValuePtr* set to SQL_TXN_READ_UNCOMMITTED, SQL_TXN_READ_COMMITTED, SQL_TXN_REPEATABLE_READ, or SQL_TXN_SERIALIZABLE.</span></span>  
  
 <span data-ttu-id="9951f-454">스냅샷 트랜잭션의 경우 애플리케이션은 Attribute를 SQL_COPT_SS_TXN_ISOLATION으로, ValuePtr을 SQL_TXN_SS_SNAPSHOT으로 설정하고 `SQLSetConnectAttr`을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-454">For snapshot transactions, applications call `SQLSetConnectAttr` with Attribute set to SQL_COPT_SS_TXN_ISOLATION and ValuePtr set to SQL_TXN_SS_SNAPSHOT.</span></span> <span data-ttu-id="9951f-455">SQL_COPT_SS_TXN_ISOLATION이나 SQL_ATTR_TXN_ISOLATION을 사용하여 스냅샷 트랜잭션을 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-455">A snapshot transaction can be retrieved using either SQL_COPT_SS_TXN_ISOLATION or SQL_ATTR_TXN_ISOLATION.</span></span>  
  
 <span data-ttu-id="9951f-456">[이 가이드의](#Top) ![맨 위 링크와 함께 사용 되는 화살표 아이콘](media/uparrow16x16.gif "맨 위로 이동 링크와 함께 사용되는 화살표 아이콘")</span><span class="sxs-lookup"><span data-stu-id="9951f-456">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="locking-in-the-database-engine"></a><a name="Lock_Engine"></a> <span data-ttu-id="9951f-457">데이터베이스 엔진에서의 잠금</span><span class="sxs-lookup"><span data-stu-id="9951f-457">Locking in the Database Engine</span></span>  

 <span data-ttu-id="9951f-458">잠금은 [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]에서 사용하는 메커니즘으로 동시에 여러 사용자가 동일한 데이터에 액세스하는 것을 동기화합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-458">Locking is a mechanism used by the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] to synchronize access by multiple users to the same piece of data at the same time.</span></span>  
  
 <span data-ttu-id="9951f-459">특정 트랜잭션이 데이터 읽기나 수정 등을 통해 현재 데이터 상태에 종속되기 전에 동일한 데이터를 수정하는 다른 트랜잭션의 영향을 받지 못하도록 해당 트랜잭션을 보호해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-459">Before a transaction acquires a dependency on the current state of a piece of data, such as by reading or modifying the data, it must protect itself from the effects of another transaction modifying the same data.</span></span> <span data-ttu-id="9951f-460">트랜잭션은 데이터에 대한 잠금을 요청하여 자체 트랜잭션을 보호합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-460">The transaction does this by requesting a lock on the piece of data.</span></span> <span data-ttu-id="9951f-461">잠금에는 공유나 배타 등의 다양한 모드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-461">Locks have different modes, such as shared or exclusive.</span></span> <span data-ttu-id="9951f-462">잠금 모드는 데이터에 대한 트랜잭션의 종속성 수준을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-462">The lock mode defines the level of dependency the transaction has on the data.</span></span> <span data-ttu-id="9951f-463">해당 데이터에 대해 이미 다른 트랜잭션에 허용된 잠금 모드와 충돌되는 잠금은 이 트랜잭션에 허용될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-463">No transaction can be granted a lock that would conflict with the mode of a lock already granted on that data to another transaction.</span></span> <span data-ttu-id="9951f-464">특정 트랜잭션에서 이미 허용된 잠금과 충돌되는 잠금 모드를 동일한 데이터에 요청하면 [!INCLUDE[ssDE](../includes/ssde-md.md)] 인스턴스는 첫 번째 잠금이 해제될 때까지 요청한 트랜잭션을 일시 중지합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-464">If a transaction requests a lock mode that conflicts with a lock that has already been granted on the same data, the instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] will pause the requesting transaction until the first lock is released.</span></span>  
  
 <span data-ttu-id="9951f-465">트랜잭션을 통해 데이터를 수정하는 경우 해당 트랜잭션이 끝날 때까지 잠금을 지속하여 수정한 내용이 유지되도록 보호합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-465">When a transaction modifies a piece of data, it holds the lock protecting the modification until the end of the transaction.</span></span> <span data-ttu-id="9951f-466">읽기 작업을 보호할 수 있도록 획득한 잠금을 트랜잭션에서 지속하는 기간은 트랜잭션 격리 수준 설정에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-466">How long a transaction holds the locks acquired to protect read operations depends on the transaction isolation level setting.</span></span> <span data-ttu-id="9951f-467">트랜잭션을 통해 지속되는 모든 잠금은 트랜잭션이 완료되어 커밋되거나 롤백될 때 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-467">All locks held by a transaction are released when the transaction completes (either commits or rolls back).</span></span>  
  
 <span data-ttu-id="9951f-468">일반적으로 애플리케이션은 잠금을 직접 요청하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-468">Applications do not typically request locks directly.</span></span> <span data-ttu-id="9951f-469">잠금은 잠금 관리자라고 하는 [!INCLUDE[ssDE](../includes/ssde-md.md)]의 일부를 통해 내부적으로 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-469">Locks are managed internally by a part of the [!INCLUDE[ssDE](../includes/ssde-md.md)] called the lock manager.</span></span> <span data-ttu-id="9951f-470">[!INCLUDE[ssDE](../includes/ssde-md.md)] 인스턴스가 [!INCLUDE[tsql](../includes/tsql-md.md)] 문을 처리할 때 [!INCLUDE[ssDE](../includes/ssde-md.md)] 쿼리 프로세서는 액세스할 리소스를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-470">When an instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] processes a [!INCLUDE[tsql](../includes/tsql-md.md)] statement, the [!INCLUDE[ssDE](../includes/ssde-md.md)] query processor determines which resources are to be accessed.</span></span> <span data-ttu-id="9951f-471">쿼리 프로세서는 액세스 유형과 트랜잭션 격리 수준 설정에 따라 각 리소스를 보호하는 데 필요한 잠금 유형을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-471">The query processor determines what types of locks are required to protect each resource based on the type of access and the transaction isolation level setting.</span></span> <span data-ttu-id="9951f-472">그런 다음 쿼리 프로세서는 잠금 관리자에게 적절한 잠금을 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-472">The query processor then requests the appropriate locks from the lock manager.</span></span> <span data-ttu-id="9951f-473">잠금 관리자는 다른 트랜잭션에서 지속되는 잠금과 충돌되지 않는 잠금을 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-473">The lock manager grants the locks if there are no conflicting locks held by other transactions.</span></span>  
  
### <a name="lock-granularity-and-hierarchies"></a><span data-ttu-id="9951f-474">잠금 세분성 및 계층</span><span class="sxs-lookup"><span data-stu-id="9951f-474">Lock Granularity and Hierarchies</span></span>  

 <span data-ttu-id="9951f-475">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]은 한 트랜잭션으로 여러 유형의 리소스를 잠글 수 있는 다양한 세분성의 잠금을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-475">The [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] has multigranular locking that allows different types of resources to be locked by a transaction.</span></span> <span data-ttu-id="9951f-476">잠금 비용을 최소화하기 위해 [!INCLUDE[ssDE](../includes/ssde-md.md)]은 자동으로 태스크에 맞는 수준에서 리소스를 잠급니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-476">To minimize the cost of locking, the [!INCLUDE[ssDE](../includes/ssde-md.md)] locks resources automatically at a level appropriate to the task.</span></span> <span data-ttu-id="9951f-477">행과 같이 작은 세분성에서 잠그면 동시성이 향상되지만 많은 행을 잠글 경우 더 많은 잠금을 보유해야 하므로 오버헤드가 늘어납니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-477">Locking at a smaller granularity, such as rows, increases concurrency but has a higher overhead because more locks must be held if many rows are locked.</span></span> <span data-ttu-id="9951f-478">테이블과 같이 큰 세분성에서 잠그면 전체 테이블이 잠겨 다른 트랜잭션이 테이블에 액세스하지 못하게 제한되므로 동시성은 떨어지지만</span><span class="sxs-lookup"><span data-stu-id="9951f-478">Locking at a larger granularity, such as tables, are expensive in terms of concurrency because locking an entire table restricts access to any part of the table by other transactions.</span></span> <span data-ttu-id="9951f-479">유지 관리할 잠금 수가 적으므로 오버헤드가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-479">However, it has a lower overhead because fewer locks are being maintained.</span></span>  
  
 <span data-ttu-id="9951f-480">[!INCLUDE[ssDE](../includes/ssde-md.md)]이 리소스를 완전히 보호하기 위해 여러 수준의 세분성에서 잠금을 획득해야 하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-480">The [!INCLUDE[ssDE](../includes/ssde-md.md)] often has to acquire locks at multiple levels of granularity to fully protect a resource.</span></span> <span data-ttu-id="9951f-481">이러한 여러 수준의 세분성 잠금 그룹을 잠금 계층 구조라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-481">This group of locks at multiple levels of granularity is called a lock hierarchy.</span></span> <span data-ttu-id="9951f-482">예를 들어 인덱스 읽기를 완전히 보호하기 위해 [!INCLUDE[ssDE](../includes/ssde-md.md)]의 인스턴스에서는 행에 대한 공유 잠금과 페이지와 테이블에 대한 내재된 공유 잠금을 획득해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-482">For example, to fully protect a read of an index, an instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] may have to acquire share locks on rows and intent share locks on the pages and table.</span></span>  
  
 <span data-ttu-id="9951f-483">다음 표에서는 [!INCLUDE[ssDE](../includes/ssde-md.md)]이 잠글 수 있는 리소스를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-483">The following table shows the resources that the [!INCLUDE[ssDE](../includes/ssde-md.md)] can lock.</span></span>  
  
|<span data-ttu-id="9951f-484">리소스</span><span class="sxs-lookup"><span data-stu-id="9951f-484">Resource</span></span>|<span data-ttu-id="9951f-485">Description</span><span class="sxs-lookup"><span data-stu-id="9951f-485">Description</span></span>|  
|--------------|-----------------|  
|<span data-ttu-id="9951f-486">RID</span><span class="sxs-lookup"><span data-stu-id="9951f-486">RID</span></span>|<span data-ttu-id="9951f-487">행 식별자는 힙 내의 단일 행을 잠그는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-487">A row identifier used to lock a single row within a heap.</span></span>|  
|<span data-ttu-id="9951f-488">KEY</span><span class="sxs-lookup"><span data-stu-id="9951f-488">KEY</span></span>|<span data-ttu-id="9951f-489">인덱스 내의 행 잠금은 직렬화 가능한 트랜잭션에서 키 범위를 보호하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-489">A row lock within an index used to protect key ranges in serializable transactions.</span></span>|  
|<span data-ttu-id="9951f-490">PAGE</span><span class="sxs-lookup"><span data-stu-id="9951f-490">PAGE</span></span>|<span data-ttu-id="9951f-491">데이터 또는 인덱스 페이지와 같은 데이터베이스의 8KB 페이지입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-491">An 8-kilobyte (KB) page in a database, such as data or index pages.</span></span>|  
|<span data-ttu-id="9951f-492">EXTENT</span><span class="sxs-lookup"><span data-stu-id="9951f-492">EXTENT</span></span>|<span data-ttu-id="9951f-493">데이터 또는 인덱스 페이지와 같은 인접한 8개의 페이지 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-493">A contiguous group of eight pages, such as data or index pages.</span></span>|  
|<span data-ttu-id="9951f-494">HoBT</span><span class="sxs-lookup"><span data-stu-id="9951f-494">HoBT</span></span>|<span data-ttu-id="9951f-495">힙 또는 B-트리입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-495">A heap or B-tree.</span></span> <span data-ttu-id="9951f-496">클러스터형 인덱스가 없는 테이블에서 힙 데이터 페이지나 B-트리(인덱스)를 보호하는 잠금입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-496">A lock protecting a B-tree (index) or the heap data pages in a table that does not have a clustered index.</span></span>|  
|<span data-ttu-id="9951f-497">TABLE</span><span class="sxs-lookup"><span data-stu-id="9951f-497">TABLE</span></span>|<span data-ttu-id="9951f-498">모든 데이터와 인덱스가 포함된 전체 테이블입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-498">The entire table, including all data and indexes.</span></span>|  
|<span data-ttu-id="9951f-499">FILE</span><span class="sxs-lookup"><span data-stu-id="9951f-499">FILE</span></span>|<span data-ttu-id="9951f-500">데이터베이스 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-500">A database file.</span></span>|  
|<span data-ttu-id="9951f-501">APPLICATION</span><span class="sxs-lookup"><span data-stu-id="9951f-501">APPLICATION</span></span>|<span data-ttu-id="9951f-502">애플리케이션이 지정한 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-502">An application-specified resource.</span></span>|  
|<span data-ttu-id="9951f-503">METADATA</span><span class="sxs-lookup"><span data-stu-id="9951f-503">METADATA</span></span>|<span data-ttu-id="9951f-504">메타데이터 잠금입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-504">Metadata locks.</span></span>|  
|<span data-ttu-id="9951f-505">ALLOCATION_UNIT</span><span class="sxs-lookup"><span data-stu-id="9951f-505">ALLOCATION_UNIT</span></span>|<span data-ttu-id="9951f-506">할당 단위입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-506">An allocation unit.</span></span>|  
|<span data-ttu-id="9951f-507">DATABASE</span><span class="sxs-lookup"><span data-stu-id="9951f-507">DATABASE</span></span>|<span data-ttu-id="9951f-508">전체 데이터베이스입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-508">The entire database.</span></span>|  
  
> [!NOTE]  
>  <span data-ttu-id="9951f-509">HoBT 및 TABLE 잠금은 [ALTER TABLE](/sql/t-sql/statements/alter-table-transact-sql)의 LOCK_ESCALATION 옵션의 영향을 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-509">HoBT and TABLE locks can be affected by the LOCK_ESCALATION option of [ALTER TABLE](/sql/t-sql/statements/alter-table-transact-sql).</span></span>  
  
### <a name="lock-modes"></a><span data-ttu-id="9951f-510">잠금 모드</span><span class="sxs-lookup"><span data-stu-id="9951f-510">Lock Modes</span></span>  

 <span data-ttu-id="9951f-511">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]은 동시 트랜잭션이 리소스에 액세스할 수 있는 방법을 결정하는 여러 가지 잠금 모드를 사용하여 리소스를 잠급니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-511">The [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] locks resources using different lock modes that determine how the resources can be accessed by concurrent transactions.</span></span>  
  
 <span data-ttu-id="9951f-512">다음 표에서는 [!INCLUDE[ssDE](../includes/ssde-md.md)]에서 사용하는 리소스 잠금 모드를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-512">The following table shows the resource lock modes that the [!INCLUDE[ssDE](../includes/ssde-md.md)] uses.</span></span>  
  
|<span data-ttu-id="9951f-513">잠금 모드</span><span class="sxs-lookup"><span data-stu-id="9951f-513">Lock mode</span></span>|<span data-ttu-id="9951f-514">Description</span><span class="sxs-lookup"><span data-stu-id="9951f-514">Description</span></span>|  
|---------------|-----------------|  
|<span data-ttu-id="9951f-515">공유(S)</span><span class="sxs-lookup"><span data-stu-id="9951f-515">Shared (S)</span></span>|<span data-ttu-id="9951f-516">SELECT 문처럼 데이터를 변경하거나 업데이트하지 않는 읽기 작업에 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-516">Used for read operations that do not change or update data, such as a SELECT statement.</span></span>|  
|<span data-ttu-id="9951f-517">업데이트(U)</span><span class="sxs-lookup"><span data-stu-id="9951f-517">Update (U)</span></span>|<span data-ttu-id="9951f-518">업데이트할 수 있는 리소스에 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-518">Used on resources that can be updated.</span></span> <span data-ttu-id="9951f-519">여러 개의 세션이 리소스를 읽고, 잠그고, 나중에 업데이트할 때 발생하는 일반적인 교착 상태를 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-519">Prevents a common form of deadlock that occurs when multiple sessions are reading, locking, and potentially updating resources later.</span></span>|  
|<span data-ttu-id="9951f-520">배타적(X)</span><span class="sxs-lookup"><span data-stu-id="9951f-520">Exclusive (X)</span></span>|<span data-ttu-id="9951f-521">INSERT, UPDATE, DELETE와 같은 데이터 수정 작업에 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-521">Used for data-modification operations, such as INSERT, UPDATE, or DELETE.</span></span> <span data-ttu-id="9951f-522">여러 개의 업데이트 작업이 같은 리소스에 대해 동시에 이루어지지 못하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-522">Ensures that multiple updates cannot be made to the same resource at the same time.</span></span>|  
|<span data-ttu-id="9951f-523">Intent</span><span class="sxs-lookup"><span data-stu-id="9951f-523">Intent</span></span>|<span data-ttu-id="9951f-524">잠금 계층 구조를 만드는 데 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-524">Used to establish a lock hierarchy.</span></span> <span data-ttu-id="9951f-525">의도 잠금의 종류에는 내재된 공유(IS), 내재된 배타(IX), 공유 내재된 배타(SIX)가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-525">The types of intent locks are: intent shared (IS), intent exclusive (IX), and shared with intent exclusive (SIX).</span></span>|  
|<span data-ttu-id="9951f-526">스키마</span><span class="sxs-lookup"><span data-stu-id="9951f-526">Schema</span></span>|<span data-ttu-id="9951f-527">테이블의 스키마에 종속되는 작업이 실행될 때 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-527">Used when an operation dependent on the schema of a table is executing.</span></span> <span data-ttu-id="9951f-528">스키마 잠금에는 스키마 수정(Sch-M)과 스키마 안정성(Sch-S) 잠금이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-528">The types of schema locks are: schema modification (Sch-M) and schema stability (Sch-S).</span></span>|  
|<span data-ttu-id="9951f-529">대량 업데이트(BU)</span><span class="sxs-lookup"><span data-stu-id="9951f-529">Bulk Update (BU)</span></span>|<span data-ttu-id="9951f-530">데이터를 테이블로 대량 복사하는 경우와 **TABLOCK** 힌트가 지정된 경우에 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-530">Used when bulk copying data into a table and the **TABLOCK** hint is specified.</span></span>|  
|<span data-ttu-id="9951f-531">키 범위</span><span class="sxs-lookup"><span data-stu-id="9951f-531">Key-range</span></span>|<span data-ttu-id="9951f-532">직렬화 가능 트랜잭션 격리 수준을 사용할 때 쿼리가 읽는 행 범위를 보호합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-532">Protects the range of rows read by a query when using the serializable transaction isolation level.</span></span> <span data-ttu-id="9951f-533">쿼리가 다시 실행될 경우 직렬화 가능 트랜잭션의 쿼리에 대해 반환되는 행을 다른 트랜잭션이 삽입할 수 없도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-533">Ensures that other transactions cannot insert rows that would qualify for the queries of the serializable transaction if the queries were run again.</span></span>|  
  
#### <a name="shared-locks"></a><span data-ttu-id="9951f-534">공유 잠금</span><span class="sxs-lookup"><span data-stu-id="9951f-534">Shared Locks</span></span>  

 <span data-ttu-id="9951f-535">공유(S) 잠금을 사용하면 비관적 동시성 제어 하에서 동시 트랜잭션이 리소스를 읽을(SELECT) 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-535">Shared (S) locks allow concurrent transactions to read (SELECT) a resource under pessimistic concurrency control.</span></span> <span data-ttu-id="9951f-536">리소스에 공유(S) 잠금이 설정되어 있는 동안에는 다른 트랜잭션이 데이터를 수정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-536">No other transactions can modify the data while shared (S) locks exist on the resource.</span></span> <span data-ttu-id="9951f-537">트랜잭션 격리 수준을 반복 읽기 이상으로 설정하거나 잠금 힌트를 사용하여 트랜잭션 기간에 대한 공유(S) 잠금을 보유하지 않는 한, 리소스에 대한 공유(S) 잠금은 읽기 작업이 완료되면 바로 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-537">Shared (S) locks on a resource are released as soon as the read operation completes, unless the transaction isolation level is set to repeatable read or higher, or a locking hint is used to retain the shared (S) locks for the duration of the transaction.</span></span>  
  
#### <a name="update-locks"></a><span data-ttu-id="9951f-538">업데이트 잠금</span><span class="sxs-lookup"><span data-stu-id="9951f-538">Update Locks</span></span>  

 <span data-ttu-id="9951f-539">업데이트(U) 잠금을 사용하면 일반적인 형태의 교착 상태가 방지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-539">Update (U) locks prevent a common form of deadlock.</span></span> <span data-ttu-id="9951f-540">반복 읽기 또는 직렬화 가능 트랜잭션의 경우 트랜잭션이 데이터를 읽고, 리소스(페이지 또는 행)에 대한 공유(S) 잠금을 얻은 다음 데이터를 수정하는데 행을 수정할 때는 배타적(X) 잠금으로 잠금을 변환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-540">In a repeatable read or serializable transaction, the transaction reads data, acquiring a shared (S) lock on the resource (page or row), and then modifies the data, which requires lock conversion to an exclusive (X) lock.</span></span> <span data-ttu-id="9951f-541">두 트랜잭션이 리소스에 대해 공유 모드 잠금을 얻은 다음 데이터를 동시에 업데이트하려고 하면 한 트랜잭션이 배타적(X) 잠금으로 잠금을 변환하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-541">If two transactions acquire shared-mode locks on a resource and then attempt to update data concurrently, one transaction attempts the lock conversion to an exclusive (X) lock.</span></span> <span data-ttu-id="9951f-542">한 트랜잭션의 배타 잠금은 다른 트랜잭션의 공유 모드 잠금과 호환되지 않으므로 공유 모드를 배타 모드로 변환할 때는 잠금 대기가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-542">The shared-mode-to-exclusive lock conversion must wait because the exclusive lock for one transaction is not compatible with the shared-mode lock of the other transaction; a lock wait occurs.</span></span> <span data-ttu-id="9951f-543">두 번째 트랜잭션이 해당 업데이트에 대해 배타적(X) 잠금을 얻으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-543">The second transaction attempts to acquire an exclusive (X) lock for its update.</span></span> <span data-ttu-id="9951f-544">이 경우 두 트랜잭션 모두 배타적(X) 잠금으로 변환 중이고 각각 상대 트랜잭션이 공유 모드 잠금을 해제하기를 기다리므로 교착 상태가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-544">Because both transactions are converting to exclusive (X) locks, and they are each waiting for the other transaction to release its shared-mode lock, a deadlock occurs.</span></span>  
  
 <span data-ttu-id="9951f-545">이러한 교착 상태를 방지하려면 업데이트(U) 잠금을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-545">To avoid this potential deadlock problem, update (U) locks are used.</span></span> <span data-ttu-id="9951f-546">한 번에 한 트랜잭션만 리소스에 대한 업데이트(U) 잠금을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-546">Only one transaction can obtain an update (U) lock to a resource at a time.</span></span> <span data-ttu-id="9951f-547">트랜잭션이 리소스를 수정하면 업데이트(U) 잠금이 배타적(X) 잠금으로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-547">If a transaction modifies a resource, the update (U) lock is converted to an exclusive (X) lock.</span></span>  
  
#### <a name="exclusive-locks"></a><span data-ttu-id="9951f-548">배타 잠금</span><span class="sxs-lookup"><span data-stu-id="9951f-548">Exclusive Locks</span></span>  

 <span data-ttu-id="9951f-549">배타적(X) 잠금을 사용하면 동시 트랜잭션이 리소스에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-549">Exclusive (X) locks prevent access to a resource by concurrent transactions.</span></span> <span data-ttu-id="9951f-550">배타(X) 잠금을 사용하면 다른 트랜잭션이 데이터를 수정할 수 없습니다. 읽기 작업은 NOLOCK 힌트 또는 READ UNCOMMITED 격리 수준을 사용해서만 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-550">With an exclusive (X) lock, no other transactions can modify data; read operations can take place only with the use of the NOLOCK hint or read uncommitted isolation level.</span></span>  
  
 <span data-ttu-id="9951f-551">INSERT, UPDATE 및 DELETE 등의 데이터 수정 문은 데이터 수정과 읽기 작업을 함께 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-551">Data modification statements, such as INSERT, UPDATE, and DELETE combine both modification and read operations.</span></span> <span data-ttu-id="9951f-552">해당 문은 먼저 읽기 작업을 수행하여 데이터를 확보한 후 필요한 수정 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-552">The statement first performs read operations to acquire data before performing the required modification operations.</span></span> <span data-ttu-id="9951f-553">따라서 데이터 수정 문은 대개 공유 잠금과 배타 잠금을 모두 필요로 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-553">Data modification statements, therefore, typically request both shared locks and exclusive locks.</span></span> <span data-ttu-id="9951f-554">예를 들어 UPDATE 문은 다른 테이블과의 조인이 있는 테이블의 행을 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-554">For example, an UPDATE statement might modify rows in one table based on a join with another table.</span></span> <span data-ttu-id="9951f-555">이 경우 UPDATE 문은 조인 테이블에서 읽는 행에 대한 공유 잠금과 업데이트되는 행에 대한 배타 잠금을 함께 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-555">In this case, the UPDATE statement requests shared locks on the rows read in the join table in addition to requesting exclusive locks on the updated rows.</span></span>  
  
#### <a name="intent-locks"></a><span data-ttu-id="9951f-556">의도 잠금</span><span class="sxs-lookup"><span data-stu-id="9951f-556">Intent Locks</span></span>  

 <span data-ttu-id="9951f-557">[!INCLUDE[ssDE](../includes/ssde-md.md)]에서는 의도 잠금을 사용하여 잠금 계층 구조 아래쪽에 있는 하위 수준 리소스에 설정되는 공유(S) 잠금 또는 배타적(X) 잠금을 보호합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-557">The [!INCLUDE[ssDE](../includes/ssde-md.md)] uses intent locks to protect placing a shared (S) lock or exclusive (X) lock on a resource lower in the lock hierarchy.</span></span> <span data-ttu-id="9951f-558">하위 수준의 잠금보다 먼저 확보되어 하위 수준에 잠금을 설정하려고 하는 의도를 나타내므로 의도 잠금이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-558">Intent locks are named intent locks because they are acquired before a lock at the lower level, and therefore signal intent to place locks at a lower level.</span></span>  
  
 <span data-ttu-id="9951f-559">의도 잠금은 다음과 같은 두 가지 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-559">Intent locks serve two purposes:</span></span>  
  
-   <span data-ttu-id="9951f-560">다른 트랜잭션이 상위 수준 리소스를 수정하여 하위 수준 잠금을 무효화하는 것을 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-560">To prevent other transactions from modifying the higher-level resource in a way that would invalidate the lock at the lower level.</span></span>  
  
-   <span data-ttu-id="9951f-561">[!INCLUDE[ssDE](../includes/ssde-md.md)]에서 상위 수준 세분성에서 발생하는 잠금 충돌을 보다 효율적으로 발견할 수 있도록 해 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-561">To improve the efficiency of the [!INCLUDE[ssDE](../includes/ssde-md.md)] in detecting lock conflicts at the higher level of granularity.</span></span>  
  
 <span data-ttu-id="9951f-562">예를 들어 테이블 내의 페이지 또는 행에 대한 공유(S) 잠금이 요청되기 전에 해당 테이블 수준에서 공유 의도 잠금이 요청됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-562">For example, a shared intent lock is requested at the table level before shared (S) locks are requested on pages or rows within that table.</span></span> <span data-ttu-id="9951f-563">테이블 수준에서 의도 잠금을 설정하면 이후에 다른 트랜잭션이 해당 페이지를 포함하는 테이블에 대해 배타적(X) 잠금을 얻을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-563">Setting an intent lock at the table level prevents another transaction from subsequently acquiring an exclusive (X) lock on the table containing that page.</span></span> <span data-ttu-id="9951f-564">[!INCLUDE[ssDE](../includes/ssde-md.md)]은 테이블 수준에서만 의도 잠금을 확인하여 트랜잭션이 해당 테이블에 대해 잠금을 얻을 수 있는지 확인하므로 의도 잠금을 사용하면 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-564">Intent locks improve performance because the [!INCLUDE[ssDE](../includes/ssde-md.md)] examines intent locks only at the table level to determine if a transaction can safely acquire a lock on that table.</span></span> <span data-ttu-id="9951f-565">이 경우 테이블의 모든 행 또는 페이지 잠금을 확인하여 트랜잭션이 전체 테이블을 잠글 수 있는지 확인할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-565">This removes the requirement to examine every row or page lock on the table to determine if a transaction can lock the entire table.</span></span>  
  
 <span data-ttu-id="9951f-566">의도 잠금에는 내재된 공유(IS) 잠금, 의도 배타(IX) 잠금, 의도 배타 공유(SIX) 잠금이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-566">Intent locks include intent shared (IS), intent exclusive (IX), and shared with intent exclusive (SIX).</span></span>  
  
|<span data-ttu-id="9951f-567">잠금 모드</span><span class="sxs-lookup"><span data-stu-id="9951f-567">Lock mode</span></span>|<span data-ttu-id="9951f-568">Description</span><span class="sxs-lookup"><span data-stu-id="9951f-568">Description</span></span>|  
|---------------|-----------------|  
|<span data-ttu-id="9951f-569">내재된 공유(IS)</span><span class="sxs-lookup"><span data-stu-id="9951f-569">Intent shared (IS)</span></span>|<span data-ttu-id="9951f-570">계층 구조의 아래쪽에 있는 일부 리소스에 대해 요청되거나 확보된 공유 잠금을 보호합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-570">Protects requested or acquired shared locks on some (but not all) resources lower in the hierarchy.</span></span>|  
|<span data-ttu-id="9951f-571">의도 배타(IX)</span><span class="sxs-lookup"><span data-stu-id="9951f-571">Intent exclusive (IX)</span></span>|<span data-ttu-id="9951f-572">계층 구조의 아래쪽에 있는 일부 리소스에 대해 요청되거나 확보된 배타 잠금을 보호합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-572">Protects requested or acquired exclusive locks on some (but not all) resources lower in the hierarchy.</span></span> <span data-ttu-id="9951f-573">IX는 IS의 상위 집합으로, 하위 수준 리소스에 대한 공유 잠금 요청도 보호합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-573">IX is a superset of IS, and it also protects requesting shared locks on lower level resources.</span></span>|  
|<span data-ttu-id="9951f-574">의도 배타 공유(SIX)</span><span class="sxs-lookup"><span data-stu-id="9951f-574">Shared with intent exclusive (SIX)</span></span>|<span data-ttu-id="9951f-575">계층 구조의 아래쪽에 있는 모든 리소스에 대해 요청되거나 확보된 공유 잠금 및 하위 수준 리소스 일부에 대해 요청되거나 확보된 의도 배타 잠금을 보호합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-575">Protects requested or acquired shared locks on all resources lower in the hierarchy and intent exclusive locks on some (but not all) of the lower level resources.</span></span> <span data-ttu-id="9951f-576">최상위 수준 리소스에서는 동시 IS 잠금이 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-576">Concurrent IS locks at the top-level resource are allowed.</span></span> <span data-ttu-id="9951f-577">예를 들어 테이블에 대한 SIX 잠금을 확보하면 수정되는 페이지에 대한 의도 배타 잠금 및 수정되는 행에 대한 배타 잠금도 동시에 확보됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-577">For example, acquiring a SIX lock on a table also acquires intent exclusive locks on the pages being modified and exclusive locks on the modified rows.</span></span> <span data-ttu-id="9951f-578">리소스당 한 번에 하나의 SIX 잠금을 설정할 수 있으므로 다른 트랜잭션이 테이블 수준에서 IS 잠금을 얻어 계층 구조 아래쪽에 있는 리소스를 읽을 수는 있어도 다른 트랜잭션이 리소스를 업데이트할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-578">There can be only one SIX lock per resource at one time, preventing updates to the resource made by other transactions, although other transactions can read resources lower in the hierarchy by obtaining IS locks at the table level.</span></span>|  
|<span data-ttu-id="9951f-579">의도 업데이트(IU)</span><span class="sxs-lookup"><span data-stu-id="9951f-579">Intent update (IU)</span></span>|<span data-ttu-id="9951f-580">계층 구조 아래쪽에 있는 모든 리소스에 대해 요청되거나 확보된 업데이트 잠금을 보호합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-580">Protects requested or acquired update locks on all resources lower in the hierarchy.</span></span> <span data-ttu-id="9951f-581">IU 잠금은 페이지 리소스에만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-581">IU locks are used only on page resources.</span></span> <span data-ttu-id="9951f-582">업데이트 작업이 발생하면 IU 잠금이 IX 잠금으로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-582">IU locks are converted to IX locks if an update operation takes place.</span></span>|  
|<span data-ttu-id="9951f-583">공유 의도 업데이트(SIU)</span><span class="sxs-lookup"><span data-stu-id="9951f-583">Shared intent update (SIU)</span></span>|<span data-ttu-id="9951f-584">S 잠금과 IU 잠금이 결합된 것으로, 두 잠금을 별도로 확보한 후 동시에 동시에 보유할 경우 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-584">A combination of S and IU locks, as a result of acquiring these locks separately and simultaneously holding both locks.</span></span> <span data-ttu-id="9951f-585">예를 들어 트랜잭션이 PAGLOCK 힌트가 있는 쿼리를 실행한 다음 업데이트 작업을 실행하면</span><span class="sxs-lookup"><span data-stu-id="9951f-585">For example, a transaction executes a query with the PAGLOCK hint and then executes an update operation.</span></span> <span data-ttu-id="9951f-586">PAGLOCK 힌트가 있는 쿼리는 S 잠금을 확보하고 업데이트 작업은 IU 잠금을 확보합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-586">The query with the PAGLOCK hint acquires the S lock, and the update operation acquires the IU lock.</span></span>|  
|<span data-ttu-id="9951f-587">업데이트 의도 배타(UIX)</span><span class="sxs-lookup"><span data-stu-id="9951f-587">Update intent exclusive (UIX)</span></span>|<span data-ttu-id="9951f-588">U 잠금과 IX 잠금이 결합된 것으로, 두 잠금을 별도로 확보한 후 동시에 동시에 보유할 경우 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-588">A combination of U and IX locks, as a result of acquiring these locks separately and simultaneously holding both locks.</span></span>|  
  
#### <a name="schema-locks"></a><span data-ttu-id="9951f-589">스키마 잠금</span><span class="sxs-lookup"><span data-stu-id="9951f-589">Schema Locks</span></span>  

 <span data-ttu-id="9951f-590">[!INCLUDE[ssDE](../includes/ssde-md.md)]은 열을 추가하거나 테이블을 삭제하는 등의 테이블 DDL(데이터 정의 언어) 작업 중에 스키마 수정(Sch-M) 잠금을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-590">The [!INCLUDE[ssDE](../includes/ssde-md.md)] uses schema modification (Sch-M) locks during a table data definition language (DDL) operation, such as adding a column or dropping a table.</span></span> <span data-ttu-id="9951f-591">Sch-M 잠금이 유지되는 동안에는 테이블에 대한 동시 액세스가 방지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-591">During the time that it is held, the Sch-M lock prevents concurrent access to the table.</span></span> <span data-ttu-id="9951f-592">즉, 잠금이 해제되기 전까지는 Sch-M 잠금이 모든 외부 작업을 차단합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-592">This means the Sch-M lock blocks all outside operations until the lock is released.</span></span>  
  
 <span data-ttu-id="9951f-593">테이블 잘림 등의 일부 DML(데이터 조작 언어)은 Sch-M 잠금을 사용하여 영향을 받는 테이블에 대한 동시 작업의 액세스를 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-593">Some data manipulation language (DML) operations, such as table truncation, use Sch-M locks to prevent access to affected tables by concurrent operations.</span></span>  
  
 <span data-ttu-id="9951f-594">[!INCLUDE[ssDE](../includes/ssde-md.md)]은 쿼리를 컴파일하고 실행할 때 스키마 안정성(Sch-S) 잠금을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-594">The [!INCLUDE[ssDE](../includes/ssde-md.md)] uses schema stability (Sch-S) locks when compiling and executing queries.</span></span> <span data-ttu-id="9951f-595">Sch-S 잠금은 배타적(X) 잠금 등의 트랜잭션 잠금을 차단하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-595">Sch-S locks do not block any transactional locks, including exclusive (X) locks.</span></span> <span data-ttu-id="9951f-596">따라서 쿼리가 컴파일되는 동안 테이블에 대한 X 잠금이 있는 트랜잭션을 포함하여 다른 트랜잭션이 계속 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-596">Therefore, other transactions, including those with X locks on a table, continue to run while a query is being compiled.</span></span> <span data-ttu-id="9951f-597">그러나 Sch-M 잠금을 획득하는 동시 DML 작업과 동시 DDL 작업은 테이블에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-597">However, concurrent DDL operations, and concurrent DML operations that acquire Sch-M locks, cannot be performed on the table.</span></span>  
  
#### <a name="bulk-update-locks"></a><span data-ttu-id="9951f-598">대량 업데이트 잠금</span><span class="sxs-lookup"><span data-stu-id="9951f-598">Bulk Update Locks</span></span>  

 <span data-ttu-id="9951f-599">대량 업데이트(BU) 잠금을 사용하면 여러 스레드가 데이터를 동시에 같은 테이블로 대량 로드하는 것은 허용하고, 데이터를 대량 로드하지 않는 다른 프로세스가 테이블에 액세스하는 것은 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-599">Bulk update (BU) locks allow multiple threads to bulk load data concurrently into the same table while preventing other processes that are not bulk loading data from accessing the table.</span></span> <span data-ttu-id="9951f-600">[!INCLUDE[ssDE](../includes/ssde-md.md)]에서는 다음 조건이 모두 충족되면 대량 업데이트(BU) 잠금을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-600">The [!INCLUDE[ssDE](../includes/ssde-md.md)] uses bulk update (BU) locks when both of the following conditions are true.</span></span>  
  
-   <span data-ttu-id="9951f-601">Transact-SQL BULK INSERT 문 또는 OPENROWSET(BULK) 함수를 사용하거나 .NET SqlBulkCopy, OLEDB 빠른 로드 API 또는 ODBC 대량 복사 API와 같은 BULK INSERT 명령 중 하나를 사용하여 데이터를 테이블에 대량 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-601">You use the Transact-SQL BULK INSERT statement, or the OPENROWSET(BULK) function, or you use one of the Bulk Insert API commands such as .NET SqlBulkCopy, OLEDB Fast Load APIs, or the ODBC Bulk Copy APIs to bulk copy data into a table.</span></span>  
  
-   <span data-ttu-id="9951f-602">**TABLOCK** 힌트를 지정하거나 **sp_tableoption**을 사용하여 **table lock on bulk load** 테이블 옵션을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-602">The **TABLOCK** hint is specified or the **table lock on bulk load** table option is set using **sp_tableoption**.</span></span>  
  
> [!TIP]  
>  <span data-ttu-id="9951f-603">덜 제한적인 대량 업데이트 잠금을 보유하는 BULK INSERT 문과 달리 TABLOCK 힌트를 사용하는 INSERT INTO...SELECT 문은 테이블에 대해 배타적(X) 잠금을 보유합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-603">Unlike the BULK INSERT statement, which holds a less restrictive Bulk Update lock, INSERT INTO...SELECT with the TABLOCK hint holds an exclusive (X) lock on the table.</span></span> <span data-ttu-id="9951f-604">즉, 병렬 삽입 작업을 사용하여 행을 삽입할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-604">This means that you cannot insert rows using parallel insert operations.</span></span>  
  
#### <a name="key-range-locks"></a><span data-ttu-id="9951f-605">키 범위 잠금</span><span class="sxs-lookup"><span data-stu-id="9951f-605">Key-Range Locks</span></span>  

 <span data-ttu-id="9951f-606">키 범위 잠금은 직렬화 가능 트랜잭션 격리 수준을 사용하는 동안 [!INCLUDE[tsql](../includes/tsql-md.md)] 문에서 읽는 레코드 집합에 포함된 행 범위를 암시적으로 보호합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-606">Key-range locks protect a range of rows implicitly included in a record set being read by a [!INCLUDE[tsql](../includes/tsql-md.md)] statement while using the serializable transaction isolation level.</span></span> <span data-ttu-id="9951f-607">키 범위 잠금은 가상 읽기를 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-607">Key-range locking prevents phantom reads.</span></span> <span data-ttu-id="9951f-608">행 간에 키 범위를 보호하면 트랜잭션이 액세스하는 레코드 집합에 대한 가상 삽입이나 가상 삭제도 방지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-608">By protecting the ranges of keys between rows, it also prevents phantom insertions or deletions into a record set accessed by a transaction.</span></span>  
  
### <a name="lock-compatibility"></a><span data-ttu-id="9951f-609">잠금 호환성</span><span class="sxs-lookup"><span data-stu-id="9951f-609">Lock Compatibility</span></span>  

 <span data-ttu-id="9951f-610">잠금 호환성에 따라 여러 트랜잭션이 동시에 같은 리소스에 대한 잠금을 획득할 수 있는지 여부가 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-610">Lock compatibility controls whether multiple transactions can acquire locks on the same resource at the same time.</span></span> <span data-ttu-id="9951f-611">이미 다른 트랜잭션에서 리소스를 잠근 경우에는 요청된 잠금 모드가 기존 잠금 모드와 호환되어야만 새 잠금 요청이 허용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-611">If a resource is already locked by another transaction, a new lock request can be granted only if the mode of the requested lock is compatible with the mode of the existing lock.</span></span> <span data-ttu-id="9951f-612">요청된 잠금의 모드가 기존 잠금과 호환되지 않을 경우 새 잠금을 요청하는 트랜잭션은 기존 잠금이 해제되거나 잠금 시간 초과 간격이 만료될 때까지 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-612">If the mode of the requested lock is not compatible with the existing lock, the transaction requesting the new lock waits for the existing lock to be released or for the lock timeout interval to expire.</span></span> <span data-ttu-id="9951f-613">예를 들어 배타적 잠금과 호환되는 잠금 모드는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-613">For example, no lock modes are compatible with exclusive locks.</span></span> <span data-ttu-id="9951f-614">배타적(X) 잠금이 설정되어 있는 동안 다른 트랜잭션은 배타적(X) 잠금이 해제될 때까지 해당 리소스에 대해 공유, 업데이트 또는 배타적 잠금을 비롯한 어떠한 유형의 잠금도 획득할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-614">While an exclusive (X) lock is held, no other transaction can acquire a lock of any kind (shared, update, or exclusive) on that resource until the exclusive (X) lock is released.</span></span> <span data-ttu-id="9951f-615">리소스에 공유(S) 잠금이 적용된 경우에는 첫 번째 트랜잭션이 완료되지 않아도 다른 트랜잭션이 해당 항목에 대해 공유 잠금 또는 업데이트(U) 잠금을 획득할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-615">Alternatively, if a shared (S) lock has been applied to a resource, other transactions can also acquire a shared lock or an update (U) lock on that item even if the first transaction has not completed.</span></span> <span data-ttu-id="9951f-616">그러나 공유 잠금이 해제될 때까지는 다른 트랜잭션이 배타적 잠금을 획득할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-616">However, other transactions cannot acquire an exclusive lock until the shared lock has been released.</span></span>  
  
 <span data-ttu-id="9951f-617">다음 표에서는 가장 일반적인 잠금 모드의 호환성을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-617">The following table shows the compatibility of the most commonly encountered lock modes.</span></span>  
  
||<span data-ttu-id="9951f-618">기존의 허가 모드</span><span class="sxs-lookup"><span data-stu-id="9951f-618">Existing granted mode</span></span>||||||  
|------|---------------------------|------|------|------|------|------|  
|<span data-ttu-id="9951f-619">**요청 모드**</span><span class="sxs-lookup"><span data-stu-id="9951f-619">**Requested mode**</span></span>|<span data-ttu-id="9951f-620">**IS**</span><span class="sxs-lookup"><span data-stu-id="9951f-620">**IS**</span></span>|<span data-ttu-id="9951f-621">**S**</span><span class="sxs-lookup"><span data-stu-id="9951f-621">**S**</span></span>|<span data-ttu-id="9951f-622">**U**</span><span class="sxs-lookup"><span data-stu-id="9951f-622">**U**</span></span>|<span data-ttu-id="9951f-623">**IX**</span><span class="sxs-lookup"><span data-stu-id="9951f-623">**IX**</span></span>|<span data-ttu-id="9951f-624">**SIX**</span><span class="sxs-lookup"><span data-stu-id="9951f-624">**SIX**</span></span>|<span data-ttu-id="9951f-625">**X**</span><span class="sxs-lookup"><span data-stu-id="9951f-625">**X**</span></span>|  
|<span data-ttu-id="9951f-626">**내재된 공유(IS)(IS)**</span><span class="sxs-lookup"><span data-stu-id="9951f-626">**Intent shared (IS)**</span></span>|<span data-ttu-id="9951f-627">예</span><span class="sxs-lookup"><span data-stu-id="9951f-627">Yes</span></span>|<span data-ttu-id="9951f-628">예</span><span class="sxs-lookup"><span data-stu-id="9951f-628">Yes</span></span>|<span data-ttu-id="9951f-629">예</span><span class="sxs-lookup"><span data-stu-id="9951f-629">Yes</span></span>|<span data-ttu-id="9951f-630">예</span><span class="sxs-lookup"><span data-stu-id="9951f-630">Yes</span></span>|<span data-ttu-id="9951f-631">예</span><span class="sxs-lookup"><span data-stu-id="9951f-631">Yes</span></span>|<span data-ttu-id="9951f-632">예</span><span class="sxs-lookup"><span data-stu-id="9951f-632">No</span></span>|  
|<span data-ttu-id="9951f-633">**공유(S)**</span><span class="sxs-lookup"><span data-stu-id="9951f-633">**Shared (S)**</span></span>|<span data-ttu-id="9951f-634">예</span><span class="sxs-lookup"><span data-stu-id="9951f-634">Yes</span></span>|<span data-ttu-id="9951f-635">예</span><span class="sxs-lookup"><span data-stu-id="9951f-635">Yes</span></span>|<span data-ttu-id="9951f-636">예</span><span class="sxs-lookup"><span data-stu-id="9951f-636">Yes</span></span>|<span data-ttu-id="9951f-637">아니요</span><span class="sxs-lookup"><span data-stu-id="9951f-637">No</span></span>|<span data-ttu-id="9951f-638">아니요</span><span class="sxs-lookup"><span data-stu-id="9951f-638">No</span></span>|<span data-ttu-id="9951f-639">예</span><span class="sxs-lookup"><span data-stu-id="9951f-639">No</span></span>|  
|<span data-ttu-id="9951f-640">**업데이트(U)**</span><span class="sxs-lookup"><span data-stu-id="9951f-640">**Update (U)**</span></span>|<span data-ttu-id="9951f-641">예</span><span class="sxs-lookup"><span data-stu-id="9951f-641">Yes</span></span>|<span data-ttu-id="9951f-642">예</span><span class="sxs-lookup"><span data-stu-id="9951f-642">Yes</span></span>|<span data-ttu-id="9951f-643">예</span><span class="sxs-lookup"><span data-stu-id="9951f-643">No</span></span>|<span data-ttu-id="9951f-644">아니요</span><span class="sxs-lookup"><span data-stu-id="9951f-644">No</span></span>|<span data-ttu-id="9951f-645">아니요</span><span class="sxs-lookup"><span data-stu-id="9951f-645">No</span></span>|<span data-ttu-id="9951f-646">예</span><span class="sxs-lookup"><span data-stu-id="9951f-646">No</span></span>|  
|<span data-ttu-id="9951f-647">**의도 배타(IX)**</span><span class="sxs-lookup"><span data-stu-id="9951f-647">**Intent exclusive (IX)**</span></span>|<span data-ttu-id="9951f-648">예</span><span class="sxs-lookup"><span data-stu-id="9951f-648">Yes</span></span>|<span data-ttu-id="9951f-649">예</span><span class="sxs-lookup"><span data-stu-id="9951f-649">No</span></span>|<span data-ttu-id="9951f-650">예</span><span class="sxs-lookup"><span data-stu-id="9951f-650">No</span></span>|<span data-ttu-id="9951f-651">예</span><span class="sxs-lookup"><span data-stu-id="9951f-651">Yes</span></span>|<span data-ttu-id="9951f-652">예</span><span class="sxs-lookup"><span data-stu-id="9951f-652">No</span></span>|<span data-ttu-id="9951f-653">예</span><span class="sxs-lookup"><span data-stu-id="9951f-653">No</span></span>|  
|<span data-ttu-id="9951f-654">**의도 배타 공유(SIX)**</span><span class="sxs-lookup"><span data-stu-id="9951f-654">**Shared with intent exclusive (SIX)**</span></span>|<span data-ttu-id="9951f-655">예</span><span class="sxs-lookup"><span data-stu-id="9951f-655">Yes</span></span>|<span data-ttu-id="9951f-656">예</span><span class="sxs-lookup"><span data-stu-id="9951f-656">No</span></span>|<span data-ttu-id="9951f-657">예</span><span class="sxs-lookup"><span data-stu-id="9951f-657">No</span></span>|<span data-ttu-id="9951f-658">아니요</span><span class="sxs-lookup"><span data-stu-id="9951f-658">No</span></span>|<span data-ttu-id="9951f-659">아니요</span><span class="sxs-lookup"><span data-stu-id="9951f-659">No</span></span>|<span data-ttu-id="9951f-660">예</span><span class="sxs-lookup"><span data-stu-id="9951f-660">No</span></span>|  
|<span data-ttu-id="9951f-661">**배타적(X)**</span><span class="sxs-lookup"><span data-stu-id="9951f-661">**Exclusive (X)**</span></span>|<span data-ttu-id="9951f-662">예</span><span class="sxs-lookup"><span data-stu-id="9951f-662">No</span></span>|<span data-ttu-id="9951f-663">아니요</span><span class="sxs-lookup"><span data-stu-id="9951f-663">No</span></span>|<span data-ttu-id="9951f-664">아니요</span><span class="sxs-lookup"><span data-stu-id="9951f-664">No</span></span>|<span data-ttu-id="9951f-665">아니요</span><span class="sxs-lookup"><span data-stu-id="9951f-665">No</span></span>|<span data-ttu-id="9951f-666">아니요</span><span class="sxs-lookup"><span data-stu-id="9951f-666">No</span></span>|<span data-ttu-id="9951f-667">예</span><span class="sxs-lookup"><span data-stu-id="9951f-667">No</span></span>|  
  
> [!NOTE]  
>  <span data-ttu-id="9951f-668">의도 배타(IX) 잠금은 모든 행이 아닌 일부 행만 업데이트하기 위한 것이므로 IX 잠금 모드와 호환됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-668">An intent exclusive (IX) lock is compatible with an IX lock mode because IX means the intention is to update only some of the rows rather than all of them.</span></span> <span data-ttu-id="9951f-669">일부 행을 읽거나 업데이트하려고 하는 다른 트랜잭션도 허용됩니다. 단, 해당 행을 다른 트랜잭션이 업데이트하고 있지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-669">Other transactions that attempt to read or update some of the rows are also permitted as long as they are not the same rows being updated by other transactions.</span></span> <span data-ttu-id="9951f-670">두 트랜잭션이 같은 행을 업데이트하려고 시도하는 경우 두 트랜잭션 모두에 테이블 및 페이지 수준의 IX 잠금이 부여됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-670">Further, if two transactions attempt to update the same row, both transactions will be granted an IX lock at table and page level.</span></span> <span data-ttu-id="9951f-671">하지만 한 트랜잭션에 행 수준의 X 잠금이 부여되므로</span><span class="sxs-lookup"><span data-stu-id="9951f-671">However, one transaction will be granted an X lock at row level.</span></span> <span data-ttu-id="9951f-672">다른 트랜잭션은 행 수준 잠금이 제거될 때까지 대기해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-672">The other transaction must wait until the row-level lock is removed.</span></span>  
  
 <span data-ttu-id="9951f-673">[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]에서 사용할 수 있는 모든 잠금 모드의 호환성을 확인하려면 다음 표를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-673">Use the following table to determine the compatibility of all the lock modes available in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span>  
  
 <span data-ttu-id="9951f-674">![잠금 호환성 행렬을 보여 주는 다이어그램](media/lockconflicttable.gif "잠금 호환성 행렬을 보여 주는 다이어그램")</span><span class="sxs-lookup"><span data-stu-id="9951f-674">![Diagram showing lock compatibility matrix](media/lockconflicttable.gif "Diagram showing lock compatibility matrix")</span></span>  
  
### <a name="key-range-locking"></a><span data-ttu-id="9951f-675">키 범위 잠금</span><span class="sxs-lookup"><span data-stu-id="9951f-675">Key-Range Locking</span></span>  

 <span data-ttu-id="9951f-676">키 범위 잠금은 직렬화 가능 트랜잭션 격리 수준을 사용하는 동안 [!INCLUDE[tsql](../includes/tsql-md.md)] 문에서 읽는 레코드 집합에 포함된 행 범위를 암시적으로 보호합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-676">Key-range locks protect a range of rows implicitly included in a record set being read by a [!INCLUDE[tsql](../includes/tsql-md.md)] statement while using the serializable transaction isolation level.</span></span> <span data-ttu-id="9951f-677">직렬화 가능 격리 수준에서는 트랜잭션 중 실행되는 모든 쿼리가 트랜잭션 중 실행될 때마다 동일한 행 집합을 가져와야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-677">The serializable isolation level requires that any query executed during a transaction must obtain the same set of rows every time it is executed during the transaction.</span></span> <span data-ttu-id="9951f-678">키 범위 잠금은 다른 트랜잭션에서 해당 키가 직렬화 가능 트랜잭션에서 읽은 키 범위에 속하는 새 행을 삽입하지 못하도록 하여 이 요구 사항을 보호합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-678">A key range lock protects this requirement by preventing other transactions from inserting new rows whose keys would fall in the range of keys read by the serializable transaction.</span></span>  
  
 <span data-ttu-id="9951f-679">키 범위 잠금은 가상 읽기를 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-679">Key-range locking prevents phantom reads.</span></span> <span data-ttu-id="9951f-680">또한 행 사이에서 키 범위를 보호하여 트랜잭션에서 액세스하는 레코드 집합에 대한 가상 삽입을 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-680">By protecting the ranges of keys between rows, it also prevents phantom insertions into a set of records accessed by a transaction.</span></span>  
  
 <span data-ttu-id="9951f-681">키 범위 잠금은 인덱스에 배치되어 시작 키 값과 종료 키 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-681">A key-range lock is placed on an index, specifying a beginning and ending key value.</span></span> <span data-ttu-id="9951f-682">이 잠금은 키 값이 해당 범위에 속하는 모든 행의 삽입, 업데이트 또는 삭제 시도를 차단합니다. 이는 이러한 작업을 수행하려면 먼저 인덱스에 대한 잠금을 획득해야 하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-682">This lock blocks any attempt to insert, update, or delete any row with a key value that falls in the range because those operations would first have to acquire a lock on the index.</span></span> <span data-ttu-id="9951f-683">예를 들어 직렬화 가능 트랜잭션은 해당 키 값이 **'** AAA **'** 및 **'** CZZ **'** 까지인 모든 행을 읽는 SELECT 문을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-683">For example, a serializable transaction could issue a SELECT statement that reads all rows whose key values are between **'** AAA **'** and **'** CZZ **'**.</span></span> <span data-ttu-id="9951f-684">**'** AAA **'** 부터 **'** CZZ **'** 까지의 범위에 있는 키 값에 대한 키 범위 잠금은 다른 트랜잭션에서 해당 키 값이 **'** ADG **'** , **'** BBD **'** 또는 **'** CAL **'** 과 같이 해당 범위에 있는 행을 삽입하지 못하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-684">A key-range lock on the key values in the range from **'** AAA **'** to **'** CZZ **'** prevents other transactions from inserting rows with key values anywhere in that range, such as **'** ADG **'**, **'** BBD **'**, or **'** CAL **'**.</span></span>  
  
#### <a name="key-range-lock-modes"></a><span data-ttu-id="9951f-685">키 범위 잠금 모드</span><span class="sxs-lookup"><span data-stu-id="9951f-685">Key-Range Lock Modes</span></span>  

 <span data-ttu-id="9951f-686">키 범위 잠금에는 범위-행 형식으로 지정된 범위 및 행 구성 요소가 모두 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-686">Key-range locks include both a range and a row component specified in range-row format:</span></span>  
  
-   <span data-ttu-id="9951f-687">범위는 두 개의 연속되는 인덱스 항목 간의 범위를 보호하는 잠금 모드를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-687">Range represents the lock mode protecting the range between two consecutive index entries.</span></span>  
  
-   <span data-ttu-id="9951f-688">행은 인덱스 항목을 보호하는 잠금 모드를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-688">Row represents the lock mode protecting the index entry.</span></span>  
  
-   <span data-ttu-id="9951f-689">모드는 사용된 혼합 잠금 모드를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-689">Mode represents the combined lock mode used.</span></span> <span data-ttu-id="9951f-690">키 범위 잠금 모드는 두 부분으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-690">Key-range lock modes consist of two parts.</span></span> <span data-ttu-id="9951f-691">첫 번째는 인덱스 범위(Range*T*)를 잠그는 데 사용하는 잠금 유형을 나타내고 두 번째는 특정 키(*K*)를 잠그는 데 사용하는 잠금 유형을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-691">The first represents the type of lock used to lock the index range (Range*T*) and the second represents the lock type used to lock a specific key (*K*).</span></span> <span data-ttu-id="9951f-692">두 부분은 *T*-*K*와 같이 하이픈(-)으로 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-692">The two parts are connected with a hyphen (-), such as Range*T*-*K*.</span></span>  
  
    |<span data-ttu-id="9951f-693">범위</span><span class="sxs-lookup"><span data-stu-id="9951f-693">Range</span></span>|<span data-ttu-id="9951f-694">행</span><span class="sxs-lookup"><span data-stu-id="9951f-694">Row</span></span>|<span data-ttu-id="9951f-695">Mode</span><span class="sxs-lookup"><span data-stu-id="9951f-695">Mode</span></span>|<span data-ttu-id="9951f-696">Description</span><span class="sxs-lookup"><span data-stu-id="9951f-696">Description</span></span>|  
    |-----------|---------|----------|-----------------|  
    |<span data-ttu-id="9951f-697">RangeS</span><span class="sxs-lookup"><span data-stu-id="9951f-697">RangeS</span></span>|<span data-ttu-id="9951f-698">S</span><span class="sxs-lookup"><span data-stu-id="9951f-698">S</span></span>|<span data-ttu-id="9951f-699">RangeS-S</span><span class="sxs-lookup"><span data-stu-id="9951f-699">RangeS-S</span></span>|<span data-ttu-id="9951f-700">공유 범위, 공유 리소스 잠금. 직렬화 가능한 범위 검색입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-700">Shared range, shared resource lock; serializable range scan.</span></span>|  
    |<span data-ttu-id="9951f-701">RangeS</span><span class="sxs-lookup"><span data-stu-id="9951f-701">RangeS</span></span>|<span data-ttu-id="9951f-702">U</span><span class="sxs-lookup"><span data-stu-id="9951f-702">U</span></span>|<span data-ttu-id="9951f-703">RangeS-U</span><span class="sxs-lookup"><span data-stu-id="9951f-703">RangeS-U</span></span>|<span data-ttu-id="9951f-704">공유 범위, 업데이트 리소스 잠금, 직렬화 가능한 업데이트 검색입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-704">Shared range, update resource lock; serializable update scan.</span></span>|  
    |<span data-ttu-id="9951f-705">RangeI</span><span class="sxs-lookup"><span data-stu-id="9951f-705">RangeI</span></span>|<span data-ttu-id="9951f-706">Null</span><span class="sxs-lookup"><span data-stu-id="9951f-706">Null</span></span>|<span data-ttu-id="9951f-707">RangeI-N</span><span class="sxs-lookup"><span data-stu-id="9951f-707">RangeI-N</span></span>|<span data-ttu-id="9951f-708">삽입 범위, null 리소스 잠금. 인덱스에 새 키를 삽입하기 전에 범위를 테스트하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-708">Insert range, null resource lock; used to test ranges before inserting a new key into an index.</span></span>|  
    |<span data-ttu-id="9951f-709">RangeX</span><span class="sxs-lookup"><span data-stu-id="9951f-709">RangeX</span></span>|<span data-ttu-id="9951f-710">X</span><span class="sxs-lookup"><span data-stu-id="9951f-710">X</span></span>|<span data-ttu-id="9951f-711">RangeX-X</span><span class="sxs-lookup"><span data-stu-id="9951f-711">RangeX-X</span></span>|<span data-ttu-id="9951f-712">배타적 범위, 배타적 리소스 잠금. 범위 내의 키를 업데이트할 때 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-712">Exclusive range, exclusive resource lock; used when updating a key in a range.</span></span>|  
  
> [!NOTE]  
>  <span data-ttu-id="9951f-713">내부적 Null 잠금 모드는 다른 모든 잠금 모드와 호환됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-713">The internal Null lock mode is compatible with all other lock modes.</span></span>  
  
 <span data-ttu-id="9951f-714">키 범위 잠금 모드에는 겹치는 키 및 범위에서 얻은 다른 잠금과 호환되는 잠금을 보여 주는 호환성 행렬이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-714">Key-range lock modes have a compatibility matrix that shows which locks are compatible with other locks obtained on overlapping keys and ranges.</span></span>  
  
||<span data-ttu-id="9951f-715">기존의 허가 모드</span><span class="sxs-lookup"><span data-stu-id="9951f-715">Existing granted mode</span></span>|||||||  
|------|---------------------------|------|------|------|------|------|------|  
|<span data-ttu-id="9951f-716">**요청 모드**</span><span class="sxs-lookup"><span data-stu-id="9951f-716">**Requested mode**</span></span>|<span data-ttu-id="9951f-717">**S**</span><span class="sxs-lookup"><span data-stu-id="9951f-717">**S**</span></span>|<span data-ttu-id="9951f-718">**U**</span><span class="sxs-lookup"><span data-stu-id="9951f-718">**U**</span></span>|<span data-ttu-id="9951f-719">**X**</span><span class="sxs-lookup"><span data-stu-id="9951f-719">**X**</span></span>|<span data-ttu-id="9951f-720">**RangeS-S**</span><span class="sxs-lookup"><span data-stu-id="9951f-720">**RangeS-S**</span></span>|<span data-ttu-id="9951f-721">**RangeS-U**</span><span class="sxs-lookup"><span data-stu-id="9951f-721">**RangeS-U**</span></span>|<span data-ttu-id="9951f-722">**RangeI-N**</span><span class="sxs-lookup"><span data-stu-id="9951f-722">**RangeI-N**</span></span>|<span data-ttu-id="9951f-723">**RangeX-X**</span><span class="sxs-lookup"><span data-stu-id="9951f-723">**RangeX-X**</span></span>|  
|<span data-ttu-id="9951f-724">**공유(S)**</span><span class="sxs-lookup"><span data-stu-id="9951f-724">**Shared (S)**</span></span>|<span data-ttu-id="9951f-725">예</span><span class="sxs-lookup"><span data-stu-id="9951f-725">Yes</span></span>|<span data-ttu-id="9951f-726">예</span><span class="sxs-lookup"><span data-stu-id="9951f-726">Yes</span></span>|<span data-ttu-id="9951f-727">예</span><span class="sxs-lookup"><span data-stu-id="9951f-727">No</span></span>|<span data-ttu-id="9951f-728">예</span><span class="sxs-lookup"><span data-stu-id="9951f-728">Yes</span></span>|<span data-ttu-id="9951f-729">예</span><span class="sxs-lookup"><span data-stu-id="9951f-729">Yes</span></span>|<span data-ttu-id="9951f-730">예</span><span class="sxs-lookup"><span data-stu-id="9951f-730">Yes</span></span>|<span data-ttu-id="9951f-731">예</span><span class="sxs-lookup"><span data-stu-id="9951f-731">No</span></span>|  
|<span data-ttu-id="9951f-732">**업데이트(U)**</span><span class="sxs-lookup"><span data-stu-id="9951f-732">**Update (U)**</span></span>|<span data-ttu-id="9951f-733">예</span><span class="sxs-lookup"><span data-stu-id="9951f-733">Yes</span></span>|<span data-ttu-id="9951f-734">예</span><span class="sxs-lookup"><span data-stu-id="9951f-734">No</span></span>|<span data-ttu-id="9951f-735">예</span><span class="sxs-lookup"><span data-stu-id="9951f-735">No</span></span>|<span data-ttu-id="9951f-736">예</span><span class="sxs-lookup"><span data-stu-id="9951f-736">Yes</span></span>|<span data-ttu-id="9951f-737">예</span><span class="sxs-lookup"><span data-stu-id="9951f-737">No</span></span>|<span data-ttu-id="9951f-738">예</span><span class="sxs-lookup"><span data-stu-id="9951f-738">Yes</span></span>|<span data-ttu-id="9951f-739">예</span><span class="sxs-lookup"><span data-stu-id="9951f-739">No</span></span>|  
|<span data-ttu-id="9951f-740">**배타적(X)**</span><span class="sxs-lookup"><span data-stu-id="9951f-740">**Exclusive (X)**</span></span>|<span data-ttu-id="9951f-741">예</span><span class="sxs-lookup"><span data-stu-id="9951f-741">No</span></span>|<span data-ttu-id="9951f-742">아니요</span><span class="sxs-lookup"><span data-stu-id="9951f-742">No</span></span>|<span data-ttu-id="9951f-743">아니요</span><span class="sxs-lookup"><span data-stu-id="9951f-743">No</span></span>|<span data-ttu-id="9951f-744">예</span><span class="sxs-lookup"><span data-stu-id="9951f-744">No</span></span>|<span data-ttu-id="9951f-745">예</span><span class="sxs-lookup"><span data-stu-id="9951f-745">No</span></span>|<span data-ttu-id="9951f-746">예</span><span class="sxs-lookup"><span data-stu-id="9951f-746">Yes</span></span>|<span data-ttu-id="9951f-747">예</span><span class="sxs-lookup"><span data-stu-id="9951f-747">No</span></span>|  
|<span data-ttu-id="9951f-748">**RangeS-S**</span><span class="sxs-lookup"><span data-stu-id="9951f-748">**RangeS-S**</span></span>|<span data-ttu-id="9951f-749">예</span><span class="sxs-lookup"><span data-stu-id="9951f-749">Yes</span></span>|<span data-ttu-id="9951f-750">예</span><span class="sxs-lookup"><span data-stu-id="9951f-750">Yes</span></span>|<span data-ttu-id="9951f-751">예</span><span class="sxs-lookup"><span data-stu-id="9951f-751">No</span></span>|<span data-ttu-id="9951f-752">예</span><span class="sxs-lookup"><span data-stu-id="9951f-752">Yes</span></span>|<span data-ttu-id="9951f-753">예</span><span class="sxs-lookup"><span data-stu-id="9951f-753">Yes</span></span>|<span data-ttu-id="9951f-754">아니요</span><span class="sxs-lookup"><span data-stu-id="9951f-754">No</span></span>|<span data-ttu-id="9951f-755">예</span><span class="sxs-lookup"><span data-stu-id="9951f-755">No</span></span>|  
|<span data-ttu-id="9951f-756">**RangeS-U**</span><span class="sxs-lookup"><span data-stu-id="9951f-756">**RangeS-U**</span></span>|<span data-ttu-id="9951f-757">예</span><span class="sxs-lookup"><span data-stu-id="9951f-757">Yes</span></span>|<span data-ttu-id="9951f-758">예</span><span class="sxs-lookup"><span data-stu-id="9951f-758">No</span></span>|<span data-ttu-id="9951f-759">예</span><span class="sxs-lookup"><span data-stu-id="9951f-759">No</span></span>|<span data-ttu-id="9951f-760">예</span><span class="sxs-lookup"><span data-stu-id="9951f-760">Yes</span></span>|<span data-ttu-id="9951f-761">예</span><span class="sxs-lookup"><span data-stu-id="9951f-761">No</span></span>|<span data-ttu-id="9951f-762">아니요</span><span class="sxs-lookup"><span data-stu-id="9951f-762">No</span></span>|<span data-ttu-id="9951f-763">예</span><span class="sxs-lookup"><span data-stu-id="9951f-763">No</span></span>|  
|<span data-ttu-id="9951f-764">**RangeI-N**</span><span class="sxs-lookup"><span data-stu-id="9951f-764">**RangeI-N**</span></span>|<span data-ttu-id="9951f-765">예</span><span class="sxs-lookup"><span data-stu-id="9951f-765">Yes</span></span>|<span data-ttu-id="9951f-766">예</span><span class="sxs-lookup"><span data-stu-id="9951f-766">Yes</span></span>|<span data-ttu-id="9951f-767">예</span><span class="sxs-lookup"><span data-stu-id="9951f-767">Yes</span></span>|<span data-ttu-id="9951f-768">예</span><span class="sxs-lookup"><span data-stu-id="9951f-768">No</span></span>|<span data-ttu-id="9951f-769">예</span><span class="sxs-lookup"><span data-stu-id="9951f-769">No</span></span>|<span data-ttu-id="9951f-770">예</span><span class="sxs-lookup"><span data-stu-id="9951f-770">Yes</span></span>|<span data-ttu-id="9951f-771">예</span><span class="sxs-lookup"><span data-stu-id="9951f-771">No</span></span>|  
|<span data-ttu-id="9951f-772">**RangeX-X**</span><span class="sxs-lookup"><span data-stu-id="9951f-772">**RangeX-X**</span></span>|<span data-ttu-id="9951f-773">예</span><span class="sxs-lookup"><span data-stu-id="9951f-773">No</span></span>|<span data-ttu-id="9951f-774">아니요</span><span class="sxs-lookup"><span data-stu-id="9951f-774">No</span></span>|<span data-ttu-id="9951f-775">아니요</span><span class="sxs-lookup"><span data-stu-id="9951f-775">No</span></span>|<span data-ttu-id="9951f-776">아니요</span><span class="sxs-lookup"><span data-stu-id="9951f-776">No</span></span>|<span data-ttu-id="9951f-777">아니요</span><span class="sxs-lookup"><span data-stu-id="9951f-777">No</span></span>|<span data-ttu-id="9951f-778">아니요</span><span class="sxs-lookup"><span data-stu-id="9951f-778">No</span></span>|<span data-ttu-id="9951f-779">아니요</span><span class="sxs-lookup"><span data-stu-id="9951f-779">No</span></span>|  
  
#### <a name="conversion-locks"></a><span data-ttu-id="9951f-780">변환 잠금</span><span class="sxs-lookup"><span data-stu-id="9951f-780">Conversion Locks</span></span>  

 <span data-ttu-id="9951f-781">변환 잠금은 키 범위 잠금이 다른 잠금과 겹칠 때 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-781">Conversion locks are created when a key-range lock overlaps another lock.</span></span>  
  
|<span data-ttu-id="9951f-782">잠금 1</span><span class="sxs-lookup"><span data-stu-id="9951f-782">Lock 1</span></span>|<span data-ttu-id="9951f-783">잠금 2</span><span class="sxs-lookup"><span data-stu-id="9951f-783">Lock 2</span></span>|<span data-ttu-id="9951f-784">변환 잠금</span><span class="sxs-lookup"><span data-stu-id="9951f-784">Conversion lock</span></span>|  
|------------|------------|---------------------|  
|<span data-ttu-id="9951f-785">S</span><span class="sxs-lookup"><span data-stu-id="9951f-785">S</span></span>|<span data-ttu-id="9951f-786">RangeI-N</span><span class="sxs-lookup"><span data-stu-id="9951f-786">RangeI-N</span></span>|<span data-ttu-id="9951f-787">RangeI-S</span><span class="sxs-lookup"><span data-stu-id="9951f-787">RangeI-S</span></span>|  
|<span data-ttu-id="9951f-788">U</span><span class="sxs-lookup"><span data-stu-id="9951f-788">U</span></span>|<span data-ttu-id="9951f-789">RangeI-N</span><span class="sxs-lookup"><span data-stu-id="9951f-789">RangeI-N</span></span>|<span data-ttu-id="9951f-790">RangeI-U</span><span class="sxs-lookup"><span data-stu-id="9951f-790">RangeI-U</span></span>|  
|<span data-ttu-id="9951f-791">X</span><span class="sxs-lookup"><span data-stu-id="9951f-791">X</span></span>|<span data-ttu-id="9951f-792">RangeI-N</span><span class="sxs-lookup"><span data-stu-id="9951f-792">RangeI-N</span></span>|<span data-ttu-id="9951f-793">RangeI-X</span><span class="sxs-lookup"><span data-stu-id="9951f-793">RangeI-X</span></span>|  
|<span data-ttu-id="9951f-794">RangeI-N</span><span class="sxs-lookup"><span data-stu-id="9951f-794">RangeI-N</span></span>|<span data-ttu-id="9951f-795">RangeS-S</span><span class="sxs-lookup"><span data-stu-id="9951f-795">RangeS-S</span></span>|<span data-ttu-id="9951f-796">RangeX-S</span><span class="sxs-lookup"><span data-stu-id="9951f-796">RangeX-S</span></span>|  
|<span data-ttu-id="9951f-797">RangeI-N</span><span class="sxs-lookup"><span data-stu-id="9951f-797">RangeI-N</span></span>|<span data-ttu-id="9951f-798">RangeS-U</span><span class="sxs-lookup"><span data-stu-id="9951f-798">RangeS-U</span></span>|<span data-ttu-id="9951f-799">RangeX-U</span><span class="sxs-lookup"><span data-stu-id="9951f-799">RangeX-U</span></span>|  
  
 <span data-ttu-id="9951f-800">변환 잠금은 다양한 복합 환경에서 짧은 시간 동안 나타날 수 있으며 때로는 동시 프로세스를 실행하는 동안에 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-800">Conversion locks can be observed for a short period of time under different complex circumstances, sometimes while running concurrent processes.</span></span>  
  
#### <a name="serializable-range-scan-singleton-fetch-delete-and-insert"></a><span data-ttu-id="9951f-801">직렬화 가능 범위 검색, 단일 인출, 삭제 및 삽입</span><span class="sxs-lookup"><span data-stu-id="9951f-801">Serializable Range Scan, Singleton Fetch, Delete, and Insert</span></span>  

 <span data-ttu-id="9951f-802">키 범위 잠금을 사용하면 다음 작업을 직렬화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-802">Key-range locking ensures that the following operations are serializable:</span></span>  
  
-   <span data-ttu-id="9951f-803">범위 검색 쿼리</span><span class="sxs-lookup"><span data-stu-id="9951f-803">Range scan query</span></span>  
  
-   <span data-ttu-id="9951f-804">존재하지 않는 행의 단일 인출</span><span class="sxs-lookup"><span data-stu-id="9951f-804">Singleton fetch of nonexistent row</span></span>  
  
-   <span data-ttu-id="9951f-805">삭제 작업</span><span class="sxs-lookup"><span data-stu-id="9951f-805">Delete operation</span></span>  
  
-   <span data-ttu-id="9951f-806">삽입 작업</span><span class="sxs-lookup"><span data-stu-id="9951f-806">Insert operation</span></span>  
  
 <span data-ttu-id="9951f-807">키 범위 잠금이 발생하려면 다음 조건을 만족해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-807">Before key-range locking can occur, the following conditions must be satisfied:</span></span>  
  
-   <span data-ttu-id="9951f-808">트랜잭션 격리 수준을 SERIALIZABLE로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-808">The transaction-isolation level must be set to SERIALIZABLE.</span></span>  
  
-   <span data-ttu-id="9951f-809">쿼리 프로세서가 인덱스를 사용하여 범위 필터 조건자를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-809">The query processor must use an index to implement the range filter predicate.</span></span> <span data-ttu-id="9951f-810">예를 들어 SELECT 문의 WHERE 절은 다음 조건자를 사용하여 범위 조건을 설정할 수 있습니다. ColumnX BETWEEN N **'** AAA **'** AND N **'** CZZ **'** .</span><span class="sxs-lookup"><span data-stu-id="9951f-810">For example, the WHERE clause in a SELECT statement could establish a range condition with this predicate: ColumnX BETWEEN N **'** AAA **'** AND N **'** CZZ **'**.</span></span> <span data-ttu-id="9951f-811">키 범위 잠금은 **ColumnX**가 인덱스 키 내에 있는 경우에만 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-811">A key-range lock can only be acquired if **ColumnX** is covered by an index key.</span></span>  
  
#### <a name="examples"></a><span data-ttu-id="9951f-812">예제</span><span class="sxs-lookup"><span data-stu-id="9951f-812">Examples</span></span>  

 <span data-ttu-id="9951f-813">다음 테이블 및 인덱스는 이어지는 키 범위 잠금 예의 기준으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-813">The following table and index are used as a basis for the key-range locking examples that follow.</span></span>  
  
 <span data-ttu-id="9951f-814">![인덱스 B-트리가 있는 데이터베이스 테이블 그림](media/btree4.gif "인덱스 B-트리가 있는 데이터베이스 테이블 그림")</span><span class="sxs-lookup"><span data-stu-id="9951f-814">![Database table with index b-tree illustration](media/btree4.gif "Database table with index b-tree illustration")</span></span>  
  
##### <a name="range-scan-query"></a><span data-ttu-id="9951f-815">범위 검색 쿼리</span><span class="sxs-lookup"><span data-stu-id="9951f-815">Range Scan Query</span></span>  

 <span data-ttu-id="9951f-816">범위 검색 쿼리가 직렬화 가능인지 확인하려면 같은 트랜잭션 내에서 같은 쿼리를 실행할 때마다 같은 결과를 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-816">To ensure a range scan query is serializable, the same query should return the same results each time it is executed within the same transaction.</span></span> <span data-ttu-id="9951f-817">다른 트랜잭션에서는 범위 스캔 쿼리 내에 새 행을 추가하면 안됩니다. 그렇지 않으면 이러한 행은 가상 삽입이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-817">New rows must not be inserted within the range scan query by other transactions; otherwise, these become phantom inserts.</span></span> <span data-ttu-id="9951f-818">예를 들어 다음 쿼리는 앞 그림의 테이블과 인덱스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-818">For example, the following query uses the table and index in the previous illustration:</span></span>  
  
```sql  
SELECT name  
    FROM mytable  
    WHERE name BETWEEN 'A' AND 'C';  
```  
  
 <span data-ttu-id="9951f-819">키 범위 잠금은 이름이 Adam과 Dale 값 사이에 있는 데이터 행 범위에 해당하는 인덱스 항목에 설정되어 앞의 쿼리에서 한정하는 새 행의 추가 또는 삭제를 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-819">Key-range locks are placed on the index entries corresponding to the range of data rows where the name is between the values Adam and Dale, preventing new rows qualifying in the previous query from being added or deleted.</span></span> <span data-ttu-id="9951f-820">이 범위의 첫 번째 이름은 Adam이지만 이 인덱스 항목에 대해 RangeS-S 모드 키 범위 잠금을 사용하면 Abigail과 같이 A로 시작하는 새 이름을 Adam 앞에 추가할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-820">Although the first name in this range is Adam, the RangeS-S mode key-range lock on this index entry ensures that no new names beginning with the letter A can be added before Adam, such as Abigail.</span></span> <span data-ttu-id="9951f-821">마찬가지로 Dale의 인덱스 항목에 대해 RangeS-S 키 범위 잠금을 사용하면 Clive와 같이 C로 시작하는 새 이름을 Carlos 뒤에 추가할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-821">Similarly, the RangeS-S key-range lock on the index entry for Dale ensures that no new names beginning with the letter C can be added after Carlos, such as Clive.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9951f-822">보유한 RangeS-S 잠금 수는 *n*+1입니다. 여기서 *n*은 쿼리를 만족하는 행 수입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-822">The number of RangeS-S locks held is *n*+1, where *n* is the number of rows that satisfy the query.</span></span>  
  
##### <a name="singleton-fetch-of-nonexistent-data"></a><span data-ttu-id="9951f-823">존재하지 않는 데이터의 단일 인출</span><span class="sxs-lookup"><span data-stu-id="9951f-823">Singleton Fetch of Nonexistent Data</span></span>  

 <span data-ttu-id="9951f-824">트랜잭션 내의 쿼리가 존재하지 않는 행을 선택하려고 하면 같은 트랜잭션 내에서 나중에 쿼리를 실행해도 같은 결과를 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-824">If a query within a transaction attempts to select a row that does not exist, issuing the query at a later point within the same transaction has to return the same result.</span></span> <span data-ttu-id="9951f-825">다른 트랜잭션도 존재하지 않는 행을 삽입할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-825">No other transaction can be allowed to insert that nonexistent row.</span></span> <span data-ttu-id="9951f-826">다음과 같은 쿼리를 예로 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-826">For example, given this query:</span></span>  
  
```sql 
SELECT name  
    FROM mytable  
    WHERE name = 'Bill';  
```  
  
 <span data-ttu-id="9951f-827">이 경우 `Ben`이라는 이름이 인접한 두 인덱스 항목 사이에 삽입되므로 키 범위 잠금은 `Bing`부터 `Bill`까지의 이름 범위에 해당하는 인덱스 항목에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-827">A key-range lock is placed on the index entry corresponding to the name range from `Ben` to `Bing` because the name `Bill` would be inserted between these two adjacent index entries.</span></span> <span data-ttu-id="9951f-828">RangeS-S 모드 키 범위 잠금은 인덱스 항목 `Bing`에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-828">The RangeS-S mode key-range lock is placed on the index entry `Bing`.</span></span> <span data-ttu-id="9951f-829">이렇게 되면 다른 모든 트랜잭션이 `Bill` 등의 값을 인덱스 항목 `Ben`과 `Bing` 사이에 삽입할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-829">This prevents any other transaction from inserting values, such as `Bill`, between the index entries `Ben` and `Bing`.</span></span>  
  
##### <a name="delete-operation"></a><span data-ttu-id="9951f-830">삭제 작업</span><span class="sxs-lookup"><span data-stu-id="9951f-830">Delete Operation</span></span>  

 <span data-ttu-id="9951f-831">트랜잭션 내에서 값을 삭제할 때는 트랜잭션이 삭제 작업을 수행하는 동안 값이 속하는 범위를 잠글 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-831">When deleting a value within a transaction, the range the value falls into does not have to be locked for the duration of the transaction performing the delete operation.</span></span> <span data-ttu-id="9951f-832">삭제된 키 값을 트랜잭션이 끝날 때까지 잠그기만 해도 직렬화 기능이 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-832">Locking the deleted key value until the end of the transaction is sufficient to maintain serializability.</span></span> <span data-ttu-id="9951f-833">다음과 같은 DELETE 문을 예로 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-833">For example, given this DELETE statement:</span></span>  
  
```sql  
DELETE mytable  
    WHERE name = 'Bob';  
```  
  
 <span data-ttu-id="9951f-834">배타적(X) 잠금이 `Bob`이라는 이름에 해당하는 인덱스 항목에 설정되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-834">An exclusive (X) lock is placed on the index entry corresponding to the name `Bob`.</span></span> <span data-ttu-id="9951f-835">다른 트랜잭션은 삭제된 값인 `Bob` 전후에 값을 삽입하거나 삭제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-835">Other transactions can insert or delete values before or after the deleted value `Bob`.</span></span> <span data-ttu-id="9951f-836">그러나 값 `Bob`을 읽거나 삽입하거나 삭제하려는 트랜잭션은 삭제 트랜잭션이 커밋되거나 롤백될 때까지 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-836">However, any transaction that attempts to read, insert, or delete the value `Bob` will be blocked until the deleting transaction either commits or rolls back.</span></span>  
  
 <span data-ttu-id="9951f-837">범위 삭제는 세 가지 기본 잠금 모드인 행 잠금, 페이지 잠금 또는 테이블 잠금을 사용하여 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-837">Range delete can be executed using three basic lock modes: row, page, or table lock.</span></span> <span data-ttu-id="9951f-838">행, 페이지 또는 테이블 잠금 전략은 쿼리 최적화 프로그램에 의해 결정되거나 ROWLOCK, PAGLOCK 또는 TABLOCK 등의 최적화 프로그램 힌트를 통해 사용자가 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-838">The row, page, or table locking strategy is decided by query optimizer or can be specified by the user through optimizer hints such as ROWLOCK, PAGLOCK, or TABLOCK.</span></span> <span data-ttu-id="9951f-839">PAGLOCK 또는 TABLOCK을 사용하는 경우 이 페이지에서 모든 행이 삭제되면 [!INCLUDE[ssDE](../includes/ssde-md.md)]은 즉시 인덱스 페이지 할당을 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-839">When PAGLOCK or TABLOCK is used, the [!INCLUDE[ssDE](../includes/ssde-md.md)] immediately deallocates an index page if all rows are deleted from this page.</span></span> <span data-ttu-id="9951f-840">반대로 ROWLOCK을 사용하면 삭제된 모든 행이 삭제된 것으로 표시만 되고 나중에 백그라운드 태스크를 사용하여 인덱스 페이지에서 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-840">In contrast, when ROWLOCK is used, all deleted rows are marked only as deleted; they are removed from the index page later using a background task.</span></span>  
  
##### <a name="insert-operation"></a><span data-ttu-id="9951f-841">삽입 작업</span><span class="sxs-lookup"><span data-stu-id="9951f-841">Insert Operation</span></span>  

 <span data-ttu-id="9951f-842">트랜잭션 내에서 값을 삽입할 때는 트랜잭션이 삽입 작업을 수행하는 동안 값이 속하는 범위를 잠글 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-842">When inserting a value within a transaction, the range the value falls into does not have to be locked for the duration of the transaction performing the insert operation.</span></span> <span data-ttu-id="9951f-843">삽입된 키 값을 트랜잭션이 끝날 때까지 잠그기만 해도 직렬화 기능이 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-843">Locking the inserted key value until the end of the transaction is sufficient to maintain serializability.</span></span> <span data-ttu-id="9951f-844">다음과 같은 INSERT 문을 예로 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-844">For example, given this INSERT statement:</span></span>  
  
```sql  
INSERT mytable VALUES ('Dan');  
```  
  
 <span data-ttu-id="9951f-845">범위를 테스트하기 위해 RangeI-N 모드 키 범위 잠금이 David 이름에 해당하는 인덱스 항목에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-845">The RangeI-N mode key-range lock is placed on the index entry corresponding to the name David to test the range.</span></span> <span data-ttu-id="9951f-846">잠금이 허용되면 `Dan`이 삽입되고 `Dan` 값에 배타적(X) 잠금이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-846">If the lock is granted, `Dan` is inserted and an exclusive (X) lock is placed on the value `Dan`.</span></span> <span data-ttu-id="9951f-847">Range-N 모드 키 범위 잠금은 범위를 테스트하는 데만 필요하며 트랜잭션이 삽입 작업을 수행하는 동안에는 보유되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-847">The RangeI-N mode key-range lock is necessary only to test the range and is not held for the duration of the transaction performing the insert operation.</span></span> <span data-ttu-id="9951f-848">다른 트랜잭션은 삽입된 값 `Dan` 전후에 값을 삽입하거나 삭제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-848">Other transactions can insert or delete values before or after the inserted value `Dan`.</span></span> <span data-ttu-id="9951f-849">그러나 값 `Dan`을 읽거나 삽입하거나 삭제하려는 트랜잭션은 삽입 트랜잭션이 커밋되거나 롤백될 때까지 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-849">However, any transaction attempting to read, insert, or delete the value `Dan` will be locked until the inserting transaction either commits or rolls back.</span></span>  
  
### <a name="dynamic-locking"></a><span data-ttu-id="9951f-850">동적 잠금</span><span class="sxs-lookup"><span data-stu-id="9951f-850">Dynamic Locking</span></span>  

 <span data-ttu-id="9951f-851">행 잠금과 같이 낮은 수준의 잠금을 사용하면 두 트랜잭션이 동일한 데이터에 대해 동시에 잠금을 요청할 확률이 줄어들어 동시성이 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-851">Using low-level locks, such as row locks, increases concurrency by decreasing the probability that two transactions will request locks on the same piece of data at the same time.</span></span> <span data-ttu-id="9951f-852">또한 잠금 수 및 잠금 관리에 필요한 리소스 수도 늘어납니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-852">Using low-level locks also increases the number of locks and the resources needed to manage them.</span></span> <span data-ttu-id="9951f-853">테이블 또는 페이지 잠금과 같이 높은 수준의 잠금을 사용하면 오버헤드는 줄어들지만 동시성이 감소합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-853">Using high-level table or page locks lowers overhead, but at the expense of lowering concurrency.</span></span>  
  
 <span data-ttu-id="9951f-854">![원가 대 세분성을 보여 주는 다이어그램](media/lockcht.gif "원가 대 세분성을 보여 주는 다이어그램")</span><span class="sxs-lookup"><span data-stu-id="9951f-854">![Diagram showing cost versus granularity](media/lockcht.gif "Diagram showing cost versus granularity")</span></span>  
  
 <span data-ttu-id="9951f-855">[!INCLUDE[msCoName](../includes/msconame-md.md)] [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]에서는 동적 잠금 전략을 사용하여 가장 비용 효율적인 잠금을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-855">The [!INCLUDE[msCoName](../includes/msconame-md.md)] [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] uses a dynamic locking strategy to determine the most cost-effective locks.</span></span> <span data-ttu-id="9951f-856">[!INCLUDE[ssDE](../includes/ssde-md.md)]에서는 스키마 및 쿼리의 특징을 기준으로 쿼리를 실행할 때 가장 적합한 잠금을 자동으로 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-856">The [!INCLUDE[ssDE](../includes/ssde-md.md)] automatically determines what locks are most appropriate when the query is executed, based on the characteristics of the schema and query.</span></span> <span data-ttu-id="9951f-857">예를 들어 잠금 오버헤드를 줄이기 위해서 인덱스 검색을 수행할 때 최적화 프로그램이 인덱스에서 페이지 수준 잠금을 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-857">For example, to reduce the overhead of locking, the optimizer may choose page-level locks in an index when performing an index scan.</span></span>  
  
 <span data-ttu-id="9951f-858">동적 잠금을 사용하면 다음과 같은 장점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-858">Dynamic locking has the following advantages:</span></span>  
  
-   <span data-ttu-id="9951f-859">데이터베이스 관리가 간단해집니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-859">Simplified database administration.</span></span> <span data-ttu-id="9951f-860">데이터베이스 관리자가 잠금 에스컬레이션 임계값을 조정할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-860">Database administrators do not have to adjust lock escalation thresholds.</span></span>  
  
-   <span data-ttu-id="9951f-861">성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-861">Increased performance.</span></span> <span data-ttu-id="9951f-862">[!INCLUDE[ssDE](../includes/ssde-md.md)]에서 태스크에 적합한 잠금을 사용하므로 시스템 오버헤드가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-862">The [!INCLUDE[ssDE](../includes/ssde-md.md)] minimizes system overhead by using locks appropriate to the task.</span></span>  
  
-   <span data-ttu-id="9951f-863">애플리케이션 개발자가 개발에만 전념할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-863">Application developers can concentrate on development.</span></span> <span data-ttu-id="9951f-864">[!INCLUDE[ssDE](../includes/ssde-md.md)]에서 잠금을 자동으로 조정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-864">The [!INCLUDE[ssDE](../includes/ssde-md.md)] adjusts locking automatically.</span></span>  
  
 <span data-ttu-id="9951f-865">[!INCLUDE[ssKatmai](../includes/sskatmai-md.md)]이상 버전에서 잠금 에스컬레이션의 동작은 LOCK_ESCALATION 옵션의 도입으로 변경 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-865">In [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] and later versions, the behavior of lock escalation has changed with the introduction of the LOCK_ESCALATION option.</span></span> <span data-ttu-id="9951f-866">자세한 내용은 [ALTER TABLE](/sql/t-sql/statements/alter-table-transact-sql)의 LOCK_ESCALATION 옵션을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="9951f-866">For more information, see the LOCK_ESCALATION option of [ALTER TABLE](/sql/t-sql/statements/alter-table-transact-sql).</span></span>  
  
### <a name="deadlocking"></a><span data-ttu-id="9951f-867">교착 상태</span><span class="sxs-lookup"><span data-stu-id="9951f-867">Deadlocking</span></span>  

 <span data-ttu-id="9951f-868">한 태스크에서 잠근 리소스를 다른 태스크에서 잠그려고 하여 둘 이상의 태스크가 서로 영구적으로 차단하면 교착 상태가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-868">A deadlock occurs when two or more tasks permanently block each other by each task having a lock on a resource which the other tasks are trying to lock.</span></span> <span data-ttu-id="9951f-869">예를 들면 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-869">For example:</span></span>  
  
-   <span data-ttu-id="9951f-870">트랜잭션 A가 1행에 대한 공유 잠금을 획득합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-870">Transaction A acquires a share lock on row 1.</span></span>  
  
-   <span data-ttu-id="9951f-871">트랜잭션 B가 2행에 대한 공유 잠금을 획득합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-871">Transaction B acquires a share lock on row 2.</span></span>  
  
-   <span data-ttu-id="9951f-872">트랜잭션 A가 2행에 대한 배타적 잠금을 요청하고 트랜잭션 B가 2행에 대해 소유하고 있는 공유 잠금을 종료 및 해제할 때까지 트랜잭션 A가 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-872">Transaction A now requests an exclusive lock on row 2, and is blocked until transaction B finishes and releases the share lock it has on row 2.</span></span>  
  
-   <span data-ttu-id="9951f-873">트랜잭션 B가 1행에 대한 배타적 잠금을 요청하고 트랜잭션 A가 1행에 대해 소유하고 있는 공유 잠금을 종료 및 해제할 때까지 트랜잭션 B가 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-873">Transaction B now requests an exclusive lock on row 1, and is blocked until transaction A finishes and releases the share lock it has on row 1.</span></span>  
  
 <span data-ttu-id="9951f-874">트랜잭션 B가 완료되어야 트랜잭션 A도 완료될 수 있지만 트랜잭션 B는 트랜잭션 A에 의해 차단된 상태입니다. 이러한 상태를 순환 종속 관계라고 합니다. 트랜잭션 A는 트랜잭션 B에 종속되고 트랜잭션 B는 트랜잭션 A에 종속된 형태로 순환됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-874">Transaction A cannot complete until transaction B completes, but transaction B is blocked by transaction A. This condition is also called a cyclic dependency: Transaction A has a dependency on transaction B, and transaction B closes the circle by having a dependency on transaction A.</span></span>  
  
 <span data-ttu-id="9951f-875">교착 상태의 트랜잭션은 둘 다 외부 프로세스에서 교착 상태를 해제할 때까지 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-875">Both transactions in a deadlock will wait forever unless the deadlock is broken by an external process.</span></span> <span data-ttu-id="9951f-876">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 교착 상태 모니터는 교착 상태에 있는 태스크가 있는지 주기적으로 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-876">The [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] deadlock monitor periodically checks for tasks that are in a deadlock.</span></span> <span data-ttu-id="9951f-877">순환 종속 관계가 발견되면 모니터는 두 작업 중 처리하지 않을 태스크를 하나 선택하고 해당 트랜잭션을 오류와 함께 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-877">If the monitor detects a cyclic dependency, it chooses one of the tasks as a victim and terminates its transaction with an error.</span></span> <span data-ttu-id="9951f-878">이렇게 하여 다른 태스크가 해당 트랜잭션을 완료할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-878">This allows the other task to complete its transaction.</span></span> <span data-ttu-id="9951f-879">오류와 함께 종료된 트랜잭션의 애플리케이션은 해당 트랜잭션을 다시 시도하며 이 트랜잭션은 대개 교착 상태의 다른 트랜잭션이 완료된 후에 끝납니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-879">The application with the transaction that terminated with an error can retry the transaction, which usually completes after the other deadlocked transaction has finished.</span></span>  
  
 <span data-ttu-id="9951f-880">교착 상태는 종종 일반적인 차단과 혼동됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-880">Deadlocking is often confused with normal blocking.</span></span> <span data-ttu-id="9951f-881">트랜잭션이 다른 트랜잭션에서 잠근 리소스에 대한 잠금을 요청하면 잠금이 해제될 때까지 잠금을 요청한 트랜잭션이 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-881">When a transaction requests a lock on a resource locked by another transaction, the requesting transaction waits until the lock is released.</span></span> <span data-ttu-id="9951f-882">기본적으로 LOCK_TIMEOUT이 설정되지 않은 한 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 트랜잭션 시간은 제한되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-882">By default, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] transactions do not time out, unless LOCK_TIMEOUT is set.</span></span> <span data-ttu-id="9951f-883">잠금을 요청하는 트랜잭션은 잠금을 소유하는 트랜잭션을 차단하기 위한 작업을 수행하지 않으므로 교착 상태에 빠지지 않고 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-883">The requesting transaction is blocked, not deadlocked, because the requesting transaction has not done anything to block the transaction owning the lock.</span></span> <span data-ttu-id="9951f-884">결국 잠금을 소유하는 트랜잭션이 완료되고 잠금을 해제하면 잠금을 요청하는 트랜잭션에 잠금이 허가되고 트랜잭션이 진행됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-884">Eventually, the owning transaction will complete and release the lock, and then the requesting transaction will be granted the lock and proceed.</span></span>  
  
 <span data-ttu-id="9951f-885">교착 상태는 deadly embrace(치명적인 포옹)라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-885">Deadlocks are sometimes called a deadly embrace.</span></span>  
  
 <span data-ttu-id="9951f-886">교착 상태는 관계형 데이터베이스 관리 시스템뿐만 아니라 다중 스레드를 사용하는 어느 시스템에서나 발생할 수 있으며 데이터베이스 개체에 대한 잠금 이외의 리소스에 대해 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-886">Deadlock is a condition that can occur on any system with multiple threads, not just on a relational database management system, and can occur for resources other than locks on database objects.</span></span> <span data-ttu-id="9951f-887">예를 들어 다중 스레드 운영 체제의 스레드는 메모리 블록과 같은 하나 이상의 리소스를 획득할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-887">For example, a thread in a multithreaded operating system might acquire one or more resources, such as blocks of memory.</span></span> <span data-ttu-id="9951f-888">획득하려는 리소스를 현재 다른 스레드가 소유하고 있으면 대상 리소스가 해제될 때까지 첫 번째 스레드가 기다려야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-888">If the resource being acquired is currently owned by another thread, the first thread may have to wait for the owning thread to release the target resource.</span></span> <span data-ttu-id="9951f-889">이렇게 대기 중인 스레드는 해당 리소스에 대해 리소스를 소유하는 스레드에 종속됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-889">The waiting thread is said to have a dependency on the owning thread for that particular resource.</span></span> <span data-ttu-id="9951f-890">[!INCLUDE[ssDE](../includes/ssde-md.md)]의 인스턴스에서 세션은 메모리나 스레드 등의 데이터베이스가 아닌 리소스를 획득할 때 교착 상태에 빠질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-890">In an instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)], sessions can deadlock when acquiring nondatabase resources, such as memory or threads.</span></span>  
  
 <span data-ttu-id="9951f-891">![트랜잭션 교착 상태를 보여 주는 다이어그램](media/dedlck1.gif "트랜잭션 교착 상태를 보여 주는 다이어그램")</span><span class="sxs-lookup"><span data-stu-id="9951f-891">![Diagram showing transaction deadlock](media/dedlck1.gif "Diagram showing transaction deadlock")</span></span>  
  
 <span data-ttu-id="9951f-892">이 그림에서 트랜잭션 T1은 **Part** 테이블 잠금 리소스에 대해 트랜잭션 T2에 종속됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-892">In the illustration, transaction T1 has a dependency on transaction T2 for the **Part** table lock resource.</span></span> <span data-ttu-id="9951f-893">마찬가지로 스레드 T2는 **Supplier** 테이블 잠금 리소스에 대해 트랜잭션 T1에 종속됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-893">Similarly, transaction T2 has a dependency on transaction T1 for the **Supplier** table lock resource.</span></span> <span data-ttu-id="9951f-894">이러한 종속 관계는 순환적이므로 스레드 T1과 T2 간에 교착 상태가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-894">Because these dependencies form a cycle, there is a deadlock between transactions T1 and T2.</span></span>  
  
 <span data-ttu-id="9951f-895">테이블이 분할되고 ALTER TABLE의 LOCK_ESCALATION 설정이 AUTO로 설정된 경우에도 교착 상태가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-895">Deadlocks can also occur when a table is partitioned and the LOCK_ESCALATION setting of ALTER TABLE is set to AUTO.</span></span> <span data-ttu-id="9951f-896">LOCK_ESCALATION를 AUTO로 설정 하면에서 테이블 [!INCLUDE[ssDE](../includes/ssde-md.md)] 수준 대신 HoBT 수준으로 테이블 파티션을 잠글 수 있으므로 동시성이 늘어납니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-896">When LOCK_ESCALATION is set to AUTO, concurrency increases by allowing the [!INCLUDE[ssDE](../includes/ssde-md.md)] to lock table partitions at the HoBT level instead of at the TABLE level.</span></span> <span data-ttu-id="9951f-897">그러나 개별 트랜잭션이 테이블에 파티션 잠금을 보유하고 다른 트랜잭션 파티션에서 잠금을 원하면 교착 상태가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-897">However, when separate transactions hold partition locks in a table and want a lock somewhere on the other transactions partition, this causes a deadlock.</span></span> <span data-ttu-id="9951f-898">이런 유형의 교착 상태는 LOCK_ESCALATION을 TABLE로 설정하면 방지할 수 있습니다. 하지만 이 설정으로 인해 테이블 잠금을 기다리도록 파티션에 대규모 업데이트가 강제 적용되어 동시성이 감소됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-898">This type of deadlock can be avoided by setting LOCK_ESCALATION to TABLE; although this setting will reduce concurrency by forcing large updates to a partition to wait for a table lock.</span></span>  
  
#### <a name="detecting-and-ending-deadlocks"></a><span data-ttu-id="9951f-899">교착 상태 검색 및 종료</span><span class="sxs-lookup"><span data-stu-id="9951f-899">Detecting and Ending Deadlocks</span></span>  

 <span data-ttu-id="9951f-900">한 태스크에서 잠근 리소스를 다른 태스크에서 잠그려고 하여 둘 이상의 태스크가 서로 영구적으로 차단하면 교착 상태가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-900">A deadlock occurs when two or more tasks permanently block each other by each task having a lock on a resource which the other tasks are trying to lock.</span></span> <span data-ttu-id="9951f-901">다음 그래프에서는 아래와 같은 교착 상태를 개괄적으로 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-901">The following graph presents a high level view of a deadlock state where:</span></span>  
  
-   <span data-ttu-id="9951f-902">태스크 T1이 리소스 R1에 대한 잠금을 가지고 있고(R1에서 T1 방향의 화살표로 표시) 리소스 R2에 대한 잠금을 요청합니다(T1에서 R2 방향의 화살표로 표시).</span><span class="sxs-lookup"><span data-stu-id="9951f-902">Task T1 has a lock on resource R1 (indicated by the arrow from R1 to T1) and has requested a lock on resource R2 (indicated by the arrow from T1 to R2).</span></span>  
  
-   <span data-ttu-id="9951f-903">태스크 T2가 리소스 R2에 대한 잠금을 가지고 있고(R2에서 T2 방향의 화살표로 표시) 리소스 R1에 대한 잠금을 요청합니다(T2에서 R1 방향의 화살표로 표시).</span><span class="sxs-lookup"><span data-stu-id="9951f-903">Task T2 has a lock on resource R2 (indicated by the arrow from R2 to T2) and has requested a lock on resource R1 (indicated by the arrow from T2 to R1).</span></span>  
  
-   <span data-ttu-id="9951f-904">리소스가 사용 가능한 상태가 되어야 태스크를 계속할 수 있고 태스크가 계속되어야 리소스를 해제할 수 있으므로 교착 상태가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-904">Because neither task can continue until a resource is available and neither resource can be released until a task continues, a deadlock state exists.</span></span>  
  
 <span data-ttu-id="9951f-905">![교착 상태에 있는 태스크를 보여 주는 다이어그램](media/task-deadlock-state.gif "교착 상태에 있는 태스크를 보여 주는 다이어그램")</span><span class="sxs-lookup"><span data-stu-id="9951f-905">![Diagram showing tasks in a deadlock state](media/task-deadlock-state.gif "Diagram showing tasks in a deadlock state")</span></span>  
  
 <span data-ttu-id="9951f-906">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]은 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]에서 교착 상태 순환을 자동으로 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-906">The [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] automatically detects deadlock cycles within [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="9951f-907">그런 다음 [!INCLUDE[ssDE](../includes/ssde-md.md)]에서 교착 상태에 있는 세션 중 처리하지 않을 세션을 하나 선택하면 현재 트랜잭션이 오류와 함께 종료되면서 교착 상태가 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-907">The [!INCLUDE[ssDE](../includes/ssde-md.md)] chooses one of the sessions as a deadlock victim and the current transaction is terminated with an error to break the deadlock.</span></span>  
  
##### <a name="resources-that-can-deadlock"></a><span data-ttu-id="9951f-908">교착 상태를 일으킬 수 있는 리소스</span><span class="sxs-lookup"><span data-stu-id="9951f-908">Resources That Can Deadlock</span></span>  

 <span data-ttu-id="9951f-909">사용자 세션마다 세션을 위해 실행 중인 태스크가 하나 이상 있고 각 태스크는 다양한 리소스를 획득하거나 획득 대기 중일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-909">Each user session might have one or more tasks running on its behalf where each task might acquire or wait to acquire a variety of resources.</span></span> <span data-ttu-id="9951f-910">다음 유형의 리소스가 차단을 일으켜 교착 상태가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-910">The following types of resources can cause blocking that could result in a deadlock.</span></span>  
  
-   <span data-ttu-id="9951f-911">**잠금**.</span><span class="sxs-lookup"><span data-stu-id="9951f-911">**Locks**.</span></span> <span data-ttu-id="9951f-912">개체, 페이지, 행, 메타데이터, 애플리케이션 등의 리소스에 대한 잠금을 획득하려고 대기할 때 교착 상태가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-912">Waiting to acquire locks on resources, such as objects, pages, rows, metadata, and applications can cause deadlock.</span></span> <span data-ttu-id="9951f-913">예를 들어 트랜잭션 T1이 r1 행에 대한 공유(S) 잠금을 가지고 있고 r2에 대한 배타적(X) 잠금을 얻으려고 대기 중입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-913">For example, transaction T1 has a shared (S) lock on row r1 and is waiting to get an exclusive (X) lock on r2.</span></span> <span data-ttu-id="9951f-914">트랜잭션 T2가 r2에 대한 공유(S) 잠금을 가지고 있고 r1 행에 대한 배타적(X) 잠금을 얻으려고 대기 중입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-914">Transaction T2 has a shared (S) lock on r2 and is waiting to get an exclusive (X) lock on row r1.</span></span> <span data-ttu-id="9951f-915">이 경우 T1과 T2가 서로 잠근 리소스를 해제할 때까지 대기하는 잠금 순환이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-915">This results in a lock cycle in which T1 and T2 wait for each other to release the locked resources.</span></span>  
  
-   <span data-ttu-id="9951f-916">**작업자 스레드**.</span><span class="sxs-lookup"><span data-stu-id="9951f-916">**Worker threads**.</span></span> <span data-ttu-id="9951f-917">사용 가능한 작업자 스레드를 대기하는 태스크가 교착 상태를 일으킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-917">A queued task waiting for an available worker thread can cause deadlock.</span></span> <span data-ttu-id="9951f-918">대기 태스크가 모든 작업자 스레드를 차단하는 리소스를 소유하는 경우 교착 상태가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-918">If the queued task owns resources that are blocking all worker threads, a deadlock will result.</span></span> <span data-ttu-id="9951f-919">예를 들어 세션 S1이 트랜잭션을 시작하고 r1 행에 대한 공유(S) 잠금을 획득한 후 중지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-919">For example, session S1 starts a transaction and acquires a shared (S) lock on row r1 and then goes to sleep.</span></span> <span data-ttu-id="9951f-920">사용 가능한 모든 작업자 스레드에서 실행 중인 활성 세션이 r1 행에 대한 배타적(X) 잠금을 획득하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-920">Active sessions running on all available worker threads are trying to acquire exclusive (X) locks on row r1.</span></span> <span data-ttu-id="9951f-921">세션 S1이 작업자 스레드를 획득할 수 없으므로 트랜잭션을 커밋할 수 없고 r1 행에 대한 잠금을 해제하지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-921">Because session S1 cannot acquire a worker thread, it cannot commit the transaction and release the lock on row r1.</span></span> <span data-ttu-id="9951f-922">이로 인해 교착 상태가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-922">This results in a deadlock.</span></span>  
  
-   <span data-ttu-id="9951f-923">**메모리**.</span><span class="sxs-lookup"><span data-stu-id="9951f-923">**Memory**.</span></span> <span data-ttu-id="9951f-924">동시 요청이 사용 가능한 메모리보다 많은 메모리 부여를 대기하는 경우 교착 상태가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-924">When concurrent requests are waiting for memory grants that cannot be satisfied with the available memory, a deadlock can occur.</span></span> <span data-ttu-id="9951f-925">예를 들어 두 개의 동시 쿼리 Q1과 Q2가 각각 10MB와 20MB의 메모리를 획득하는 사용자 정의 함수를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-925">For example, two concurrent queries, Q1 and Q2, execute as user-defined functions that acquire 10MB and 20MB of memory respectively.</span></span> <span data-ttu-id="9951f-926">각 쿼리에 30MB가 필요하고 사용 가능한 총 메모리는 20MB인 경우 Q1과 Q2는 서로 메모리를 해제할 때까지 대기해야 하며 이로 인해 교착 상태가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-926">If each query needs 30MB and the total available memory is 20MB, then Q1 and Q2 must wait for each other to release memory, and this results in a deadlock.</span></span>  
  
-   <span data-ttu-id="9951f-927">**병렬 쿼리 실행 관련 리소스**. 교환 포트와 관련된 코디네이터, 제작자 및 소비자 스레드는 대개 병렬 쿼리에 속하지 않는 하나 이상의 다른 프로세스를 포함할 경우 서로 차단하여 교착 상태를 일으킵니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-927">**Parallel query execution-related resources** Coordinator, producer, or consumer threads associated with an exchange port may block each other causing a deadlock usually when including at least one other process that is not a part of the parallel query.</span></span> <span data-ttu-id="9951f-928">또한 병렬 쿼리 실행을 시작할 때 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]는 현재 작업을 기반으로 병렬 처리 수준, 즉 작업자 스레드 수를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-928">Also, when a parallel query starts execution, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] determines the degree of parallelism, or the number of worker threads, based upon the current workload.</span></span> <span data-ttu-id="9951f-929">예를 들어 서버에서 새 쿼리 실행이 시작되거나 시스템에 작업자 스레드가 부족하여 시스템 작업이 예기치 않게 변경되면 교착 상태가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-929">If the system workload unexpectedly changes, for example, where new queries start running on the server or the system runs out of worker threads, then a deadlock could occur.</span></span>  
  
-   <span data-ttu-id="9951f-930">**MARS(Multiple Active Result Sets) 리소스**.</span><span class="sxs-lookup"><span data-stu-id="9951f-930">**Multiple Active Result Sets (MARS) resources**.</span></span> <span data-ttu-id="9951f-931">MARS 리소스는 MARS에서 여러 활성 요청의 인터리브를 제어하는 데 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-931">These resources are used to control interleaving of multiple active requests under MARS.</span></span> <span data-ttu-id="9951f-932">자세한 내용은 [SQL Server에서 MARS (Multiple Active Result Sets)](https://msdn.microsoft.com/library/ms345109(v=SQL.90).aspx)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-932">For more information, see [Multiple Active Result Sets (MARS) in SQL Server](https://msdn.microsoft.com/library/ms345109(v=SQL.90).aspx).</span></span>  
  
    -   <span data-ttu-id="9951f-933">**사용자 리소스**.</span><span class="sxs-lookup"><span data-stu-id="9951f-933">**User resource**.</span></span> <span data-ttu-id="9951f-934">스레드가 사용자 애플리케이션에서 제어하는 리소스를 대기할 때 해당 리소스는 외부 또는 사용자 리소스로 간주되고 잠금처럼 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-934">When a thread is waiting for a resource that is potentially controlled by a user application, the resource is considered to be an external or user resource and is treated like a lock.</span></span>  
  
    -   <span data-ttu-id="9951f-935">**세션 뮤텍스**.</span><span class="sxs-lookup"><span data-stu-id="9951f-935">**Session mutex**.</span></span> <span data-ttu-id="9951f-936">한 세션에서 실행되고 있는 태스크가 인터리브됩니다. 이는 세션에서 한 태스크만 실행할 수 있음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-936">The tasks running in one session are interleaved, meaning that only one task can run under the session at a given time.</span></span> <span data-ttu-id="9951f-937">세션 뮤텍스를 배타적으로 사용할 수 있어야 태스크가 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-937">Before the task can run, it must have exclusive access to the session mutex.</span></span>  
  
    -   <span data-ttu-id="9951f-938">**트랜잭션 뮤텍스**.</span><span class="sxs-lookup"><span data-stu-id="9951f-938">**Transaction mutex**.</span></span> <span data-ttu-id="9951f-939">한 트랜잭션에서 실행되고 있는 가 인터리브됩니다. 이는 트랜잭션에서 한 태스크만 실행할 수 있음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-939">All tasks running in one transaction are interleaved, meaning that only one task can run under the transaction at a given time.</span></span> <span data-ttu-id="9951f-940">트랜잭션 뮤텍스를 배타적으로 사용할 수 있어야 태스크가 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-940">Before the task can run, it must have exclusive access to the transaction mutex.</span></span>  
  
     <span data-ttu-id="9951f-941">MARS에서 태스크가 빠르게 실행되려면 태스크가 세션 뮤텍스를 획득해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-941">In order for a task to run under MARS, it must acquire the session mutex.</span></span> <span data-ttu-id="9951f-942">태스크가 트랜잭션에서 실행되고 있는 경우에는 트랜잭션 뮤텍스를 획득해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-942">If the task is running under a transaction, it must then acquire the transaction mutex.</span></span> <span data-ttu-id="9951f-943">이를 통해 지정된 세션과 지정된 트랜잭션에서 한 번에 한 태스크만 활성화되도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-943">This guarantees that only one task is active at one time in a given session and a given transaction.</span></span> <span data-ttu-id="9951f-944">필요한 뮤텍스가 획득되면 태스크가 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-944">Once the required mutexes have been acquired, the task can execute.</span></span> <span data-ttu-id="9951f-945">태스크가 완료되거나 요청 중간에 취소되면 태스크는 뮤텍스를 획득할 때와는 반대의 순서로 먼저 트랜잭션 뮤텍스를 해제하고 세션 뮤텍스를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-945">When the task finishes, or yields in the middle of the request, it will first release transaction mutex followed by the session mutex in reverse order of acquisition.</span></span> <span data-ttu-id="9951f-946">그러나 이러한 리소스에서 교착 상태가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-946">However, deadlocks can occur with these resources.</span></span> <span data-ttu-id="9951f-947">다음 코드 예제에서는 사용자 요청 U1과 사용자 요청 U2라는 두 태스크가 같은 세션에서 실행되고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-947">In the following code example, two tasks, user request U1 and user request U2, are running in the same session.</span></span>  
  
    ```  
    U1:    Rs1=Command1.Execute("insert sometable EXEC usp_someproc");  
    U2:    Rs2=Command2.Execute("select colA from sometable");  
    ```  
  
     <span data-ttu-id="9951f-948">사용자 요청 U1에서 실행되는 저장 프로시저가 세션 뮤텍스를 획득합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-948">The stored procedure executing from user request U1 has acquired the session mutex.</span></span> <span data-ttu-id="9951f-949">저장 프로시저를 실행하는 데 시간이 오래 걸리면 [!INCLUDE[ssDE](../includes/ssde-md.md)]은 저장 프로시저가 사용자 입력을 대기하고 있는 것으로 간주합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-949">If the stored procedure takes a long time to execute, it is assumed by the [!INCLUDE[ssDE](../includes/ssde-md.md)] that the stored procedure is waiting for input from the user.</span></span> <span data-ttu-id="9951f-950">사용자가 사용자 요청 U2의 결과 집합을 대기하는 동안 U2는 세션 뮤텍스를 대기하고 U1은 사용자 리소스를 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-950">User request U2 is waiting for the session mutex while the user is waiting for the result set from U2, and U1 is waiting for a user resource.</span></span> <span data-ttu-id="9951f-951">다음 그림에서는 이 교착 상태를 논리적으로 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-951">This is deadlock state logically illustrated as:</span></span>  
  
 <span data-ttu-id="9951f-952">![사용자 프로세스 교착 상태를 보여 주는 논리 다이어그램](media/udb9-logicflowexamplec.gif "사용자 프로세스 교착 상태를 보여 주는 논리 다이어그램")</span><span class="sxs-lookup"><span data-stu-id="9951f-952">![Logic diagram showing user process deadlock.](media/udb9-logicflowexamplec.gif "Logic diagram showing user process deadlock.")</span></span>  
  
##### <a name="deadlock-detection"></a><span data-ttu-id="9951f-953">교착 상태 검색</span><span class="sxs-lookup"><span data-stu-id="9951f-953">Deadlock Detection</span></span>  

 <span data-ttu-id="9951f-954">위의 섹션에서 나열한 리소스는 모두 [!INCLUDE[ssDE](../includes/ssde-md.md)] 교착 상태 검색 스키마에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-954">All of the resources listed in the section above participate in the [!INCLUDE[ssDE](../includes/ssde-md.md)] deadlock detection scheme.</span></span> <span data-ttu-id="9951f-955">교착 상태 검색은 [!INCLUDE[ssDE](../includes/ssde-md.md)] 인스턴스의 모든 태스크에 대한 검색을 주기적으로 시작하는 잠금 모니터에서 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-955">Deadlock detection is performed by a lock monitor thread that periodically initiates a search through all of the tasks in an instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)].</span></span> <span data-ttu-id="9951f-956">다음은 검색 프로세스에 대한 설명입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-956">The following points describe the search process:</span></span>  
  
-   <span data-ttu-id="9951f-957">기본 간격은 5초입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-957">The default interval is 5 seconds.</span></span>  
  
-   <span data-ttu-id="9951f-958">잠금 모니터 스레드가 교착 상태를 발견하면 잠금 상태의 빈도에 따라 5초에서 최하 100밀리초까지 교착 상태 검색 간격이 짧아집니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-958">If the lock monitor thread finds deadlocks, the deadlock detection interval will drop from 5 seconds to as low as 100 milliseconds depending on the frequency of deadlocks.</span></span>  
  
-   <span data-ttu-id="9951f-959">잠금 모니터 스레드가 교착 상태 검색을 중지하면 [!INCLUDE[ssDE](../includes/ssde-md.md)]은 검색 간격을 5초로 늘립니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-959">If the lock monitor thread stops finding deadlocks, the [!INCLUDE[ssDE](../includes/ssde-md.md)] increases the intervals between searches to 5 seconds.</span></span>  
  
-   <span data-ttu-id="9951f-960">교착 상태가 검색되면 잠금을 대기해야 하는 다음 스레드가 교착 상태 순환에 들어가는 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-960">If a deadlock has just been detected, it is assumed that the next threads that must wait for a lock are entering the deadlock cycle.</span></span> <span data-ttu-id="9951f-961">교착 상태 검색 후 처음 두 번의 잠금 대기에서 다음 교착 상태 검색 간격을 대기하지 않고 교착 상태 검색을 즉시 트리거합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-961">The first couple of lock waits after a deadlock has been detected will immediately trigger a deadlock search rather than wait for the next deadlock detection interval.</span></span> <span data-ttu-id="9951f-962">예를 들어 현재 간격이 5초일 경우 교착 상태가 검색되면 다음 잠금 대기에서 교착 상태 검색기를 즉시 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-962">For example, if the current interval is 5 seconds, and a deadlock was just detected, the next lock wait will kick off the deadlock detector immediately.</span></span> <span data-ttu-id="9951f-963">교착 상태에 속할 경우 이 잠금 대기는 다음 교착 상태 검색 전에 바로 검색됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-963">If this lock wait is part of a deadlock, it will be detected right away rather than during next deadlock search.</span></span>  
  
 <span data-ttu-id="9951f-964">일반적으로 [!INCLUDE[ssDE](../includes/ssde-md.md)]은 주기적인 교착 상태 검색만 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-964">The [!INCLUDE[ssDE](../includes/ssde-md.md)] typically performs periodic deadlock detection only.</span></span> <span data-ttu-id="9951f-965">시스템에서 발생하는 교착 상태 수는 대개 적으므로 주기적인 교착 상태 검색을 통해 시스템의 교착 상태 검색 오버헤드를 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-965">Because the number of deadlocks encountered in the system is usually small, periodic deadlock detection helps to reduce the overhead of deadlock detection in the system.</span></span>  
  
 <span data-ttu-id="9951f-966">특정 스레드에 대해 교착 상태 검색을 시작할 때 잠금 모니터는 스레드가 대기하고 있는 리소스를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-966">When the lock monitor initiates deadlock search for a particular thread, it identifies the resource on which the thread is waiting.</span></span> <span data-ttu-id="9951f-967">그런 다음 잠금 모니터는 해당 리소스의 소유자를 찾은 후 순환을 발견할 때까지 이러한 스레드에 대한 교착 상태 검색을 반복적으로 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-967">The lock monitor then finds the owner(s) for that particular resource and recursively continues the deadlock search for those threads until it finds a cycle.</span></span> <span data-ttu-id="9951f-968">이러한 방법을 통해 확인된 순환으로 교착 상태가 일어납니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-968">A cycle identified in this manner forms a deadlock.</span></span>  
  
 <span data-ttu-id="9951f-969">교착 상태가 검색되면 [!INCLUDE[ssDE](../includes/ssde-md.md)]은 교착 상태에 있는 스레드 중 처리하지 않을 스레드를 하나 선택하여 교착 상태를 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-969">After a deadlock is detected, the [!INCLUDE[ssDE](../includes/ssde-md.md)] ends a deadlock by choosing one of the threads as a deadlock victim.</span></span> <span data-ttu-id="9951f-970">[!INCLUDE[ssDE](../includes/ssde-md.md)]은 스레드에 대해 실행되고 있는 현재 일괄 처리를 종료하고 해당 트랜잭션을 롤백한 후 애플리케이션에 1205 오류를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-970">The [!INCLUDE[ssDE](../includes/ssde-md.md)] terminates the current batch being executed for the thread, rolls back the transaction of the deadlock victim, and returns a 1205 error to the application.</span></span> <span data-ttu-id="9951f-971">처리하지 않도록 선택된 스레드의 트랜잭션이 롤백되면 이 트랜잭션에서 보유하는 모든 잠금이 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-971">Rolling back the transaction for the deadlock victim releases all locks held by the transaction.</span></span> <span data-ttu-id="9951f-972">이를 통해 다른 스레드의 트랜잭션이 차단 해제되고 계속됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-972">This allows the transactions of the other threads to become unblocked and continue.</span></span> <span data-ttu-id="9951f-973">1205 교착 상태 미처리 오류는 교착 상태와 관련된 스레드와 리소스에 대한 정보를 오류 로그에 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-973">The 1205 deadlock victim error records information about the threads and resources involved in a deadlock in the error log.</span></span>  
  
 <span data-ttu-id="9951f-974">기본적으로 [!INCLUDE[ssDE](../includes/ssde-md.md)]은 롤백 비용이 가장 저렴한 트랜잭션을 실행하는 세션을 처리하지 않도록 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-974">By default, the [!INCLUDE[ssDE](../includes/ssde-md.md)] chooses as the deadlock victim the session running the transaction that is least expensive to roll back.</span></span> <span data-ttu-id="9951f-975">또는 사용자가 SET DEADLOCK_PRIORITY 문을 사용하여 교착 상태에 있는 세션의 우선 순위를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-975">Alternatively, a user can specify the priority of sessions in a deadlock situation using the SET DEADLOCK_PRIORITY statement.</span></span> <span data-ttu-id="9951f-976">DEADLOCK_PRIORITY를 LOW, NORMAL 또는 HIGH로 설정하거나 -10에서 10 사이의 정수 값으로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-976">DEADLOCK_PRIORITY can be set to LOW, NORMAL, or HIGH, or alternatively can be set to any integer value in the range (-10 to 10).</span></span> <span data-ttu-id="9951f-977">교착 상태 우선 순위는 기본적으로 NORMAL입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-977">The deadlock priority defaults to NORMAL.</span></span> <span data-ttu-id="9951f-978">두 세션의 교착 상태 우선 순위가 다르면 교착 상태 우선 순위가 낮은 세션이 처리하지 않을 세션으로 선택됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-978">If two sessions have different deadlock priorities, the session with the lower priority is chosen as the deadlock victim.</span></span> <span data-ttu-id="9951f-979">두 세션의 교착 상태 우선 순위가 같으면 롤백 비용이 가장 저렴한 트랜잭션의 세션이 선택됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-979">If both sessions have the same deadlock priority, the session with the transaction that is least expensive to roll back is chosen.</span></span> <span data-ttu-id="9951f-980">교착 상태 순환과 관련된 세션의 교착 상태 우선 순위와 비용이 같으면 임의의 세션이 선택됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-980">If sessions involved in the deadlock cycle have the same deadlock priority and the same cost, a victim is chosen randomly.</span></span>  
  
 <span data-ttu-id="9951f-981">CLR를 사용할 경우 교착 상태 모니터는 관리 프로시저 내부에서 액세스하는 모니터, 판독기/기록기 잠금, 스레드 조인 등의 동기화 리소스에 대한 교착 상태를 자동으로 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-981">When working with CLR, the deadlock monitor automatically detects deadlock for synchronization resources (monitors, reader/writer lock and thread join) accessed inside managed procedures.</span></span> <span data-ttu-id="9951f-982">그러나 처리하지 않도록 선택된 프로시저에서 예외가 발생하면 교착 상태가 해결됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-982">However, the deadlock is resolved by throwing an exception in the procedure that was selected to be the deadlock victim.</span></span> <span data-ttu-id="9951f-983">처리하지 않도록 선택된 프로시저에서 현재 소유하고 있는 리소스가 예외를 통해 자동으로 해제되지는 않습니다. 리소스는 명시적으로 해제해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-983">It is important to understand that the exception does not automatically release resources currently owned by the victim; the resources must be explicitly released.</span></span> <span data-ttu-id="9951f-984">예외 동작에 따라 처리하지 않도록 선택된 프로시저를 확인하는 데 사용되는 예외를 찾아 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-984">Consistent with exception behavior, the exception used to identify a deadlock victim can be caught and dismissed.</span></span>  
  
##### <a name="deadlock-information-tools"></a><span data-ttu-id="9951f-985">교착 상태 정보 도구</span><span class="sxs-lookup"><span data-stu-id="9951f-985">Deadlock Information Tools</span></span>  

 <span data-ttu-id="9951f-986">교착 상태 정보를 표시하기 위해 [!INCLUDE[ssDE](../includes/ssde-md.md)]은 [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)]에서 교착 상태 그래프 이벤트와 두 개의 추적 플래그 형식으로 모니터링 도구를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-986">To view deadlock information, the [!INCLUDE[ssDE](../includes/ssde-md.md)] provides monitoring tools in the form of two trace flags, and the deadlock graph event in [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)].</span></span>  
  
###### <a name="trace-flag-1204-and-trace-flag-1222"></a><span data-ttu-id="9951f-987">추적 플래그 1204 및 추적 플래그 1222</span><span class="sxs-lookup"><span data-stu-id="9951f-987">Trace Flag 1204 and Trace Flag 1222</span></span>  

 <span data-ttu-id="9951f-988">교착 상태가 발생하면 추적 플래그 1204와 추적 플래그 1222는 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 오류 로그에 캡처된 정보를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-988">When deadlocks occur, trace flag 1204 and trace flag 1222 return information that is captured in the [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] error log.</span></span> <span data-ttu-id="9951f-989">추적 플래그 1204는 교착 상태와 관련된 각 노드에 의해 형식이 지정된 교착 상태 정보를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-989">Trace flag 1204 reports deadlock information formatted by each node involved in the deadlock.</span></span> <span data-ttu-id="9951f-990">추적 플래그 1222는 프로세스별 및 리소스별 순서로 교착 상태 정보의 형식을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-990">Trace flag 1222 formats deadlock information, first by processes and then by resources.</span></span> <span data-ttu-id="9951f-991">두 추적 플래그에서 동일한 교착 상태 이벤트의 두 가지 표현을 가져오도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-991">It is possible to enable both trace flags to obtain two representations of the same deadlock event.</span></span>  
  
 <span data-ttu-id="9951f-992">다음 표에서는 추적 플래그 1204 및 1222의 속성 정의 외에도 두 추적 플래그의 유사점과 차이점을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-992">In addition to defining the properties of trace flag 1204 and 1222, the following table also shows the similarities and differences.</span></span>  
  
|<span data-ttu-id="9951f-993">속성</span><span class="sxs-lookup"><span data-stu-id="9951f-993">Property</span></span>|<span data-ttu-id="9951f-994">추적 플래그 1204 및 추적 플래그 1222</span><span class="sxs-lookup"><span data-stu-id="9951f-994">Trace Flag 1204 and Trace Flag 1222</span></span>|<span data-ttu-id="9951f-995">추적 플래그 1204만 해당</span><span class="sxs-lookup"><span data-stu-id="9951f-995">Trace Flag 1204 only</span></span>|<span data-ttu-id="9951f-996">추적 플래그 1222만 해당</span><span class="sxs-lookup"><span data-stu-id="9951f-996">Trace Flag 1222 only</span></span>|  
|--------------|-----------------------------------------|--------------------------|--------------------------|  
|<span data-ttu-id="9951f-997">출력 형식</span><span class="sxs-lookup"><span data-stu-id="9951f-997">Output format</span></span>|<span data-ttu-id="9951f-998">[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 오류 로그에 출력이 캡처됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-998">Output is captured in the [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] error log.</span></span>|<span data-ttu-id="9951f-999">교착 상태와 관련된 노드에 초점을 둡니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-999">Focused on the nodes involved in the deadlock.</span></span> <span data-ttu-id="9951f-1000">각 노드에 해당하는 섹션이 있으며 마지막 섹션에서 교착 상태에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1000">Each node has a dedicated section, and the final section describes the deadlock victim.</span></span>|<span data-ttu-id="9951f-1001">XSD(XML 스키마 정의) 스키마를 따르지 않는 XML과 유사한 형식으로 정보를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1001">Returns information in an XML-like format that does not conform to an XML Schema Definition (XSD) schema.</span></span> <span data-ttu-id="9951f-1002">형식은 3가지 주요 섹션으로 이루어져 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1002">The format has three major sections.</span></span> <span data-ttu-id="9951f-1003">첫 번째 섹션에서는 교착 상태를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1003">The first section declares the deadlock victim.</span></span> <span data-ttu-id="9951f-1004">두 번째 섹션에서는 교착 상태와 관련된 각 프로세스에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1004">The second section describes each process involved in the deadlock.</span></span> <span data-ttu-id="9951f-1005">세 번째 섹션에서는 추적 플래그 1204의 노드와 같은 리소스에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1005">The third section describes the resources that are synonymous with nodes in trace flag 1204.</span></span>|  
|<span data-ttu-id="9951f-1006">식별 특성</span><span class="sxs-lookup"><span data-stu-id="9951f-1006">Identifying attributes</span></span>|<span data-ttu-id="9951f-1007">**SPID: \<x> ECID: \<x> .**</span><span class="sxs-lookup"><span data-stu-id="9951f-1007">**SPID:\<x> ECID:\<x>.**</span></span> <span data-ttu-id="9951f-1008">병렬 프로세스의 경우 시스템 프로세스 ID 스레드를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1008">Identifies the system process ID thread in cases of parallel processes.</span></span> <span data-ttu-id="9951f-1009">`SPID:<x> ECID:0` \<x> 는 SPID 값으로 대체 되는 항목으로, 주 스레드를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1009">The entry `SPID:<x> ECID:0`, where \<x> is replaced by the SPID value, represents the main thread.</span></span> <span data-ttu-id="9951f-1010">항목이 `SPID:<x> ECID:<y>` \<x> spid 값으로 바뀌고가 \<y> 0 보다 큰 항목은 동일한 spid의 하위 스레드를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1010">The entry `SPID:<x> ECID:<y>`, where \<x> is replaced by the SPID value and \<y> is greater than 0, represents the sub-threads for the same SPID.</span></span><br /><br /> <span data-ttu-id="9951f-1011">**BatchID**(추적 플래그 1222의 경우 **sbid**).</span><span class="sxs-lookup"><span data-stu-id="9951f-1011">**BatchID** (**sbid** for trace flag 1222).</span></span> <span data-ttu-id="9951f-1012">잠금을 요청하거나 보유하고 있는 코드 실행이 속한 일괄 처리를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1012">Identifies the batch from which code execution is requesting or holding a lock.</span></span> <span data-ttu-id="9951f-1013">MARS(Multiple Active Result Sets)가 해제되어 있으면 BatchID 값은 0입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1013">When Multiple Active Result Sets (MARS) is disabled, the BatchID value is 0.</span></span> <span data-ttu-id="9951f-1014">MARS가 설정되어 있으면 활성 일괄 처리 값은 1에서 *n* 사이입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1014">When MARS is enabled, the value for active batches is 1 to *n*.</span></span> <span data-ttu-id="9951f-1015">세션에 활성 일괄 처리가 없는 경우 BatchID는 0입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1015">If there are no active batches in the session, BatchID is 0.</span></span><br /><br /> <span data-ttu-id="9951f-1016">**모드**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1016">**Mode**.</span></span> <span data-ttu-id="9951f-1017">스레드가 요청, 부여 또는 대기한 특정 리소스에 대한 잠금 유형을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1017">Specifies the type of lock for a particular resource that is requested, granted, or waited on by a thread.</span></span> <span data-ttu-id="9951f-1018">Mode는 IS(내재된 공유), S(공유), U(업데이트), IX(의도 배타), SIX(의도 배타 공유) 및 X(배타)가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1018">Mode can be IS (Intent Shared), S (Shared), U (Update), IX (Intent Exclusive), SIX (Shared with Intent Exclusive), and X (Exclusive).</span></span><br /><br /> <span data-ttu-id="9951f-1019">**Line #** (추적 플래그 1222의 경우 **line**).</span><span class="sxs-lookup"><span data-stu-id="9951f-1019">**Line #** (**line** for trace flag 1222).</span></span> <span data-ttu-id="9951f-1020">현재 문 일괄 처리에서 교착 상태 발생 시 실행 중이었던 줄 번호를 나열합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1020">Lists the line number in the current batch of statements that was being executed when the deadlock occurred.</span></span><br /><br /> <span data-ttu-id="9951f-1021">**Input Buf** (추적 플래그 1222의 경우 **inputbuf**).</span><span class="sxs-lookup"><span data-stu-id="9951f-1021">**Input Buf** (**inputbuf** for trace flag 1222).</span></span> <span data-ttu-id="9951f-1022">현재 일괄 처리에 있는 모든 문을 나열합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1022">Lists all the statements in the current batch.</span></span>|<span data-ttu-id="9951f-1023">**노드**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1023">**Node**.</span></span> <span data-ttu-id="9951f-1024">교착 상태 체인에서 항목 번호를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1024">Represents the entry number in the deadlock chain.</span></span><br /><br /> <span data-ttu-id="9951f-1025">**목록**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1025">**Lists**.</span></span> <span data-ttu-id="9951f-1026">잠금 소유자는 다음 목록에 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1026">The lock owner can be part of these lists:</span></span><br /><br /> <span data-ttu-id="9951f-1027">**Grant List**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1027">**Grant List**.</span></span> <span data-ttu-id="9951f-1028">리소스의 현재 소유자를 열거합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1028">Enumerates the current owners of the resource.</span></span><br /><br /> <span data-ttu-id="9951f-1029">**Convert List**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1029">**Convert List**.</span></span> <span data-ttu-id="9951f-1030">잠금을 더 높은 수준으로 변환 중인 현재 소유자를 열거합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1030">Enumerates the current owners that are trying to convert their locks to a higher level.</span></span><br /><br /> <span data-ttu-id="9951f-1031">**Wait List**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1031">**Wait List**.</span></span> <span data-ttu-id="9951f-1032">리소스에 대한 현재 새 잠금 요청을 열거합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1032">Enumerates current new lock requests for the resource.</span></span><br /><br /> <span data-ttu-id="9951f-1033">**Statement Type**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1033">**Statement Type**.</span></span> <span data-ttu-id="9951f-1034">스레드에 사용 권한이 있는 DML 문의 유형(SELECT, INSERT, UPDATE 또는 DELETE)에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1034">Describes the type of DML statement (SELECT, INSERT, UPDATE, or DELETE) on which the threads have permissions.</span></span><br /><br /> <span data-ttu-id="9951f-1035">**Victim Resource Owner**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1035">**Victim Resource Owner**.</span></span> <span data-ttu-id="9951f-1036">[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]에서 교착 상태 순환을 끊도록 선택되는 참여하는 스레드를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1036">Specifies the participating thread that [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] chooses as the victim to break the deadlock cycle.</span></span> <span data-ttu-id="9951f-1037">선택된 스레드와 기존의 모든 하위 스레드가 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1037">The chosen thread and all existing sub-threads are terminated.</span></span><br /><br /> <span data-ttu-id="9951f-1038">**Next Branch**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1038">**Next Branch**.</span></span> <span data-ttu-id="9951f-1039">교착 상태 순환과 관련된 동일한 SPID의 하위 스레드 두 개 이상을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1039">Represents the two or more sub-threads from the same SPID that are involved in the deadlock cycle.</span></span>|<span data-ttu-id="9951f-1040">**deadlock victim**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1040">**deadlock victim**.</span></span> <span data-ttu-id="9951f-1041">교착 상태에 있는 태스크 중 처리하지 않도록 선택된 태스크의 실제 메모리 주소를 나타냅니다. [sys.dm_os_tasks&#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-os-tasks-transact-sql)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="9951f-1041">Represents the physical memory address of the task (see [sys.dm_os_tasks &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-os-tasks-transact-sql)) that was selected as a deadlock victim.</span></span> <span data-ttu-id="9951f-1042">해결되지 않은 교착 상태의 경우 이 속성이 0일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1042">It may be 0 (zero) in the case of an unresolved deadlock.</span></span> <span data-ttu-id="9951f-1043">롤백하고 있는 태스크를 처리하지 않도록 선택할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1043">A task that is rolling back cannot be chosen as a deadlock victim.</span></span><br /><br /> <span data-ttu-id="9951f-1044">**executionstack**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1044">**executionstack**.</span></span> <span data-ttu-id="9951f-1045">교착 상태 발생 시 실행 중인 [!INCLUDE[tsql](../includes/tsql-md.md)] 코드를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1045">Represents [!INCLUDE[tsql](../includes/tsql-md.md)] code that is being executed at the time the deadlock occurs.</span></span><br /><br /> <span data-ttu-id="9951f-1046">**priority**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1046">**priority**.</span></span> <span data-ttu-id="9951f-1047">교착 상태 우선 순위를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1047">Represents deadlock priority.</span></span> <span data-ttu-id="9951f-1048">특정 경우에 동시성 향상을 위해 [!INCLUDE[ssDE](../includes/ssde-md.md)]에서 잠시 교착 상태 우선 순위를 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1048">In certain cases, the [!INCLUDE[ssDE](../includes/ssde-md.md)] may opt to alter the deadlock priority for a short duration to achieve better concurrency.</span></span><br /><br /> <span data-ttu-id="9951f-1049">**logused**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1049">**logused**.</span></span> <span data-ttu-id="9951f-1050">태스크에서 사용하는 로그 공간입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1050">Log space used by the task.</span></span><br /><br /> <span data-ttu-id="9951f-1051">**소유자 ID**. 요청을 제어하는 트랜잭션의 ID입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1051">**owner id**. The ID of the transaction that has control of the request.</span></span><br /><br /> <span data-ttu-id="9951f-1052">**상태**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1052">**status**.</span></span> <span data-ttu-id="9951f-1053">태스크의 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1053">State of the task.</span></span> <span data-ttu-id="9951f-1054">다음 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1054">It is one of the following values:</span></span><br /><br /> <span data-ttu-id="9951f-1055">>> **보류 중**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1055">>> **pending**.</span></span> <span data-ttu-id="9951f-1056">작업자 스레드 대기 중입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1056">Waiting for a worker thread.</span></span><br /><br /> <span data-ttu-id="9951f-1057">>> **실행 가능**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1057">>> **runnable**.</span></span> <span data-ttu-id="9951f-1058">실행 준비가 완료되었지만 퀀텀 대기 중입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1058">Ready to run but waiting for a quantum.</span></span><br /><br /> <span data-ttu-id="9951f-1059">>> **실행**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1059">>> **running**.</span></span> <span data-ttu-id="9951f-1060">현재 스케줄러에서 실행 중입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1060">Currently running on the scheduler.</span></span><br /><br /> <span data-ttu-id="9951f-1061">>> **일시 중지됨**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1061">>> **suspended**.</span></span> <span data-ttu-id="9951f-1062">실행이 일시 중지되었습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1062">Execution is suspended.</span></span><br /><br /> <span data-ttu-id="9951f-1063">>> **완료**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1063">>> **done**.</span></span> <span data-ttu-id="9951f-1064">태스크가 완료되었습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1064">Task has completed.</span></span><br /><br /> <span data-ttu-id="9951f-1065">>> **spinloop**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1065">>> **spinloop**.</span></span> <span data-ttu-id="9951f-1066">spinlock이 사용 가능할 때까지 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1066">Waiting for a spinlock to become free.</span></span><br /><br /> <span data-ttu-id="9951f-1067">**waitresource**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1067">**waitresource**.</span></span> <span data-ttu-id="9951f-1068">태스크에 필요한 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1068">The resource needed by the task.</span></span><br /><br /> <span data-ttu-id="9951f-1069">**waittime**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1069">**waittime**.</span></span> <span data-ttu-id="9951f-1070">리소스 대기 시간(밀리초)입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1070">Time in milliseconds waiting for the resource.</span></span><br /><br /> <span data-ttu-id="9951f-1071">**schedulerid**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1071">**schedulerid**.</span></span> <span data-ttu-id="9951f-1072">이 태스크와 관련된 스케줄러입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1072">Scheduler associated with this task.</span></span> <span data-ttu-id="9951f-1073">[sys.dm_os_schedulers&#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-os-schedulers-transact-sql) 참조.</span><span class="sxs-lookup"><span data-stu-id="9951f-1073">See [sys.dm_os_schedulers &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-os-schedulers-transact-sql).</span></span><br /><br /> <span data-ttu-id="9951f-1074">**hostname**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1074">**hostname**.</span></span> <span data-ttu-id="9951f-1075">워크스테이션의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1075">The name of the workstation.</span></span><br /><br /> <span data-ttu-id="9951f-1076">**isolationlevel**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1076">**isolationlevel**.</span></span> <span data-ttu-id="9951f-1077">현재 트랜잭션 격리 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1077">The current transaction isolation level.</span></span><br /><br /> <span data-ttu-id="9951f-1078">**Xactid**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1078">**Xactid**.</span></span> <span data-ttu-id="9951f-1079">요청을 제어하는 트랜잭션의 ID입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1079">The ID of the transaction that has control of the request.</span></span><br /><br /> <span data-ttu-id="9951f-1080">**currentdb**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1080">**currentdb**.</span></span> <span data-ttu-id="9951f-1081">데이터베이스의 ID입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1081">The ID of the database.</span></span><br /><br /> <span data-ttu-id="9951f-1082">**lastbatchstarted**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1082">**lastbatchstarted**.</span></span> <span data-ttu-id="9951f-1083">클라이언트 프로세스에서 일괄 처리 실행을 마지막으로 시작한 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1083">The last time a client process started batch execution.</span></span><br /><br /> <span data-ttu-id="9951f-1084">**lastbatchcompleted**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1084">**lastbatchcompleted**.</span></span> <span data-ttu-id="9951f-1085">클라이언트 프로세스에서 일괄 처리 실행을 마지막으로 완료한 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1085">The last time a client process completed batch execution.</span></span><br /><br /> <span data-ttu-id="9951f-1086">**clientoption1 및 clientoption2**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1086">**clientoption1 and clientoption2**.</span></span> <span data-ttu-id="9951f-1087">이 클라이언트 연결의 옵션을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1087">Set options on this client connection.</span></span> <span data-ttu-id="9951f-1088">대개 SET NOCOUNT와 SET XACTABORT 등의 SET 문으로 제어하는 옵션에 대한 정보가 포함된 비트 마스크입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1088">This is a bitmask that includes information about options usually controlled by SET statements such as SET NOCOUNT and SET XACTABORT.</span></span><br /><br /> <span data-ttu-id="9951f-1089">**associatedObjectId**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1089">**associatedObjectId**.</span></span> <span data-ttu-id="9951f-1090">HoBT(힙 또는 B-트리) ID를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1090">Represents the HoBT (heap or b-tree) ID.</span></span>|  
|<span data-ttu-id="9951f-1091">리소스 특성</span><span class="sxs-lookup"><span data-stu-id="9951f-1091">Resource attributes</span></span>|<span data-ttu-id="9951f-1092">**RID**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1092">**RID**.</span></span> <span data-ttu-id="9951f-1093">잠금이 보유 또는 요청된 테이블 내의 단일 행을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1093">Identifies the single row within a table on which a lock is held or requested.</span></span> <span data-ttu-id="9951f-1094">RID는 RID로 표시됩니다. *db_id:file_id:page_no:row_no*.</span><span class="sxs-lookup"><span data-stu-id="9951f-1094">RID is represented as RID: *db_id:file_id:page_no:row_no*.</span></span> <span data-ttu-id="9951f-1095">예들 들어 `RID: 6:1:20789:0`입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1095">For example, `RID: 6:1:20789:0`.</span></span><br /><br /> <span data-ttu-id="9951f-1096">**OBJECT**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1096">**OBJECT**.</span></span> <span data-ttu-id="9951f-1097">잠금이 보유 또는 요청된 테이블을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1097">Identifies the table on which a lock is held or requested.</span></span> <span data-ttu-id="9951f-1098">OBJECT는 OBJECT로 표시됩니다. *db_id:object_id*.</span><span class="sxs-lookup"><span data-stu-id="9951f-1098">OBJECT is represented as OBJECT: *db_id:object_id*.</span></span> <span data-ttu-id="9951f-1099">예들 들어 `TAB: 6:2009058193`입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1099">For example, `TAB: 6:2009058193`.</span></span><br /><br /> <span data-ttu-id="9951f-1100">**KEY**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1100">**KEY**.</span></span> <span data-ttu-id="9951f-1101">잠금이 보유 또는 요청된 인덱스 내의 키 범위를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1101">Identifies the key range within an index on which a lock is held or requested.</span></span> <span data-ttu-id="9951f-1102">KEY는 KEY로 표시됩니다. *db_id:hobt_id* (*index key hash value*).</span><span class="sxs-lookup"><span data-stu-id="9951f-1102">KEY is represented as KEY: *db_id:hobt_id* (*index key hash value*).</span></span> <span data-ttu-id="9951f-1103">예들 들어 `KEY: 6:72057594057457664 (350007a4d329)`입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1103">For example, `KEY: 6:72057594057457664 (350007a4d329)`.</span></span><br /><br /> <span data-ttu-id="9951f-1104">**PAG**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1104">**PAG**.</span></span> <span data-ttu-id="9951f-1105">잠금이 보유 또는 요청된 페이지 리소스를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1105">Identifies the page resource on which a lock is held or requested.</span></span> <span data-ttu-id="9951f-1106">PAG는 PAG로 표시됩니다. *db_id:file_id:page_no*.</span><span class="sxs-lookup"><span data-stu-id="9951f-1106">PAG is represented as PAG: *db_id:file_id:page_no*.</span></span> <span data-ttu-id="9951f-1107">예들 들어 `PAG: 6:1:20789`입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1107">For example, `PAG: 6:1:20789`.</span></span><br /><br /> <span data-ttu-id="9951f-1108">**EXT**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1108">**EXT**.</span></span> <span data-ttu-id="9951f-1109">익스텐트 구조를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1109">Identifies the extent structure.</span></span> <span data-ttu-id="9951f-1110">EXT는 EXT로 표시됩니다. *db_id:file_id:extent_no*.</span><span class="sxs-lookup"><span data-stu-id="9951f-1110">EXT is represented as EXT: *db_id:file_id:extent_no*.</span></span> <span data-ttu-id="9951f-1111">예들 들어 `EXT: 6:1:9`입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1111">For example, `EXT: 6:1:9`.</span></span><br /><br /> <span data-ttu-id="9951f-1112">**DB**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1112">**DB**.</span></span> <span data-ttu-id="9951f-1113">데이터베이스 잠금을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1113">Identifies the database lock.</span></span> <span data-ttu-id="9951f-1114">**DB는 다음 방법 중 하나로 표시됩니다.**</span><span class="sxs-lookup"><span data-stu-id="9951f-1114">**DB is represented in one of the following ways:**</span></span><br /><br /> <span data-ttu-id="9951f-1115">DB: *db_id*</span><span class="sxs-lookup"><span data-stu-id="9951f-1115">DB: *db_id*</span></span><br /><br /> <span data-ttu-id="9951f-1116">DB: *db_id*[BULK-OP-DB]. 이 방법은 백업 데이터베이스에서 수행된 데이터베이스 잠금을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1116">DB: *db_id*[BULK-OP-DB], which identifies the database lock taken by the backup database.</span></span><br /><br /> <span data-ttu-id="9951f-1117">DB: *db_id*[BULK-OP-LOG]. 이 방법은 특정 데이터베이스에 대해 백업 로그에서 수행된 잠금을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1117">DB: *db_id*[BULK-OP-LOG], which identifies the lock taken by the backup log for that particular database.</span></span><br /><br /> <span data-ttu-id="9951f-1118">**APP**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1118">**APP**.</span></span> <span data-ttu-id="9951f-1119">애플리케이션 리소스에서 수행된 잠금을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1119">Identifies the lock taken by an application resource.</span></span> <span data-ttu-id="9951f-1120">APP는 APP로 표시됩니다. *lock_resource*.</span><span class="sxs-lookup"><span data-stu-id="9951f-1120">APP is represented as APP: *lock_resource*.</span></span> <span data-ttu-id="9951f-1121">예들 들어 `APP: Formf370f478`입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1121">For example, `APP: Formf370f478`.</span></span><br /><br /> <span data-ttu-id="9951f-1122">**METADATA**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1122">**METADATA**.</span></span> <span data-ttu-id="9951f-1123">교착 상태와 관련된 메타데이터 리소스를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1123">Represents metadata resources involved in a deadlock.</span></span> <span data-ttu-id="9951f-1124">METADATA에는 많은 하위 리소스가 있으므로 반환되는 값은 교착 상태가 발생한 하위 리소스에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1124">Because METADATA has many subresources, the value returned depends upon the subresource that has deadlocked.</span></span> <span data-ttu-id="9951f-1125">예를 들어 메타 데이터입니다. USER_TYPE 반환 `user_type_id =` \<*integer_value*> 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1125">For example, METADATA.USER_TYPE returns `user_type_id =` \<*integer_value*>.</span></span> <span data-ttu-id="9951f-1126">METADATA 리소스 및 하위 리소스에 대한 자세한 내용은 [sys.dm_tran_locks&#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-locks-transact-sql)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="9951f-1126">For more information about METADATA resources and subresources, see [sys.dm_tran_locks &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-locks-transact-sql).</span></span><br /><br /> <span data-ttu-id="9951f-1127">**HOBT**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1127">**HOBT**.</span></span> <span data-ttu-id="9951f-1128">교착 상태와 관련된 힙 또는 B-트리를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1128">Represents a heap or b-tree involved in a deadlock.</span></span>|<span data-ttu-id="9951f-1129">이 추적 플래그에만 관련된 사항이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1129">None exclusive to this trace flag.</span></span>|<span data-ttu-id="9951f-1130">이 추적 플래그에만 관련된 사항이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1130">None exclusive to this trace flag.</span></span>|  
  
###### <a name="trace-flag-1204-example"></a><span data-ttu-id="9951f-1131">추적 플래그 1204 예</span><span class="sxs-lookup"><span data-stu-id="9951f-1131">Trace Flag 1204 Example</span></span>  

 <span data-ttu-id="9951f-1132">다음 예에서는 추적 플래그 1204가 설정되어 있을 때의 출력을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1132">The following example shows the output when trace flag 1204 is turned on.</span></span> <span data-ttu-id="9951f-1133">이 경우 노드 1의 테이블은 인덱스가 없는 힙이고 노드 2의 테이블은 비클러스터형 인덱스가 있는 힙입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1133">In this case, the table in Node 1 is a heap with no indexes, and the table in Node 2 is a heap with a nonclustered index.</span></span> <span data-ttu-id="9951f-1134">노드 2의 인덱스 키는 교착 상태 발생 시 업데이트 중입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1134">The index key in Node 2 is being updated when the deadlock occurs.</span></span>  
  
```  
Deadlock encountered .... Printing deadlock information  
Wait-for graph  
  
Node:1  
  
RID: 6:1:20789:0               CleanCnt:3 Mode:X Flags: 0x2  
 Grant List 0:  
   Owner:0x0315D6A0 Mode: X          
     Flg:0x0 Ref:0 Life:02000000 SPID:55 ECID:0 XactLockInfo: 0x04D9E27C  
   SPID: 55 ECID: 0 Statement Type: UPDATE Line #: 6  
   Input Buf: Language Event:   
BEGIN TRANSACTION  
   EXEC usp_p2  
 Requested By:   
   ResType:LockOwner Stype:'OR'Xdes:0x03A3DAD0   
     Mode: U SPID:54 BatchID:0 ECID:0 TaskProxy:(0x04976374) Value:0x315d200 Cost:(0/868)  
  
Node:2  
  
KEY: 6:72057594057457664 (350007a4d329) CleanCnt:2 Mode:X Flags: 0x0  
 Grant List 0:  
   Owner:0x0315D140 Mode: X          
     Flg:0x0 Ref:0 Life:02000000 SPID:54 ECID:0 XactLockInfo: 0x03A3DAF4  
   SPID: 54 ECID: 0 Statement Type: UPDATE Line #: 6  
   Input Buf: Language Event:   
     BEGIN TRANSACTION  
       EXEC usp_p1  
 Requested By:   
   ResType:LockOwner Stype:'OR'Xdes:0x04D9E258   
     Mode: U SPID:55 BatchID:0 ECID:0 TaskProxy:(0x0475E374) Value:0x315d4a0 Cost:(0/380)  
  
Victim Resource Owner:  
 ResType:LockOwner Stype:'OR'Xdes:0x04D9E258   
     Mode: U SPID:55 BatchID:0 ECID:0 TaskProxy:(0x0475E374) Value:0x315d4a0 Cost:(0/380)  
```  
  
###### <a name="trace-flag-1222-example"></a><span data-ttu-id="9951f-1135">추적 플래그 1222 예</span><span class="sxs-lookup"><span data-stu-id="9951f-1135">Trace Flag 1222 Example</span></span>  

 <span data-ttu-id="9951f-1136">다음 예에서는 추적 플래그 1222가 설정되어 있을 때의 출력을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1136">The following example shows the output when trace flag 1222 is turned on.</span></span> <span data-ttu-id="9951f-1137">이 경우 한 테이블은 인덱스가 없는 힙이고 다른 테이블은 비클러스터형 인덱스가 있는 힙입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1137">In this case, one table is a heap with no indexes, and the other table is a heap with a nonclustered index.</span></span> <span data-ttu-id="9951f-1138">두 번째 테이블의 인덱스 키는 교착 상태 발생 시 업데이트 중입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1138">In the second table, the index key is being updated when the deadlock occurs.</span></span>  
  
```  
deadlock-list  
 deadlock victim=process689978  
  process-list  
   process id=process6891f8 taskpriority=0 logused=868   
   waitresource=RID: 6:1:20789:0 waittime=1359 ownerId=310444   
   transactionname=user_transaction   
   lasttranstarted=2005-09-05T11:22:42.733 XDES=0x3a3dad0   
   lockMode=U schedulerid=1 kpid=1952 status=suspended spid=54   
   sbid=0 ecid=0 priority=0 transcount=2   
   lastbatchstarted=2005-09-05T11:22:42.733   
   lastbatchcompleted=2005-09-05T11:22:42.733   
   clientapp=Microsoft SQL Server Management Studio - Query   
   hostname=TEST_SERVER hostpid=2216 loginname=DOMAIN\user   
   isolationlevel=read committed (2) xactid=310444 currentdb=6   
   lockTimeout=4294967295 clientoption1=671090784 clientoption2=390200  
    executionStack  
     frame procname=AdventureWorks2012.dbo.usp_p1 line=6 stmtstart=202   
     sqlhandle=0x0300060013e6446b027cbb00c69600000100000000000000  
     UPDATE T2 SET COL1 = 3 WHERE COL1 = 1;       
     frame procname=adhoc line=3 stmtstart=44   
     sqlhandle=0x01000600856aa70f503b8104000000000000000000000000  
     EXEC usp_p1       
    inputbuf  
      BEGIN TRANSACTION  
       EXEC usp_p1  
   process id=process689978 taskpriority=0 logused=380   
   waitresource=KEY: 6:72057594057457664 (350007a4d329)     
   waittime=5015 ownerId=310462 transactionname=user_transaction   
   lasttranstarted=2005-09-05T11:22:44.077 XDES=0x4d9e258 lockMode=U   
   schedulerid=1 kpid=3024 status=suspended spid=55 sbid=0 ecid=0   
   priority=0 transcount=2 lastbatchstarted=2005-09-05T11:22:44.077   
   lastbatchcompleted=2005-09-05T11:22:44.077   
   clientapp=Microsoft SQL Server Management Studio - Query   
   hostname=TEST_SERVER hostpid=2216 loginname=DOMAIN\user   
   isolationlevel=read committed (2) xactid=310462 currentdb=6   
   lockTimeout=4294967295 clientoption1=671090784 clientoption2=390200  
    executionStack  
     frame procname=AdventureWorks2012.dbo.usp_p2 line=6 stmtstart=200   
     sqlhandle=0x030006004c0a396c027cbb00c69600000100000000000000  
     UPDATE T1 SET COL1 = 4 WHERE COL1 = 1;       
     frame procname=adhoc line=3 stmtstart=44   
     sqlhandle=0x01000600d688e709b85f8904000000000000000000000000  
     EXEC usp_p2       
    inputbuf  
      BEGIN TRANSACTION  
        EXEC usp_p2      
  resource-list  
   ridlock fileid=1 pageid=20789 dbid=6 objectname=AdventureWorks2012.dbo.T2   
   id=lock3136940 mode=X associatedObjectId=72057594057392128  
    owner-list  
     owner id=process689978 mode=X  
    waiter-list  
     waiter id=process6891f8 mode=U requestType=wait  
   keylock hobtid=72057594057457664 dbid=6 objectname=AdventureWorks2012.dbo.T1   
   indexname=nci_T1_COL1 id=lock3136fc0 mode=X   
   associatedObjectId=72057594057457664  
    owner-list  
     owner id=process6891f8 mode=X  
    waiter-list  
     waiter id=process689978 mode=U requestType=wait  
```  
  
###### <a name="profiler-deadlock-graph-event"></a><span data-ttu-id="9951f-1139">프로파일러 교착 상태 그래프 이벤트</span><span class="sxs-lookup"><span data-stu-id="9951f-1139">Profiler Deadlock Graph Event</span></span>  

 <span data-ttu-id="9951f-1140">교착 상태와 관련된 태스크 및 리소스를 그림으로 설명하는 [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)]의 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1140">This is an event in [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)] that presents a graphical depiction of the tasks and resources involved in a deadlock.</span></span> <span data-ttu-id="9951f-1141">다음 예에서는 교착 상태 그래프 이벤트가 설정되어 있을 때 [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)]의 출력을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1141">The following example shows the output from [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)] when the deadlock graph event is turned on.</span></span>  
  
 <span data-ttu-id="9951f-1142">![사용자 프로세스 교착 상태를 보여 주는 논리 흐름 다이어그램](media/udb9-profilerdeadlockgraphc.gif "사용자 프로세스 교착 상태를 보여 주는 논리 흐름 다이어그램")</span><span class="sxs-lookup"><span data-stu-id="9951f-1142">![Logic flow diagram showing user process deadlock.](media/udb9-profilerdeadlockgraphc.gif "Logic flow diagram showing user process deadlock.")</span></span>  
  
 <span data-ttu-id="9951f-1143">교착 상태 그래프를 실행 하는 방법에 대 한 자세한 내용은 [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)] [SQL Server Profiler&#41;&#40;교착 상태 그래프 저장 ](../relational-databases/performance/save-deadlock-graphs-sql-server-profiler.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-1143">For more information about running the [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)] deadlock graph, see [Save Deadlock Graphs &#40;SQL Server Profiler&#41;](../relational-databases/performance/save-deadlock-graphs-sql-server-profiler.md).</span></span>  
  
#### <a name="handling-deadlocks"></a><span data-ttu-id="9951f-1144">교착 상태 처리</span><span class="sxs-lookup"><span data-stu-id="9951f-1144">Handling Deadlocks</span></span>  

 <span data-ttu-id="9951f-1145">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 인스턴스에서 교착 상태의 트랜잭션 중 처리하지 않을 트랜잭션이 선택되면 현재 배치가 종료되고 해당 트랜잭션이 롤백된 후 애플리케이션에 오류 메시지 1205가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1145">When an instance of the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] chooses a transaction as a deadlock victim, it terminates the current batch, rolls back the transaction, and returns error message 1205 to the application.</span></span>  
  
 `Your transaction (process ID #52) was deadlocked on {lock | communication buffer | thread} resources with another process and has been chosen as the deadlock victim. Rerun your transaction.`  
  
 <span data-ttu-id="9951f-1146">[!INCLUDE[tsql](../includes/tsql-md.md)] 쿼리를 전달하는 모든 애플리케이션은 교착 상태에서 처리되지 않을 수 있으므로 애플리케이션에 오류 메시지 1205를 트래핑할 수 있는 오류 처리기가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1146">Because any application submitting [!INCLUDE[tsql](../includes/tsql-md.md)] queries can be chosen as the deadlock victim, applications should have an error handler that can trap error message 1205.</span></span> <span data-ttu-id="9951f-1147">애플리케이션에서 오류를 트래핑하지 않으면 해당 트랜잭션이 롤백된 것을 모르고 계속 진행하여 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1147">If an application does not trap the error, the application can proceed unaware that its transaction has been rolled back and errors can occur.</span></span>  
  
 <span data-ttu-id="9951f-1148">오류 메시지 1205를 트래핑하는 오류 처리기를 구현하면 애플리케이션에서 교착 상황을 처리하고 자동으로 교착 상태와 관련된 쿼리를 다시 전송하는 등의 동작을 취할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1148">Implementing an error handler that traps error message 1205 allows an application to handle the deadlock situation and take remedial action (for example, automatically resubmitting the query that was involved in the deadlock).</span></span> <span data-ttu-id="9951f-1149">쿼리를 자동으로 다시 전송하므로 사용자는 교착 상태가 발생한 것을 알 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1149">By resubmitting the query automatically, the user does not need to know that a deadlock occurred.</span></span>  
  
 <span data-ttu-id="9951f-1150">쿼리를 다시 전송하기 전에 애플리케이션이 일시 중지되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1150">The application should pause briefly before resubmitting its query.</span></span> <span data-ttu-id="9951f-1151">이때 교착 상태와 관련된 다른 트랜잭션이 완료되어 교착 상태의 원인이 되는 해당 잠금을 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1151">This gives the other transaction involved in the deadlock a chance to complete and release its locks that formed part of the deadlock cycle.</span></span> <span data-ttu-id="9951f-1152">이를 통해 다시 전송하는 쿼리에서 잠금을 요청할 때 교착 상태가 다시 발생할 가능성을 최소화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1152">This minimizes the likelihood of the deadlock reoccurring when the resubmitted query requests its locks.</span></span>  
  
#### <a name="minimizing-deadlocks"></a><span data-ttu-id="9951f-1153">교착 상태 최소화</span><span class="sxs-lookup"><span data-stu-id="9951f-1153">Minimizing Deadlocks</span></span>  

 <span data-ttu-id="9951f-1154">교착 상태를 완전히 피할 수는 없지만 특정 코딩 규칙을 따르면 교착 상태가 발생하는 기회를 최소화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1154">Although deadlocks cannot be completely avoided, following certain coding conventions can minimize the chance of generating a deadlock.</span></span> <span data-ttu-id="9951f-1155">교착 상태를 최소화하면 트랜잭션 처리량이 늘어나고 더 적은 수의 트랜잭션이 다음과 같이 되므로 시스템 오버헤드가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1155">Minimizing deadlocks can increase transaction throughput and reduce system overhead because fewer transactions are:</span></span>  
  
-   <span data-ttu-id="9951f-1156">롤백되어 트랜잭션에 의해 수행된 모든 작업이 실행 취소됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1156">Rolled back, undoing all the work performed by the transaction.</span></span>  
  
-   <span data-ttu-id="9951f-1157">교착 상태 발생 시 롤백되었으므로 애플리케이션에 의해 다시 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1157">Resubmitted by applications because they were rolled back when deadlocked.</span></span>  
  
 <span data-ttu-id="9951f-1158">교착 상태를 최소화하려면</span><span class="sxs-lookup"><span data-stu-id="9951f-1158">To help minimize deadlocks:</span></span>  
  
-   <span data-ttu-id="9951f-1159">같은 순서로 개체에 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1159">Access objects in the same order.</span></span>  
  
-   <span data-ttu-id="9951f-1160">트랜잭션에서 사용자 상호 작용을 피합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1160">Avoid user interaction in transactions.</span></span>  
  
-   <span data-ttu-id="9951f-1161">트랜잭션을 하나의 일괄 처리로 짧게 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1161">Keep transactions short and in one batch.</span></span>  
  
-   <span data-ttu-id="9951f-1162">낮은 격리 수준을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1162">Use a lower isolation level.</span></span>  
  
-   <span data-ttu-id="9951f-1163">행 버전 관리 기반의 격리 수준을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1163">Use a row versioning-based isolation level.</span></span>  
  
    -   <span data-ttu-id="9951f-1164">READ_COMMITTED_SNAPSHOT 데이터베이스 옵션을 ON으로 설정하여 커밋된 읽기 트랜잭션이 행 버전 관리를 사용할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1164">Set READ_COMMITTED_SNAPSHOT database option ON to enable read-committed transactions to use row versioning.</span></span>  
  
    -   <span data-ttu-id="9951f-1165">스냅샷 격리를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1165">Use snapshot isolation.</span></span>  
  
-   <span data-ttu-id="9951f-1166">바인딩된 연결을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1166">Use bound connections.</span></span>  
  
##### <a name="access-objects-in-the-same-order"></a><span data-ttu-id="9951f-1167">같은 순서로 개체 액세스</span><span class="sxs-lookup"><span data-stu-id="9951f-1167">Access Objects in the Same Order</span></span>  

 <span data-ttu-id="9951f-1168">모든 동시 트랜잭션이 같은 순서로 개체에 액세스하면 교착 상태의 발생 가능성이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1168">If all concurrent transactions access objects in the same order, deadlocks are less likely to occur.</span></span> <span data-ttu-id="9951f-1169">예를 들어 두 개의 동시 트랜잭션이 **Supplier** 테이블에 대해 잠금을 얻은 다음, **Part** 테이블에 대해 잠금을 얻으면 다른 트랜잭션이 완료될 때까지 한 트랜잭션이 **Supplier** 테이블에서 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1169">For example, if two concurrent transactions obtain a lock on the **Supplier** table and then on the **Part** table, one transaction is blocked on the **Supplier** table until the other transaction is completed.</span></span> <span data-ttu-id="9951f-1170">첫 번째 트랜잭션이 커밋되거나 롤백된 후 두 번째가 계속되므로 교착 상태는 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1170">After the first transaction commits or rolls back, the second continues, and a deadlock does not occur.</span></span> <span data-ttu-id="9951f-1171">모든 데이터 수정에 대해 저장 프로시저를 사용하면 개체 액세스 순서를 표준화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1171">Using stored procedures for all data modifications can standardize the order of accessing objects.</span></span>  
  
 <span data-ttu-id="9951f-1172">![교착 상태 방지 방법을 보여 주는 다이어그램](media/dedlck2.gif "교착 상태 방지 방법을 보여 주는 다이어그램")</span><span class="sxs-lookup"><span data-stu-id="9951f-1172">![Diagram showing deadlock avoidance](media/dedlck2.gif "Diagram showing deadlock avoidance")</span></span>  
  
##### <a name="avoid-user-interaction-in-transactions"></a><span data-ttu-id="9951f-1173">트랜잭션에서 사용자 상호 작용 금지</span><span class="sxs-lookup"><span data-stu-id="9951f-1173">Avoid User Interaction in Transactions</span></span>  

 <span data-ttu-id="9951f-1174">사용자 개입 없이 실행되는 일괄 처리의 속도는 애플리케이션의 매개 변수 요청 프롬프트에 대한 응답 등 사용자가 수동으로 쿼리에 응답해야 하는 경우의 속도에 비해 매우 빠르므로 사용자 상호 작용을 포함하는 트랜잭션은 작성하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1174">Avoid writing transactions that include user interaction, because the speed of batches running without user intervention is much faster than the speed at which a user must manually respond to queries, such as replying to a prompt for a parameter requested by an application.</span></span> <span data-ttu-id="9951f-1175">예를 들어 트랜잭션이 사용자 입력을 기다리고 있는데 사용자가 식사를 하러 가거나 퇴근한 경우 사용자는 트랜잭션을 완료할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1175">For example, if a transaction is waiting for user input and the user goes to lunch or even home for the weekend, the user delays the transaction from completing.</span></span> <span data-ttu-id="9951f-1176">이 경우 트랜잭션에서 보유한 잠금은 트랜잭션이 커밋 또는 롤백되어야 해제되므로 시스템 처리량이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1176">This degrades system throughput because any locks held by the transaction are released only when the transaction is committed or rolled back.</span></span> <span data-ttu-id="9951f-1177">교착 상태가 발생하지 않아도 같은 리소스에 액세스하는 다른 트랜잭션은 해당 트랜잭션이 완료될 때까지 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1177">Even if a deadlock situation does not arise, other transactions accessing the same resources are blocked while waiting for the transaction to complete.</span></span>  
  
##### <a name="keep-transactions-short-and-in-one-batch"></a><span data-ttu-id="9951f-1178">트랜잭션을 하나의 일괄 처리로 짧게 유지</span><span class="sxs-lookup"><span data-stu-id="9951f-1178">Keep Transactions Short and in One Batch</span></span>  

 <span data-ttu-id="9951f-1179">교착 상태는 보통 오래 실행되는 여러 개의 트랜잭션이 같은 데이터베이스에서 동시에 실행될 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1179">A deadlock typically occurs when several long-running transactions execute concurrently in the same database.</span></span> <span data-ttu-id="9951f-1180">트랜잭션 실행 시간이 길수록 배타적 또는 업데이트 잠금 보유 시간이 길어지므로 다른 작업을 차단하고 교착 상태를 일으킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1180">The longer the transaction, the longer the exclusive or update locks are held, blocking other activity and leading to possible deadlock situations.</span></span>  
  
 <span data-ttu-id="9951f-1181">트랜잭션을 하나의 일괄 처리로 유지하면 트랜잭션 중 네트워크 왕복이 최소화되므로 트랜잭션을 완료하고 잠금을 해제하는 데 걸리는 지연 시간을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1181">Keeping transactions in one batch minimizes network roundtrips during a transaction, reducing possible delays in completing the transaction and releasing locks.</span></span>  
  
##### <a name="use-a-lower-isolation-level"></a><span data-ttu-id="9951f-1182">낮은 격리 수준 사용</span><span class="sxs-lookup"><span data-stu-id="9951f-1182">Use a Lower Isolation Level</span></span>  

 <span data-ttu-id="9951f-1183">트랜잭션을 더 낮은 격리 수준에서 실행할 수 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1183">Determine whether a transaction can run at a lower isolation level.</span></span> <span data-ttu-id="9951f-1184">커밋된 읽기를 구현하면 트랜잭션에서는 처음 트랜잭션이 완료될 때까지 기다리지 않고 다른 트랜잭션에서 이전에 읽은 수정되지 않은 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1184">Implementing read committed allows a transaction to read data previously read (not modified) by another transaction without waiting for the first transaction to complete.</span></span> <span data-ttu-id="9951f-1185">커밋된 읽기 등 낮은 격리 수준을 사용하면 순차 가능 등의 높은 격리 수준보다 짧은 기간 동안 공유 잠금을 보유합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1185">Using a lower isolation level, such as read committed, holds shared locks for a shorter duration than a higher isolation level, such as serializable.</span></span> <span data-ttu-id="9951f-1186">그 결과 잠금 경합이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1186">This reduces locking contention.</span></span>  
  
##### <a name="use-a-row-versioning-based-isolation-level"></a><span data-ttu-id="9951f-1187">행 버전 관리 기반의 격리 수준 사용</span><span class="sxs-lookup"><span data-stu-id="9951f-1187">Use a Row Versioning-based Isolation Level</span></span>  

 <span data-ttu-id="9951f-1188">READ_COMMITTED_SNAPSHOT 데이터베이스 옵션을 ON으로 설정하면 커밋된 읽기 격리 수준에서 실행되는 트랜잭션은 읽기 작업 동안 공유 잠금 대신 행 버전 관리를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1188">When the READ_COMMITTED_SNAPSHOT database option is set ON, a transaction running under read committed isolation level uses row versioning rather than shared locks during read operations.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9951f-1189">일부 애플리케이션은 커밋된 읽기 격리의 잠금과 차단에 의존합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1189">Some applications rely upon locking and blocking behavior of read committed isolation.</span></span> <span data-ttu-id="9951f-1190">이러한 애플리케이션의 경우 이 옵션을 설정하기 전에 몇 가지 사항을 변경해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1190">For these applications, some change is required before this option can be enabled.</span></span>  
  
 <span data-ttu-id="9951f-1191">스냅샷 격리에서도 읽기 작업 중 공유 잠금을 사용하지 않는 행 버전 관리를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1191">Snapshot isolation also uses row versioning, which does not use shared locks during read operations.</span></span> <span data-ttu-id="9951f-1192">스냅샷 격리 상태에서 트랜잭션을 실행하려면 먼저 ALLOW_SNAPSHOT_ISOLATION 데이터베이스 옵션을 ON으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1192">Before a transaction can run under snapshot isolation, the ALLOW_SNAPSHOT_ISOLATION database option must be set ON.</span></span>  
  
 <span data-ttu-id="9951f-1193">읽기 작업과 쓰기 작업 간에 발생할 수 있는 교착 상태를 최소화하려면 이러한 격리 수준을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1193">Implement these isolation levels to minimize deadlocks that can occur between read and write operations.</span></span>  
  
##### <a name="use-bound-connections"></a><span data-ttu-id="9951f-1194">바인딩된 연결 사용</span><span class="sxs-lookup"><span data-stu-id="9951f-1194">Use Bound Connections</span></span>  

 <span data-ttu-id="9951f-1195">바인딩된 연결을 사용하면 같은 애플리케이션에서 열어 놓은 둘 이상의 연결을 함께 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1195">Using bound connections, two or more connections opened by the same application can cooperate with each other.</span></span> <span data-ttu-id="9951f-1196">보조 연결에서 얻은 잠금은 기본 연결에서 얻은 것과 같이 유지되며 반대의 경우도 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1196">Any locks acquired by the secondary connections are held as if they were acquired by the primary connection, and vice versa.</span></span> <span data-ttu-id="9951f-1197">따라서 서로를 차단하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1197">Therefore they do not block each other.</span></span>  
  
### <a name="lock-partitioning"></a><span data-ttu-id="9951f-1198">잠금 분할</span><span class="sxs-lookup"><span data-stu-id="9951f-1198">Lock Partitioning</span></span>  

 <span data-ttu-id="9951f-1199">잠금을 확보하고 해제하는 과정에서는 내부 잠금 리소스에 대한 경합이 발생하기 때문에 대규모 컴퓨터 시스템의 경우 자주 참조되는 개체를 잠그면 성능이 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1199">For large computer systems, locks on frequently referenced objects can become a performance bottleneck as acquiring and releasing locks place contention on internal locking resources.</span></span> <span data-ttu-id="9951f-1200">잠금 분할은 하나의 잠금 리소스를 여러 잠금 리소스로 분할하여 잠금 성능을 높입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1200">Lock partitioning enhances locking performance by splitting a single lock resource into multiple lock resources.</span></span> <span data-ttu-id="9951f-1201">이 기능은 CPU가 16개 이상인 시스템에서만 사용할 수 있고 자동으로 설정되며 해제할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1201">This feature is only available for systems with 16 or more CPUs, and is automatically enabled and cannot be disabled.</span></span> <span data-ttu-id="9951f-1202">개체 잠금만 분할할 수 있습니다. 하위 유형이 있는 개체 잠금은 분할할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1202">Only object locks can be partitioned.Object locks that have a subtype are not partitioned.</span></span> <span data-ttu-id="9951f-1203">자세한 내용은 [sys.dm_tran_locks&#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-locks-transact-sql)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-1203">For more information, see [sys.dm_tran_locks &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-locks-transact-sql).</span></span>  
  
#### <a name="understanding-lock-partitioning"></a><span data-ttu-id="9951f-1204">잠금 분할 이해</span><span class="sxs-lookup"><span data-stu-id="9951f-1204">Understanding Lock Partitioning</span></span>  

 <span data-ttu-id="9951f-1205">잠금 태스크에서는 몇 가지 공유 리소스에 액세스하게 되며 잠금 분할을 통해 이 중 두 가지 리소스에 대한 액세스를 최적화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1205">Locking tasks access several shared resources, two of which are optimized by lock partitioning:</span></span>  
  
-   <span data-ttu-id="9951f-1206">**Spinlock**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1206">**Spinlock**.</span></span> <span data-ttu-id="9951f-1207">행 또는 테이블과 같은 잠금 리소스에 대한 액세스를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1207">This controls access to a lock resource, such as a row or a table.</span></span>  
  
     <span data-ttu-id="9951f-1208">잠금 분할을 사용하지 않으면 하나의 spinlock이 단일 잠금 리소스에 대한 모든 잠금 요청을 관리하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1208">Without lock partitioning, one spinlock manages all lock requests for a single lock resource.</span></span> <span data-ttu-id="9951f-1209">작업량이 많은 시스템에서는 여러 잠금 요청이 spinlock을 사용하기 위해 대기하므로 경합이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1209">On systems that experience a large volume of activity, contention can occur as lock requests wait for the spinlock to become available.</span></span> <span data-ttu-id="9951f-1210">이러한 상황에서 잠금을 획득하게 되면 병목이 발생하여 성능을 저하시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1210">Under this situation, acquiring locks can become a bottleneck and can negatively impact performance.</span></span>  
  
     <span data-ttu-id="9951f-1211">잠금 분할은 단일 잠금 리소스를 여러 잠금 리소스로 분할하여 여러 spinlock에 로드를 분산함으로써 단일 잠금 리소스에 대한 경합을 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1211">To reduce contention on a single lock resource, lock partitioning splits a single lock resource into multiple lock resources to distribute the load across multiple spinlocks.</span></span>  
  
-   <span data-ttu-id="9951f-1212">**메모리**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1212">**Memory**.</span></span> <span data-ttu-id="9951f-1213">잠금 리소스 구조를 저장하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1213">This is used to store the lock resource structures.</span></span>  
  
     <span data-ttu-id="9951f-1214">spinlock이 확보되면 잠금 구조가 메모리에 저장된 다음 액세스되고 경우에 따라 수정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1214">Once the spinlock is acquired, lock structures are stored in memory and then accessed and possibly modified.</span></span> <span data-ttu-id="9951f-1215">잠금 액세스를 여러 리소스로 분산하면 CPU 간에 메모리 블록을 전송할 필요가 없으므로 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1215">Distributing lock access across multiple resources helps to eliminate the need to transfer memory blocks between CPUs, which will help to improve performance.</span></span>  
  
#### <a name="implementing-and-monitoring-lock-partitioning"></a><span data-ttu-id="9951f-1216">잠금 분할 구현 및 모니터링</span><span class="sxs-lookup"><span data-stu-id="9951f-1216">Implementing and Monitoring Lock Partitioning</span></span>  

 <span data-ttu-id="9951f-1217">CPU가 16개 이상인 시스템의 경우 잠금 분할이 기본적으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1217">Lock partitioning is turned on by default for systems with 16 or more CPUs.</span></span> <span data-ttu-id="9951f-1218">잠금 분할을 사용하면 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 오류 로그에 정보 메시지가 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1218">When lock partitioning is enabled, an informational message is recorded in the [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] error log.</span></span>  
  
 <span data-ttu-id="9951f-1219">분할된 리소스에 대해 잠금을 확보하는 경우</span><span class="sxs-lookup"><span data-stu-id="9951f-1219">When acquiring locks on a partitioned resource:</span></span>  
  
-   <span data-ttu-id="9951f-1220">NL, SCH-S, IS, IU 및 IX 잠금 모드만 단일 파티션에 대해 확보됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1220">Only NL, SCH-S, IS, IU, and IX lock modes are acquired on a single partition.</span></span>  
  
-   <span data-ttu-id="9951f-1221">NL, SCH-S, IS, IU 및 IX 이외의 모드에서 공유 잠금(S), 배타적 잠금(X) 등의 잠금은 파티션 ID가 0으로 시작하고 파티션 ID 순서를 따르는 모든 파티션에 대해 확보되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1221">Shared (S), exclusive (X), and other locks in modes other than NL, SCH-S, IS, IU, and IX must be acquired on all partitions starting with partition ID 0 and following in partition ID order.</span></span> <span data-ttu-id="9951f-1222">각 파티션은 효율적인 별도의 잠금이 되므로 분할된 리소스에 이러한 대한 잠금은 동일한 모드에서 분할되지 않은 리소스에 대한 잠금보다 메모리를 더 많이 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1222">These locks on a partitioned resource will use more memory than locks in the same mode on a non-partitioned resource since each partition is effectively a separate lock.</span></span> <span data-ttu-id="9951f-1223">메모리 증가는 파티션의 수에 따라 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1223">The memory increase is determined by the number of partitions.</span></span> <span data-ttu-id="9951f-1224">Windows 성능 모니터에서 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 잠금 카운터에는 분할된 잠금과 분할되지 않은 잠금에 사용되는 메모리에 대한 정보가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1224">The [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] lock counters in the Windows Performance Monitor will display information about memory used by partitioned and non-partitioned locks.</span></span>  
  
 <span data-ttu-id="9951f-1225">트랜잭션이 시작되면 파티션에 트랜잭션이 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1225">A transaction is assigned to a partition when the transaction starts.</span></span> <span data-ttu-id="9951f-1226">트랜잭션의 경우 분할할 수 있는 모든 잠금 요청에는 트랜잭션에 할당된 파티션이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1226">For the transaction, all lock requests that can be partitioned use the partition assigned to that transaction.</span></span> <span data-ttu-id="9951f-1227">이러한 방법으로 동일한 개체의 잠금 리소스에 대한 여러 트랜잭션의 액세스가 여러 파티션으로 분산됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1227">By this method, access to lock resources of the same object by different transactions is distributed across different partitions.</span></span>  
  
 <span data-ttu-id="9951f-1228">sys.dm_tran_locks 동적 관리 뷰의 resource_lock_partition 열은 잠금 분할 리소스에 대한 잠금 파티션 ID를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1228">The resource_lock_partition column in the sys.dm_tran_locks Dynamic Management View provides the lock partition ID for a lock partitioned resource.</span></span> <span data-ttu-id="9951f-1229">자세한 내용은 [sys.dm_tran_locks&#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-locks-transact-sql)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-1229">For more information, see [sys.dm_tran_locks &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-locks-transact-sql).</span></span>  
  
 <span data-ttu-id="9951f-1230">[!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)]의 잠금 이벤트 아래에서 BigintData1 열에는 잠금 분할 리소스에 대한 잠금 파티션 ID가 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1230">Under the Locks event in [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)], the BigintData1 column provides the lock partition ID for a lock partitioned resource.</span></span>  
  
#### <a name="working-with-lock-partitioning"></a><span data-ttu-id="9951f-1231">잠금 분할 작업</span><span class="sxs-lookup"><span data-stu-id="9951f-1231">Working with Lock Partitioning</span></span>  

 <span data-ttu-id="9951f-1232">다음은 잠금 분할을 보여 주는 코드 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1232">The following code examples illustrate lock partitioning.</span></span> <span data-ttu-id="9951f-1233">이 예제에서는 서로 다른 두 세션에서 실행되는 두 가지 트랜잭션을 통해 CPU가 16개인 시스템의 잠금 분할 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1233">In the examples, two transactions are executed in two different sessions in order to show lock partitioning behavior on a computer system with 16 CPUs.</span></span>  
  
 <span data-ttu-id="9951f-1234">다음 [!INCLUDE[tsql](../includes/tsql-md.md)] 문은 이후에 나오는 예제에서 사용되는 테스트 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1234">These [!INCLUDE[tsql](../includes/tsql-md.md)] statements create test objects that are used in the examples that follow.</span></span>  
  
```sql  
-- Create a test table.  
CREATE TABLE TestTable  
    (col1        int);  
GO  
  
-- Create a clustered index on the table.  
CREATE CLUSTERED INDEX ci_TestTable   
    ON TestTable (col1);  
GO  
  
-- Populate the table.  
INSERT INTO TestTable VALUES (1);  
GO  
```  
  
##### <a name="example-a"></a><span data-ttu-id="9951f-1235">예 1</span><span class="sxs-lookup"><span data-stu-id="9951f-1235">Example A</span></span>  

 <span data-ttu-id="9951f-1236">세션 1:</span><span class="sxs-lookup"><span data-stu-id="9951f-1236">Session 1:</span></span>  
  
 <span data-ttu-id="9951f-1237">트랜잭션에서 `SELECT` 문이 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1237">A `SELECT` statement is executed under a transaction.</span></span> <span data-ttu-id="9951f-1238">`HOLDLOCK` 잠금 힌트로 인해 이 문은 해당 테이블에 대해 IS(내재된 공유) 잠금을 획득하여 유지합니다. 이 그림에서는 행 잠금 및 페이지 잠금이 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1238">Because of the `HOLDLOCK` lock hint, this statement will acquire and retain an Intent shared (IS) lock on the table (for this illustration, row and page locks are ignored).</span></span> <span data-ttu-id="9951f-1239">IS 잠금은 트랜잭션에 할당된 파티션에 대해서만 획득할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1239">The IS lock will be acquired only on the partition assigned to the transaction.</span></span> <span data-ttu-id="9951f-1240">이 예에서는 파티션 ID 7에 대해 IS 잠금을 획득했다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1240">For this example, it is assumed that the IS lock is acquired on partition ID 7.</span></span>  
  
```sql  
-- Start a transaction.  
BEGIN TRANSACTION  
    -- This SELECT statement will acquire an IS lock on the table.  
    SELECT col1  
        FROM TestTable  
        WITH (HOLDLOCK);  
```  
  
 <span data-ttu-id="9951f-1241">세션 2:</span><span class="sxs-lookup"><span data-stu-id="9951f-1241">Session 2:</span></span>  
  
 <span data-ttu-id="9951f-1242">트랜잭션이 시작되고 이 트랜잭션에서 실행되는 `SELECT` 문이 테이블에 대한 S(공유) 잠금을 획득 및 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1242">A transaction is started, and the `SELECT` statement running under this transaction will acquire and retain a shared (S) lock on the table.</span></span> <span data-ttu-id="9951f-1243">S 잠금은 모든 파티션에 대해 확보되므로 각 파티션에 대해 하나씩 잠금이 생성되어 여러 테이블이 잠기게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1243">The S lock will be acquired on all partitions which results in multiple table locks, one for each partition.</span></span> <span data-ttu-id="9951f-1244">예를 들어 CPU가 16개인 시스템에서 잠금 파티션 ID 0-15까지 16개의 잠금이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1244">For example, on a 16-cpu system, 16 S locks will be issued across lock partition IDs 0-15.</span></span> <span data-ttu-id="9951f-1245">S 잠금은 세션 1의 트랜잭션에 의해 파티션 ID 7에 확보된 IS 잠금과 호환되므로 트랜잭션 간에 차단이 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1245">Because the S lock is compatible with the IS lock being held on partition ID 7 by the transaction in session 1, there is no blocking between transactions.</span></span>  
  
```sql  
BEGIN TRANSACTION  
    SELECT col1  
        FROM TestTable  
        WITH (TABLOCK, HOLDLOCK);  
```  
  
 <span data-ttu-id="9951f-1246">세션 1:</span><span class="sxs-lookup"><span data-stu-id="9951f-1246">Session 1:</span></span>  
  
 <span data-ttu-id="9951f-1247">세션 1에서 아직 활성화되어 있는 트랜잭션에서 다음 `SELECT` 문이 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1247">The following `SELECT` statement is executed under the transaction that is still active under session 1.</span></span> <span data-ttu-id="9951f-1248">X(배타적) 테이블 잠금 힌트로 인해 트랜잭션이 테이블에 대해 X 잠금을 획득하려 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1248">Because of the exclusive (X) table lock hint, the transaction will attempt to acquire an X lock on the table.</span></span> <span data-ttu-id="9951f-1249">그러나 세션 2의 트랜잭션에 의해 확보된 S 잠금이 파티션 ID 0에서 X 잠금을 차단합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1249">However, the S lock that is being held by the transaction in session 2 will block the X lock at partition ID 0.</span></span>  
  
```sql  
SELECT col1  
    FROM TestTable  
    WITH (TABLOCKX);  
```  
  
##### <a name="example-b"></a><span data-ttu-id="9951f-1250">예 2</span><span class="sxs-lookup"><span data-stu-id="9951f-1250">Example B</span></span>  

 <span data-ttu-id="9951f-1251">세션 1:</span><span class="sxs-lookup"><span data-stu-id="9951f-1251">Session 1:</span></span>  
  
 <span data-ttu-id="9951f-1252">트랜잭션에서 `SELECT` 문이 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1252">A `SELECT` statement is executed under a transaction.</span></span> <span data-ttu-id="9951f-1253">`HOLDLOCK` 잠금 힌트로 인해 이 문은 해당 테이블에 대해 IS(내재된 공유) 잠금을 획득하여 유지합니다. 이 그림에서는 행 잠금 및 페이지 잠금이 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1253">Because of the `HOLDLOCK` lock hint, this statement will acquire and retain an Intent shared (IS) lock on the table (for this illustration, row and page locks are ignored).</span></span> <span data-ttu-id="9951f-1254">IS 잠금은 트랜잭션에 할당된 파티션에 대해서만 획득할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1254">The IS lock will be acquired only on the partition assigned to the transaction.</span></span> <span data-ttu-id="9951f-1255">이 예에서는 파티션 ID 6에 대해 IS 잠금을 획득했다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1255">For this example, it is assumed that the IS lock is acquired on partition ID 6.</span></span>  
  
```sql  
-- Start a transaction.  
BEGIN TRANSACTION  
    -- This SELECT statement will acquire an IS lock on the table.  
    SELECT col1  
        FROM TestTable  
        WITH (HOLDLOCK);  
```  
  
 <span data-ttu-id="9951f-1256">세션 2:</span><span class="sxs-lookup"><span data-stu-id="9951f-1256">Session 2:</span></span>  
  
 <span data-ttu-id="9951f-1257">트랜잭션에서 `SELECT` 문이 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1257">A `SELECT` statement is executed under a transaction.</span></span> <span data-ttu-id="9951f-1258">`TABLOCKX` 잠금 힌트로 인해 트랜잭션이 테이블에 대해 X(배타적) 잠금을 획득하려 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1258">Because of the `TABLOCKX` lock hint, the transaction tries to acquire an exclusive (X) lock on the table.</span></span> <span data-ttu-id="9951f-1259">파티션 ID가 0으로 시작하는 모든 파티션에 대해 획득되어야 하므로</span><span class="sxs-lookup"><span data-stu-id="9951f-1259">Remember that the X lock must be acquired on all partitions starting with partition ID 0.</span></span> <span data-ttu-id="9951f-1260">X 잠금은 0-5의 모든 파티션 ID에 대해 획득되지만 파티션 ID 6에 획득된 IS 잠금에 의해 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1260">The X lock will be acquired on all partitions IDs 0-5 but will be blocked by the IS lock that is acquired on partition ID 6.</span></span>  
  
 <span data-ttu-id="9951f-1261">아직 X 잠금이 획득되지 않은 파티션 ID 7-15에서 다른 트랜잭션이 계속 잠금을 획득할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1261">On partition IDs 7-15 that the X lock has not yet reached, other transactions can continue to acquire locks.</span></span>  
  
```sql  
BEGIN TRANSACTION  
    SELECT col1  
        FROM TestTable  
        WITH (TABLOCKX, HOLDLOCK);  
```  
  
 <span data-ttu-id="9951f-1262">[이 가이드의](#Top) ![맨 위 링크와 함께 사용 되는 화살표 아이콘](media/uparrow16x16.gif "맨 위로 이동 링크와 함께 사용되는 화살표 아이콘")</span><span class="sxs-lookup"><span data-stu-id="9951f-1262">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="row-versioning-based-isolation-levels-in-the-database-engine"></a><a name="Row_versioning"></a><span data-ttu-id="9951f-1263">데이터베이스 엔진의 행 버전 관리 기반 격리 수준</span><span class="sxs-lookup"><span data-stu-id="9951f-1263">Row Versioning-based Isolation Levels in the Database Engine</span></span>  

 <span data-ttu-id="9951f-1264">SQL Server 2005부터 데이터베이스 엔진에서는 기존 격리 수준을 구현한 커밋된 읽기를 제공하여 행 버전 관리를 사용하는 문 수준 스냅샷을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1264">Starting with SQL Server 2005, the Database Engine offers an implementation of an existing transaction isolation level, read committed, that provides a statement level snapshot using row versioning.</span></span> <span data-ttu-id="9951f-1265">또한 SQL Server 데이터베이스 엔진에서는 트랜잭션 격리 수준인 스냅샷이 도입되어 행 버전 관리를 사용하는 트랜잭션 수준 스냅샷을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1265">SQL Server Database Engine also offers a transaction isolation level, snapshot, that provides a transaction level snapshot also using row versioning.</span></span>  
  
 <span data-ttu-id="9951f-1266">[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]에서 행 버전 관리는 행을 수정하거나 삭제할 때 쓰기 시 복사 메커니즘을 호출하는 일반적인 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1266">Row versioning is a general framework in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] that invokes a copy-on-write mechanism when a row is modified or deleted.</span></span> <span data-ttu-id="9951f-1267">이렇게 하려면 트랜잭션을 실행하는 동안 트랜잭션의 일관성 있는 이전 상태가 요구되는 트랜잭션에서 이전 기존 행 버전을 사용할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1267">This requires that while the transaction is running, the old version of the row must be available for transactions that require an earlier transactionally consistent state.</span></span> <span data-ttu-id="9951f-1268">행 버전 관리는 다음 용도로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1268">Row versioning is used to do the following:</span></span>  
  
-   <span data-ttu-id="9951f-1269">트리거에 **inserted** 및 **deleted** 테이블 작성.</span><span class="sxs-lookup"><span data-stu-id="9951f-1269">Build the **inserted** and **deleted** tables in triggers.</span></span> <span data-ttu-id="9951f-1270">트리거에 의해 수정된 모든 행의 버전이 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1270">Any rows modified by the trigger are versioned.</span></span> <span data-ttu-id="9951f-1271">여기에는 트리거를 실행한 문에 의해 수정된 행과 트리거에 의해 수정된 모든 데이터가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1271">This includes the rows modified by the statement that launched the trigger, as well as any data modifications made by the trigger.</span></span>  
  
-   <span data-ttu-id="9951f-1272">MARS(Multiple Active Result Sets) 지원.</span><span class="sxs-lookup"><span data-stu-id="9951f-1272">Support Multiple Active Result Sets (MARS).</span></span> <span data-ttu-id="9951f-1273">활성 결과 집합이 있을 때 MARS 세션에서 INSERT, UPDATE 또는 DELETE와 같은 데이터 수정 문을 실행하면 이 수정 문의 영향을 받는 행의 버전이 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1273">If a MARS session issues a data modification statement (such as INSERT, UPDATE, or DELETE) at a time there is an active result set, the rows affected by the modification statement are versioned.</span></span>  
  
-   <span data-ttu-id="9951f-1274">ONLINE 옵션을 지정하는 인덱스 작업 지원</span><span class="sxs-lookup"><span data-stu-id="9951f-1274">Support index operations that specify the ONLINE option.</span></span>  
  
-   <span data-ttu-id="9951f-1275">행 버전 관리 기반 트랜잭션 격리 수준 지원</span><span class="sxs-lookup"><span data-stu-id="9951f-1275">Support row versioning-based transaction isolation levels:</span></span>  
  
    -   <span data-ttu-id="9951f-1276">행 버전 관리를 사용하여 문 수준의 읽기 일관성을 유지하는 새로운 커밋된 읽기 격리 수준 구현</span><span class="sxs-lookup"><span data-stu-id="9951f-1276">A new implementation of read committed isolation level that uses row versioning to provide statement-level read consistency.</span></span>  
  
    -   <span data-ttu-id="9951f-1277">트랜잭션 수준의 읽기 일관성을 유지하는 새로운 스냅샷 격리 수준</span><span class="sxs-lookup"><span data-stu-id="9951f-1277">A new isolation level, snapshot, to provide transaction-level read consistency.</span></span>  
  
 <span data-ttu-id="9951f-1278">`tempdb` 데이터베이스에는 버전 저장소로 사용할 공간이 충분해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1278">The `tempdb` database must have enough space for the version store.</span></span> <span data-ttu-id="9951f-1279">`tempdb`이 꽉 차면 업데이트 작업이 버전 생성을 중단하고 계속 진행되지만 필요한 특정 행 버전이 더 이상 존재하지 않으므로 읽기 작업이 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1279">When `tempdb` is full, update operations will stop generating versions and continue to succeed, but read operations might fail because a particular row version that is needed no longer exists.</span></span> <span data-ttu-id="9951f-1280">이것은 트리거, MARS 및 온라인 인덱싱 등의 작업에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1280">This affects operations like triggers, MARS, and online indexing.</span></span>  
  
 <span data-ttu-id="9951f-1281">커밋된 읽기 및 스냅샷 트랜잭션에 행 버전 관리를 사용하는 과정은 다음 두 단계로 이루어집니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1281">Using row versioning for read-committed and snapshot transactions is a two-step process:</span></span>  
  
1.  <span data-ttu-id="9951f-1282">READ_COMMITTED_SNAPSHOT 및 ALLOW_SNAPSHOT_ISOLATION 데이터베이스 옵션 중 하나 또는 모두를 ON으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1282">Set either or both the READ_COMMITTED_SNAPSHOT and ALLOW_SNAPSHOT_ISOLATION database options ON.</span></span>  
  
2.  <span data-ttu-id="9951f-1283">애플리케이션에서 적절한 트랜잭션 격리 수준을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1283">Set the appropriate transaction isolation level in an application:</span></span>  
  
    -   <span data-ttu-id="9951f-1284">READ_COMMITTED_SNAPSHOT 데이터베이스 옵션을 ON으로 설정하면 커밋된 읽기 격리 수준을 설정하는 트랜잭션에 행 버전 관리가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1284">When the READ_COMMITTED_SNAPSHOT database option is ON, transactions setting the read committed isolation level use row versioning.</span></span>  
  
    -   <span data-ttu-id="9951f-1285">ALLOW_SNAPSHOT_ISOLATION 데이터베이스 옵션을 ON으로 설정하면 트랜잭션에서 스냅샷 격리 수준을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1285">When the ALLOW_SNAPSHOT_ISOLATION database option is ON, transactions can set the snapshot isolation level.</span></span>  
  
 <span data-ttu-id="9951f-1286">READ_COMMITTED_SNAPSHOT 또는 ALLOW_SNAPSHOT_ISOLATION 데이터베이스 옵션을 ON으로 설정하면 [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]에서 행 버전 관리를 사용하여 데이터를 조작하는 각 트랜잭션에 XSN(트랜잭션 시퀀스 번호)을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1286">When either READ_COMMITTED_SNAPSHOT or ALLOW_SNAPSHOT_ISOLATION database option is set ON, the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] assigns a transaction sequence number (XSN) to each transaction that manipulates data using row versioning.</span></span> <span data-ttu-id="9951f-1287">트랜잭션은 BEGIN TRANSACTION 문이 실행될 때 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1287">Transactions start at the time a BEGIN TRANSACTION statement is executed.</span></span> <span data-ttu-id="9951f-1288">그러나 트랜잭션 시퀀스 번호는 BEGIN TRANSACTION 문 이후 첫 번째 읽기 또는 쓰기 작업이 실행될 때 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1288">However, the transaction sequence number starts with the first read or write operation after the BEGIN TRANSACTION statement.</span></span> <span data-ttu-id="9951f-1289">트랜잭션 시퀀스 번호는 할당될 때마다 1씩 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1289">The transaction sequence number is incremented by one each time it is assigned.</span></span>  
  
 <span data-ttu-id="9951f-1290">READ_COMMITTED_SNAPSHOT 또는 ALLOW_SNAPSHOT_ISOLATION 데이터베이스 옵션을 ON으로 설정하면 데이터베이스에서 수행된 모든 데이터 수정 내용에 대한 논리적 복사본(버전)이 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1290">When either the READ_COMMITTED_SNAPSHOT or ALLOW_SNAPSHOT_ISOLATION database options are ON, logical copies (versions) are maintained for all data modifications performed in the database.</span></span> <span data-ttu-id="9951f-1291">특정 트랜잭션에 의해 행이 수정될 때마다 [!INCLUDE[ssDE](../includes/ssde-md.md)] 인스턴스는 행의 이전에 커밋된 이미지 버전을 `tempdb`에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1291">Every time a row is modified by a specific transaction, the instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] stores a version of the previously committed image of the row in `tempdb`.</span></span> <span data-ttu-id="9951f-1292">각 버전은 행을 변경한 트랜잭션의 트랜잭션 시퀀스 번호로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1292">Each version is marked with the transaction sequence number of the transaction that made the change.</span></span> <span data-ttu-id="9951f-1293">수정된 행의 여러 버전은 연결 목록을 통해 체인으로 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1293">The versions of modified rows are chained using a link list.</span></span> <span data-ttu-id="9951f-1294">최신 행 값은 항상 현재 데이터베이스에 저장되고 `tempdb`에 저장된 버전 지정된 행과 체인으로 연결되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1294">The newest row value is always stored in the current database and chained to the versioned rows stored in `tempdb`.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9951f-1295">LOB(Large Object) 수정 내용의 경우 변경된 조각만 `tempdb`의 버전 저장소에 복사됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1295">For modification of large objects (LOBs), only the changed fragment is copied to the version store in `tempdb`.</span></span>  
  
 <span data-ttu-id="9951f-1296">행 버전은 행 버전 관리 기반 격리 수준으로 실행되는 트랜잭션의 요구 사항을 만족할 때까지 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1296">Row versions are held long enough to satisfy the requirements of transactions running under row versioning-based isolation levels.</span></span> <span data-ttu-id="9951f-1297">[!INCLUDE[ssDE](../includes/ssde-md.md)]은 가장 오래된 유용한 트랜잭션 시퀀스 번호를 추적하여 해당 번호보다 낮은 트랜잭션 시퀀스 번호로 표시된 모든 행 버전을 주기적으로 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1297">The [!INCLUDE[ssDE](../includes/ssde-md.md)] tracks the earliest useful transaction sequence number and periodically deletes all row versions stamped with transaction sequence numbers that are lower than the earliest useful sequence number.</span></span>  
  
 <span data-ttu-id="9951f-1298">두 가지 데이터베이스 옵션을 모두 OFF로 설정하면 트리거 또는 MARS 세션에 의해 수정되었거나 ONLINE 인덱스 작업에서 읽은 행에만 버전이 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1298">When both database options are set to OFF, only rows modified by triggers or MARS sessions, or read by ONLINE index operations, are versioned.</span></span> <span data-ttu-id="9951f-1299">이러한 행 버전은 더 이상 필요하지 않을 경우 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1299">Those row versions are released when no longer needed.</span></span> <span data-ttu-id="9951f-1300">백그라운드 스레드가 주기적으로 실행되어 오래되어 필요 없는 행 버전을 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1300">A background thread periodically executes to remove stale row versions.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9951f-1301">짧게 실행되는 트랜잭션의 경우 수정된 행의 버전이 `tempdb` 데이터베이스의 디스크 파일에 작성되지 않고 버퍼 풀에 캐시될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1301">For short-running transactions, a version of a modified row may get cached in the buffer pool without getting written into the disk files of the `tempdb` database.</span></span> <span data-ttu-id="9951f-1302">버전이 지정된 행이 일시적으로 필요한 경우에는 버퍼 풀에서 삭제되며 이것이 반드시 I/O 오버헤드를 유발하는 것은 아닐 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1302">If the need for the versioned row is short-lived, it will simply get dropped from the buffer pool and may not necessarily incur I/O overhead.</span></span>  
  
### <a name="behavior-when-reading-data"></a><span data-ttu-id="9951f-1303">데이터를 읽는 경우의 동작</span><span class="sxs-lookup"><span data-stu-id="9951f-1303">Behavior When Reading Data</span></span>  

 <span data-ttu-id="9951f-1304">행 버전 관리 기반 격리 데이터 읽기 수준으로 트랜잭션이 실행되는 경우에는 읽기 작업에서 읽고 있는 데이터에 대한 공유(S) 잠금을 획득하지 못하므로 데이터를 수정하는 트랜잭션을 차단하지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1304">When transactions running under row versioning-based isolation read data, the read operations do not acquire shared (S) locks on the data being read, and therefore do not block transactions that are modifying data.</span></span> <span data-ttu-id="9951f-1305">또한 획득한 잠금 수가 감소함에 따라 리소스 잠금으로 인한 오버헤드가 최소화됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1305">Also, the overhead of locking resources is minimized as the number of locks acquired is reduced.</span></span> <span data-ttu-id="9951f-1306">행 버전 관리를 사용하는 커밋된 읽기 격리 및 스냅샷 격리는 버전이 지정된 데이터에 대해 문 수준 또는 트랜잭션 수준의 읽기 일관성을 유지하도록 디자인되었습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1306">Read committed isolation using row versioning and snapshot isolation are designed to provide statement-level or transaction-level read consistencies of versioned data.</span></span>  
  
 <span data-ttu-id="9951f-1307">행 버전 관리 기반 격리 수준에서 실행되는 트랜잭션을 포함하여 모든 쿼리는 컴파일 및 실행 중에 Sch-S(스키마 안정성) 잠금을 획득합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1307">All queries, including transactions running under row versioning-based isolation levels, acquire Sch-S (schema stability) locks during compilation and execution.</span></span> <span data-ttu-id="9951f-1308">이 때문에 동시 트랜잭션이 테이블에 대해 Sch-M(스키마 수정) 잠금을 유지하면 쿼리가 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1308">Because of this, queries are blocked when a concurrent transaction holds a Sch-M (schema modification) lock on the table.</span></span> <span data-ttu-id="9951f-1309">예를 들어 DDL(데이터 정의 언어) 작업은 테이블의 스키마 정보를 수정하기 전에 Sch-M 잠금을 획득합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1309">For example, a data definition language (DDL) operation acquires a Sch-M lock before it modifies the schema information of the table.</span></span> <span data-ttu-id="9951f-1310">행 버전 관리 기반 격리 수준에서 실행되는 쿼리 트랜잭션을 포함하여 Sch-S 잠금을 획득하려고 시도하는 쿼리 트랜잭션은 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1310">Query transactions, including those running under a row versioning-based isolation level, are blocked when attempting to acquire a Sch-S lock.</span></span> <span data-ttu-id="9951f-1311">반대로 Sch-S 잠금을 유지하는 쿼리는 Sch-M 잠금을 획득하려고 시도하는 동시 트랜잭션을 차단합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1311">Conversely, a query holding a Sch-S lock blocks a concurrent transaction that attempts to acquire a Sch-M lock.</span></span>  
  
 <span data-ttu-id="9951f-1312">스냅샷 격리 수준을 사용하는 트랜잭션이 시작되면 [!INCLUDE[ssDE](../includes/ssde-md.md)] 인스턴스에서 현재 활성화된 모든 트랜잭션을 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1312">When a transaction using the snapshot isolation level starts, the instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] records all of the currently active transactions.</span></span> <span data-ttu-id="9951f-1313">스냅샷 트랜잭션에서 버전 체인이 있는 행을 읽으면 [!INCLUDE[ssDE](../includes/ssde-md.md)]이 체인을 추적하여 다음과 같은 트랜잭션 시퀀스 번호가 있는 행을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1313">When the snapshot transaction reads a row that has a version chain, the [!INCLUDE[ssDE](../includes/ssde-md.md)] follows the chain and retrieves the row where the transaction sequence number is:</span></span>  
  
-   <span data-ttu-id="9951f-1314">행을 읽는 스냅샷 트랜잭션의 시퀀스 번호보다 낮으면서 가장 근사한 번호</span><span class="sxs-lookup"><span data-stu-id="9951f-1314">Closest to but lower than the sequence number of the snapshot transaction reading the row.</span></span>  
  
-   <span data-ttu-id="9951f-1315">스냅샷 트랜잭션이 시작되었을 때 활성화된 트랜잭션의 목록에 없는 번호</span><span class="sxs-lookup"><span data-stu-id="9951f-1315">Not in the list of the transactions active when the snapshot transaction started.</span></span>  
  
 <span data-ttu-id="9951f-1316">스냅샷 트랜잭션에 따라 수행된 읽기 작업에서는 스냅샷 트랜잭션이 시작되었을 때 커밋된 각 행의 마지막 버전을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1316">Read operations performed by a snapshot transaction retrieve the last version of each row that had been committed at the time the snapshot transaction started.</span></span> <span data-ttu-id="9951f-1317">따라서 트랜잭션의 시작 부분에 데이터가 위치하게 되므로 데이터의 스냅샷 트랜잭션이 일관되게 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1317">This provides a transactionally consistent snapshot of the data as it existed at the start of the transaction.</span></span>  
  
 <span data-ttu-id="9951f-1318">행 버전 관리가 사용된 커밋된 읽기 트랜잭션도 이와 비슷한 방식으로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1318">Read-committed transactions using row versioning operate in much the same way.</span></span> <span data-ttu-id="9951f-1319">다만 커밋된 읽기 트랜잭션에서는 행 버전을 선택할 때 고유한 트랜잭션 시퀀스 번호가 사용되지 않는다는 점이 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1319">The difference is that the read-committed transaction does not use its own transaction sequence number when choosing row versions.</span></span> <span data-ttu-id="9951f-1320">문이 시작될 때마다 커밋된 읽기 트랜잭션에서는 [!INCLUDE[ssDE](../includes/ssde-md.md)] 인스턴스에 대해 생성된 가장 최근의 트랜잭션 시퀀스 번호를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1320">Each time a statement is started, the read-committed transaction reads the latest transaction sequence number issued for that instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)].</span></span> <span data-ttu-id="9951f-1321">이 트랜잭션 시퀀스 번호는 해당 문에 대해 올바른 행 버전을 선택하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1321">This is the transaction sequence number used to select the correct row versions for that statement.</span></span> <span data-ttu-id="9951f-1322">이러한 방법으로 커밋된 읽기 트랜잭션에서 각 문의 시작 부분에 있는 데이터의 스냅샷을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1322">This allows read-committed transactions to see a snapshot of the data as it exists at the start of each statement.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9951f-1323">행 버전 관리를 사용하는 커밋된 읽기 트랜잭션은 문 수준에서 트랜잭션이 일관된 데이터 뷰를 제공하지만 이 유형의 트랜잭션에서 생성하거나 액세스한 행 버전은 해당 트랜잭션이 완료될 때까지 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1323">Even though read-committed transactions using row versioning provides a transactionally consistent view of the data at a statement level, row versions generated or accessed by this type of transaction are maintained until the transaction completes.</span></span>  
  
### <a name="behavior-when-modifying-data"></a><span data-ttu-id="9951f-1324">데이터를 수정하는 경우의 동작</span><span class="sxs-lookup"><span data-stu-id="9951f-1324">Behavior When Modifying Data</span></span>  

 <span data-ttu-id="9951f-1325">행 버전 관리가 사용되는 커밋된 읽기 트랜잭션에서는 데이터 값을 읽을 때 데이터 행에 업데이트(U) 잠금이 적용되는 차단 검색을 사용하여 업데이트할 행을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1325">In a read-committed transaction using row versioning, the selection of rows to update is done using a blocking scan where an update (U) lock is taken on the data row as data values are read.</span></span> <span data-ttu-id="9951f-1326">이것은 행 버전 관리를 사용하지 않는 커밋된 읽기 트랜잭션과 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1326">This is the same as a read-committed transaction that does not use row versioning.</span></span> <span data-ttu-id="9951f-1327">데이터 행이 업데이트 조건에 맞지 않으면 해당 행의 업데이트 잠금이 해제되고 그 다음 행이 잠겨 검색됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1327">If the data row does not meet the update criteria, the update lock is released on that row and the next row is locked and scanned.</span></span>  
  
 <span data-ttu-id="9951f-1328">스냅샷 격리 수준으로 실행되는 트랜잭션은 제약 조건을 적용하기 위해 수정 내용을 수행하기 전에 데이터에 대한 잠금을 획득하는 낙관적 데이터 수정 방법을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1328">Transactions running under snapshot isolation take an optimistic approach to data modification by acquiring locks on data before performing the modification only to enforce constraints.</span></span> <span data-ttu-id="9951f-1329">그렇지 않으면 데이터가 수정될 때까지 데이터에 대한 잠금도 획득되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1329">Otherwise, locks are not acquired on data until the data is to be modified.</span></span> <span data-ttu-id="9951f-1330">스냅샷 트랜잭션은 데이터 행이 업데이트 조건에 맞으면 이 스냅샷 트랜잭션이 시작된 후 커밋된 동시 트랜잭션에 의해 해당 데이터 행이 수정되지 않았는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1330">When a data row meets the update criteria, the snapshot transaction verifies that the data row has not been modified by a concurrent transaction that committed after the snapshot transaction began.</span></span> <span data-ttu-id="9951f-1331">스냅샷 트랜잭션이 아닌 다른 트랜잭션에 의해 데이터 행이 수정된 경우에는 업데이트 충돌이 발생하고 스냅샷 트랜잭션이 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1331">If the data row has been modified outside of the snapshot transaction, an update conflict occurs and the snapshot transaction is terminated.</span></span> <span data-ttu-id="9951f-1332">[!INCLUDE[ssDE](../includes/ssde-md.md)]은 업데이트 충돌을 처리합니다. 업데이트 충돌 검색 기능은 해제할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1332">The update conflict is handled by the [!INCLUDE[ssDE](../includes/ssde-md.md)] and there is no way to disable the update conflict detection.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9951f-1333">내부적으로 스냅샷 격리 수준으로 실행되는 업데이트 작업은 스냅샷 트랜잭션이 다음 항목에 액세스할 때는 커밋된 읽기 격리 수준으로 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1333">Update operations running under snapshot isolation internally execute under read committed isolation when the snapshot transaction accesses any of the following:</span></span>  
>   
>  <span data-ttu-id="9951f-1334">FOREIGN KEY 제약 조건이 있는 테이블</span><span class="sxs-lookup"><span data-stu-id="9951f-1334">A table with a FOREIGN KEY constraint.</span></span>  
>   
>  <span data-ttu-id="9951f-1335">다른 테이블의 FOREIGN KEY 제약 조건에서 참조되는 테이블</span><span class="sxs-lookup"><span data-stu-id="9951f-1335">A table that is referenced in the FOREIGN KEY constraint of another table.</span></span>  
>   
>  <span data-ttu-id="9951f-1336">둘 이상의 테이블을 참조하는 인덱싱된 뷰</span><span class="sxs-lookup"><span data-stu-id="9951f-1336">An indexed view referencing more than one table.</span></span>  
>   
>  <span data-ttu-id="9951f-1337">그러나 이러한 조건에서도 업데이트 작업은 다른 트랜잭션에 의해 데이터가 수정되지 않았는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1337">However, even under these conditions the update operation will continue to verify that the data has not been modified by another transaction.</span></span> <span data-ttu-id="9951f-1338">다른 트랜잭션에 의해 데이터가 수정된 경우 스냅샷 트랜잭션에서 업데이트 충돌이 발생하고 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1338">If data has been modified by another transaction, the snapshot transaction encounters an update conflict and is terminated.</span></span>  
  
### <a name="behavior-in-summary"></a><span data-ttu-id="9951f-1339">동작 요약</span><span class="sxs-lookup"><span data-stu-id="9951f-1339">Behavior in Summary</span></span>  

 <span data-ttu-id="9951f-1340">다음 표에서는 행 버전 관리를 사용하는 스냅샷 격리와 커밋된 읽기 격리의 차이점을 요약합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1340">The following table summarizes the differences between snapshot isolation and read committed isolation using row versioning.</span></span>  
  
|<span data-ttu-id="9951f-1341">속성</span><span class="sxs-lookup"><span data-stu-id="9951f-1341">Property</span></span>|<span data-ttu-id="9951f-1342">행 버전 관리를 사용하는 커밋된 읽기 격리 수준</span><span class="sxs-lookup"><span data-stu-id="9951f-1342">Read-committed isolation level using row versioning</span></span>|<span data-ttu-id="9951f-1343">스냅샷 격리 수준</span><span class="sxs-lookup"><span data-stu-id="9951f-1343">Snapshot isolation level</span></span>|  
|--------------|----------------------------------------------------------|------------------------------|  
|<span data-ttu-id="9951f-1344">지원 요구 사항에 따라 ON으로 설정되어야 하는 데이터베이스 옵션</span><span class="sxs-lookup"><span data-stu-id="9951f-1344">The database option that must be set to ON to enable the required support.</span></span>|<span data-ttu-id="9951f-1345">READ_COMMITTED_SNAPSHOT</span><span class="sxs-lookup"><span data-stu-id="9951f-1345">READ_COMMITTED_SNAPSHOT</span></span>|<span data-ttu-id="9951f-1346">ALLOW_SNAPSHOT_ISOLATION</span><span class="sxs-lookup"><span data-stu-id="9951f-1346">ALLOW_SNAPSHOT_ISOLATION</span></span>|  
|<span data-ttu-id="9951f-1347">세션에서 특정한 유형의 행 버전 관리를 요청하는 방법</span><span class="sxs-lookup"><span data-stu-id="9951f-1347">How a session requests the specific type of row versioning.</span></span>|<span data-ttu-id="9951f-1348">기본 커밋된 읽기 격리 수준을 사용하거나 SET TRANSACTION ISOLATION LEVEL 문을 실행하여 READ COMMITTED 격리 수준을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1348">Use the default read-committed isolation level, or run the SET TRANSACTION ISOLATION LEVEL statement to specify the READ COMMITTED isolation level.</span></span> <span data-ttu-id="9951f-1349">이 작업은 트랜잭션이 시작된 후에 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1349">This can be done after the transaction starts.</span></span>|<span data-ttu-id="9951f-1350">트랜잭션이 시작되기 전에 SET TRANSACTION ISOLATION LEVEL 문을 실행하여 SNAPSHOT 격리 수준을 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1350">Requires the execution of SET TRANSACTION ISOLATION LEVEL to specify the SNAPSHOT isolation level before the start of the transaction.</span></span>|  
|<span data-ttu-id="9951f-1351">문에서 읽는 데이터의 버전</span><span class="sxs-lookup"><span data-stu-id="9951f-1351">The version of data read by statements.</span></span>|<span data-ttu-id="9951f-1352">각 문이 시작되기 전에 커밋된 모든 데이터</span><span class="sxs-lookup"><span data-stu-id="9951f-1352">All data that was committed before the start of each statement.</span></span>|<span data-ttu-id="9951f-1353">각 트랜잭션이 시작되기 전에 커밋된 모든 데이터</span><span class="sxs-lookup"><span data-stu-id="9951f-1353">All data that was committed before the start of each transaction.</span></span>|  
|<span data-ttu-id="9951f-1354">업데이트 처리 방법</span><span class="sxs-lookup"><span data-stu-id="9951f-1354">How updates are handled.</span></span>|<span data-ttu-id="9951f-1355">행 버전을 실제 데이터로 변환하여 업데이트할 행을 선택하고 선택한 데이터 행에 업데이트 잠금을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1355">Reverts from row versions to actual data to select rows to update and uses update locks on the data rows selected.</span></span> <span data-ttu-id="9951f-1356">수정할 실제 데이터 행에 대해 배타적 잠금을 획득합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1356">Acquires exclusive locks on actual data rows to be modified.</span></span> <span data-ttu-id="9951f-1357">업데이트 충돌 검색은 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1357">No update conflict detection.</span></span>|<span data-ttu-id="9951f-1358">행 버전을 사용하여 업데이트할 행을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1358">Uses row versions to select rows to update.</span></span> <span data-ttu-id="9951f-1359">수정할 실제 데이터 행에 대해 배타적 잠금을 획득하려고 시도합니다. 데이터가 다른 트랜잭션에 의해 이미 수정된 경우에는 업데이트 충돌이 발생하며 스냅샷 트랜잭션이 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1359">Tries to acquire an exclusive lock on the actual data row to be modified, and if the data has been modified by another transaction, an update conflict occurs and the snapshot transaction is terminated.</span></span>|  
|<span data-ttu-id="9951f-1360">업데이트 충돌 검색</span><span class="sxs-lookup"><span data-stu-id="9951f-1360">Update conflict detection.</span></span>|<span data-ttu-id="9951f-1361">없음</span><span class="sxs-lookup"><span data-stu-id="9951f-1361">None.</span></span>|<span data-ttu-id="9951f-1362">통합 지원되며</span><span class="sxs-lookup"><span data-stu-id="9951f-1362">Integrated support.</span></span> <span data-ttu-id="9951f-1363">해제할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1363">Cannot be disabled.</span></span>|  
  
### <a name="row-versioning-resource-usage"></a><span data-ttu-id="9951f-1364">행 버전 관리 리소스 사용</span><span class="sxs-lookup"><span data-stu-id="9951f-1364">Row Versioning Resource Usage</span></span>  

 <span data-ttu-id="9951f-1365">행 버전 관리 프레임워크는 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]의 다음 기능을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1365">The row versioning framework supports the following features available in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]:</span></span>  
  
-   <span data-ttu-id="9951f-1366">트리거</span><span class="sxs-lookup"><span data-stu-id="9951f-1366">Triggers</span></span>  
  
-   <span data-ttu-id="9951f-1367">MARS(Multiple Active Results Sets)</span><span class="sxs-lookup"><span data-stu-id="9951f-1367">Multiple Active Results Sets (MARS)</span></span>  
  
-   <span data-ttu-id="9951f-1368">온라인 인덱싱</span><span class="sxs-lookup"><span data-stu-id="9951f-1368">Online indexing</span></span>  
  
 <span data-ttu-id="9951f-1369">또한 행 버전 관리 프레임워크는 다음 행 버전 관리 기반 트랜잭션 격리 수준을 지원합니다. 이러한 격리 수준은 기본적으로 설정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1369">The row versioning framework also supports the following row versioning-based transaction isolation levels, which by default are not enabled:</span></span>  
  
-   <span data-ttu-id="9951f-1370">READ_COMMITTED_SNAPSHOT 데이터베이스 옵션이 ON이면 READ_COMMITTED 트랜잭션이 행 버전 관리를 사용하여 문 수준의 읽기 일관성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1370">When the READ_COMMITTED_SNAPSHOT database option is ON, READ_COMMITTED transactions provide statement-level read consistency using row versioning.</span></span>  
  
-   <span data-ttu-id="9951f-1371">ALLOW_SNAPSHOT_ISOLATION 데이터베이스 옵션이 ON이면 SNAPSHOT 트랜잭션이 행 버전 관리를 사용하여 트랜잭션 수준의 읽기 일관성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1371">When the ALLOW_SNAPSHOT_ISOLATION database option is ON, SNAPSHOT transactions provide transaction-level read consistency using row versioning.</span></span>  
  
 <span data-ttu-id="9951f-1372">행 버전 관리 기반 격리 수준을 이용하면 읽기 작업에 대해 공유 잠금을 사용하지 않아도 되므로 트랜잭션에 의해 확보되는 잠금 수가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1372">Row versioning-based isolation levels reduce the number of locks acquired by transaction by eliminating the use of shared locks on read operations.</span></span> <span data-ttu-id="9951f-1373">결과적으로 잠금 관리에 사용되는 리소스가 줄어 시스템 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1373">This increases system performance by reducing the resources used to manage locks.</span></span> <span data-ttu-id="9951f-1374">또한 다른 트랜잭션에 의해 확보된 잠금으로 인해 트랜잭션이 차단되는 횟수도 줄어 성능이 한층 더 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1374">Performance is also increased by reducing the number of times a transaction is blocked by locks acquired by other transactions.</span></span>  
  
 <span data-ttu-id="9951f-1375">행 버전 관리 기반 격리 수준을 이용하면 데이터 수정에 필요한 리소스가 늘어납니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1375">Row versioning-based isolation levels increase the resources needed by data modifications.</span></span> <span data-ttu-id="9951f-1376">이 옵션을 설정하면 데이터베이스의 모든 데이터 수정에 대해 버전이 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1376">Enabling these options causes all data modifications for the database to be versioned.</span></span> <span data-ttu-id="9951f-1377">행 버전 관리 기반 격리를 사용하는 활성 트랜잭션이 없는 경우에도 수정 전에 데이터의 복사본이 tempdb에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1377">A copy of the data before modification is stored in tempdb even when there are no active transactions using row versioning-based isolation.</span></span> <span data-ttu-id="9951f-1378">수정 후의 데이터에는 tempdb에 저장된 버전 지정 데이터에 대한 포인터가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1378">The data after modification includes a pointer to the versioned data stored in tempdb.</span></span> <span data-ttu-id="9951f-1379">큰 개체의 경우 개체의 변경된 부분만 tempdb에 복사됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1379">For large objects, only part of the object that changed is copied to tempdb.</span></span>  
  
#### <a name="space-used-in-tempdb"></a><span data-ttu-id="9951f-1380">tempdb의 사용된 공간</span><span class="sxs-lookup"><span data-stu-id="9951f-1380">Space Used in tempdb</span></span>  

 <span data-ttu-id="9951f-1381">각 [!INCLUDE[ssDE](../includes/ssde-md.md)] 인스턴스의 tempdb에는 해당 인스턴스의 모든 데이터베이스에 대해 생성된 행 버전을 보유할 수 있는 공간이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1381">For each instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)], tempdb must have enough space to hold the row versions generated for every database in the instance.</span></span> <span data-ttu-id="9951f-1382">데이터베이스 관리자는 tempdb에 버전 저장소를 포함할 수 있는 충분한 공간이 있는지를 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1382">The database administrator must ensure that tempdb has ample space to support the version store.</span></span> <span data-ttu-id="9951f-1383">tempdb에는 다음의 두 버전 저장소가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1383">There are two version stores in tempdb:</span></span>  
  
-   <span data-ttu-id="9951f-1384">온라인 인덱스 작성 버전 저장소는 모든 데이터베이스의 온라인 인덱스 작성에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1384">The online index build version store is used for online index builds in all databases.</span></span>  
  
-   <span data-ttu-id="9951f-1385">공용 버전 저장소는 모든 데이터베이스의 다른 모든 데이터 수정 작업에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1385">The common version store is used for all other data modification operations in all databases.</span></span>  
  
 <span data-ttu-id="9951f-1386">활성 트랜잭션에서 행 버전에 액세스해야 하는 동안에는 행 버전이 저장되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1386">Row versions must be stored for as long as an active transaction needs to access it.</span></span> <span data-ttu-id="9951f-1387">1분마다 백그라운드 스레드가 필요 없게 된 행 버전을 제거하여 tempdb에서 공간을 비웁니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1387">Once every minute, a background thread removes row versions that are no longer needed and frees up the version space in tempdb.</span></span> <span data-ttu-id="9951f-1388">다음 중 하나에 해당될 경우 장기 실행 트랜잭션은 버전 저장소의 공간이 해제되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1388">A long-running transaction prevents space in the version store from being released if it meets any of the following conditions:</span></span>  
  
-   <span data-ttu-id="9951f-1389">행 버전 관리 기반 격리를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1389">It uses row versioning-based isolation.</span></span>  
  
-   <span data-ttu-id="9951f-1390">트리거, MARS 또는 온라인 인덱스 작성 작업을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1390">It uses triggers, MARS, or online index build operations.</span></span>  
  
-   <span data-ttu-id="9951f-1391">행 버전을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1391">It generates row versions.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9951f-1392">트랜잭션 내부에서 트리거를 호출하면 해당 트리거에 의해 생성된 행 버전은 트리거가 완료된 후 행 버전이 더 이상 필요하지 않아도 트랜잭션이 끝날 때까지 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1392">When a trigger is invoked inside a transaction, the row versions created by the trigger are maintained until the end of the transaction, even though the row versions are no longer needed after the trigger completes.</span></span> <span data-ttu-id="9951f-1393">이는 행 버전 관리를 사용하는 커밋된 읽기 트랜잭션에도 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1393">This also applies to read-committed transactions that use row versioning.</span></span> <span data-ttu-id="9951f-1394">이 유형의 트랜잭션에서는 트랜잭션의 각 문에 대해서만 데이터베이스의 트랜잭션 뷰가 일치해야 하므로</span><span class="sxs-lookup"><span data-stu-id="9951f-1394">With this type of transaction, a transactionally consistent view of the database is needed only for each statement in the transaction.</span></span> <span data-ttu-id="9951f-1395">문이 완료된 후에는 트랜잭션의 문에 대해 생성된 행 버전이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1395">This means that the row versions created for a statement in the transaction are no longer needed after the statement completes.</span></span> <span data-ttu-id="9951f-1396">그러나 트랜잭션의 각 문에 의해 생성된 행 버전은 트랜잭션이 완료될 때까지 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1396">However, row versions created by each statement in the transaction are maintained until the transaction completes.</span></span>  
  
 <span data-ttu-id="9951f-1397">tempdb의 공간이 부족하면 [!INCLUDE[ssDE](../includes/ssde-md.md)]에서 버전 저장소를 강제로 축소합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1397">When tempdb runs out of space, the [!INCLUDE[ssDE](../includes/ssde-md.md)] forces the version stores to shrink.</span></span> <span data-ttu-id="9951f-1398">축소하는 동안, 아직 행 버전을 생성하지 않은 트랜잭션 중 장기 실행 트랜잭션은 교착 상태가 발생한 것으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1398">During the shrink process, the longest running transactions that have not yet generated row versions are marked as victims.</span></span> <span data-ttu-id="9951f-1399">오류 로그에는 교착 상태가 발생한 각 트랜잭션에 대해 메시지 3967이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1399">A message 3967 is generated in the error log for each victim transaction.</span></span> <span data-ttu-id="9951f-1400">교착 상태가 발생한 것으로 표시된 트랜잭션은 버전 저장소의 행 버전을 더 이상 읽을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1400">If a transaction is marked as a victim, it can no longer read the row versions in the version store.</span></span> <span data-ttu-id="9951f-1401">행 버전을 읽으려고 하면 메시지 3966이 생성되고 트랜잭션이 롤백됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1401">When it attempts to read row versions, message 3966 is generated and the transaction is rolled back.</span></span> <span data-ttu-id="9951f-1402">축소하는 데 성공하면 tempdb에서 공간을 사용할 수 있게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1402">If the shrinking process succeeds, space becomes available in tempdb.</span></span> <span data-ttu-id="9951f-1403">그렇지 않으면 tempdb의 공간이 부족해지고 다음과 같은 상황이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1403">Otherwise, tempdb runs out of space and the following occurs:</span></span>  
  
-   <span data-ttu-id="9951f-1404">쓰기 작업이 계속 실행되지만 버전을 생성하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1404">Write operations continue to execute but do not generate versions.</span></span> <span data-ttu-id="9951f-1405">오류 로그에 정보 메시지(3959)가 나타납니다. 데이터를 기록한 트랜잭션은 영향을 받지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1405">An information message (3959) appears in the error log, but the transaction that writes data is not affected.</span></span>  
  
-   <span data-ttu-id="9951f-1406">tempdb의 완전 롤백으로 인해 생성되지 않은 행 버전에 액세스하려고 하는 트랜잭션은 오류 3958과 함께 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1406">Transactions that attempt to access row versions that were not generated because of a tempdb full rollback terminate with an error 3958.</span></span>  
  
#### <a name="space-used-in-data-rows"></a><span data-ttu-id="9951f-1407">데이터 행의 공간 사용량</span><span class="sxs-lookup"><span data-stu-id="9951f-1407">Space Used in Data Rows</span></span>  

 <span data-ttu-id="9951f-1408">각 데이터베이스 행의 행 끝에서 최대 14바이트를 사용하여 행 버전 관리 정보를 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1408">Each database row may use up to 14 bytes at the end of the row for row versioning information.</span></span> <span data-ttu-id="9951f-1409">행 버전 관리 정보에는 버전을 커밋한 트랜잭션의 트랜잭션 시퀀스 번호와 버전이 지정된 행에 대한 포인터가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1409">The row versioning information contains the transaction sequence number of the transaction that committed the version and the pointer to the versioned row.</span></span> <span data-ttu-id="9951f-1410">이 14바이트는 다음과 같은 조건에서 행이 처음 수정될 때 또는 새 행이 삽입될 때 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1410">These 14 bytes are added the first time the row is modified, or when a new row is inserted, under any of these conditions:</span></span>  
  
-   <span data-ttu-id="9951f-1411">READ_COMMITTED_SNAPSHOT 또는 ALLOW_SNAPSHOT_ISOLATION 옵션이 ON입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1411">READ_COMMITTED_SNAPSHOT or ALLOW_SNAPSHOT_ISOLATION options are ON.</span></span>  
  
-   <span data-ttu-id="9951f-1412">테이블에 트리거가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1412">The table has a trigger.</span></span>  
  
-   <span data-ttu-id="9951f-1413">MARS(Multiple Active Results Sets)를 사용하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1413">Multiple Active Results Sets (MARS) is being used.</span></span>  
  
-   <span data-ttu-id="9951f-1414">테이블에서 현재 온라인 인덱스 작성 작업이 실행되고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1414">Online index build operations are currently running on the table.</span></span>  
  
 <span data-ttu-id="9951f-1415">이 14바이트는 다음과 같은 조건에서 행이 처음 수정될 때 데이터베이스 행에서 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1415">These 14 bytes are removed from the database row the first time the row is modified under all of these conditions:</span></span>  
  
-   <span data-ttu-id="9951f-1416">READ_COMMITTED_SNAPSHOT 및 ALLOW_SNAPSHOT_ISOLATION 옵션이 OFF입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1416">READ_COMMITTED_SNAPSHOT and ALLOW_SNAPSHOT_ISOLATION options are OFF.</span></span>  
  
-   <span data-ttu-id="9951f-1417">테이블에 트리거가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1417">The trigger no longer exists on the table.</span></span>  
  
-   <span data-ttu-id="9951f-1418">MARS를 사용하고 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1418">MARS is not being used.</span></span>  
  
-   <span data-ttu-id="9951f-1419">현재 온라인 인덱스 작성 작업이 실행되고 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1419">Online index build operations are not currently running.</span></span>  
  
 <span data-ttu-id="9951f-1420">행 버전 관리 기능을 사용하는 경우에는 데이터베이스 행당 14바이트를 사용할 수 있도록 데이터베이스에 더 많은 디스크 공간을 할당해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1420">If you use any of the row versioning features, you might need to allocate additional disk space for the database to accommodate the 14 bytes per database row.</span></span> <span data-ttu-id="9951f-1421">행 버전 관리 정보를 추가하면 인덱스 페이지가 분할되거나 현재 페이지에 사용 가능한 공간이 충분하지 않은 경우에는 새 데이터 페이지가 할당될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1421">Adding the row versioning information can cause index page splits or the allocation of a new data page if there is not enough space available on the current page.</span></span> <span data-ttu-id="9951f-1422">예를 들어 평균 행 길이가 100바이트인 경우 14바이트를 추가하면 기존 테이블이 최대 14% 증가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1422">For example, if the average row length is 100 bytes, the additional 14 bytes cause an existing table to grow up to 14 percent.</span></span>  
  
 <span data-ttu-id="9951f-1423">[채우기 비율](../relational-databases/indexes/specify-fill-factor-for-an-index.md)을 낮추면 인덱스 페이지의 조각화를 방지하거나 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1423">Decreasing the [fill factor](../relational-databases/indexes/specify-fill-factor-for-an-index.md) might help to prevent or decrease fragmentation of index pages.</span></span> <span data-ttu-id="9951f-1424">테이블 또는 뷰의 데이터 및 인덱스에 대 한 조각화 정보를 보려면 [DBCC SHOWCONTIG](/sql/t-sql/database-console-commands/dbcc-showcontig-transact-sql)를 사용 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1424">To view fragmentation information for the data and indexes of a table or view, you can use [DBCC SHOWCONTIG](/sql/t-sql/database-console-commands/dbcc-showcontig-transact-sql).</span></span>  
  
#### <a name="space-used-in-large-objects"></a><span data-ttu-id="9951f-1425">큰 개체의 공간 사용량</span><span class="sxs-lookup"><span data-stu-id="9951f-1425">Space Used in Large Objects</span></span>  

 <span data-ttu-id="9951f-1426">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]에서는 최대 2GB의 큰 문자열을 저장할 수 있는 6개의 데이터 형식을 지원합니다. 6개의 데이터 형식은 `nvarchar(max)`, `varchar(max)`, `varbinary(max)`, `ntext`, `text` 및 `image`입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1426">The [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] supports six data types that can hold large strings up to 2 gigabytes (GB) in length: `nvarchar(max)`, `varchar(max)`, `varbinary(max)`, `ntext`, `text`, and `image`.</span></span> <span data-ttu-id="9951f-1427">이러한 데이터 형식을 사용하여 저장된 큰 문자열은 데이터 행에 연결된 일련의 데이터 조각에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1427">Large strings stored using these data types are stored in a series of data fragments that are linked to the data row.</span></span> <span data-ttu-id="9951f-1428">행 버전 관리 정보는 큰 문자열이 저장된 각 조각에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1428">Row versioning information is stored in each fragment used to store these large strings.</span></span> <span data-ttu-id="9951f-1429">데이터 조각은 테이블의 큰 개체에만 사용되는 페이지의 모음입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1429">Data fragments are a collection of pages dedicated to large objects in a table.</span></span>  
  
 <span data-ttu-id="9951f-1430">데이터베이스에 새로 큰 값이 추가될 때 조각당 최대 8040바이트의 데이터가 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1430">As new large values are added to a database, they are allocated using a maximum of 8040 bytes of data per fragment.</span></span> <span data-ttu-id="9951f-1431">이전 버전의 [!INCLUDE[ssDE](../includes/ssde-md.md)]에서는 조각당 최대 8080바이트의 `ntext`, `text` 또는 `image` 데이터를 저장했습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1431">Earlier versions of the [!INCLUDE[ssDE](../includes/ssde-md.md)] stored up to 8080 bytes of `ntext`, `text`, or `image` data per fragment.</span></span>  
  
 <span data-ttu-id="9951f-1432">이전 버전의 `ntext`에서 `text`로 데이터베이스를 업그레이드한 경우에는 행 버전 관리 정보를 저장할 공간을 만들기 위해 기존 `image`, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 및 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] LOB(Large Object) 데이터가 업데이트되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1432">Existing `ntext`, `text`, and `image` large object (LOB) data is not updated to make space for the row versioning information when a database is upgraded to [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] from an earlier version of [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="9951f-1433">그러나 LOB 데이터가 처음 수정될 때는 버전 관리 정보를 스토리지할 수 있도록 데이터가 동적으로 업그레이드됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1433">However, the first time the LOB data is modified, it is dynamically upgraded to enable storage of versioning information.</span></span> <span data-ttu-id="9951f-1434">이는 행 버전이 생성되지 않은 경우에도 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1434">This will happen even if row versions are not generated.</span></span> <span data-ttu-id="9951f-1435">LOB 데이터가 업그레이드된 후에는 조각당 저장되는 최대 바이트 수가 8080바이트에서 8040바이트로 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1435">After the LOB data is upgraded, the maximum number of bytes stored per fragment is reduced from 8080 bytes to 8040 bytes.</span></span> <span data-ttu-id="9951f-1436">업그레이드 프로세스에서는 LOB 값을 삭제하고 동일한 값을 다시 삽입합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1436">The upgrade process is equivalent to deleting the LOB value and reinserting the same value.</span></span> <span data-ttu-id="9951f-1437">1바이트만 수정되더라도 LOB 데이터가 업그레이드됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1437">The LOB data is upgraded even if only one byte is modified.</span></span> <span data-ttu-id="9951f-1438">이 작업은 각 `ntext`, `text` 또는 `image` 열에 대해 한 번 수행되지만 LOB 데이터의 크기에 따라 각 작업 수행 시 대량의 페이지 할당 및 I/O 작업이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1438">This is a one-time operation for each `ntext`, `text`, or `image` column, but each operation may generate a large amount of page allocations and I/O activity depending upon the size of the LOB data.</span></span> <span data-ttu-id="9951f-1439">수정 내용 전체가 로깅되는 경우에는 대량의 로깅 작업이 발생할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1439">It may also generate a large amount of logging activity if the modification is fully logged.</span></span> <span data-ttu-id="9951f-1440">데이터베이스 복구 모드를 FULL로 설정하지 않으면 WRITETEXT와 UPDATETEXT 작업에서 최소한의 정보만 로깅합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1440">WRITETEXT and UPDATETEXT operations are minimally logged if database recovery mode is not set to FULL.</span></span>  
  
 <span data-ttu-id="9951f-1441">`nvarchar(max)`, `varchar(max)` 및 `varbinary(max)` 데이터 형식은 이전 버전의 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]에서는 사용할 수 없으므로</span><span class="sxs-lookup"><span data-stu-id="9951f-1441">The `nvarchar(max)`, `varchar(max)`, and `varbinary(max)` data types are not available in earlier versions of [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="9951f-1442">업그레이드 문제가 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1442">Therefore, they have no upgrade issues.</span></span>  
  
 <span data-ttu-id="9951f-1443">이 요구 사항을 충족하는 충분한 디스크 공간을 할당해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1443">Enough disk space should be allocated to accommodate this requirement.</span></span>  
  
#### <a name="monitoring-row-versioning-and-the-version-store"></a><span data-ttu-id="9951f-1444">행 버전 관리 및 버전 저장소 모니터링</span><span class="sxs-lookup"><span data-stu-id="9951f-1444">Monitoring Row Versioning and the Version Store</span></span>  

 <span data-ttu-id="9951f-1445">행 버전 관리, 버전 저장소 및 스냅샷 격리 프로세스의 성능과 문제를 모니터링하기 위해 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]에서는 DMV(동적 관리 뷰) 및 Windows 시스템 모니터의 성능 카운터 형태로 도구를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1445">For monitoring row versioning, version store, and snapshot isolation processes for performance and problems, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] provides tools in the form of Dynamic Management Views (DMVs) and performance counters in Windows System Monitor.</span></span>  
  
##### <a name="dmvs"></a><span data-ttu-id="9951f-1446">DMV</span><span class="sxs-lookup"><span data-stu-id="9951f-1446">DMVs</span></span>  

 <span data-ttu-id="9951f-1447">다음 DMV는 tempdb와 버전 저장소 및 행 버전 관리를 사용하는 트랜잭션의 현재 상태에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1447">The following DMVs provide information about the current system state of tempdb and the version store, as well as transactions using row versioning.</span></span>  
  
 <span data-ttu-id="9951f-1448">sys.dm_db_file_space_usage.</span><span class="sxs-lookup"><span data-stu-id="9951f-1448">sys.dm_db_file_space_usage.</span></span> <span data-ttu-id="9951f-1449">데이터베이스의 각 파일에 대한 공간 사용량 정보를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1449">Returns space usage information for each file in the database.</span></span> <span data-ttu-id="9951f-1450">자세한 내용은 [sys.dm_db_file_space_usage &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-file-space-usage-transact-sql)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-1450">For more information, see [sys.dm_db_file_space_usage &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-file-space-usage-transact-sql).</span></span>  
  
 <span data-ttu-id="9951f-1451">sys.dm_db_session_space_usage.</span><span class="sxs-lookup"><span data-stu-id="9951f-1451">sys.dm_db_session_space_usage.</span></span> <span data-ttu-id="9951f-1452">데이터베이스에서 발생하는 세션별 페이지 할당 및 할당 취소 작업을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1452">Returns page allocation and deallocation activity by session for the database.</span></span> <span data-ttu-id="9951f-1453">자세한 내용은 [sys.dm_db_session_space_usage&#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-session-space-usage-transact-sql)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-1453">For more information, see [sys.dm_db_session_space_usage &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-session-space-usage-transact-sql).</span></span>  
  
 <span data-ttu-id="9951f-1454">sys.dm_db_task_space_usage.</span><span class="sxs-lookup"><span data-stu-id="9951f-1454">sys.dm_db_task_space_usage.</span></span> <span data-ttu-id="9951f-1455">데이터베이스에서 발생하는 태스크별로 페이지 할당 및 할당 취소 작업을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1455">Returns page allocation and deallocation activity by task for the database.</span></span> <span data-ttu-id="9951f-1456">자세한 내용은 [sys.dm_db_task_space_usage&#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-task-space-usage-transact-sql)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-1456">For more information, see [sys.dm_db_task_space_usage &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-task-space-usage-transact-sql).</span></span>  
  
 <span data-ttu-id="9951f-1457">sys.dm_tran_top_version_generators.</span><span class="sxs-lookup"><span data-stu-id="9951f-1457">sys.dm_tran_top_version_generators.</span></span> <span data-ttu-id="9951f-1458">버전 저장소의 버전 대부분을 생성하는 개체에 대한 가상 테이블을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1458">Returns a virtual table for the objects producing the most versions in the version store.</span></span> <span data-ttu-id="9951f-1459">256개의 집계 레코드 길이를 database_id 및 rowset_id에 따라 그룹화합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1459">It groups the top 256 aggregated record lengths by database_id and rowset_id.</span></span> <span data-ttu-id="9951f-1460">이 함수를 사용하면 버전 저장소를 가장 많이 사용하는 소비자를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1460">Use this function to find the largest consumers of the version store.</span></span> <span data-ttu-id="9951f-1461">자세한 내용은 [sys.dm_tran_top_version_generators&#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-top-version-generators-transact-sql)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-1461">For more information, see [sys.dm_tran_top_version_generators &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-top-version-generators-transact-sql).</span></span>  
  
 <span data-ttu-id="9951f-1462">sys.dm_tran_version_store.</span><span class="sxs-lookup"><span data-stu-id="9951f-1462">sys.dm_tran_version_store.</span></span> <span data-ttu-id="9951f-1463">공용 버전 저장소의 모든 버전 레코드를 표시하는 가상 테이블을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1463">Returns a virtual table that displays all version records in the common version store.</span></span> <span data-ttu-id="9951f-1464">자세한 내용은 [sys.dm_tran_version_store&#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-version-store-transact-sql)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-1464">For more information, see [sys.dm_tran_version_store &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-version-store-transact-sql).</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9951f-1465">sys.dm_tran_top_version_generators와 sys.dm_tran_version_store 함수는 버전 저장소 전체를 쿼리하므로 버전 저장소의 크기가 클 경우에는 실행하는 데 비용이 많이 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1465">sys.dm_tran_top_version_generators and sys.dm_tran_version_store are potentially very expensive functions to run, since both query the entire version store, which could be very large.</span></span>  
  
 <span data-ttu-id="9951f-1466">sys.dm_tran_active_snapshot_database_transactions.</span><span class="sxs-lookup"><span data-stu-id="9951f-1466">sys.dm_tran_active_snapshot_database_transactions.</span></span> <span data-ttu-id="9951f-1467">행 버전 관리를 사용하는 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 인스턴스 내의 모든 데이터베이스에 있는 전체 활성 트랜잭션에 대한 가상 테이블을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1467">Returns a virtual table for all active transactions in all databases within the [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] instance that use row versioning.</span></span> <span data-ttu-id="9951f-1468">시스템 트랜잭션은 이 DMV에 나타나지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1468">System transactions do not appear in this DMV.</span></span> <span data-ttu-id="9951f-1469">자세한 내용은 [sys.dm_tran_active_snapshot_database_transactions&#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-active-snapshot-database-transactions-transact-sql)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-1469">For more information, see [sys.dm_tran_active_snapshot_database_transactions &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-active-snapshot-database-transactions-transact-sql).</span></span>  
  
 <span data-ttu-id="9951f-1470">sys.dm_tran_transactions_snapshot.</span><span class="sxs-lookup"><span data-stu-id="9951f-1470">sys.dm_tran_transactions_snapshot.</span></span> <span data-ttu-id="9951f-1471">각 트랜잭션에서 사용한 스냅샷을 표시하는 가상 테이블을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1471">Returns a virtual table that displays snapshots taken by each transaction.</span></span> <span data-ttu-id="9951f-1472">스냅샷에는 행 버전 관리를 사용하는 활성 트랜잭션의 시퀀스 번호가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1472">The snapshot contains the sequence number of the active transactions that use row versioning.</span></span> <span data-ttu-id="9951f-1473">자세한 내용은 [sys.dm_tran_transactions_snapshot&#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-transactions-snapshot-transact-sql)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-1473">For more information, see [sys.dm_tran_transactions_snapshot &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-transactions-snapshot-transact-sql).</span></span>  
  
 <span data-ttu-id="9951f-1474">sys.dm_tran_current_transaction.</span><span class="sxs-lookup"><span data-stu-id="9951f-1474">sys.dm_tran_current_transaction.</span></span> <span data-ttu-id="9951f-1475">현재 세션에 있는 트랜잭션의 행 버전 관리 관련 상태 정보를 표시하는 단일 행을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1475">Returns a single row that displays row versioning-related state information of the transaction in the current session.</span></span> <span data-ttu-id="9951f-1476">자세한 내용은 [sys.dm_tran_current_transaction&#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-current-transaction-transact-sql)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-1476">For more information, see [sys.dm_tran_current_transaction &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-current-transaction-transact-sql).</span></span>  
  
 <span data-ttu-id="9951f-1477">sys.dm_tran_current_snapshot.</span><span class="sxs-lookup"><span data-stu-id="9951f-1477">sys.dm_tran_current_snapshot.</span></span> <span data-ttu-id="9951f-1478">현재 스냅샷 격리 트랜잭션이 시작될 때의 모든 활성 트랜잭션을 표시하는 가상 테이블을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1478">Returns a virtual table that displays all active transactions at the time the current snapshot isolation transaction starts.</span></span> <span data-ttu-id="9951f-1479">현재 트랜잭션에서 스냅샷 격리를 사용중인 경우 이 함수는 행을 반환하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1479">If the current transaction is using snapshot isolation, this function returns no rows.</span></span> <span data-ttu-id="9951f-1480">sys.dm_tran_current_snapshot이 현재 스냅샷에 대한 활성 트랜잭션만 반환한다는 점을 제외하고 sys.dm_tran_transactions_snapshot과 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1480">sys.dm_tran_current_snapshot is similar to sys.dm_tran_transactions_snapshot, except that it returns only the active transactions for the current snapshot.</span></span> <span data-ttu-id="9951f-1481">자세한 내용은 [sys.dm_tran_current_snapshot&#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-current-snapshot-transact-sql)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-1481">For more information, see [sys.dm_tran_current_snapshot &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-current-snapshot-transact-sql).</span></span>  
  
##### <a name="performance-counters"></a><span data-ttu-id="9951f-1482">성능 카운터</span><span class="sxs-lookup"><span data-stu-id="9951f-1482">Performance Counters</span></span>  

 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] <span data-ttu-id="9951f-1483">성능 카운터는 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 프로세스의 영향을 받는 시스템 성능에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1483">performance counters provide information about the system performance impacted by [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] processes.</span></span> <span data-ttu-id="9951f-1484">다음 성능 카운터는 tempdb와 버전 저장소 및 행 버전 관리를 사용하는 트랜잭션을 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1484">The following performance counters monitor tempdb and the version store, as well as transactions using row versioning.</span></span> <span data-ttu-id="9951f-1485">이러한 성능 카운터는 SQLServer:Transactions 성능 개체에 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1485">The performance counters are contained in the SQLServer:Transactions performance object.</span></span>  
  
 <span data-ttu-id="9951f-1486">**Free Space in tempdb (KB)** .</span><span class="sxs-lookup"><span data-stu-id="9951f-1486">**Free Space in tempdb (KB)**.</span></span> <span data-ttu-id="9951f-1487">tempdb 데이터베이스의 사용 가능한 공간(KB)을 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1487">Monitors the amount, in kilobytes (KB), of free space in the tempdb database.</span></span> <span data-ttu-id="9951f-1488">tempdb에는 스냅샷 격리를 지원하는 버전 저장소를 처리하기에 충분한 공간이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1488">There must be enough free space in tempdb to handle the version store that supports snapshot isolation.</span></span>  
  
 <span data-ttu-id="9951f-1489">다음 공식을 사용하여 버전 저장소의 예상 크기를 대략적으로 계산할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1489">The following formula provides a rough estimate of the size of the version store.</span></span> <span data-ttu-id="9951f-1490">장기 실행 트랜잭션의 경우 생성 및 정리 속도를 모니터링하여 버전 저장소의 예상 최대 크기를 결정하면 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1490">For long-running transactions, it may be useful to monitor the generation and cleanup rate to estimate the maximum size of the version store.</span></span>  
  
 <span data-ttu-id="9951f-1491">[공용 버전 저장소의 크기] = 2 \* [분당 생성되는 버전 저장소 데이터] \* [트랜잭션의 최장 실행 시간(분)]</span><span class="sxs-lookup"><span data-stu-id="9951f-1491">[size of common version store] = 2 \* [version store data generated per minute] \* [longest running time (minutes) of the transaction]</span></span>  
  
 <span data-ttu-id="9951f-1492">트랜잭션의 최장 실행 시간에는 온라인 인덱스 작성이 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1492">The longest running time of transactions should not include online index builds.</span></span> <span data-ttu-id="9951f-1493">큰 테이블의 경우 온라인 인덱스 작성 작업에 많은 시간이 소요되므로 이 작업은 별도의 버전 저장소를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1493">Because these operations may take a long time on very large tables, online index builds use a separate version store.</span></span> <span data-ttu-id="9951f-1494">온라인 인덱스 작성 버전 저장소의 크기는 온라인 인덱스 작성을 수행하는 동안 모든 인덱스를 포함하여 테이블에서 수정된 전체 데이터 양과 거의 같습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1494">The approximate size of the online index build version store equals the amount of data modified in the table, including all indexes, while the online index build is active.</span></span>  
  
 <span data-ttu-id="9951f-1495">**Version Store Size (KB)** .</span><span class="sxs-lookup"><span data-stu-id="9951f-1495">**Version Store Size (KB)**.</span></span> <span data-ttu-id="9951f-1496">모든 버전 저장소의 크기(KB)를 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1496">Monitors the size in KB of all version stores.</span></span> <span data-ttu-id="9951f-1497">이 정보를 통해 tempdb 데이터베이스의 버전 저장소에 필요한 공간을 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1497">This information helps determine the amount of space needed in the tempdb database for the version store.</span></span> <span data-ttu-id="9951f-1498">이 카운터를 지속적으로 모니터링하면 tempdb에 필요한 추가 공간을 예측할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1498">Monitoring this counter over a period of time provides a useful estimate of additional space needed for tempdb.</span></span>  
  
 <span data-ttu-id="9951f-1499">`Version Generation rate (KB/s)`.</span><span class="sxs-lookup"><span data-stu-id="9951f-1499">`Version Generation rate (KB/s)`.</span></span> <span data-ttu-id="9951f-1500">모든 버전 저장소의 버전 생성 속도(KB/초)를 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1500">Monitors the version generation rate in KB per second in all version stores.</span></span>  
  
 <span data-ttu-id="9951f-1501">`Version Cleanup rate (KB/s)`.</span><span class="sxs-lookup"><span data-stu-id="9951f-1501">`Version Cleanup rate (KB/s)`.</span></span> <span data-ttu-id="9951f-1502">모든 버전 저장소의 버전 정리 속도(KB/초)를 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1502">Monitors the version cleanup rate in KB per second in all version stores.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9951f-1503">Version Generation rate (KB/s) 및 Version Cleanup rate (KB/s)에서 제공하는 정보를 통해 tempdb에 필요한 공간을 예측할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1503">Information from Version Generation rate (KB/s) and Version Cleanup rate (KB/s) can be used to predict tempdb space requirements.</span></span>  
  
 <span data-ttu-id="9951f-1504">**Version Store unit count**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1504">**Version Store unit count**.</span></span> <span data-ttu-id="9951f-1505">버전 저장소 단위 수를 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1505">Monitors the count of version store units.</span></span>  
  
 <span data-ttu-id="9951f-1506">**Version Store unit creation**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1506">**Version Store unit creation**.</span></span> <span data-ttu-id="9951f-1507">인스턴스가 시작된 이후 행 버전을 저장하기 위해 생성된 버전 저장소 단위의 총 수를 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1507">Monitors the total number of version store units created to store row versions since the instance was started.</span></span>  
  
 <span data-ttu-id="9951f-1508">**Version Store unit truncation**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1508">**Version Store unit truncation**.</span></span> <span data-ttu-id="9951f-1509">인스턴스가 시작된 이후 잘린 버전 저장소 단위의 총 수를 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1509">Monitors the total number of version store units truncated since the instance was started.</span></span> <span data-ttu-id="9951f-1510">[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]에서 버전 저장소 단위에 저장된 버전 행이 활성 트랜잭션을 실행하는 데 불필요하다고 결정하면 버전 저장소 단위가 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1510">A version store unit is truncated when [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] determines that none of the version rows stored in the version store unit are needed to run active transactions.</span></span>  
  
 <span data-ttu-id="9951f-1511">**Update conflict ratio**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1511">**Update conflict ratio**.</span></span> <span data-ttu-id="9951f-1512">총 업데이트 스냅샷 트랜잭션 중 업데이트 충돌이 있는 업데이트 스냅샷 트랜잭션의 비율을 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1512">Monitors the ratio of update snapshot transaction that have update conflicts to the total number of update snapshot transactions.</span></span>  
  
 <span data-ttu-id="9951f-1513">**Longest Transaction Running Time**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1513">**Longest Transaction Running Time**.</span></span> <span data-ttu-id="9951f-1514">행 버전 관리를 사용하는 트랜잭션의 가장 긴 실행 시간(초)을 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1514">Monitors the longest running time in seconds of any transaction using row versioning.</span></span> <span data-ttu-id="9951f-1515">이 정보를 사용하면 특별한 이유 없이 오래 실행되는 트랜잭션이 있는지를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1515">This can be used to determine if any transaction is running for an unreasonable amount of time.</span></span>  
  
 <span data-ttu-id="9951f-1516">**트랜잭션**.</span><span class="sxs-lookup"><span data-stu-id="9951f-1516">**Transactions**.</span></span> <span data-ttu-id="9951f-1517">활성 트랜잭션의 총 수를 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1517">Monitors the total number of active transactions.</span></span> <span data-ttu-id="9951f-1518">시스템 트랜잭션은 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1518">This does not include system transactions.</span></span>  
  
 <span data-ttu-id="9951f-1519">`Snapshot Transactions`.</span><span class="sxs-lookup"><span data-stu-id="9951f-1519">`Snapshot Transactions`.</span></span> <span data-ttu-id="9951f-1520">활성 스냅샷 트랜잭션의 총 수를 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1520">Monitors the total number of active snapshot transactions.</span></span>  
  
 <span data-ttu-id="9951f-1521">`Update Snapshot Transactions`.</span><span class="sxs-lookup"><span data-stu-id="9951f-1521">`Update Snapshot Transactions`.</span></span> <span data-ttu-id="9951f-1522">업데이트 작업을 수행하는 활성 스냅샷 트랜잭션의 총 수를 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1522">Monitors the total number of active snapshot transactions that perform update operations.</span></span>  
  
 <span data-ttu-id="9951f-1523">`NonSnapshot Version Transactions`.</span><span class="sxs-lookup"><span data-stu-id="9951f-1523">`NonSnapshot Version Transactions`.</span></span> <span data-ttu-id="9951f-1524">버전 레코드를 생성하는 활성 비스냅샷 트랜잭션의 총 수를 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1524">Monitors the total number of active non-snapshot transactions that generate version records.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9951f-1525">Update Snapshot Transactions와 NonSnapshot Version Transactions의 합은 버전 생성에 참여하는 트랜잭션의 총 수를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1525">The sum of Update Snapshot Transactions and NonSnapshot Version Transactions represents the total number of transactions that participate in version generation.</span></span> <span data-ttu-id="9951f-1526">Snapshot Transactions와 Update Snapshot Transactions 값의 차이를 보고 읽기 전용 스냅샷 트랜잭션의 수를 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1526">The difference of Snapshot Transactions and Update Snapshot Transactions reports the number of read-only snapshot transactions.</span></span>  
  
### <a name="row-versioning-based-isolation-level-example"></a><span data-ttu-id="9951f-1527">행 버전 관리 기반 격리 수준 예</span><span class="sxs-lookup"><span data-stu-id="9951f-1527">Row Versioning-based Isolation Level Example</span></span>  

 <span data-ttu-id="9951f-1528">다음 예에서는 스냅샷 격리 트랜잭션과 행 버전 관리를 사용하는 커밋된 읽기 트랜잭션 동작의 차이를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1528">The following examples show the differences in behavior between snapshot isolation transactions and read-committed transactions that use row versioning.</span></span>  
  
#### <a name="a-working-with-snapshot-isolation"></a><span data-ttu-id="9951f-1529">A.</span><span class="sxs-lookup"><span data-stu-id="9951f-1529">A.</span></span> <span data-ttu-id="9951f-1530">스냅샷 격리 작업</span><span class="sxs-lookup"><span data-stu-id="9951f-1530">Working with snapshot isolation</span></span>  

 <span data-ttu-id="9951f-1531">이 예에서는 스냅샷 격리에서 실행되는 트랜잭션이 다른 트랜잭션에서 수정한 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1531">In this example, a transaction running under snapshot isolation reads data that is then modified by another transaction.</span></span> <span data-ttu-id="9951f-1532">스냅샷 트랜잭션은 다른 트랜잭션에서 실행하는 업데이트 작업을 차단하지 않으며 데이터 수정을 무시하고 계속 버전이 지정된 행에서 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1532">The snapshot transaction does not block the update operation executed by the other transaction, and it continues to read data from the versioned row, ignoring the data modification.</span></span> <span data-ttu-id="9951f-1533">그러나 스냅샷 트랜잭션이 다른 트랜잭션에서 이미 수정한 데이터를 수정할 경우 스냅샷 트랜잭션은 오류를 생성하고 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1533">However, when the snapshot transaction attempts to modify the data that has already been modified by the other transaction, the snapshot transaction generates an error and is terminated.</span></span>  
  
 <span data-ttu-id="9951f-1534">세션 1:</span><span class="sxs-lookup"><span data-stu-id="9951f-1534">On session 1:</span></span>  
  
```sql  
USE AdventureWorks2012;  -- Or the 2008 or 2008R2 version of the AdventureWorks database.  
GO  
  
-- Enable snapshot isolation on the database.  
ALTER DATABASE AdventureWorks2012  
    SET ALLOW_SNAPSHOT_ISOLATION ON;  
GO  
  
-- Start a snapshot transaction  
SET TRANSACTION ISOLATION LEVEL SNAPSHOT;  
GO  
  
BEGIN TRANSACTION;  
    -- This SELECT statement will return  
    -- 48 vacation hours for the employee.  
    SELECT BusinessEntityID, VacationHours  
        FROM HumanResources.Employee  
        WHERE BusinessEntityID = 4;  
```  
  
 <span data-ttu-id="9951f-1535">세션 2:</span><span class="sxs-lookup"><span data-stu-id="9951f-1535">On session 2:</span></span>  
  
```sql  
USE AdventureWorks2012;  
GO  
  
-- Start a transaction.  
BEGIN TRANSACTION;  
    -- Subtract a vacation day from employee 4.  
    -- Update is not blocked by session 1 since  
    -- under snapshot isolation shared locks are  
    -- not requested.  
    UPDATE HumanResources.Employee  
        SET VacationHours = VacationHours - 8  
        WHERE BusinessEntityID = 4;  
  
    -- Verify that the employee now has 40 vacation hours.  
    SELECT VacationHours  
        FROM HumanResources.Employee  
        WHERE BusinessEntityID = 4;  
```  
  
 <span data-ttu-id="9951f-1536">세션 1:</span><span class="sxs-lookup"><span data-stu-id="9951f-1536">On session 1:</span></span>  
  
```sql  
    -- Reissue the SELECT statement - this shows  
    -- the employee having 48 vacation hours.  The  
    -- snapshot transaction is still reading data from  
    -- the versioned row.  
    SELECT BusinessEntityID, VacationHours  
        FROM HumanResources.Employee  
        WHERE BusinessEntityID = 4;  
```  
  
 <span data-ttu-id="9951f-1537">세션 2:</span><span class="sxs-lookup"><span data-stu-id="9951f-1537">On session 2:</span></span>  
  
```sql  
-- Commit the transaction; this commits the data  
-- modification.  
COMMIT TRANSACTION;  
GO  
```  
  
 <span data-ttu-id="9951f-1538">세션 1:</span><span class="sxs-lookup"><span data-stu-id="9951f-1538">On session 1:</span></span>  
  
```sql  
    -- Reissue the SELECT statement - this still   
    -- shows the employee having 48 vacation hours  
    -- even after the other transaction has committed  
    -- the data modification.  
    SELECT BusinessEntityID, VacationHours  
        FROM HumanResources.Employee  
        WHERE BusinessEntityID = 4;  
  
    -- Because the data has been modified outside of the  
    -- snapshot transaction, any further data changes to   
    -- that data by the snapshot transaction will cause   
    -- the snapshot transaction to fail. This statement   
    -- will generate a 3960 error and the transaction will   
    -- terminate.  
    UPDATE HumanResources.Employee  
        SET SickLeaveHours = SickLeaveHours - 8  
        WHERE BusinessEntityID = 4;  
  
-- Undo the changes to the database from session 1.   
-- This will not undo the change from session 2.  
ROLLBACK TRANSACTION  
GO  
```  
  
#### <a name="b-working-with-read-committed-using-row-versioning"></a><span data-ttu-id="9951f-1539">B.</span><span class="sxs-lookup"><span data-stu-id="9951f-1539">B.</span></span> <span data-ttu-id="9951f-1540">행 버전 관리를 사용한 커밋된 읽기 작업</span><span class="sxs-lookup"><span data-stu-id="9951f-1540">Working with read-committed using row versioning</span></span>  

 <span data-ttu-id="9951f-1541">이 예에서 행 버전 관리를 사용하는 커밋된 읽기 트랜잭션은 다른 트랜잭션과 동시에 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1541">In this example, a read-committed transaction using row versioning runs concurrently with another transaction.</span></span> <span data-ttu-id="9951f-1542">커밋된 읽기 트랜잭션은 스냅샷 트랜잭션과 다르게 동작합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1542">The read-committed transaction behaves differently than a snapshot transaction.</span></span> <span data-ttu-id="9951f-1543">스냅샷 트랜잭션과 마찬가지로 커밋된 읽기 트랜잭션도 다른 트랜잭션이 데이터를 수정한 이후에 버전이 지정된 행을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1543">Like a snapshot transaction, the read-committed transaction will read versioned rows even after the other transaction has modified data.</span></span> <span data-ttu-id="9951f-1544">그러나 커밋된 읽기 트랜잭션은 스냅샷 트랜잭션과 달리 다음 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1544">However, unlike a snapshot transaction, the read-committed transaction will:</span></span>  
  
-   <span data-ttu-id="9951f-1545">다른 트랜잭션이 데이터 변경 내용을 커밋한 이후에 수정한 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1545">Read the modified data after the other transaction commits the data changes.</span></span>  
  
-   <span data-ttu-id="9951f-1546">스냅샷 트랜잭션과 달리 다른 트랜잭션에서 수정한 데이터를 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1546">Be able to update the data modified by the other transaction where the snapshot transaction could not.</span></span>  
  
 <span data-ttu-id="9951f-1547">세션 1:</span><span class="sxs-lookup"><span data-stu-id="9951f-1547">On session 1:</span></span>  
  
```sql  
USE AdventureWorks2012;  -- Or any earlier version of the AdventureWorks database.  
GO  
  
-- Enable READ_COMMITTED_SNAPSHOT on the database.  
-- For this statement to succeed, this session  
-- must be the only connection to the AdventureWorks2012  
-- database.  
ALTER DATABASE AdventureWorks2012  
    SET READ_COMMITTED_SNAPSHOT ON;  
GO  
  
-- Start a read-committed transaction  
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;  
GO  
  
BEGIN TRANSACTION;  
    -- This SELECT statement will return  
    -- 48 vacation hours for the employee.  
    SELECT BusinessEntityID, VacationHours  
        FROM HumanResources.Employee  
        WHERE BusinessEntityID = 4;  
  
```  
  
 <span data-ttu-id="9951f-1548">세션 2:</span><span class="sxs-lookup"><span data-stu-id="9951f-1548">On session 2:</span></span>  
  
```sql  
USE AdventureWorks2012;  
GO  
  
-- Start a transaction.  
BEGIN TRANSACTION;  
    -- Subtract a vacation day from employee 4.  
    -- Update is not blocked by session 1 since  
    -- under read-committed using row versioning shared locks are  
    -- not requested.  
    UPDATE HumanResources.Employee  
        SET VacationHours = VacationHours - 8  
        WHERE BusinessEntityID = 4;  
  
    -- Verify that the employee now has 40 vacation hours.  
    SELECT VacationHours  
        FROM HumanResources.Employee  
        WHERE BusinessEntityID = 4;  
  
```  
  
 <span data-ttu-id="9951f-1549">세션 1:</span><span class="sxs-lookup"><span data-stu-id="9951f-1549">On session 1:</span></span>  
  
```sql  
    -- Reissue the SELECT statement - this still shows  
    -- the employee having 48 vacation hours.  The  
    -- read-committed transaction is still reading data   
    -- from the versioned row and the other transaction   
    -- has not committed the data changes yet.  
    SELECT BusinessEntityID, VacationHours  
        FROM HumanResources.Employee  
        WHERE BusinessEntityID = 4;  
  
```  
  
 <span data-ttu-id="9951f-1550">세션 2:</span><span class="sxs-lookup"><span data-stu-id="9951f-1550">On session 2:</span></span>  
  
```sql  
-- Commit the transaction.  
COMMIT TRANSACTION;  
GO  
  
```  
  
 <span data-ttu-id="9951f-1551">세션 1:</span><span class="sxs-lookup"><span data-stu-id="9951f-1551">On session 1:</span></span>  
  
```sql  
    -- Reissue the SELECT statement which now shows the   
    -- employee having 40 vacation hours.  Being   
    -- read-committed, this transaction is reading the   
    -- committed data. This is different from snapshot  
    -- isolation which reads from the versioned row.  
    SELECT BusinessEntityID, VacationHours  
        FROM HumanResources.Employee  
        WHERE BusinessEntityID = 4;  
  
    -- This statement, which caused the snapshot transaction   
    -- to fail, will succeed with read-committed using row versioning.  
    UPDATE HumanResources.Employee  
        SET SickLeaveHours = SickLeaveHours - 8  
        WHERE BusinessEntityID = 4;  
  
-- Undo the changes to the database from session 1.   
-- This will not undo the change from session 2.  
ROLLBACK TRANSACTION;  
GO  
```  
  
### <a name="enabling-row-versioning-based-isolation-levels"></a><span data-ttu-id="9951f-1552">행 버전 관리 기반 격리 수준 설정</span><span class="sxs-lookup"><span data-stu-id="9951f-1552">Enabling Row Versioning-Based Isolation Levels</span></span>  

 <span data-ttu-id="9951f-1553">데이터베이스 관리자는 ALTER DATABASE 문에서 READ_COMMITTED_SNAPSHOT과 ALLOW_SNAPSHOT_ISOLATION 데이터베이스 옵션을 사용하여 행 버전 관리에 대한 데이터베이스 수준 설정을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1553">Database administrators control the database-level settings for row versioning by using the READ_COMMITTED_SNAPSHOT and ALLOW_SNAPSHOT_ISOLATION database options in the ALTER DATABASE statement.</span></span>  
  
 <span data-ttu-id="9951f-1554">READ_COMMITTED_SNAPSHOT 데이터베이스 옵션을 ON으로 설정하면 이 옵션을 지원하는 메커니즘이 즉시 활성화됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1554">When the READ_COMMITTED_SNAPSHOT database option is set ON, the mechanisms used to support the option are activated immediately.</span></span> <span data-ttu-id="9951f-1555">READ_COMMITTED_SNAPSHOT 옵션을 설정할 때는 ALTER DATABASE 명령을 실행하는 연결만 데이터베이스에서 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1555">When setting the READ_COMMITTED_SNAPSHOT option, only the connection executing the ALTER DATABASE command is allowed in the database.</span></span> <span data-ttu-id="9951f-1556">ALTER DATABASE 명령 실행이 완료될 때까지 데이터베이스에서 다른 열린 연결이 없어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1556">There must be no other open connection in the database until ALTER DATABASE is complete.</span></span> <span data-ttu-id="9951f-1557">데이터베이스가 단일 사용자 모드에 있을 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1557">The database does not have to be in single-user mode.</span></span>  
  
 <span data-ttu-id="9951f-1558">다음 [!INCLUDE[tsql](../includes/tsql-md.md)] 문은 READ_COMMITTED_SNAPSHOT을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1558">The following [!INCLUDE[tsql](../includes/tsql-md.md)] statement enables READ_COMMITTED_SNAPSHOT:</span></span>  
  
```sql  
ALTER DATABASE AdventureWorks2012  
    SET READ_COMMITTED_SNAPSHOT ON;  
```  
  
 <span data-ttu-id="9951f-1559">ALLOW_SNAPSHOT_ISOLATION 데이터베이스 옵션을 ON으로 설정하면 데이터베이스에서 데이터를 수정한 모든 활성 트랜잭션이 완료될 때까지 [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 인스턴스가 수정된 데이터에 대해 행 버전을 생성하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1559">When the ALLOW_SNAPSHOT_ISOLATION database option is set ON, the instance of the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] does not generate row versions for modified data until all active transactions that have modified data in the database complete.</span></span> <span data-ttu-id="9951f-1560">활성 수정 트랜잭션이 있으면 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]에서 이 옵션의 상태를 PENDING_ON으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1560">If there are active modification transactions, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] sets the state of the option to PENDING_ON.</span></span> <span data-ttu-id="9951f-1561">모든 수정 트랜잭션이 완료된 후에는 이 옵션의 상태가 ON으로 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1561">After all of the modification transactions complete, the state of the option is changed to ON.</span></span> <span data-ttu-id="9951f-1562">사용자는 이 옵션이 완전히 ON으로 설정되기 전까지는 해당 데이터베이스에서 스냅샷 트랜잭션을 시작할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1562">Users cannot start a snapshot transaction in that database until the option is fully ON.</span></span> <span data-ttu-id="9951f-1563">데이터베이스 관리자가 ALLOW_SNAPSHOT_ISOLATION 옵션을 OFF로 설정하면 데이터베이스의 상태가 먼저 PENDING_OFF가 된 후 OFF로 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1563">The database passes through a PENDING_OFF state when the database administrator sets the ALLOW_SNAPSHOT_ISOLATION option to OFF.</span></span>  
  
 <span data-ttu-id="9951f-1564">다음 [!INCLUDE[tsql](../includes/tsql-md.md)] 문은 ALLOW_SNAPSHOT_ISOLATION을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1564">The following [!INCLUDE[tsql](../includes/tsql-md.md)] statement will enable ALLOW_SNAPSHOT_ISOLATION:</span></span>  
  
```sql  
ALTER DATABASE AdventureWorks2012  
    SET ALLOW_SNAPSHOT_ISOLATION ON;  
```  
  
 <span data-ttu-id="9951f-1565">다음 표에서는 ALLOW_SNAPSHOT_ISOLATION 옵션을 나열하고 각각의 상태에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1565">The following table lists and describes the states of the ALLOW_SNAPSHOT_ISOLATION option.</span></span> <span data-ttu-id="9951f-1566">ALTER DATABASE에 ALLOW_SNAPSHOT_ISOLATION 옵션을 사용할 경우 현재 데이터베이스 데이터에 액세스하고 있는 사용자는 차단되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1566">Using ALTER DATABASE with the ALLOW_SNAPSHOT_ISOLATION option does not block users who are currently accessing the database data.</span></span>  
  
|<span data-ttu-id="9951f-1567">현재 데이터베이스에 대한 스냅샷 격리 프레임워크의 상태</span><span class="sxs-lookup"><span data-stu-id="9951f-1567">State of snapshot isolation framework for current database</span></span>|<span data-ttu-id="9951f-1568">Description</span><span class="sxs-lookup"><span data-stu-id="9951f-1568">Description</span></span>|  
|----------------------------------------------------------------|-----------------|  
|<span data-ttu-id="9951f-1569">OFF</span><span class="sxs-lookup"><span data-stu-id="9951f-1569">OFF</span></span>|<span data-ttu-id="9951f-1570">스냅샷 격리 트랜잭션에 대한 지원이 활성화되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1570">The support for snapshot isolation transactions is not activated.</span></span> <span data-ttu-id="9951f-1571">스냅샷 격리 트랜잭션이 허용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1571">No snapshot isolation transactions are allowed.</span></span>|  
|<span data-ttu-id="9951f-1572">PENDING_ON</span><span class="sxs-lookup"><span data-stu-id="9951f-1572">PENDING_ON</span></span>|<span data-ttu-id="9951f-1573">스냅샷 격리 트랜잭션에 대한 지원이 OFF에서 ON으로 전환되는 중입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1573">The support for snapshot isolation transactions is in transition state (from OFF to ON).</span></span> <span data-ttu-id="9951f-1574">열린 트랜잭션을 완료해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1574">Open transactions must complete.</span></span><br /><br /> <span data-ttu-id="9951f-1575">스냅샷 격리 트랜잭션이 허용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1575">No snapshot isolation transactions are allowed.</span></span>|  
|<span data-ttu-id="9951f-1576">켜기</span><span class="sxs-lookup"><span data-stu-id="9951f-1576">ON</span></span>|<span data-ttu-id="9951f-1577">스냅샷 격리 트랜잭션에 대한 지원이 활성화되었습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1577">The support for snapshot isolation transactions is activated.</span></span><br /><br /> <span data-ttu-id="9951f-1578">스냅샷 트랜잭션이 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1578">Snapshot transactions are allowed.</span></span>|  
|<span data-ttu-id="9951f-1579">PENDING_OFF</span><span class="sxs-lookup"><span data-stu-id="9951f-1579">PENDING_OFF</span></span>|<span data-ttu-id="9951f-1580">스냅샷 격리 트랜잭션에 대한 지원이 ON에서 OFF로 전환되는 중입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1580">The support for snapshot isolation transactions is in transition state (from ON to OFF).</span></span><br /><br /> <span data-ttu-id="9951f-1581">이 시점 이후에 시작된 스냅샷 트랜잭션은 이 데이터베이스에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1581">Snapshot transactions started after this time cannot access this database.</span></span> <span data-ttu-id="9951f-1582">업데이트 트랜잭션은 이 데이터베이스에서 계속해서 버전 관리를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1582">Update transactions still pay the cost of versioning in this database.</span></span> <span data-ttu-id="9951f-1583">기존 스냅샷 트랜잭션은 문제 없이 이 데이터베이스에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1583">Existing snapshot transactions can still access this database without a problem.</span></span> <span data-ttu-id="9951f-1584">데이터베이스 스냅샷 격리 상태가 ON이었을 때 활성화되어 있던 스냅샷 트랜잭션이 모두 완료되어야 PENDING_OFF 상태가 OFF로 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1584">The state PENDING_OFF does not become OFF until all snapshot transactions that were active when the database snapshot isolation state was ON finish.</span></span>|  
  
 <span data-ttu-id="9951f-1585">두 행 버전 관리 데이터베이스 옵션의 상태를 확인하려면 sys.databases 카탈로그 뷰를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1585">Use the sys.databases catalog view to determine the state of both row versioning database options.</span></span>  
  
 <span data-ttu-id="9951f-1586">모든 사용자 테이블과 master 및 msdb에 저장된 일부 시스템 테이블에 대한 모든 업데이트는 행 버전을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1586">All updates to user tables and some system tables stored in master and msdb generate row versions.</span></span>  
  
 <span data-ttu-id="9951f-1587">master 및 msdb 데이터베이스에서는 ALLOW_SNAPSHOT_ISOLATION 옵션이 자동으로 ON으로 설정되고 비활성화할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1587">The ALLOW_SNAPSHOT_ISOLATION option is automatically set ON in the master and msdb databases, and cannot be disabled.</span></span>  
  
 <span data-ttu-id="9951f-1588">사용자는 master, tempdb 또는 msdb에서 READ_COMMITTED_SNAPSHOT 옵션을 ON으로 설정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1588">Users cannot set the READ_COMMITTED_SNAPSHOT option ON in master, tempdb, or msdb.</span></span>  
  
### <a name="using-row-versioning-based-isolation-levels"></a><span data-ttu-id="9951f-1589">행 버전 관리 기반 격리 수준 사용</span><span class="sxs-lookup"><span data-stu-id="9951f-1589">Using Row Versioning-based Isolation Levels</span></span>  

 <span data-ttu-id="9951f-1590">행 버전 관리 프레임워크는 항상 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]에 설정되어 있으며 여러 기능에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1590">The row versioning framework is always enabled in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], and is used by multiple features.</span></span> <span data-ttu-id="9951f-1591">행 버전 관리 기반 격리 수준을 제공할 뿐만 아니라 MARS(Multiple Active Result Set) 세션과 트리거의 수정 내용을 지원하고 온라인 인덱스 작업을 위한 데이터 읽기를 지원하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1591">Besides providing row versioning-based isolation levels, it is used to support modifications made in triggers and multiple active result sets (MARS) sessions, and to support data reads for ONLINE index operations.</span></span>  
  
 <span data-ttu-id="9951f-1592">행 버전 관리 기반 격리 수준은 데이터베이스 수준에서 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1592">Row versioning-based isolation levels are enabled at the database level.</span></span> <span data-ttu-id="9951f-1593">설정된 데이터베이스의 개체에 액세스하는 애플리케이션은 모두 다음과 같은 격리 수준을 사용하여 쿼리를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1593">Any application accessing objects from enabled databases can run queries using the following isolation levels:</span></span>  
  
-   <span data-ttu-id="9951f-1594">다음 코드 예제에서는 `READ_COMMITTED_SNAPSHOT` 데이터베이스 옵션을 `ON`으로 설정하여 행 버전 관리를 사용하는 커밋된 읽기를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1594">Read-committed that uses row versioning by setting the `READ_COMMITTED_SNAPSHOT` database option to `ON` as shown in the following code example:</span></span>  
  
    ```sql  
    ALTER DATABASE AdventureWorks2012  
        SET READ_COMMITTED_SNAPSHOT ON;  
    ```  
  
     <span data-ttu-id="9951f-1595">데이터베이스에 READ_COMMITTED_SNAPSHOT을 설정하면 커밋된 읽기 격리 수준으로 실행되는 모든 쿼리에 행 버전 관리가 사용됩니다. 즉, 읽기 작업 시 업데이트 작업이 차단되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1595">When the database is enabled for READ_COMMITTED_SNAPSHOT, all queries running under the read committed isolation level use row versioning, which means that read operations do not block update operations.</span></span>  
  
-   <span data-ttu-id="9951f-1596">다음 코드 예에서는 `ALLOW_SNAPSHOT_ISOLATION` 데이터베이스 옵션을 `ON`으로 설정하여 스냅샷 격리를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1596">Snapshot isolation by setting the `ALLOW_SNAPSHOT_ISOLATION` database option to `ON` as shown in the following code example:</span></span>  
  
    ```sql  
    ALTER DATABASE AdventureWorks2012  
        SET ALLOW_SNAPSHOT_ISOLATION ON;  
    ```  
  
     <span data-ttu-id="9951f-1597">스냅샷 격리로 실행되는 트랜잭션은 스냅샷이 설정된 데이터베이스의 테이블에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1597">A transaction running under snapshot isolation can access tables in the database that have been enabled for snapshot.</span></span> <span data-ttu-id="9951f-1598">스냅샷이 설정되지 않은 테이블에 액세스하려면 격리 수준을 변경해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1598">To access tables that have not been enabled for snapshot, the isolation level must be changed.</span></span> <span data-ttu-id="9951f-1599">예를 들어 다음 코드 예제에서는 스냅샷 트랜잭션으로 실행되는 동안 두 테이블을 조인하는 `SELECT` 문을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1599">For example, the following code example shows a `SELECT` statement that joins two tables while running under a snapshot transaction.</span></span> <span data-ttu-id="9951f-1600">한 테이블은 스냅샷 격리가 설정되지 않은 데이터베이스에 속합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1600">One table belongs to a database in which snapshot isolation is not enabled.</span></span> <span data-ttu-id="9951f-1601">스냅샷 격리에서 `SELECT` 문을 실행하면 실행이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1601">When the `SELECT` statement runs under snapshot isolation, it fails to execute successfully.</span></span>  
  
    ```sql  
    SET TRANSACTION ISOLATION LEVEL SNAPSHOT;  
    BEGIN TRAN  
        SELECT t1.col5, t2.col5  
            FROM Table1 as t1  
            INNER JOIN SecondDB.dbo.Table2 as t2  
                ON t1.col1 = t2.col2;  
    ```  
  
     <span data-ttu-id="9951f-1602">다음 코드 예제에서는 트랜잭션 격리 수준을 커밋된 읽기로 변경하도록 수정된 동일한 `SELECT` 문을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1602">The following code example shows the same `SELECT` statement that has been modified to change the transaction isolation level to read-committed.</span></span> <span data-ttu-id="9951f-1603">이렇게 변경하면 `SELECT` 문이 성공적으로 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1603">Because of this change, the `SELECT` statement executes successfully.</span></span>  
  
    ```sql  
    SET TRANSACTION ISOLATION LEVEL SNAPSHOT;  
    BEGIN TRAN  
        SELECT t1.col5, t2.col5  
            FROM Table1 as t1  
            WITH (READCOMMITTED)  
            INNER JOIN SecondDB.dbo.Table2 as t2  
                ON t1.col1 = t2.col2;  
    ```  
  
#### <a name="limitations-of-transactions-using-row-versioning-based-isolation-levels"></a><span data-ttu-id="9951f-1604">행 버전 관리 기반 격리 수준을 사용하는 트랜잭션의 제한 사항</span><span class="sxs-lookup"><span data-stu-id="9951f-1604">Limitations of Transactions Using Row Versioning-based Isolation Levels</span></span>  

 <span data-ttu-id="9951f-1605">행 버전 관리 기반 격리 수준을 사용할 때 다음 제한 사항을 고려하십시오.</span><span class="sxs-lookup"><span data-stu-id="9951f-1605">Consider the following limitations when working with row versioning-based isolation levels:</span></span>  
  
-   <span data-ttu-id="9951f-1606">tempdb, msdb 또는 master에는 READ_COMMITTED_SNAPSHOT을 설정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1606">READ_COMMITTED_SNAPSHOT cannot be enabled in tempdb, msdb, or master.</span></span>  
  
-   <span data-ttu-id="9951f-1607">전역 임시 테이블은 tempdb에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1607">Global temp tables are stored in tempdb.</span></span> <span data-ttu-id="9951f-1608">스냅샷 트랜잭션 내의 전역 임시 테이블에 액세스할 때 다음 중 하나를 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1608">When accessing global temp tables inside a snapshot transaction, one of the following must happen:</span></span>  
  
    -   <span data-ttu-id="9951f-1609">tempdb에서 ALLOW_SNAPSHOT_ISOLATION 데이터베이스 옵션을 ON으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1609">Set the ALLOW_SNAPSHOT_ISOLATION database option ON in tempdb.</span></span>  
  
    -   <span data-ttu-id="9951f-1610">격리 힌트를 사용하여 문에 대한 격리 수준을 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1610">Use an isolation hint to change the isolation level for the statement.</span></span>  
  
-   <span data-ttu-id="9951f-1611">다음과 같은 경우 스냅샷 트랜잭션이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1611">Snapshot transactions fail when:</span></span>  
  
    -   <span data-ttu-id="9951f-1612">스냅샷 트랜잭션이 시작된 후 데이터베이스에 액세스하기 전에 데이터베이스가 읽기 전용으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1612">A database is made read-only after the snapshot transaction starts, but before the snapshot transaction accesses the database.</span></span>  
  
    -   <span data-ttu-id="9951f-1613">여러 데이터베이스의 개체에 액세스하는 경우 스냅샷 트랜잭션이 시작된 후 데이터베이스에 액세스하기 전에 데이터베이스 복구를 수반하는 방식으로 데이터베이스 상태가 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1613">If accessing objects from multiple databases, a database state was changed in such a way that database recovery occurred after a snapshot transaction starts, but before the snapshot transaction accesses the database.</span></span> <span data-ttu-id="9951f-1614">예를 들어 데이터베이스가 OFFLINE으로 설정되었다가 ONLINE으로 설정되거나 데이터베이스가 자동으로 닫히고 열리거나 데이터베이스가 분리되고 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1614">For example: the database was set to OFFLINE and then to ONLINE, database autoclose and open, or database detach and attach.</span></span>  
  
-   <span data-ttu-id="9951f-1615">분산 분할된 데이터베이스의 쿼리를 포함하여 분산 트랜잭션은 스냅샷 격리로 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1615">Distributed transactions, including queries in distributed partitioned databases, are not supported under snapshot isolation.</span></span>  
  
-   [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]<span data-ttu-id="9951f-1616">는 여러 버전의 시스템 메타데이터를 보관하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1616">does not keep multiple versions of system metadata.</span></span> <span data-ttu-id="9951f-1617">테이블의 DDL(데이터 정의 언어) 문이나 기타 데이터베이스 개체(인덱스, 뷰, 데이터 형식, 저장 프로시저 및 공용 언어 런타임 함수)는 메타데이터를 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1617">Data definition language (DDL) statements on tables and other database objects (indexes, views, data types, stored procedures, and common language runtime functions) change metadata.</span></span> <span data-ttu-id="9951f-1618">DDL 문이 개체를 수정하면 스냅샷 격리의 개체에 대한 동시 참조로 인해 스냅샷 트랜잭션이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1618">If a DDL statement modifies an object, any concurrent reference to the object under snapshot isolation causes the snapshot transaction to fail.</span></span> <span data-ttu-id="9951f-1619">READ_COMMITTED_SNAPSHOT 데이터베이스 옵션이 ON이면 커밋된 읽기 트랜잭션에 이러한 제한 사항이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1619">Read-committed transactions do not have this limitation when the READ_COMMITTED_SNAPSHOT database option is ON.</span></span>  
  
     <span data-ttu-id="9951f-1620">예를 들어 데이터베이스 관리자가 다음 `ALTER INDEX` 문을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1620">For example, a database administrator executes the following `ALTER INDEX` statement.</span></span>  
  
    ```sql  
    USE AdventureWorks2012;  
    GO  
    ALTER INDEX AK_Employee_LoginID  
        ON HumanResources.Employee REBUILD;  
    GO  
    ```  
  
     <span data-ttu-id="9951f-1621">`ALTER INDEX` 문이 실행된 후 `HumanResources.Employee` 테이블을 참조하려고 하면 `ALTER INDEX` 문 실행 시 활성 상태인 모든 스냅샷 트랜잭션에 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1621">Any snapshot transaction that is active when the `ALTER INDEX` statement is executed receives an error if it attempts to reference the `HumanResources.Employee` table after the `ALTER INDEX` statement is executed.</span></span> <span data-ttu-id="9951f-1622">행 버전 관리를 사용하는 커밋된 읽기 트랜잭션은 영향을 받지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1622">Read-committed transactions using row versioning are not affected.</span></span>  
  
    > [!NOTE]  
    >  <span data-ttu-id="9951f-1623">BULK INSERT 작업을 수행할 때 대상 테이블 메타데이터가 변경될 수 있습니다. 제약 조건 검사를 해제한 경우를 예로 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1623">BULK INSERT operations may cause changes to target table metadata (for example, when disabling constraint checks).</span></span> <span data-ttu-id="9951f-1624">이렇게 대상 테이블 메타데이터가 변경되면 동시 스냅샷 격리 트랜잭션이 대량 삽입된 테이블에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1624">When this happens, concurrent snapshot isolation transactions accessing bulk inserted tables fail.</span></span>  
  
 <span data-ttu-id="9951f-1625">[이 가이드의](#Top) ![맨 위 링크와 함께 사용 되는 화살표 아이콘](media/uparrow16x16.gif "맨 위로 이동 링크와 함께 사용되는 화살표 아이콘")</span><span class="sxs-lookup"><span data-stu-id="9951f-1625">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
## <a name="customizing-locking-and-row-versioning"></a><span data-ttu-id="9951f-1626">잠금 및 행 버전 관리 사용자 지정</span><span class="sxs-lookup"><span data-stu-id="9951f-1626">Customizing Locking and Row Versioning</span></span>  
  
### <a name="customizing-the-lock-time-out"></a><span data-ttu-id="9951f-1627">잠금 제한 시간 사용자 지정</span><span class="sxs-lookup"><span data-stu-id="9951f-1627">Customizing the Lock Time-Out</span></span>  

 <span data-ttu-id="9951f-1628">다른 트랜잭션에서 이미 리소스에 대해 충돌되는 잠금을 소유하고 있어 [!INCLUDE[msCoName](../includes/msconame-md.md)] [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]의 인스턴스에서 트랜잭션에 잠금을 허가할 수 없는 경우 이 트랜잭션은 기존 잠금이 해제되기를 기다리면서 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1628">When an instance of the [!INCLUDE[msCoName](../includes/msconame-md.md)] [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] cannot grant a lock to a transaction because another transaction already owns a conflicting lock on the resource, the first transaction becomes blocked waiting for the existing lock to be released.</span></span> <span data-ttu-id="9951f-1629">기본적으로 정해진 제한 시간은 없으며 리소스를 잠그기 전에 해당 리소스가 잠겨 있는지 여부를 확인할 수 없습니다. 단, 데이터에 대한 액세스를 시도할 수는 있으나 이로 인해 무기한으로 차단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1629">By default, there is no mandatory time-out period and no way to test whether a resource is locked before locking it, except to attempt to access the data (and potentially get blocked indefinitely).</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9951f-1630">[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]에서는 **sys.dm_os_waiting_tasks** 동적 관리 뷰를 사용하여 프로세스가 차단되었는지 여부와 프로세스를 차단하고 있는 주체를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1630">In [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], use the **sys.dm_os_waiting_tasks** dynamic management view to determine whether a process is being blocked and who is blocking it.</span></span> <span data-ttu-id="9951f-1631">이전 버전의 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]에서는 **sp_who** 시스템 저장 프로시저를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1631">In earlier versions of [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], use the **sp_who** system stored procedure.</span></span>  
  
 <span data-ttu-id="9951f-1632">LOCK_TIMEOUT 설정을 사용하여 문이 차단된 리소스를 기다리는 최대 시간을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1632">The LOCK_TIMEOUT setting allows an application to set a maximum time that a statement waits on a blocked resource.</span></span> <span data-ttu-id="9951f-1633">문이 LOCK_TIMEOUT 설정보다 오래 기다린 경우 차단된 문은 자동으로 취소되고 오류 메시지 1222(`Lock request time-out period exceeded`)가 애플리케이션으로 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1633">When a statement has waited longer than the LOCK_TIMEOUT setting, the blocked statement is canceled automatically, and error message 1222 (`Lock request time-out period exceeded`) is returned to the application.</span></span> <span data-ttu-id="9951f-1634">그러나 문을 포함하는 트랜잭션은 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]에서 롤백되거나 취소되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1634">Any transaction containing the statement, however, is not rolled back or canceled by [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="9951f-1635">따라서 애플리케이션에는 오류 메시지 1222를 트래핑할 수 있는 오류 처리기가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1635">Therefore, the application must have an error handler that can trap error message 1222.</span></span> <span data-ttu-id="9951f-1636">애플리케이션에서 오류를 트래핑하지 않으면 트랜잭션 내의 각 문이 취소된 것을 모르고 애플리케이션이 계속 진행하여 나중에 트랜잭션의 문이 실행되지 않은 문을 참조할 경우 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1636">If an application does not trap the error, the application can proceed unaware that an individual statement within a transaction has been canceled, and errors can occur because statements later in the transaction might depend on the statement that was never executed.</span></span>  
  
 <span data-ttu-id="9951f-1637">오류 메시지 1222를 트래핑하는 오류 처리기를 구현하면 애플리케이션에서 시간 초과 상황을 처리하고 차단된 문을 자동으로 다시 전송하거나 전체 트랜잭션을 롤백하는 등의 해결 동작을 취할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1637">Implementing an error handler that traps error message 1222 allows an application to handle the time-out situation and take remedial action, such as: automatically resubmitting the statement that was blocked or rolling back the entire transaction.</span></span>  
  
 <span data-ttu-id="9951f-1638">현재 LOCK_TIMEOUT 설정을 확인 하려면 @ 함수를 실행 합니다 @LOCK_TIMEOUT .</span><span class="sxs-lookup"><span data-stu-id="9951f-1638">To determine the current LOCK_TIMEOUT setting, execute the @@LOCK_TIMEOUT function:</span></span>  
  
```sql  
SELECT @@lock_timeout;  
GO  
```  
  
### <a name="customizing-transaction-isolation-level"></a><span data-ttu-id="9951f-1639">트랜잭션 격리 수준 사용자 지정</span><span class="sxs-lookup"><span data-stu-id="9951f-1639">Customizing Transaction Isolation Level</span></span>  

 <span data-ttu-id="9951f-1640">READ COMMITTED는 [!INCLUDE[msCoName](../includes/msconame-md.md)] [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]의 기본 격리 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1640">READ COMMITTED is the default isolation level for the [!INCLUDE[msCoName](../includes/msconame-md.md)] [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)].</span></span> <span data-ttu-id="9951f-1641">애플리케이션을 다른 격리 수준에서 실행해야 하는 경우 다음과 같은 방법으로 격리 수준을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1641">If an application must operate at a different isolation level, it can use the following methods to set the isolation level:</span></span>  
  
-   <span data-ttu-id="9951f-1642">[SET TRANSACTION ISOLATION LEVEL](/sql/t-sql/statements/set-transaction-isolation-level-transact-sql) 문을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1642">Run the [SET TRANSACTION ISOLATION LEVEL](/sql/t-sql/statements/set-transaction-isolation-level-transact-sql) statement.</span></span>  
  
-   <span data-ttu-id="9951f-1643">System.Data.SqlClient 관리 네임스페이스를 사용하는 ADO.NET 애플리케이션에서는 SqlConnection.BeginTransaction 메서드를 사용하여 *IsolationLevel* 옵션을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1643">ADO.NET applications that use the System.Data.SqlClient managed namespace can specify an *IsolationLevel* option by using the SqlConnection.BeginTransaction method.</span></span>  
  
-   <span data-ttu-id="9951f-1644">ADO를 사용하는 애플리케이션에서는 `Autocommit Isolation Levels` 속성을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1644">Applications that use ADO can set the `Autocommit Isolation Levels` property.</span></span>  
  
-   <span data-ttu-id="9951f-1645">OLE DB를 사용하는 애플리케이션에서는 트랜잭션을 시작할 때 *isoLevel*을 원하는 트랜잭션 격리 수준으로 설정하고 ITransactionLocal::StartTransaction을 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1645">When starting a transaction, applications using OLE DB can call ITransactionLocal::StartTransaction with *isoLevel* set to the desired transaction isolation level.</span></span> <span data-ttu-id="9951f-1646">자동 커밋 모드에서 격리 수준을 지정할 때 OLE DB를 사용하는 애플리케이션에서는 DBPROPSET_SESSION 속성인 DBPROP_SESS_AUTOCOMMITISOLEVELS를 원하는 트랜잭션 격리 수준으로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1646">When specifying the isolation level in autocommit mode, applications that use OLE DB can set the DBPROPSET_SESSION property DBPROP_SESS_AUTOCOMMITISOLEVELS to the desired transaction isolation level.</span></span>  
  
-   <span data-ttu-id="9951f-1647">ODBC를 사용하는 애플리케이션에서는 SQLSetConnectAttr를 사용하여 SQL_COPT_SS_TXN_ISOLATION 특성을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1647">Applications that use ODBC can set the SQL_COPT_SS_TXN_ISOLATION attribute by using SQLSetConnectAttr.</span></span>  
  
 <span data-ttu-id="9951f-1648">격리 수준을 지정하면 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 세션에서 모든 쿼리와 DML(데이터 조작 언어) 문의 잠금 동작이 해당 격리 수준에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1648">When the isolation level is specified, the locking behavior for all queries and data manipulation language (DML) statements in the [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] session operates at that isolation level.</span></span> <span data-ttu-id="9951f-1649">세션이 종료되거나 격리 수준을 다른 수준으로 설정할 때까지 해당 격리 수준이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1649">The isolation level remains in effect until the session terminates or until the isolation level is set to another level.</span></span>  
  
 <span data-ttu-id="9951f-1650">다음 예에서는 `SERIALIZABLE` 격리 수준을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1650">The following example sets the `SERIALIZABLE` isolation level:</span></span>  
  
```sql  
USE AdventureWorks2012;  
GO  
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;  
GO  
BEGIN TRANSACTION;  
SELECT BusinessEntityID  
    FROM HumanResources.Employee;  
GO  
```  
  
 <span data-ttu-id="9951f-1651">필요에 따라 테이블 수준 힌트를 지정하여 개별 쿼리나 DML 문에 대해 격리 수준을 무시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1651">The isolation level can be overridden for individual query or DML statements, if necessary, by specifying a table-level hint.</span></span> <span data-ttu-id="9951f-1652">테이블 수준 힌트를 지정해도 세션의 다른 문에는 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1652">Specifying a table-level hint does not affect other statements in the session.</span></span> <span data-ttu-id="9951f-1653">꼭 필요한 경우에만 테이블 수준 힌트를 사용하여 기본 동작을 변경하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1653">We recommend that table-level hints be used to change the default behavior only when absolutely necessary.</span></span>  
  
 <span data-ttu-id="9951f-1654">데이터를 읽을 때 공유 잠금을 요청하지 않는 수준으로 격리 수준이 설정된 경우에도 [!INCLUDE[ssDE](../includes/ssde-md.md)]에서 잠금을 획득해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1654">The [!INCLUDE[ssDE](../includes/ssde-md.md)] might have to acquire locks when reading metadata even when the isolation level is set to a level where share locks are not requested when reading data.</span></span> <span data-ttu-id="9951f-1655">예를 들어 커밋되지 않은 읽기 격리 수준에서 실행되는 트랜잭션은 데이터를 읽을 때 공유 잠금을 획득하지 않지만 시스템 카탈로그 뷰를 읽을 때 잠금을 요청하는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1655">For example, a transaction running at the read-uncommitted isolation level does not acquire share locks when reading data, but might sometime request locks when reading a system catalog view.</span></span> <span data-ttu-id="9951f-1656">즉 동시 트랜잭션이 해당 테이블의 메타데이터를 수정할 때 커밋되지 않은 읽기 트랜잭션이 테이블 쿼리를 차단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1656">This means it is possible for a read uncommitted transaction to cause blocking when querying a table when a concurrent transaction is modifying the metadata of that table.</span></span>  
  
 <span data-ttu-id="9951f-1657">현재 설정된 트랜잭션 격리 수준을 확인하려면 다음 예와 같이 `DBCC USEROPTIONS` 문을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1657">To determine the transaction isolation level currently set, use the `DBCC USEROPTIONS` statement as shown in the following example.</span></span> <span data-ttu-id="9951f-1658">이 결과 집합은 사용 중인 컴퓨터의 결과 집합과 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1658">The result set may vary from the result set on your system.</span></span>  
  
```sql  
USE AdventureWorks2012;  
GO  
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;  
GO  
DBCC USEROPTIONS;  
GO  
```  
  
 [!INCLUDE[ssResult](../includes/ssresult-md.md)]  
  
 `Set Option                   Value`  
  
 `---------------------------- -------------------------------------------`  
  
 `textsize                     2147483647`  
  
 `language                     us_english`  
  
 `dateformat                   mdy`  
  
 `datefirst                    7`  
  
 `...                          ...`  
  
 `Isolation level              repeatable read`  
  
 ``  
  
 `(14 row(s) affected)`  
  
 ``  
  
 `DBCC execution completed. If DBCC printed error messages, contact your system administrator.`  
  
### <a name="locking-hints"></a><span data-ttu-id="9951f-1659">잠금 힌트</span><span class="sxs-lookup"><span data-stu-id="9951f-1659">Locking Hints</span></span>  

 <span data-ttu-id="9951f-1660">SELECT, INSERT, UPDATE 및 DELETE 문의 개별 테이블 참조에 대해 잠금 힌트를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1660">Locking hints can be specified for individual table references in the SELECT, INSERT, UPDATE, and DELETE statements.</span></span> <span data-ttu-id="9951f-1661">힌트는 [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 인스턴스가 테이블 데이터에 대해 사용하는 잠금 유형 또는 행 버전 관리를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1661">The hints specify the type of locking or row versioning the instance of the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] uses for the table data.</span></span> <span data-ttu-id="9951f-1662">테이블 수준의 잠금 힌트는 개체에 대해 얻은 잠금 유형에 대해 더 세부적인 제어가 필요할 때 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1662">Table-level locking hints can be used when a finer control of the types of locks acquired on an object is required.</span></span> <span data-ttu-id="9951f-1663">이러한 잠금 힌트는 세션에 대해 현재 트랜잭션 격리 수준을 무시합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1663">These locking hints override the current transaction isolation level for the session.</span></span>  
  
 <span data-ttu-id="9951f-1664">특정 잠금 힌트와 해당 동작에 대한 자세한 내용은 [Table Hints&#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-table)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="9951f-1664">For more information about the specific locking hints and their behaviors, see [Table Hints &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-table).</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9951f-1665">[!INCLUDE[ssDE](../includes/ssde-md.md)] 쿼리 최적화 프로그램에서는 거의 대부분 올바른 잠금 수준을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1665">The [!INCLUDE[ssDE](../includes/ssde-md.md)] query optimizer almost always chooses the correct locking level.</span></span> <span data-ttu-id="9951f-1666">필요할 때만 테이블 수준의 잠금 힌트를 사용하여 기본 잠금 동작을 변경하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1666">We recommend that table-level locking hints be used to change the default locking behavior only when necessary.</span></span> <span data-ttu-id="9951f-1667">잠금 수준의 허용을 취소하면 동시성에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1667">Disallowing a locking level can adversely affect concurrency.</span></span>  
  
 <span data-ttu-id="9951f-1668">데이터를 읽을 때 공유 잠금 요청을 막는 잠금 힌트를 사용하여 SELECT를 처리하는 경우에도 메타데이터를 읽을 때 [!INCLUDE[ssDE](../includes/ssde-md.md)]에서 잠금을 획득해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1668">The [!INCLUDE[ssDE](../includes/ssde-md.md)] might have to acquire locks when reading metadata, even when processing a select with a locking hint that prevents requests for share locks when reading data.</span></span> <span data-ttu-id="9951f-1669">예를 들어 NOLOCK 힌트를 사용하는 SELECT는 데이터를 읽을 때 공유 잠금을 획득하지 않지만 시스템 카탈로그 뷰를 읽을 때는 경우에 따라 잠금을 요청할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1669">For example, a SELECT using the NOLOCK hint does not acquire share locks when reading data, but might sometime request locks when reading a system catalog view.</span></span> <span data-ttu-id="9951f-1670">즉, NOLOCK을 사용하는 SELECT 문을 차단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1670">This means it is possible for a SELECT statement using NOLOCK to be blocked.</span></span>  
  
 <span data-ttu-id="9951f-1671">다음 예와 같이 트랜잭션 격리 수준이 `SERIALIZABLE`로 설정되고 테이블 수준 잠금 힌트인 `NOLOCK`이 `SELECT` 문과 함께 사용되면 일반적으로 직렬화 가능 트랜잭션을 유지 관리하는 데 사용되는 키 범위 잠금이 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1671">As shown in the following example, if the transaction isolation level is set to `SERIALIZABLE`, and the table-level locking hint `NOLOCK` is used with the `SELECT` statement, key-range locks typically used to maintain serializable transactions are not taken.</span></span>  
  
```sql  
USE AdventureWorks2012;  
GO  
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;  
GO  
BEGIN TRANSACTION;  
GO  
SELECT JobTitle  
    FROM HumanResources.Employee WITH (NOLOCK);  
GO  
  
-- Get information about the locks held by   
-- the transaction.  
SELECT    
        resource_type,   
        resource_subtype,   
        request_mode  
    FROM sys.dm_tran_locks  
    WHERE request_session_id = @@spid;  
  
-- End the transaction.  
ROLLBACK;  
GO  
```  
  
 <span data-ttu-id="9951f-1672">`HumanResources.Employee`를 참조하는 유일한 잠금은 스키마 안정성(Sch-S) 잠금입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1672">The only lock taken that references `HumanResources.Employee` is a schema stability (Sch-S) lock.</span></span> <span data-ttu-id="9951f-1673">이 경우 순차성은 더 이상 보장되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1673">In this case, serializability is no longer guaranteed.</span></span>  
  
 <span data-ttu-id="9951f-1674">[!INCLUDE[ssCurrent](../includes/sscurrent-md.md)]에서는 ALTER TABLE의 LOCK_ESCALATION 옵션에서 테이블 잠금을 선호하지 않을 수 있으며 분할된 테이블에 HoBT 잠금을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1674">In [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)], the LOCK_ESCALATION option of ALTER TABLE can disfavor table locks, and enable HoBT locks on partitioned tables.</span></span> <span data-ttu-id="9951f-1675">이 옵션은 잠금 힌트가 아니지만 잠금 에스컬레이션을 줄이는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1675">This option is not a locking hint, but can but used to reduce lock escalation.</span></span> <span data-ttu-id="9951f-1676">자세한 내용은 [ALTER TABLE&#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-table-transact-sql)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-1676">For more information, see [ALTER TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-table-transact-sql).</span></span>  
  
###  <a name="customizing-locking-for-an-index"></a><a name="Customize"></a> <span data-ttu-id="9951f-1677">인덱스 잠금 사용자 지정</span><span class="sxs-lookup"><span data-stu-id="9951f-1677">Customizing Locking for an Index</span></span>  

 <span data-ttu-id="9951f-1678">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]은 대부분의 경우 쿼리에 가장 적합한 잠금 세분성을 자동으로 선택하는 동적 잠금 전략을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1678">The [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] uses a dynamic locking strategy that automatically chooses the best locking granularity for queries in most cases.</span></span> <span data-ttu-id="9951f-1679">페이지 잠금 및 행 잠금이 설정되어 있는 기본 잠금 수준은 잘 알려져 있으며 일관적인 테이블 또는 인덱스 액세스 패턴이 아닌 경우 및 리소스 충돌 문제를 해결해야 하는 경우 재정의하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1679">We recommend that you do not override the default locking levels, which have page and row locking on, unless table or index access patterns are well understood and consistent, and there is a resource contention problem to solve.</span></span> <span data-ttu-id="9951f-1680">잠금 수준을 재정의하면 테이블 또는 인덱스에 대한 동시 액세스에 심각한 방해가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1680">Overriding a locking level can significantly impede concurrent access to a table or index.</span></span> <span data-ttu-id="9951f-1681">예를 들어 사용자의 액세스가 빈번한 대규모 테이블에 테이블 수준 잠금만을 지정하는 경우, 사용자가 테이블에 액세스하려면 테이블 수준 잠금이 해제될 때까지 기다려야 하므로 병목 현상이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1681">For example, specifying only table-level locks on a large table that users access heavily can cause bottlenecks because users must wait for the table-level lock to be released before accessing the table.</span></span>  
  
 <span data-ttu-id="9951f-1682">잘 알려져 있으며 일관된 액세스 패턴의 경우 페이지 잠금 또는 행 잠금을 허용하지 않는 것이 좋은 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1682">There are a few cases where disallowing page or row locking can be beneficial, if the access patterns are well understood and consistent.</span></span> <span data-ttu-id="9951f-1683">예를 들어 데이터베이스 애플리케이션에서 일괄 처리를 통해 매주 업데이트되는 조회 테이블을 사용하는 경우를 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1683">For example, a database application uses a lookup table that is updated weekly in a batch process.</span></span> <span data-ttu-id="9951f-1684">동시 판독기는 공유(S) 잠금으로 테이블에 액세스하고, 주간 일괄 업데이트는 배타적(X) 잠금으로 테이블에 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1684">Concurrent readers access the table with a shared (S) lock and the weekly batch update accesses the table with an exclusive (X) lock.</span></span> <span data-ttu-id="9951f-1685">테이블에서 페이지 및 행 잠금을 해제하면 판독기가 공유 테이블 잠금을 통해 동시에 테이블에 액세스할 수 있어 주중 잠금 오버헤드가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1685">Turning off page and row locking on the table reduces the locking overhead throughout the week by allowing readers to concurrently access the table through shared table locks.</span></span> <span data-ttu-id="9951f-1686">일괄 작업을 실행하면 배타적 테이블 잠금을 얻어 업데이트를 효율적으로 완료할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1686">When the batch job runs, it can complete the update efficiently because it obtains an exclusive table lock.</span></span>  
  
 <span data-ttu-id="9951f-1687">주간 일괄 업데이트는 업데이트 실행 동안 동시 판독기의 테이블 액세스를 차단하므로 페이지 및 행 잠금 해제가 허용될 수도, 그렇지 않을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1687">Turning off page and row locking might or might not be acceptable because the weekly batch update will block the concurrent readers from accessing the table while the update runs.</span></span> <span data-ttu-id="9951f-1688">행 또는 페이지만 변경하는 일괄 작업의 경우, 행 또는 페이지 수준 잠금을 허용하도록 잠금 수준을 변경하여 다른 세션에서 차단 없이 테이블에서 읽기를 수행하도록 허용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1688">If the batch job only changes a few rows or pages, you can change the locking level to allow row or page level locking, which will enable other sessions to read from the table without blocking.</span></span> <span data-ttu-id="9951f-1689">업데이트가 다수 포함된 일괄 작업의 경우, 테이블에 대한 배타적 잠금이 효율적인 일괄 작업 완수를 위한 최상의 방법일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1689">If the batch job has a large number of updates, obtaining an exclusive lock on the table may be the best way to ensure the batch job finishes efficiently.</span></span>  
  
 <span data-ttu-id="9951f-1690">2건의 동시 작업에서 모두 페이지 잠금이 필요하여 동일 테이블에서 행 잠금을 구한 다음 차단함에 따라 교착 상태가 발생하는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1690">Occasionally a deadlock occurs when two concurrent operations acquire row locks on the same table and then block because they both need to lock the page.</span></span> <span data-ttu-id="9951f-1691">행 잠금을 허용하지 않으면 두 작업 중 하나를 대기시켜 교착 상태를 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1691">Disallowing row locks forces one of the operations to wait, avoiding the deadlock.</span></span>  
  
 <span data-ttu-id="9951f-1692">인덱스에 사용되는 잠금의 세분성은 CREATE INDEX 및 ALTER INDEX 문을 사용하여 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1692">The granularity of locking used on an index can be set using the CREATE INDEX and ALTER INDEX statements.</span></span> <span data-ttu-id="9951f-1693">잠금 설정은 인덱스 페이지와 테이블 페이지에 모두 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1693">The lock settings apply to both the index pages and the table pages.</span></span> <span data-ttu-id="9951f-1694">또한 CREATE TABLE 및 ALTER TABLE 문을 사용하여 PRIMARY KEY 및 UNIQUE 제약 조건에 대한 잠금 세분성을 설정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1694">In addition, the CREATE TABLE and ALTER TABLE statements can be used to set locking granularity on PRIMARY KEY and UNIQUE constraints.</span></span> <span data-ttu-id="9951f-1695">이전 버전과의 호환성을 위해 **sp_indexoption** 시스템 저장 프로시저 에서도 세분성을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1695">For backwards compatibility, the **sp_indexoption** system stored procedure can also set the granularity.</span></span> <span data-ttu-id="9951f-1696">특정 인덱스에 대한 현재 잠금 옵션을 표시하려면 INDEXPROPERTY 함수를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1696">To display the current locking option for a given index, use the INDEXPROPERTY function.</span></span> <span data-ttu-id="9951f-1697">페이지 수준 잠금, 행 수준 잠금 또는 페이지 수준 및 행 수준 잠금의 혼합 방법은 인덱스에 따라 허용되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1697">Page-level locks, row-level locks, or a combination of page-level and row-level locks can be disallowed for a given index.</span></span>  
  
|<span data-ttu-id="9951f-1698">허용되지 않는 잠금</span><span class="sxs-lookup"><span data-stu-id="9951f-1698">Disallowed locks</span></span>|<span data-ttu-id="9951f-1699">허용되는 잠금</span><span class="sxs-lookup"><span data-stu-id="9951f-1699">Index accessed by</span></span>|  
|----------------------|-----------------------|  
|<span data-ttu-id="9951f-1700">페이지 수준</span><span class="sxs-lookup"><span data-stu-id="9951f-1700">Page level</span></span>|<span data-ttu-id="9951f-1701">행 수준 및 테이블 수준 잠금</span><span class="sxs-lookup"><span data-stu-id="9951f-1701">Row-level and table-level locks</span></span>|  
|<span data-ttu-id="9951f-1702">행 수준</span><span class="sxs-lookup"><span data-stu-id="9951f-1702">Row level</span></span>|<span data-ttu-id="9951f-1703">페이지 수준 및 테이블 수준 잠금</span><span class="sxs-lookup"><span data-stu-id="9951f-1703">Page-level and table-level locks</span></span>|  
|<span data-ttu-id="9951f-1704">페이지 수준 및 행 수준</span><span class="sxs-lookup"><span data-stu-id="9951f-1704">Page level and row level</span></span>|<span data-ttu-id="9951f-1705">테이블 수준 잠금</span><span class="sxs-lookup"><span data-stu-id="9951f-1705">Table-level locks</span></span>|  
  
 <span data-ttu-id="9951f-1706">[이 가이드의](#Top) ![맨 위 링크와 함께 사용 되는 화살표 아이콘](media/uparrow16x16.gif "맨 위로 이동 링크와 함께 사용되는 화살표 아이콘")</span><span class="sxs-lookup"><span data-stu-id="9951f-1706">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="advanced-transaction-information"></a><a name="Advanced"></a> <span data-ttu-id="9951f-1707">고급 트랜잭션 정보</span><span class="sxs-lookup"><span data-stu-id="9951f-1707">Advanced Transaction Information</span></span>  
  
### <a name="nesting-transactions"></a><span data-ttu-id="9951f-1708">중첩 트랜잭션</span><span class="sxs-lookup"><span data-stu-id="9951f-1708">Nesting Transactions</span></span>  

 <span data-ttu-id="9951f-1709">명시적 트랜잭션은 중첩할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1709">Explicit transactions can be nested.</span></span> <span data-ttu-id="9951f-1710">중첩 트랜잭션은 주로 트랜잭션의 기존 프로세스나 활성 트랜잭션이 없는 프로세스에서 호출할 수 있는 저장 프로시저의 트랜잭션을 지원하기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1710">This is primarily intended to support transactions in stored procedures that can be called either from a process already in a transaction or from processes that have no active transaction.</span></span>  
  
 <span data-ttu-id="9951f-1711">다음 예에서는 중첩된 트랜잭션의 용도를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1711">The following example shows the intended use of nested transactions.</span></span> <span data-ttu-id="9951f-1712">`TransProc` 프로시저는 프로시저를 실행하는 프로세스의 트랜잭션 모드에 관계없이 트랜잭션을 강제 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1712">The procedure `TransProc` enforces its transaction regardless of the transaction mode of any process that executes it.</span></span> <span data-ttu-id="9951f-1713">트랜잭션이 활성 중일 때 `TransProc`를 호출하면 `TransProc`에서 중첩된 트랜잭션이 대부분 무시되고 바깥쪽 트랜잭션에서 수행된 최종 동작을 기준으로 INSERT 문이 커밋 또는 롤백됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1713">If `TransProc` is called when a transaction is active, the nested transaction in `TransProc` is largely ignored, and its INSERT statements are committed or rolled back based on the final action taken for the outer transaction.</span></span> <span data-ttu-id="9951f-1714">처리 중인 트랜잭션이 없는 프로세스에서 `TransProc`를 실행하면 실제로 프로시저 마지막에서 COMMIT TRANSACTION이 INSERT 문이 커밋됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1714">If `TransProc` is executed by a process that does not have an outstanding transaction, the COMMIT TRANSACTION at the end of the procedure effectively commits the INSERT statements.</span></span>  
  
```sql  
SET QUOTED_IDENTIFIER OFF;  
GO  
SET NOCOUNT OFF;  
GO  
CREATE TABLE TestTrans(Cola INT PRIMARY KEY,  
               Colb CHAR(3) NOT NULL);  
GO  
CREATE PROCEDURE TransProc @PriKey INT, @CharCol CHAR(3) AS  
BEGIN TRANSACTION InProc  
INSERT INTO TestTrans VALUES (@PriKey, @CharCol)  
INSERT INTO TestTrans VALUES (@PriKey + 1, @CharCol)  
COMMIT TRANSACTION InProc;  
GO  
/* Start a transaction and execute TransProc. */  
BEGIN TRANSACTION OutOfProc;  
GO  
EXEC TransProc 1, 'aaa';  
GO  
/* Roll back the outer transaction, this will  
   roll back TransProc's nested transaction. */  
ROLLBACK TRANSACTION OutOfProc;  
GO  
EXECUTE TransProc 3,'bbb';  
GO  
/* The following SELECT statement shows only rows 3 and 4 are   
   still in the table. This indicates that the commit  
   of the inner transaction from the first EXECUTE statement of  
   TransProc was overridden by the subsequent rollback. */  
SELECT * FROM TestTrans;  
GO  
```  
  
 <span data-ttu-id="9951f-1715">안쪽 트랜잭션 커밋은 [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]에서 무시합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1715">Committing inner transactions is ignored by the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)].</span></span> <span data-ttu-id="9951f-1716">트랜잭션은 가장 바깥쪽 트랜잭션 마지막에 수행된 동작을 기준으로 커밋 또는 롤백됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1716">The transaction is either committed or rolled back based on the action taken at the end of the outermost transaction.</span></span> <span data-ttu-id="9951f-1717">바깥쪽 트랜잭션이 커밋되면 안쪽 중첩 트랜잭션도 커밋됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1717">If the outer transaction is committed, the inner nested transactions are also committed.</span></span> <span data-ttu-id="9951f-1718">바깥쪽 트랜잭션이 롤백되면 안쪽 트랜잭션이 개별적으로 커밋되었는지에 관계없이 모든 안쪽 트랜잭션이 롤백됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1718">If the outer transaction is rolled back, then all inner transactions are also rolled back, regardless of whether or not the inner transactions were individually committed.</span></span>  
  
 <span data-ttu-id="9951f-1719">COMMIT TRANSACTION 또는 COMMIT WORK에 대한 각 호출은 마지막으로 실행한 BEGIN TRANSACTION에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1719">Each call to COMMIT TRANSACTION or COMMIT WORK applies to the last executed BEGIN TRANSACTION.</span></span> <span data-ttu-id="9951f-1720">BEGIN TRANSACTION 문을 중첩하면 COMMIT 문이 마지막으로 중첩된 트랜잭션, 즉 가장 안쪽의 트랜잭션에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1720">If the BEGIN TRANSACTION statements are nested, then a COMMIT statement applies only to the last nested transaction, which is the innermost transaction.</span></span> <span data-ttu-id="9951f-1721">중첩 된 트랜잭션 내의 COMMIT TRANSACTION *transaction_name* 문이 외부 트랜잭션의 트랜잭션 이름을 참조 하는 경우에도 커밋은 가장 안쪽의 트랜잭션에만 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1721">Even if a COMMIT TRANSACTION *transaction_name* statement within a nested transaction refers to the transaction name of the outer transaction, the commit applies only to the innermost transaction.</span></span>  
  
 <span data-ttu-id="9951f-1722">ROLLBACK TRANSACTION 문의 *transaction_name* 매개 변수는 명명 된 중첩 트랜잭션 집합의 내부 트랜잭션을 참조할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1722">It is not legal for the *transaction_name* parameter of a ROLLBACK TRANSACTION statement to refer to the inner transactions of a set of named nested transactions.</span></span> <span data-ttu-id="9951f-1723">*transaction_name*은 가장 바깥쪽 트랜잭션의 트랜잭션 이름만 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1723">*transaction_name* can refer only to the transaction name of the outermost transaction.</span></span> <span data-ttu-id="9951f-1724">바깥쪽 트랜잭션의 이름을 사용하는 ROLLBACK TRANSACTION *transaction_name* 문이 중첩 트랜잭션 집합의 특정 수준에서 실행되면 중첩된 트랜잭션이 모두 롤백됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1724">If a ROLLBACK TRANSACTION *transaction_name* statement using the name of the outer transaction is executed at any level of a set of nested transactions, all of the nested transactions are rolled back.</span></span> <span data-ttu-id="9951f-1725">*Transaction_name* 매개 변수 없이 rollback WORK 또는 rollback transaction 문이 중첩 된 트랜잭션 집합의 모든 수준에서 실행 되는 경우 가장 바깥쪽 트랜잭션을 포함 하 여 중첩 된 모든 트랜잭션을 롤백합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1725">If a ROLLBACK WORK or ROLLBACK TRANSACTION statement without a *transaction_name* parameter is executed at any level of a set of nested transaction, it rolls back all of the nested transactions, including the outermost transaction.</span></span>  
  
 <span data-ttu-id="9951f-1726">@ @TRANCOUNT 함수는 현재 트랜잭션 중첩 수준을 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1726">The @@TRANCOUNT function records the current transaction nesting level.</span></span> <span data-ttu-id="9951f-1727">각 BEGIN TRANSACTION 문은 @을 1 씩 증가 시킵니다 @TRANCOUNT .</span><span class="sxs-lookup"><span data-stu-id="9951f-1727">Each BEGIN TRANSACTION statement increments @@TRANCOUNT by one.</span></span> <span data-ttu-id="9951f-1728">각 COMMIT TRANSACTION 또는 COMMIT WORK 문은 @를 1 씩 감소 시킵니다 @TRANCOUNT .</span><span class="sxs-lookup"><span data-stu-id="9951f-1728">Each COMMIT TRANSACTION or COMMIT WORK statement decrements @@TRANCOUNT by one.</span></span> <span data-ttu-id="9951f-1729">트랜잭션 이름이 없는 ROLLBACK WORK 또는 ROLLBACK TRANSACTION 문은 모든 중첩 트랜잭션을 롤백하고 @ @TRANCOUNT 를 0으로 감소 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1729">A ROLLBACK WORK or a ROLLBACK TRANSACTION statement that does not have a transaction name rolls back all nested transactions and decrements @@TRANCOUNT to 0.</span></span> <span data-ttu-id="9951f-1730">중첩 된 트랜잭션 집합에서 가장 바깥쪽 트랜잭션의 트랜잭션 이름을 사용 하는 ROLLBACK 트랜잭션은 중첩 된 모든 트랜잭션을 롤백하고 @ @TRANCOUNT 을 0으로 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1730">A ROLLBACK TRANSACTION that uses the transaction name of the outermost transaction in a set of nested transactions rolls back all of the nested transactions and decrements @@TRANCOUNT to 0.</span></span> <span data-ttu-id="9951f-1731">트랜잭션에 이미 있는지 확실 하지 않은 경우 @를 선택 @TRANCOUNT 하 여 1 이상 인지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1731">When you are unsure if you are already in a transaction, SELECT @@TRANCOUNT to determine if it is 1 or more.</span></span> <span data-ttu-id="9951f-1732">@ @TRANCOUNT 가 0 이면 트랜잭션에 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1732">If @@TRANCOUNT is 0, you are not in a transaction.</span></span>  
  
### <a name="using-bound-sessions"></a><span data-ttu-id="9951f-1733">바운드 세션 사용</span><span class="sxs-lookup"><span data-stu-id="9951f-1733">Using Bound Sessions</span></span>  

 <span data-ttu-id="9951f-1734">바운드 세션을 통해 같은 서버의 여러 세션 간에 동작을 편리하게 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1734">Bound sessions ease the coordination of actions across multiple sessions on the same server.</span></span> <span data-ttu-id="9951f-1735">바운드 세션을 사용하면 두 개 이상의 세션에서 같은 트랜잭션과 잠금을 공유할 수 있으며 여러 바운드 세션이 잠금 충돌 없이 같은 데이터 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1735">Bound sessions allow two or more sessions to share the same transaction and locks, and can work on the same data without lock conflicts.</span></span> <span data-ttu-id="9951f-1736">바운드 세션은 같은 애플리케이션 내의 여러 세션에서 생성되거나 개별 세션의 여러 애플리케이션에서 생성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1736">Bound sessions can be created from multiple sessions within the same application or from multiple applications with separate sessions.</span></span>  
  
 <span data-ttu-id="9951f-1737">바운드 세션에 참여하려면 세션에서 개방형 Data Services를 통한 **srv_getbindtoken**이나 **sp_getbindtoken**을 호출하여 바인드 토큰을 가져와야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1737">To participate in a bound session, a session calls **sp_getbindtoken** or **srv_getbindtoken** (through Open Data Services) to get a bind token.</span></span> <span data-ttu-id="9951f-1738">바인드 토큰은 각 바운드 트랜잭션을 고유하게 식별하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1738">A bind token is a character string that uniquely identifies each bound transaction.</span></span> <span data-ttu-id="9951f-1739">가져온 바인드 토큰은 현재 세션과 바인딩할 다른 세션으로 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1739">The bind token is then sent to the other sessions to be bound with the current session.</span></span> <span data-ttu-id="9951f-1740">다른 세션은 첫 번째 세션으로부터 받은 바인드 토큰으로 **sp_bindsession**을 호출하여 트랜잭션에 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1740">The other sessions bind to the transaction by calling **sp_bindsession**, using the bind token received from the first session.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9951f-1741">**Sp_getbindtoken** 또는 **srv_getbindtoken** 성공 하려면 세션에 활성 사용자 트랜잭션이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1741">A session must have an active user transaction in order for **sp_getbindtoken** or **srv_getbindtoken** to succeed.</span></span>  
  
 <span data-ttu-id="9951f-1742">애플리케이션 코드에 대한 첫 번째 세션을 만들고 애플리케이션 코드의 세션을 첫 번째 세션에 바인딩하는 애플리케이션 코드에서 바인드 토큰을 전송해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1742">Bind tokens must be transmitted from the application code that makes the first session to the application code that subsequently binds their sessions to the first session.</span></span> <span data-ttu-id="9951f-1743">애플리케이션이 다른 프로세스에서 시작한 트랜잭션에 대한 바인드 토큰을 얻을 수 있는 [!INCLUDE[tsql](../includes/tsql-md.md)] 문이나 API 함수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1743">There is no [!INCLUDE[tsql](../includes/tsql-md.md)] statement or API function that an application can use to get the bind token for a transaction started by another process.</span></span> <span data-ttu-id="9951f-1744">다음과 같은 방법으로 바인드 토큰을 전송할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1744">Some of the methods that can be used to transmit a bind token include the following:</span></span>  
  
-   <span data-ttu-id="9951f-1745">세션이 모두 같은 애플리케이션 프로세스에서 시작되는 경우에는 바인드 토큰을 글로벌 메모리에 저장하거나 매개 변수로 함수에 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1745">If the sessions are all initiated from the same application process, bind tokens can be stored in global memory or passed into functions as a parameter.</span></span>  
  
-   <span data-ttu-id="9951f-1746">세션이 개별 애플리케이션 프로세스에서 생성되는 경우에는 RPC(원격 프로시저 호출)나 DDE(동적 데이터 교환) 등의 IPC(프로세스 간 통신)를 사용하여 바인드 토큰을 전송할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1746">If the sessions are made from separate application processes, bind tokens can be transmitted using interprocess communication (IPC), such as a remote procedure call (RPC) or dynamic data exchange (DDE).</span></span>  
  
-   <span data-ttu-id="9951f-1747">첫 번째 세션에 바인딩하려는 세션에서 읽을 수 있는 [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] 인스턴스의 테이블에 바인드 토큰을 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1747">Bind tokens can be stored in a table in an instance of the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] that can be read by processes wanting to bind to the first session.</span></span>  
  
 <span data-ttu-id="9951f-1748">항상 바운드 세션 집합의 한 세션만 활성화될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1748">Only one session in a set of bound sessions can be active at any time.</span></span> <span data-ttu-id="9951f-1749">세션이 인스턴스에서 문을 실행하고 있거나 인스턴스로부터 보류 중인 결과를 받으면 이 세션에 연결된 다른 세션은 현재 세션이 처리를 마치거나 현재 문을 취소할 때까지 해당 인스턴스에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1749">If one session is executing a statement on the instance or has results pending from the instance, no other session bound to it can access the instance until the current session finishes processing or cancels the current statement.</span></span> <span data-ttu-id="9951f-1750">인스턴스가 다른 바운드 세션의 문을 처리하고 있으면 트랜잭션 공간이 사용 중이므로 나중에 세션을 다시 시도해야 함을 나타내는 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1750">If the instance is busy processing a statement from another of the bound sessions, an error occurs indicating that the transaction space is in use and the session should retry later.</span></span>  
  
 <span data-ttu-id="9951f-1751">세션을 바인딩할 때 각 세션의 해당 격리 수준 설정이 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1751">When you bind sessions, each session retains its isolation level setting.</span></span> <span data-ttu-id="9951f-1752">SET TRANSACTION ISOLATION LEVEL을 사용하여 한 세션의 격리 수준 설정을 변경해도 이 세션에 바인딩된 다른 세션의 설정에는 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1752">Using SET TRANSACTION ISOLATION LEVEL to change the isolation level setting of one session does not affect the setting of any other session bound to it.</span></span>  
  
#### <a name="types-of-bound-sessions"></a><span data-ttu-id="9951f-1753">바운드 세션 유형</span><span class="sxs-lookup"><span data-stu-id="9951f-1753">Types of Bound Sessions</span></span>  

 <span data-ttu-id="9951f-1754">바운드 세션에는 로컬과 분산의 두 가지 유형이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1754">The two types of bound sessions are local and distributed.</span></span>  
  
-   <span data-ttu-id="9951f-1755">로컬 바운드 세션</span><span class="sxs-lookup"><span data-stu-id="9951f-1755">Local bound session</span></span>  
  
     <span data-ttu-id="9951f-1756">여러 바운드 세션이 [!INCLUDE[ssDE](../includes/ssde-md.md)]의 단일 인스턴스에서 단일 트랜잭션의 트랜잭션 공간을 공유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1756">Allows bound sessions to share the transaction space of a single transaction in a single instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)].</span></span>  
  
-   <span data-ttu-id="9951f-1757">분산 바운드 세션</span><span class="sxs-lookup"><span data-stu-id="9951f-1757">Distributed bound session</span></span>  
  
     <span data-ttu-id="9951f-1758">MS DTC([!INCLUDE[msCoName](../includes/msconame-md.md)] Distributed Transaction Coordinator)를 사용하여 전체 트랜잭션을 커밋하거나 롤백할 때까지 여러 바운드 세션이 둘 이상의 인스턴스에서 같은 트랜잭션을 공유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1758">Allows bound sessions to share the same transaction across two or more instances until the entire transaction is either committed or rolled back by using [!INCLUDE[msCoName](../includes/msconame-md.md)] Distributed Transaction Coordinator (MS DTC).</span></span>  
  
 <span data-ttu-id="9951f-1759">분산 바운드 세션은 문자열 바인드 토큰으로 식별되지 않고 분산 트랜잭션 식별 번호로 식별됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1759">Distributed bound sessions are not identified by a character string bind token; they are identified by distributed transaction identification numbers.</span></span> <span data-ttu-id="9951f-1760">바운드 세션이 로컬 트랜잭션과 관련되어 있고 원격 서버에서 SET REMOTE_PROC_TRANSACTIONS를 ON으로 설정하여 RPC를 실행하는 경우에는 MS DTC에 의해 로컬 바운드 트랜잭션이 분산 바운드 트랜잭션으로 자동 승격되고 MS DTC 세션이 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1760">If a bound session is involved in a local transaction and executes an RPC on a remote server with SET REMOTE_PROC_TRANSACTIONS ON, the local bound transaction is automatically promoted to a distributed bound transaction by MS DTC and an MS DTC session is started.</span></span>  
  
#### <a name="when-to-use-bound-sessions"></a><span data-ttu-id="9951f-1761">바운드 세션 사용 시기</span><span class="sxs-lookup"><span data-stu-id="9951f-1761">When to Use Bound Sessions</span></span>  

 <span data-ttu-id="9951f-1762">이전 버전의 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]에서 바운드 세션은 [!INCLUDE[tsql](../includes/tsql-md.md)] 문을 호출하는 프로세스를 대신하여 이 문을 실행해야 하는 확장 저장 프로시저를 개발하는 데 주로 사용되었습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1762">In earlier versions of [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], bound sessions were primarily used in developing extended stored procedures that must execute [!INCLUDE[tsql](../includes/tsql-md.md)] statements on behalf of the process that calls them.</span></span> <span data-ttu-id="9951f-1763">호출 프로세스에서 바인드 토큰을 확장 저장 프로시저의 한 매개 변수로 전달하도록 설정하면 프로시저가 호출 프로세스의 트랜잭션 공간에 참여하여 호출 프로시저와 확장 저장 프로시저가 통합됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1763">Having the calling process pass in a bind token as one parameter of the extended stored procedure allows the procedure to join the transaction space of the calling process, thereby integrating the extended stored procedure with the calling process.</span></span>  
  
 <span data-ttu-id="9951f-1764">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]에서는 저장 프로시저를 CLR로 작성하여 확장 저장 프로시저보다 뛰어난 안전성, 확장성 및 안정성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1764">In the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)], stored procedures written using CLR are more secure, scalable, and stable than extended stored procedures.</span></span> <span data-ttu-id="9951f-1765">CLR 저장 프로시저는 **Sqlcontext** 개체를 사용 하 여 **sp_bindsession**이 아닌 호출 세션의 컨텍스트에 참여 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1765">CLR-stored procedures use the **SqlContext** object to join the context of the calling session, not **sp_bindsession**.</span></span>  
  
 <span data-ttu-id="9951f-1766">바운드 세션을 사용하여 단일 업무 트랜잭션에서 함께 작업하는 여러 개별 프로그램에 비즈니스 논리가 통합되는 3계층 애플리케이션을 개발할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1766">Bound sessions can be used to develop three-tier applications in which business logic is incorporated into separate programs that work cooperatively on a single business transaction.</span></span> <span data-ttu-id="9951f-1767">이러한 프로그램의 경우 데이터베이스 액세스를 잘 조정하도록 코드를 작성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1767">These programs must be coded to carefully coordinate their access to a database.</span></span> <span data-ttu-id="9951f-1768">두 세션이 같은 잠금을 공유하기 때문에 두 프로그램이 동시에 같은 데이터를 수정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1768">Because the two sessions share the same locks, the two programs must not try to modify the same data at the same time.</span></span> <span data-ttu-id="9951f-1769">항상 한 세션만 트랜잭션의 일부로 작업을 수행할 수 있으므로 병렬 실행은 불가능합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1769">At any point in time, only one session can be doing work as part of the transaction; there can be no parallel execution.</span></span> <span data-ttu-id="9951f-1770">모든 DML 문이 완료되어 결과가 검색된 경우와 같이 잘 정의된 양보점(yield point)에서만 세션 간에 트랜잭션이 전환될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1770">The transaction can only be switched between sessions at well-defined yield points, such as when all DML statements have completed and their results have been retrieved.</span></span>  
  
### <a name="coding-efficient-transactions"></a><span data-ttu-id="9951f-1771">효율적인 트랜잭션 코딩</span><span class="sxs-lookup"><span data-stu-id="9951f-1771">Coding Efficient Transactions</span></span>  

 <span data-ttu-id="9951f-1772">트랜잭션을 되도록 짧게 유지하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1772">It is important to keep transactions as short as possible.</span></span> <span data-ttu-id="9951f-1773">트랜잭션이 시작되면 DBMS(데이터베이스 관리 시스템)가 트랜잭션이 끝날 때까지 많은 리소스를 보유하여 트랜잭션의 ACID(원자성, 일관성, 격리성, 영속성) 속성을 보호합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1773">When a transaction is started, a database management system (DBMS) must hold many resources until the end of the transaction to protect the atomicity, consistency, isolation, and durability (ACID) properties of the transaction.</span></span> <span data-ttu-id="9951f-1774">데이터가 수정되면 다른 트랜잭션이 읽을 수 없도록 수정된 행이 배타적 잠금으로 보호되어야 하며 트랜잭션이 커밋되거나 롤백될 때까지 배타적 잠금이 유지되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1774">If data is modified, the modified rows must be protected with exclusive locks that prevent any other transaction from reading the rows, and exclusive locks must be held until the transaction is committed or rolled back.</span></span> <span data-ttu-id="9951f-1775">트랜잭션 격리 수준 설정에 따라 SELECT 문에서 트랜잭션이 커밋 또는 롤백될 때까지 보유해야 하는 잠금을 획득할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1775">Depending on transaction isolation level settings, SELECT statements may acquire locks that must be held until the transaction is committed or rolled back.</span></span> <span data-ttu-id="9951f-1776">특히 많은 사용자가 사용하는 시스템에서는 트랜잭션을 되도록 짧게 유지하여 동시 연결 간에 리소스에 대한 잠금 경합을 줄여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1776">Especially in systems with many users, transactions must be kept as short as possible to reduce locking contention for resources between concurrent connections.</span></span> <span data-ttu-id="9951f-1777">실행 시간이 긴 비효율적인 트랜잭션은 사용자 수가 적을 때는 별로 문제가 되지 않지만 사용자가 많을 때는 심각한 문제가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1777">Long-running, inefficient transactions may not be a problem with small numbers of users, but they are intolerable in a system with thousands of users.</span></span> <span data-ttu-id="9951f-1778">[!INCLUDE[ssSQL14](../includes/sssql14-md.md)][!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]부터 지연된 영구 트랜잭션이 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1778">Beginning with [!INCLUDE[ssSQL14](../includes/sssql14-md.md)][!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] supports delayed durable transactions.</span></span> <span data-ttu-id="9951f-1779">지연된 내구성 있는 트랜잭션은 내구성을 보장하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1779">Delayed durable transactions do not guarantee durability.</span></span> <span data-ttu-id="9951f-1780">자세한 내용은 [트랜잭션 내구성](../relational-databases/logs/control-transaction-durability.md) 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-1780">See the topic [Transaction Durability](../relational-databases/logs/control-transaction-durability.md) for more information.</span></span>  
  
#### <a name="coding-guidelines"></a><span data-ttu-id="9951f-1781">코딩 지침</span><span class="sxs-lookup"><span data-stu-id="9951f-1781">Coding Guidelines</span></span>  

 <span data-ttu-id="9951f-1782">효율적인 트랜잭션을 코딩하려면 다음 지침을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="9951f-1782">These are guidelines for coding efficient transactions:</span></span>  
  
-   <span data-ttu-id="9951f-1783">트랜잭션 중 사용자로부터 입력을 요청하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="9951f-1783">Do not require input from users during a transaction.</span></span>  
  
     <span data-ttu-id="9951f-1784">트랜잭션이 시작되기 전에 사용자로부터 필요한 입력 내용을 모두 입력받아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1784">Get all required input from users before a transaction is started.</span></span> <span data-ttu-id="9951f-1785">트랜잭션 중 추가 사용자 입력이 필요하면 현재 트랜잭션을 롤백하고 사용자 입력이 제공된 후 트랜잭션을 다시 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1785">If additional user input is required during a transaction, roll back the current transaction and restart the transaction after the user input is supplied.</span></span> <span data-ttu-id="9951f-1786">사용자가 즉시 응답하더라도 사람의 반응 속도는 컴퓨터 속도보다 매우 느립니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1786">Even if users respond immediately, human reaction times are vastly slower than computer speeds.</span></span> <span data-ttu-id="9951f-1787">트랜잭션에 의해 보유된 모든 리소스는 꽤 긴 시간 동안 보유되므로 차단 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1787">All resources held by the transaction are held for an extremely long time, which has the potential to cause blocking problems.</span></span> <span data-ttu-id="9951f-1788">사용자가 응답하지 않으면 응답할 때까지 몇 분 또는 몇 시간 동안 트랜잭션이 계속 활성 상태로 남아 있고 중요한 리소스가 잠겨 있게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1788">If users do not respond, the transaction remains active, locking critical resources until they respond, which may not happen for several minutes or even hours.</span></span>  
  
-   <span data-ttu-id="9951f-1789">가능하면 데이터를 찾아보는 동안에는 트랜잭션을 열지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="9951f-1789">Do not open a transaction while browsing through data, if at all possible.</span></span>  
  
     <span data-ttu-id="9951f-1790">모든 예비 데이터 분석이 완료될 때까지 트랜잭션을 시작하지 말아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1790">Transactions should not be started until all preliminary data analysis has been completed.</span></span>  
  
-   <span data-ttu-id="9951f-1791">트랜잭션을 되도록 짧게 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1791">Keep the transaction as short as possible.</span></span>  
  
     <span data-ttu-id="9951f-1792">수정해야 한다고 판단되면 트랜잭션을 시작하고 수정 문을 실행한 다음 즉시 커밋 또는 롤백합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1792">After you know the modifications that have to be made, start a transaction, execute the modification statements, and then immediately commit or roll back.</span></span> <span data-ttu-id="9951f-1793">필요할 때까지는 트랜잭션을 열지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="9951f-1793">Do not open the transaction before it is required.</span></span>  
  
-   <span data-ttu-id="9951f-1794">차단을 줄이려면 읽기 전용 쿼리에 행 버전 관리 기반의 격리 수준을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1794">To reduce blocking, consider using a row versioning-based isolation level for read-only queries.</span></span>  
  
-   <span data-ttu-id="9951f-1795">낮은 트랜잭션 격리 수준을 효율적으로 사용하십시오.</span><span class="sxs-lookup"><span data-stu-id="9951f-1795">Make intelligent use of lower transaction isolation levels.</span></span>  
  
     <span data-ttu-id="9951f-1796">대부분의 애플리케이션은 커밋된 읽기 트랜잭션 격리 수준을 사용하도록 코딩할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1796">Many applications can be readily coded to use a read-committed transaction isolation level.</span></span> <span data-ttu-id="9951f-1797">모든 트랜잭션에서 직렬화 가능 트랜잭션 격리 수준이 필요한 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1797">Not all transactions require the serializable transaction isolation level.</span></span>  
  
-   <span data-ttu-id="9951f-1798">낙관적 동시성 옵션과 같이 낮은 커서 동시성 옵션을 효율적으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1798">Make intelligent use of lower cursor concurrency options, such as optimistic concurrency options.</span></span>  
  
     <span data-ttu-id="9951f-1799">동시 업데이트 가능성이 적은 시스템에서는 한 사용자가 데이터를 읽은 후 다른 사용자가 해당 데이터를 변경하여 발생하는 오류를 처리하는 오버헤드가 데이터를 읽을 때마다 행을 잠그는 오버헤드보다 훨씬 적을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1799">In a system with a low probability of concurrent updates, the overhead of dealing with an occasional "somebody else changed your data after you read it" error can be much lower than the overhead of always locking rows as they are read.</span></span>  
  
-   <span data-ttu-id="9951f-1800">트랜잭션에서는 가능한 적은 양의 데이터에 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1800">Access the least amount of data possible while in a transaction.</span></span>  
  
     <span data-ttu-id="9951f-1801">이렇게 하면 잠긴 행 수가 줄어들어 트랜잭션 간의 경합이 감소됩니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1801">This lessens the number of locked rows, thereby reducing contention between transactions.</span></span>  
  
#### <a name="avoiding-concurrency-and-resource-problems"></a><span data-ttu-id="9951f-1802">동시성 문제 및 리소스 문제 방지</span><span class="sxs-lookup"><span data-stu-id="9951f-1802">Avoiding Concurrency and Resource Problems</span></span>  

 <span data-ttu-id="9951f-1803">동시성 문제와 리소스 문제를 방지하려면 암시적 트랜잭션을 신중하게 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1803">To prevent concurrency and resource problems, manage implicit transactions carefully.</span></span> <span data-ttu-id="9951f-1804">암시적 트랜잭션을 사용할 때는 COMMIT 또는 ROLLBACK 다음의 [!INCLUDE[tsql](../includes/tsql-md.md)] 문이 자동으로 새 트랜잭션을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1804">When using implicit transactions, the next [!INCLUDE[tsql](../includes/tsql-md.md)] statement after COMMIT or ROLLBACK automatically starts a new transaction.</span></span> <span data-ttu-id="9951f-1805">이로 인해 애플리케이션에서 데이터를 찾아보는 동안이나 사용자 입력이 필요할 때 새 트랜잭션이 열릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1805">This can cause a new transaction to be opened while the application browses through data, or even when it requires input from the user.</span></span> <span data-ttu-id="9951f-1806">데이터 수정을 보호하는 데 필요한 마지막 트랜잭션을 완료한 다음 데이터 수정을 보호하기 위해 트랜잭션이 다시 한 번 필요할 때까지 암시적 트랜잭션을 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1806">After completing the last transaction required to protect data modifications, turn off implicit transactions until a transaction is once again required to protect data modifications.</span></span> <span data-ttu-id="9951f-1807">이렇게 하면 애플리케이션에서 데이터를 찾아보고 사용자로부터 입력을 받는 동안 [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]이 자동 커밋 모드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1807">This process lets the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] use autocommit mode while the application is browsing data and getting input from the user.</span></span>  
  
 <span data-ttu-id="9951f-1808">또한 스냅샷 격리 수준을 사용하면 새 트랜잭션이 잠금을 확보하지 않더라도 장기 실행 트랜잭션이 `tempdb`에서 이전 버전이 제거되지 않도록 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1808">In addition, when the snapshot isolation level is enabled, although a new transaction will not hold locks, a long-running transaction will prevent the old versions from being removed from `tempdb`.</span></span>  
  
### <a name="managing-long-running-transactions"></a><span data-ttu-id="9951f-1809">장기 실행 트랜잭션 관리</span><span class="sxs-lookup"><span data-stu-id="9951f-1809">Managing Long-Running Transactions</span></span>  

 <span data-ttu-id="9951f-1810">*장기 실행 트랜잭션*은 제때에 커밋되거나 롤백되지 않은 활성 트랜잭션입니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1810">A *long-running transaction* is an active transaction that has not been committed or roll backed the transaction in a timely manner.</span></span> <span data-ttu-id="9951f-1811">예를 들어 트랜잭션의 시작과 끝을 사용자가 제어하는 경우에는 대개 사용자가 트랜잭션을 시작한 후 트랜잭션에서 사용자의 응답을 기다리는 동안 자리를 비울 때 장기 실행 트랜잭션이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1811">For example, if the beginning and end of a transaction is controlled by the user, a typical cause of a long-running transaction is a user starting a transaction and then leaving while the transaction waits for a response from the user.</span></span>  
  
 <span data-ttu-id="9951f-1812">장기 실행 트랜잭션으로 인해 데이터베이스에 대해 다음과 같은 심각한 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1812">A long running transaction can cause serious problems for a database, as follows:</span></span>  
  
-   <span data-ttu-id="9951f-1813">활성 트랜잭션이 커밋되지 않은 많은 수정 작업을 수행한 후에 서버 인스턴스가 종료 되 면 이후 다시 시작의 복구 단계는 **recovery interval** 서버 구성 옵션 또는 ALTER database ...에서 지정한 시간 보다 훨씬 더 오래 걸릴 수 있습니다. TARGET_RECOVERY_TIME 옵션을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1813">If a server instance is shut down after an active transaction has performed many uncommitted modifications, the recovery phase of the subsequent restart can take much longer than the time specified by the **recovery interval** server configuration option or by the ALTER DATABASE... SET TARGET_RECOVERY_TIME option.</span></span> <span data-ttu-id="9951f-1814">이러한 옵션은 활성 검사점 및 간접 검사점의 빈도를 각각 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1814">These options control the frequency of active and indirect checkpoints, respectively.</span></span> <span data-ttu-id="9951f-1815">검사점 형식에 대한 자세한 내용은 [데이터베이스 검사점&#40;SQL Server&#41;](../relational-databases/logs/database-checkpoints-sql-server.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-1815">For more information about the types of checkpoints, see [Database Checkpoints &#40;SQL Server&#41;](../relational-databases/logs/database-checkpoints-sql-server.md).</span></span>  
  
-   <span data-ttu-id="9951f-1816">무엇보다도 대기 중인 트랜잭션은 로그를 거의 생성하지 않을 수 있지만 로그 잘림을 무한정 방해하여 트랜잭션 로그가 커져 가득 찰 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1816">More importantly, although a waiting transaction might generate very little log, it holds up log truncation indefinitely, causing the transaction log to grow and possibly fill up.</span></span> <span data-ttu-id="9951f-1817">트랜잭션 로그가 꽉 차면 데이터베이스에서 업데이트를 더 이상 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1817">If the transaction log fills up, the database cannot perform any more updates.</span></span> <span data-ttu-id="9951f-1818">자세한 내용은 [전체 트랜잭션 로그 &#40;문제 해결 SQL Server 오류 9002&#41;](../relational-databases/logs/troubleshoot-a-full-transaction-log-sql-server-error-9002.md)및 [트랜잭션 로그 &#40;SQL Server&#41;](../relational-databases/logs/the-transaction-log-sql-server.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-1818">For more information, see [Troubleshoot a Full Transaction Log &#40;SQL Server Error 9002&#41;](../relational-databases/logs/troubleshoot-a-full-transaction-log-sql-server-error-9002.md), and [The Transaction Log &#40;SQL Server&#41;](../relational-databases/logs/the-transaction-log-sql-server.md).</span></span>  
  
#### <a name="discovering-long-running-transactions"></a><span data-ttu-id="9951f-1819">장기 실행 트랜잭션 검색</span><span class="sxs-lookup"><span data-stu-id="9951f-1819">Discovering Long-Running Transactions</span></span>  

 <span data-ttu-id="9951f-1820">장기 실행 트랜잭션을 찾으려면 다음 중 하나를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1820">To look for long-running transactions, use one of the following:</span></span>  
  
-   <span data-ttu-id="9951f-1821">**sys.dm_tran_database_transactions**</span><span class="sxs-lookup"><span data-stu-id="9951f-1821">**sys.dm_tran_database_transactions**</span></span>  
  
     <span data-ttu-id="9951f-1822">이 동적 관리 뷰는 데이터베이스 수준에서 트랜잭션 정보를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1822">This dynamic management view returns information about transactions at the database level.</span></span> <span data-ttu-id="9951f-1823">장기 실행 트랜잭션과 특히 관련된 열에는 첫 번째 로그 레코드 시간(**database_transaction_begin_time**), 현재 트랜잭션 상태(**database_transaction_state**), 트랜잭션 로그(**database_transaction_begin_lsn**)에서 시작 레코드의 LSN(로그 시퀀스 번호) 등이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1823">For a long-running transaction, columns of particular interest include the time of the first log record (**database_transaction_begin_time**), the current state of the transaction (**database_transaction_state**), and the log sequence number (LSN) of the begin record in the transaction log (**database_transaction_begin_lsn**).</span></span>  
  
     <span data-ttu-id="9951f-1824">자세한 내용은 [sys.dm_tran_database_transactions&#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-database-transactions-transact-sql)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-1824">For more information, see [sys.dm_tran_database_transactions &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-database-transactions-transact-sql).</span></span>  
  
-   <span data-ttu-id="9951f-1825">DBCC OPENTRAN</span><span class="sxs-lookup"><span data-stu-id="9951f-1825">DBCC OPENTRAN</span></span>  
  
     <span data-ttu-id="9951f-1826">이 문을 사용하면 트랜잭션 소유자의 사용자 ID를 식별할 수 있으므로 트랜잭션의 출처를 추적하여 롤백 대신 커밋을 더 많이 수행하는 순차적 종료 작업을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1826">This statement lets you identify the user ID of the owner of the transaction, so you can potentially track down the source of the transaction for a more orderly termination (committing it rather than rolling it back).</span></span> <span data-ttu-id="9951f-1827">자세한 내용은 [DBCC OPENTRAN&#40;Transact-SQL&#41;](/sql/t-sql/database-console-commands/dbcc-opentran-transact-sql)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-1827">For more information, see [DBCC OPENTRAN &#40;Transact-SQL&#41;](/sql/t-sql/database-console-commands/dbcc-opentran-transact-sql).</span></span>  
  
#### <a name="stopping-a-transaction"></a><span data-ttu-id="9951f-1828">트랜잭션 중지</span><span class="sxs-lookup"><span data-stu-id="9951f-1828">Stopping a Transaction</span></span>  

 <span data-ttu-id="9951f-1829">KILL 문을 사용해야 하는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9951f-1829">You may have to use the KILL statement.</span></span> <span data-ttu-id="9951f-1830">그러나 특히 중요한 프로세스가 실행 중일 때는 이 문을 신중하게 사용하십시오.</span><span class="sxs-lookup"><span data-stu-id="9951f-1830">Use this statement very carefully, however, especially when critical processes are running.</span></span> <span data-ttu-id="9951f-1831">자세한 내용은 [KILL&#40;Transact-SQL&#41;](/sql/t-sql/language-elements/kill-transact-sql)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9951f-1831">For more information, see [KILL &#40;Transact-SQL&#41;](/sql/t-sql/language-elements/kill-transact-sql).</span></span>  
  
 <span data-ttu-id="9951f-1832">[이 가이드의](#Top) ![맨 위 링크와 함께 사용 되는 화살표 아이콘](media/uparrow16x16.gif "맨 위로 이동 링크와 함께 사용되는 화살표 아이콘")</span><span class="sxs-lookup"><span data-stu-id="9951f-1832">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9951f-1833">참고 항목</span><span class="sxs-lookup"><span data-stu-id="9951f-1833">See Also</span></span>  

 <span data-ttu-id="9951f-1834">[SQL Server 2005 행 버전 관리 기반 트랜잭션 격리](https://msdn.microsoft.com/library/ms345124(v=sql.90).aspx) </span><span class="sxs-lookup"><span data-stu-id="9951f-1834">[SQL Server 2005 Row Versioning-Based Transaction Isolation](https://msdn.microsoft.com/library/ms345124(v=sql.90).aspx) </span></span>  
 <span data-ttu-id="9951f-1835">[행 버전 관리 오버헤드](https://blogs.msdn.com/b/sqlserverstorageengine/archive/2008/03/30/overhead-of-row-versioning.aspx) </span><span class="sxs-lookup"><span data-stu-id="9951f-1835">[Overhead of Row Versioning](https://blogs.msdn.com/b/sqlserverstorageengine/archive/2008/03/30/overhead-of-row-versioning.aspx) </span></span>  
 [<span data-ttu-id="9951f-1836">SQL Server 2008에서 자치 트랜잭션을 만드는 방법</span><span class="sxs-lookup"><span data-stu-id="9951f-1836">How to create an autonomous transaction in SQL Server 2008</span></span>](https://blogs.msdn.com/b/sqlprogrammability/archive/2008/08/22/how-to-create-an-autonomous-transaction-in-sql-server-2008.aspx)  
  
  
