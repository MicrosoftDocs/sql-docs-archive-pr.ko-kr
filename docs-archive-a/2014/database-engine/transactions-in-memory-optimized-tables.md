---
title: 메모리 액세스에 최적화 된 테이블의 트랜잭션 | Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 2cd07d26-a1f1-4034-8d6f-f196eed1b763
author: stevestein
ms.author: sstein
ms.openlocfilehash: bc9109c7243e609e5ddd820b61386183761167bf
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87742472"
---
# <a name="transactions-in-memory-optimized-tables"></a><span data-ttu-id="52165-102">메모리 액세스에 최적화된 테이블의 트랜잭션</span><span class="sxs-lookup"><span data-stu-id="52165-102">Transactions in Memory-Optimized Tables</span></span>
  <span data-ttu-id="52165-103">디스크 기반 테이블의 행 버전 관리(SNAPSHOT 격리 또는 READ_COMMITTED_SNAPSHOT 사용)는 낙관적 동시성 제어의 형태를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-103">Row versioning on disk-based tables (using SNAPSHOT isolation or READ_COMMITTED_SNAPSHOT) provides a form of optimistic concurrency control.</span></span> <span data-ttu-id="52165-104">판독기와 기록기는 서로를 차단하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-104">Readers and writers do not block each other.</span></span> <span data-ttu-id="52165-105">메모리 최적화 테이블을 사용하면 기록기는 기록기를 차단하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-105">With memory-optimized tables, writers do not block writers.</span></span> <span data-ttu-id="52165-106">디스크 기반 테이블에서 행 버전 관리를 사용하면 한 트랜잭션은 행을 잠그며 이 행을 업데이트하려고 하는 동시 트랜잭션은 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="52165-106">With row versioning on disk-based tables, one transaction locks the row and concurrent transactions attempting to update the row are blocked.</span></span> <span data-ttu-id="52165-107">메모리 최적화 테이블을 사용할 때는 잠금 기능이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-107">There is no locking with memory-optimized tables.</span></span> <span data-ttu-id="52165-108">대신 두 트랜잭션이 같은 행을 업데이트하려고 하는 경우 쓰기/쓰기 충돌이 발생하게 됩니다(오류 41302).</span><span class="sxs-lookup"><span data-stu-id="52165-108">Instead, if two transactions attempt to update the same row, a write/write conflict (error 41302) will occur.</span></span>

 <span data-ttu-id="52165-109">디스크 기반 테이블과 달리 메모리 최적화 테이블을 사용하면 더 높은 격리 수준인 REPEATABLE READ 및 SERIALIZABLE을 사용하여 낙관적 동시성 제어를 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-109">Unlike disk-based tables, memory-optimized tables allow optimistic concurrency control with the higher isolation levels, REPEATABLE READ and SERIALIZABLE.</span></span> <span data-ttu-id="52165-110">격리 수준을 적용하기 위해 잠금은 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-110">Locks are not taken to enforce the isolation levels.</span></span> <span data-ttu-id="52165-111">대신 트랜잭션이 끝나면 반복 읽기나 순차성 가정을 확실하기 하기 위해 유효성 검사가 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="52165-111">Instead, at the end of the transaction validation ensures the repeatable read or serializability assumptions.</span></span> <span data-ttu-id="52165-112">가정을 위반하는 경우 트랜잭션이 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="52165-112">If the assumptions are violated, the transaction is terminated.</span></span> <span data-ttu-id="52165-113">자세한 내용은 [Transaction Isolation Levels](../../2014/database-engine/transaction-isolation-levels.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="52165-113">For more information, see [Transaction Isolation Levels](../../2014/database-engine/transaction-isolation-levels.md).</span></span>

 <span data-ttu-id="52165-114">메모리 최적화 테이블의 중요한 트랜잭션 의미는</span><span class="sxs-lookup"><span data-stu-id="52165-114">The important transaction semantics for memory-optimized tables are:</span></span>

-   <span data-ttu-id="52165-115">다중 버전 관리</span><span class="sxs-lookup"><span data-stu-id="52165-115">Multi-versioning</span></span>

-   <span data-ttu-id="52165-116">스냅샷 기반 트랜잭션 격리</span><span class="sxs-lookup"><span data-stu-id="52165-116">Snapshot-based transaction isolation</span></span>

-   <span data-ttu-id="52165-117">Optimistic</span><span class="sxs-lookup"><span data-stu-id="52165-117">Optimistic</span></span>

-   <span data-ttu-id="52165-118">충돌 검색</span><span class="sxs-lookup"><span data-stu-id="52165-118">Conflict detection</span></span>

 <span data-ttu-id="52165-119">각각에 대한 의미는 다음 섹션에서 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-119">Each of these semantics is explained in the following sections.</span></span>

## <a name="multi-versioning-in-memory-optimized-tables"></a><span data-ttu-id="52165-120">메모리 액세스에 최적화된 테이블에서 다중 버전 관리</span><span class="sxs-lookup"><span data-stu-id="52165-120">Multi-Versioning in Memory-Optimized Tables</span></span>
 <span data-ttu-id="52165-121">메모리 최적화 테이블의 행에 다른 버전이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-121">Rows in memory-optimized tables can have different versions.</span></span> <span data-ttu-id="52165-122">동시 트랜잭션은 같은 행의 다른 버전에 액세스할 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-122">Concurrent transactions access potentially different versions of the same row.</span></span>

 <span data-ttu-id="52165-123">메모리 액세스에 최적화된 테이블은 버전을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-123">Memory-optimized table data is version-based.</span></span> <span data-ttu-id="52165-124">모든 행에 대해 다른 행 버전이 있을 수 있으며 다른 시점에서 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-124">For any row there may be different row versions that are valid at different points in time.</span></span> <span data-ttu-id="52165-125">READ_COMMITTED_SNAPSHOT 또는 ALLOW_SNAPSHOT_ISOLATION이 ON이면 디스크 기반 테이블에서 여러 행 버전을 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-125">Disk-based tables maintain different row versions when READ_COMMITTED_SNAPSHOT or ALLOW_SNAPSHOT_ISOLATION is ON.</span></span> <span data-ttu-id="52165-126">메모리 액세스에 최적화된 테이블은 READ_COMMITTED_SNAPSHOT 및 ALLOW_SNAPSHOT_ISOLATION이 OFF여도 다른 행 버전을 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-126">Memory-optimized tables maintain different row versions, even if READ_COMMITTED_SNAPSHOT and ALLOW_SNAPSHOT_ISOLATION are OFF.</span></span> <span data-ttu-id="52165-127">tempdb에서는 메모리 최적화 테이블의 행 버전이 유지되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-127">The row versions of memory-optimized tables are not maintained in tempdb.</span></span> <span data-ttu-id="52165-128">대신, 행 버전은 메모리에 행을 저장하는 메모리 최적화 데이터 구조의 한 부분으로 인라인으로 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="52165-128">Instead, the row versions are maintained in-line, as part of the memory-optimized data structures storing the rows in memory.</span></span>

## <a name="snapshot-based-transaction-isolation-for-memory-optimized-tables"></a><span data-ttu-id="52165-129">메모리 액세스에 최적화된 테이블의 스냅샷 기반 트랜잭션 격리</span><span class="sxs-lookup"><span data-stu-id="52165-129">Snapshot-Based Transaction Isolation for Memory-Optimized Tables</span></span>
 <span data-ttu-id="52165-130">단일 트랜잭션의 모든 작업은 트랜잭션 측면에서 메모리 최적화 테이블의 동일한 일관성 스냅샷을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-130">All operations in a single transaction use the same transactionally-consistent snapshot of the memory-optimized tables.</span></span> <span data-ttu-id="52165-131">메모리 최적화 테이블의 모든 트랜잭션 격리는 스냅샷을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-131">All transaction isolation for memory-optimized tables is snapshot-based.</span></span> <span data-ttu-id="52165-132">예를 들어, 직렬화 가능 격리 수준을 사용하여 메모리 최적화 테이블에 액세스하는 트랜잭션은 동일한 트랜잭션 측면에서 일관된 스냅샷에서 모든 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-132">For example, a transaction using the serializable isolation level to access memory-optimized tables will perform all operations on the same transactionally consistent snapshot.</span></span>

 <span data-ttu-id="52165-133">메모리 최적화 테이블에 액세스하는 트랜잭션은 이 행 버전 관리를 사용하여 트랜잭션 측면에서 테이블에 있는 행의 일관된 스냅샷을 얻습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-133">Transactions that access memory-optimized tables use this row versioning to obtain a transactionally consistent snapshot of the rows in the tables.</span></span> <span data-ttu-id="52165-134">트랜잭션의 문이 읽은 데이터는 트랜잭션을 시작할 때 존재하던 데이터 버전과 트랜잭션별로 일관성이 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="52165-134">The data read by any statement in the transaction will be the transactionally consistent version of the data that existed at the time the transaction started.</span></span> <span data-ttu-id="52165-135">따라서 동시에 실행 중인 트랜잭션의 수정 내용이 현재 트랜잭션의 문에는 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-135">Therefore, any modifications made by concurrently running transactions are not visible to statements in the current transaction.</span></span>

## <a name="optimistic-concurrency-control-for-memory-optimized-tables"></a><span data-ttu-id="52165-136">메모리 액세스에 최적화된 테이블의 낙관적 동시성 제어</span><span class="sxs-lookup"><span data-stu-id="52165-136">Optimistic Concurrency Control for Memory-Optimized Tables</span></span>
 <span data-ttu-id="52165-137">충돌과 오류는 드물게 발생하며 메모리 최적화 테이블의 트랜잭션은 동시 트랜잭션과의 충돌이 없고 작업이 성공한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-137">Conflicts and failures are rare and transactions on memory-optimized tables assume there are no conflicts with concurrent transactions and operations succeed.</span></span> <span data-ttu-id="52165-138">트랜잭션에서 트랜잭션 격리를 보증하기 위해 메모리 최적화 테이블에 잠금이나 래치를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-138">Transactions do not take locks or latches on memory-optimized table to guarantee transaction isolation.</span></span> <span data-ttu-id="52165-139">기록기는 판독기를 차단하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-139">Writers do not block readers.</span></span> <span data-ttu-id="52165-140">기록기는 기록기를 차단하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-140">Writers do not block writers.</span></span> <span data-ttu-id="52165-141">대신 트랜잭션은 다른 트랜잭션과 충돌이 없을 것이라는 (낙관적) 가정 하에서 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="52165-141">Instead, transactions proceed under the (optimistic) assumption that there will be no conflicts with other transactions.</span></span> <span data-ttu-id="52165-142">잠금과 래치를 사용하지 않고 다른 트랜잭션에서 같은 행 처리를 마칠 때까지 기다리지 않으면 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="52165-142">Not using locks and latches and not waiting for other transactions to finish processing the same rows improves performance.</span></span>

 <span data-ttu-id="52165-143">또한 커밋 중인 다른 트랜잭션(TxB)이 삽입하거나 수정한 행을 트랜잭션(TxA)이 읽는 경우 커밋이 발생하기를 기다리는 대신 다른 트랜잭션이 커밋한다고 낙관적으로 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-143">In addition, if a transaction (TxA) reads rows that have been inserted or modified by another transaction (TxB) that is in the process of committing, it will optimistically assume the other transaction will commit rather than wait for the commit to occur.</span></span> <span data-ttu-id="52165-144">이 경우 트랜잭션 TxA는 트랜잭션 TxB에서 커밋 종속성을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-144">In this case, transaction TxA will take a commit dependency on transaction TxB.</span></span>

## <a name="conflict-detection-validation-and-commit-dependency-checks"></a><span data-ttu-id="52165-145">충돌 검색, 유효성 검사 및 커밋 종속성 확인</span><span class="sxs-lookup"><span data-stu-id="52165-145">Conflict Detection, Validation, and Commit Dependency Checks</span></span>
 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]<span data-ttu-id="52165-146">에서는 동시 트랜잭션 사이의 충돌, 격리 수준 위반을 감지하고 충돌하는 트랜잭션 중 하나를 종료시킵니다.</span><span class="sxs-lookup"><span data-stu-id="52165-146">detects conflicts between concurrent transactions, as well as isolation level violations, and will doom one of the conflicting transactions.</span></span> <span data-ttu-id="52165-147">이 트랜잭션은 다시 시도해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-147">This transaction will need to be retried.</span></span> <span data-ttu-id="52165-148">(자세한 내용은 메모리 액세스에 [최적화 된 테이블의 트랜잭션에 대 한 재시도 논리에 대 한 지침](../relational-databases/in-memory-oltp/memory-optimized-tables.md)을 참조 하세요.)</span><span class="sxs-lookup"><span data-stu-id="52165-148">(For more information, see [Guidelines for Retry Logic for Transactions on Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).)</span></span>

 <span data-ttu-id="52165-149">시스템은 아무 충돌도 없고 트랜잭션 격리의 위반이 없다고 낙관적으로 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-149">The system optimistically assumes there are no conflicts and no violations of transaction isolation.</span></span> <span data-ttu-id="52165-150">충돌이 있어 데이터베이스에 불일치가 발생하거나 트랜잭션 격리를 위반할 수 있는 경우 이러한 충돌은 감지되고 트랜잭션이 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="52165-150">If any conflicts occur that may cause inconsistencies in the database or that may violate transaction isolation, these conflicts are detected, and the transaction is terminated.</span></span>

 <span data-ttu-id="52165-151">충돌이 감지되면 트랜잭션이 종료되고 클라이언트를 다시 시도해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-151">If a conflict is detected, the transaction is terminated and the client needs to retry.</span></span>

 <span data-ttu-id="52165-152">다음 표에는 메모리 최적화 테이블에 액세스하는 트랜잭션에 대한 오류 조건이 요약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-152">The following table summarizes the error conditions for transactions that accesses memory-optimized tables.</span></span>

### <a name="error-conditions-for-transactions-accessing-memory-optimized-tables"></a><span data-ttu-id="52165-153">메모리 최적화 테이블에 액세스하는 트랜잭션에 대한 오류 조건.</span><span class="sxs-lookup"><span data-stu-id="52165-153">Error conditions for transactions accessing memory-optimized tables.</span></span>

|<span data-ttu-id="52165-154">오류</span><span class="sxs-lookup"><span data-stu-id="52165-154">Error</span></span>|<span data-ttu-id="52165-155">시나리오</span><span class="sxs-lookup"><span data-stu-id="52165-155">Scenario</span></span>|
|-----------|--------------|
|<span data-ttu-id="52165-156">쓰기 충돌.</span><span class="sxs-lookup"><span data-stu-id="52165-156">Write conflict.</span></span> <span data-ttu-id="52165-157">트랜잭션이 시작된 이후 업데이트된 레코드를 업데이트 하려고 시도.</span><span class="sxs-lookup"><span data-stu-id="52165-157">Attempting to update a record that has been updated since the transaction started.</span></span>|<span data-ttu-id="52165-158">동시 트랜잭션에 의해 업데이트 또는 삭제된 행을 업데이트하거나 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-158">UPDATE or DELETE a row that has been updated or deleted by a concurrent transaction.</span></span>|
|<span data-ttu-id="52165-159">반복 가능한 읽기 유효성 검사 오류.</span><span class="sxs-lookup"><span data-stu-id="52165-159">Repeatable read validation failure.</span></span>|<span data-ttu-id="52165-160">트랜잭션이 시작된 이후 트랜잭션에서 읽은 행이 변경되었습니다(업데이트 또는 삭제).</span><span class="sxs-lookup"><span data-stu-id="52165-160">A row that was read by the transaction has changed (updated or deleted) since the transaction started.</span></span> <span data-ttu-id="52165-161">반복 읽기 유효성 검사는 대개 REPEATABLE READ 및 SERIALIZABLE 트랜잭션 격리 수준을 사용할 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-161">Repeatable read validation is typically occurs when using REPEATABLE READ and SERIALIZABLE transaction isolation levels.</span></span>|
|<span data-ttu-id="52165-162">직렬화 유효성 검사 오류.</span><span class="sxs-lookup"><span data-stu-id="52165-162">Serializable validation failure.</span></span>|<span data-ttu-id="52165-163">트랜잭션이 시작된 이후 새로운(가상) 행이 트랜잭션의 검색 범위 중 하나에 삽입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-163">A new (phantom) row has been inserted in one of the scan ranges in the transaction, since the transaction started.</span></span> <span data-ttu-id="52165-164">트랜잭션이 시작되기 전에 행이 데이터베이스에 커밋된 경우 트랜잭션에 해당 행이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="52165-164">The row would have been visible to the transaction if the row had been committed to the database before the transaction started.</span></span> <span data-ttu-id="52165-165">SERIALIZABLE 유효성 검사는 대개 SERIALIZABLE 격리를 사용하고 PRIMARY KEY 제약 조건의 유효성을 검사할 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-165">SERIALIZABLE validation typically occurs when using SERIALIZABLE isolation and validating PRIMARY KEY constraints.</span></span>|
|<span data-ttu-id="52165-166">커밋 종속성이 실패했습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-166">Commit dependency failure.</span></span>|<span data-ttu-id="52165-167">트랜잭션이 이 테이블의 오류 중 하나, 메모리 부족 상태 또는 트랜잭션 로그에 대한 커밋 실패로 인해 커밋하지 못한 다른 트랜잭션에서 종속성을 수행했습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-167">The transaction took a dependency on another transaction that failed to commit, either due to one of the failures in this table, an out-of-memory condition, or due to failure to commit to the transaction log.</span></span> <span data-ttu-id="52165-168">이 오류는 읽기/쓰기와 읽기 전용 트랜잭션에서 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-168">This failure can occur with both read/write and read-only transactions.</span></span>|

### <a name="transaction-lifetime"></a><span data-ttu-id="52165-169">트랜잭션 수명</span><span class="sxs-lookup"><span data-stu-id="52165-169">Transaction Lifetime</span></span>
 <span data-ttu-id="52165-170">이전 테이블에서 언급한 오류는 트랜잭션 중 여러 지점에서 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-170">The failures mentioned in the previous table can occur at different points during a transaction.</span></span> <span data-ttu-id="52165-171">다음 그림은 메모리 최적화 테이블에 액세스하는 트랜잭션의 단계를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="52165-171">The following figure illustrates the phases of a transaction that accesses memory-optimized tables.</span></span>

 <span data-ttu-id="52165-172">![트랜잭션 수명](../../2014/database-engine/media/hekaton-transactions.gif "트랜잭션 수명")</span><span class="sxs-lookup"><span data-stu-id="52165-172">![Lifetime of a transaction.](../../2014/database-engine/media/hekaton-transactions.gif "Lifetime of a transaction.")</span></span>
<span data-ttu-id="52165-173">메모리 최적화 테이블에 액세스하는 트랜잭션의 수명입니다.</span><span class="sxs-lookup"><span data-stu-id="52165-173">Lifetime of a transaction that accesses memory-optimized tables.</span></span>

#### <a name="regular-processing"></a><span data-ttu-id="52165-174">일반 처리</span><span class="sxs-lookup"><span data-stu-id="52165-174">Regular Processing</span></span>
 <span data-ttu-id="52165-175">이 단계에서는 사용자가 시작한 [!INCLUDE[tsql](../includes/tsql-md.md)]문이 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="52165-175">During this phase, the user-issued [!INCLUDE[tsql](../includes/tsql-md.md)] statements are executed.</span></span> <span data-ttu-id="52165-176">테이블에서 행을 읽고 데이터베이스에 새로운 행 버전을 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-176">Rows are read from the tables, and new row versions are written to the database.</span></span> <span data-ttu-id="52165-177">트랜잭션은 다른 모든 동시 트랜잭션으로부터 격리됩니다.</span><span class="sxs-lookup"><span data-stu-id="52165-177">The transaction is isolated from all other concurrent transactions.</span></span> <span data-ttu-id="52165-178">트랜잭션은 트랜잭션 시작 시 있는 메모리 최적화 테이블의 스냅샷을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-178">The transaction uses the snapshot of the memory-optimized tables that exists at the start of the transaction.</span></span>

 <span data-ttu-id="52165-179">트랜잭션의이 단계에서 테이블에 대 한 쓰기는 다른 트랜잭션에 아직 표시 되지 않습니다. 단, 쓰기 충돌을 감지 하기 위해 행 업데이트와 삭제가 다른 트랜잭션의 업데이트 및 삭제 작업에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="52165-179">Writes to the tables in this phase of the transaction are not yet visible to other transactions, with one exception: row updates and deletes are visible to update and delete operations in other transactions, in order to detect write conflicts.</span></span>

 <span data-ttu-id="52165-180">업데이트나 삭제 작업 중 트랜잭션의 논리적 시작 이후로 행이 업데이트 또는 삭제된 것이 확인되면 작업은 오류 41302가 발생하며 실패하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="52165-180">If an update or delete operation sees that a row has been updated or deleted since the logical start of the transaction, the operation will fail with error 41302.</span></span> <span data-ttu-id="52165-181">오류 41302의 메시지는 "현재 트랜잭션에서 이 트랜잭션이 시작된 이후로 업데이트된 레코드를 업데이트하려고 시도했습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-181">The message for error 41302 is "The current transaction attempted to update a record in table X that has been updated since this transaction started.</span></span> <span data-ttu-id="52165-182">트랜잭션이 중단되었습니다."입니다.</span><span class="sxs-lookup"><span data-stu-id="52165-182">The transaction was aborted."</span></span>

 <span data-ttu-id="52165-183">이 오류는 XACT_ABORT가 OFF로 설정되어 있어도 트랜잭션을 종료시킵니다. 즉, 사용자 세션이 종료되면 트랜잭션이 롤백됩니다.</span><span class="sxs-lookup"><span data-stu-id="52165-183">This error dooms the transaction (even if XACT_ABORT is OFF), meaning that the transaction will be rolled back when the user session ends.</span></span> <span data-ttu-id="52165-184">종료된 트랜잭션을 커밋할 수 없으며 로그에 쓰지 않는 읽기 작업을 지원하고 메모리 최적화 테이블에 액세스하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-184">Doomed transactions cannot be committed and only support read operations that do not write to the log and do not access memory-optimized tables.</span></span>

#####  <a name="commit-dependencies"></a><a name="cd"></a><span data-ttu-id="52165-185">커밋 종속성</span><span class="sxs-lookup"><span data-stu-id="52165-185">Commit Dependencies</span></span>
 <span data-ttu-id="52165-186">정상적인 처리 중에 트랜잭션은 유효성 검사 또는 커밋 단계에 있지만 아직 커밋되지 않은 다른 트랜잭션에서 기록한 행을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-186">During regular processing, a transaction can read rows written by other transactions that are in the validation or commit phase, but have not yet committed.</span></span> <span data-ttu-id="52165-187">유효성 검사 단계를 시작할 때 트랜잭션의 논리적 종료 시간이 할당되었기 때문에 행을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-187">The rows are visible because the logical end time of the transactions has been assigned at the start of the validation phase.</span></span>

 <span data-ttu-id="52165-188">트랜잭션이 이런 커밋되지 않은 행을 읽는 경우 해당 트랜잭션에서 커밋 종속성을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-188">If a transaction reads such uncommitted rows, it will take a commit dependency on that transaction.</span></span> <span data-ttu-id="52165-189">여기에는 두 가지 주요 문제점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-189">This has two main implications:</span></span>

-   <span data-ttu-id="52165-190">트랜잭션은 자신이 종속된 트랜잭션이 커밋될 때까지 커밋될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-190">A transaction cannot commit until the transactions it depends on have committed.</span></span> <span data-ttu-id="52165-191">즉, 모든 종속성이 삭제될 때까지 커밋 단계에 들어갈 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-191">In other words, it cannot enter the commit phase, until all dependencies have cleared.</span></span>

-   <span data-ttu-id="52165-192">또한 모든 종속성이 삭제될 때까지 클라이언트에 결과 집합이 반환되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-192">In addition, result sets are not returned to the client until all dependencies have cleared.</span></span> <span data-ttu-id="52165-193">따라서 클라이언트가 커밋되지 않은 데이터를 관찰하지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-193">This prevents the client from observing uncommitted data.</span></span>

 <span data-ttu-id="52165-194">종속 트랜잭션이 커밋에 실패하는 경우 커밋 종속성 오류가 있는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="52165-194">If any of the dependent transactions fails to commit, there is a commit dependency failure.</span></span> <span data-ttu-id="52165-195">즉, 트랜잭션이 오류 41301이 발생하며 커밋에 실패하게 됩니다("현재 트랜잭션이 종속성을 갖고 있는 이전 트랜잭션이 중단되어 현재 트랜잭션을 더 이상 커밋할 수 없습니다.").</span><span class="sxs-lookup"><span data-stu-id="52165-195">This means the transaction will fail to commit with error 41301 ("A previous transaction that the current transaction took a dependency on has aborted, and the current transaction can no longer commit.").</span></span>

#### <a name="validation-phase"></a><span data-ttu-id="52165-196">유효성 검사 단계</span><span class="sxs-lookup"><span data-stu-id="52165-196">Validation Phase</span></span>
 <span data-ttu-id="52165-197">유효성 검사 단계 동안 시스템은 요청한 트랜잭션 격리 수준에 필요한 가정이 트랜잭션의 논리적 시작과 논리적 종료 사이에 참이었는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-197">During the validation phase, the system validates that the assumptions necessary for the requested transaction isolation level were true between the logical start and logical end of the transaction.</span></span>

 <span data-ttu-id="52165-198">유효성 검사 단계를 시작할 때 트랜잭션에는 논리적 종료 시간이 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="52165-198">At the start of the validation phase, the transaction is assigned a logical end time.</span></span> <span data-ttu-id="52165-199">데이터베이스에 기록된 행 버전은 논리적 종료 시간에 다른 트랜잭션에 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="52165-199">The row versions written in the database become visible to other transactions at the logical end time.</span></span> <span data-ttu-id="52165-200">자세한 내용은 [커밋 종속성](#cd)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="52165-200">For more information, see [Commit Dependencies](#cd).</span></span>

##### <a name="repeatable-read-validation"></a><span data-ttu-id="52165-201">반복 가능한 읽기 유효성 검사</span><span class="sxs-lookup"><span data-stu-id="52165-201">Repeatable Read Validation</span></span>
 <span data-ttu-id="52165-202">트랜잭션의 격리 수준을 반복 읽기 또는 SERIALIZABLE로 설정 하거나 반복 읽기 또는 직렬화 가능 격리에서 테이블에 액세스 하는 경우 (자세한 내용은 [트랜잭션 격리 수준](../../2014/database-engine/transaction-isolation-levels.md)에서 개별 작업의 격리에 대 한 섹션 참조), 시스템은 읽기가 반복 가능한 지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-202">If the isolation level of the transaction is REPEATABLE READ or SERIALIZABLE, or if tables are accessed under REPEATABLE READ or SERIALIZABLE isolation (for more information, see the section on Isolation of Individual Operations in [Transaction Isolation Levels](../../2014/database-engine/transaction-isolation-levels.md)), the system validates that the reads are repeatable.</span></span> <span data-ttu-id="52165-203">즉, 트랜잭션에서 읽은 행의 버전이 트랜잭션의 논리적 종료 시간에 여전히 유효한 행 버전인 것으로 유효성을 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-203">This means it validates that the versions of the rows read by the transaction are still valid row versions at the logical end time of the transaction.</span></span>

 <span data-ttu-id="52165-204">행이 업데이트 또는 변경된 경우 트랜잭션은 오류 41305가 발생하며 커밋에 실패합니다("반복 읽기 유효성 검사 실패로 인해 현재 트랜잭션을 커밋하지 못했습니다.").</span><span class="sxs-lookup"><span data-stu-id="52165-204">If any of the rows have been updated or changed, the transaction fails to commit with error 41305 ("The current transaction failed to commit due to a repeatable read validation failure.").</span></span>

 <span data-ttu-id="52165-205">이 오류는 삽입, 업데이트 또는 삭제 작업 후, 트랜잭션을 커밋하기 전에 테이블이 삭제된 경우에도 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-205">This error can also occur if a table is dropped after an insert, update, or delete operation and before the transaction commits.</span></span> <span data-ttu-id="52165-206">이는 고유하게 컴파일된 저장 프로시저의 삽입, 업데이트 또는 삭제 작업에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="52165-206">This applies only to insert, update, or delete operations in natively compiled stored procedures.</span></span> <span data-ttu-id="52165-207">해석된 [!INCLUDE[tsql](../includes/tsql-md.md)]을 통해 수행된 이런 쓰기 작업은 DROP TABLE 문을 차단하고 트랜잭션이 커밋될 때까지 대기시킵니다.</span><span class="sxs-lookup"><span data-stu-id="52165-207">Such write operations performed through interpreted [!INCLUDE[tsql](../includes/tsql-md.md)] cause the DROP TABLE statement to block and wait until the transaction commits.</span></span>

##### <a name="serializable-validation"></a><span data-ttu-id="52165-208">직렬화 유효성 검사</span><span class="sxs-lookup"><span data-stu-id="52165-208">Serializable Validation</span></span>
 <span data-ttu-id="52165-209">두 가지 경우에 직렬화 유효성 검사가 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="52165-209">Serializable validation is performed in two cases:</span></span>

-   <span data-ttu-id="52165-210">트랜잭션의 격리 수준이 SERIALIZABLE이거나 테이블을 SERIALIZABLE 격리 상태에서 액세스하는 경우.</span><span class="sxs-lookup"><span data-stu-id="52165-210">If the isolation level of the transaction is SERIALIZABLE or tables are accessed under SERIALIZABLE isolation.</span></span>

-   <span data-ttu-id="52165-211">PRIMARY KEY 제약 조건에 대해 만들어진 인덱스 같이 행이 고유한 인덱스에 삽입된 경우.</span><span class="sxs-lookup"><span data-stu-id="52165-211">If rows are inserted in a unique index, such as the index created for a PRIMARY KEY constraint.</span></span> <span data-ttu-id="52165-212">시스템은 동일한 키가 동시에 삽입된 행이 없는지 유효성을 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-212">The system validates that no rows with the same key have been concurrently inserted.</span></span>

 <span data-ttu-id="52165-213">시스템은 데이터베이스에 가상 행이 기록되지 않았는지 유효성을 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-213">The system validates that no phantom rows have been written to the database.</span></span> <span data-ttu-id="52165-214">트랜잭션에서 수행한 읽기 작업은 이러한 읽기 작업의 검색 범위에서 새 행이 삽입되지 않았는지 확인하기 위해 평가됩니다.</span><span class="sxs-lookup"><span data-stu-id="52165-214">The read operations performed by the transaction are evaluated to determine that no new rows were inserted in the scan ranges of these read operations.</span></span>

 <span data-ttu-id="52165-215">고유한 인덱스에 키를 삽입하는 것은 키가 중복되지 않는지 확인하기 위한 암시적인 읽기 작업을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-215">Insertion of a key in a unique index includes an implicit read operation, to determine that the key is not a duplicate.</span></span> <span data-ttu-id="52165-216">고유한 인덱스에 대한 직렬화 유효성 검사를 수행하면 두 트랜잭션이 동시에 동일한 키를 삽입하는 경우 이러한 인덱스에 중복이 발생하지 않도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-216">Serializable validation for unique indexes ensures these indexes cannot have duplicates in case two transactions concurrently insert the same key.</span></span>

 <span data-ttu-id="52165-217">가상 행이 발견된 경우 트랜잭션은 오류 41325가 발생하며 커밋에 실패합니다("직렬화 유효성 검사 실패로 인해 현재 트랜잭션을 커밋하지 못했습니다.").</span><span class="sxs-lookup"><span data-stu-id="52165-217">If phantom rows are detected, the transaction fails to commit with error 41325 ("The current transaction failed to commit due to a serializable validation failure.").</span></span>

#### <a name="commit-processing"></a><span data-ttu-id="52165-218">커밋 처리</span><span class="sxs-lookup"><span data-stu-id="52165-218">Commit Processing</span></span>
 <span data-ttu-id="52165-219">유효성 검사에 성공하고 모든 트랜잭션 종속성이 삭제된 경우 트랜잭션은 커밋 처리 단계에 들어갑니다.</span><span class="sxs-lookup"><span data-stu-id="52165-219">If validation succeeds and all transaction dependencies clear, the transaction enters the commit processing phase.</span></span> <span data-ttu-id="52165-220">이 단계 동안 내구성이 있는 테이블의 변경 내용이 로그에 기록되고 로그는 디스크에 기록되어 내구성을 보장합니다.</span><span class="sxs-lookup"><span data-stu-id="52165-220">During this phase the changes to durable tables are written to the log, and the log is written to disk, to ensure durability.</span></span> <span data-ttu-id="52165-221">트랜잭션에 대한 로그 레코드가 디스크에 기록되면 컨트롤이 다시 클라이언트로 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="52165-221">Once the log record for the transaction has been written to disk, control is returned to the client.</span></span>

 <span data-ttu-id="52165-222">이 트랜잭션의 모든 커밋 종속성이 삭제되고 이 트랜잭션이 커밋하기를 기다리던 모든 트랜잭션을 진행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-222">All commit dependencies on this transaction are cleared, and all transactions that had been waiting for this transaction to commit can proceed.</span></span>

## <a name="limitations"></a><span data-ttu-id="52165-223">제한 사항</span><span class="sxs-lookup"><span data-stu-id="52165-223">Limitations</span></span>

-   <span data-ttu-id="52165-224">데이터베이스간 트랜잭션은 메모리 최적화 테이블에서 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-224">Cross-database transactions are not supported with memory-optimized tables.</span></span> <span data-ttu-id="52165-225">메모리 최적화 테이블에 액세스하는 모든 트랜잭션은 tempdb에 대한 읽기-쓰기 액세스와 시스템 데이터베이스 마스터에 대한 읽기 전용 액세스를 제외하고는 둘 이상의 데이터베이스에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-225">Every transaction that accesses memory-optimized tables cannot access more than one database, with the exception of read-write access to tempdb and read-only access to the system database master.</span></span>

-   <span data-ttu-id="52165-226">분산 트랜잭션은 메모리 최적화 테이블에서 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-226">Distributed transactions are not supported with memory-optimized tables.</span></span> <span data-ttu-id="52165-227">BEGIN DISTRIBUTED TRANSACTION으로 시작한 분산 트랜잭션은 메모리 최적화 테이블에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-227">Distributed transactions started with BEGIN DISTRIBUTED TRANSACTION cannot access memory-optimized tables.</span></span>

-   <span data-ttu-id="52165-228">메모리 액세스에 최적화된 테이블은 잠금을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-228">Memory-optimized tables do not support locking.</span></span> <span data-ttu-id="52165-229">메모리 최적화 테이블에서 잠금 힌트(예: TABLOCK, XLOCK, ROWLOCK)를 통한 명시적 잠금은 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="52165-229">Explicit locks through locking hints (such as TABLOCK, XLOCK, ROWLOCK) are not supported with memory-optimized tables.</span></span>

## <a name="see-also"></a><span data-ttu-id="52165-230">참고 항목</span><span class="sxs-lookup"><span data-stu-id="52165-230">See Also</span></span>
 [<span data-ttu-id="52165-231">메모리 액세스에 최적화된 테이블의 트랜잭션 이해</span><span class="sxs-lookup"><span data-stu-id="52165-231">Understanding Transactions on Memory-Optimized Tables</span></span>](../../2014/database-engine/understanding-transactions-on-memory-optimized-tables.md)


