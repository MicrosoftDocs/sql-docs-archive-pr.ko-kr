---
title: 트랜잭션 격리 수준 메모리 액세스에 최적화 된 테이블 | Microsoft Docs
ms.custom: seo-dt-2019
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 8a6a82bf-273c-40ab-a101-46bd3615db8a
author: stevestein
ms.author: sstein
ms.openlocfilehash: 5ee0ba17dc999c9076ca4622d47db28b8200b851
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87730856"
---
# <a name="transaction-isolation-levels-in-memory-optimized-tables"></a><span data-ttu-id="9026d-102">메모리 액세스에 최적화 된 테이블의 트랜잭션 격리 수준</span><span class="sxs-lookup"><span data-stu-id="9026d-102">Transaction Isolation Levels in memory-optimized tables</span></span>

  <span data-ttu-id="9026d-103">다음 격리 수준은 메모리 최적화 테이블에 액세스하는 트랜잭션에 대해 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-103">The following isolation levels are supported for transactions that access memory-optimized tables.</span></span>  
  
-   <span data-ttu-id="9026d-104">SNAPSHOT</span><span class="sxs-lookup"><span data-stu-id="9026d-104">SNAPSHOT</span></span>  
  
-   <span data-ttu-id="9026d-105">REPEATABLE READ</span><span class="sxs-lookup"><span data-stu-id="9026d-105">REPEATABLE READ</span></span>  
  
-   <span data-ttu-id="9026d-106">직렬화 가능</span><span class="sxs-lookup"><span data-stu-id="9026d-106">SERIALIZABLE</span></span>  
  
-   <span data-ttu-id="9026d-107">READ COMMITTED</span><span class="sxs-lookup"><span data-stu-id="9026d-107">READ COMMITTED</span></span>  
  
 <span data-ttu-id="9026d-108">트랜잭션 격리 수준은 고유하게 컴파일된 저장 프로시저의 원자 블록의 일부로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-108">The transaction isolation level can be specified as part of the atomic block of a natively compiled stored procedure.</span></span> <span data-ttu-id="9026d-109">자세한 내용은 [CREATE PROCEDURE&#40;Transact-SQL&#41;](/sql/t-sql/statements/create-procedure-transact-sql)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9026d-109">For more information, see [CREATE PROCEDURE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-procedure-transact-sql).</span></span> <span data-ttu-id="9026d-110">메모리 최적화 테이블을 해석된 [!INCLUDE[tsql](../includes/tsql-md.md)]에서 액세스하면 테이블 수준 힌트를 사용하여 격리 수준을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-110">When accessing memory-optimized tables from interpreted [!INCLUDE[tsql](../includes/tsql-md.md)], the isolation level can be specified using table-level hints.</span></span>  
  
 <span data-ttu-id="9026d-111">고유하게 컴파일된 저장 프로시저를 정의할 때는 트랜잭션 격리 수준을 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-111">You must specify the transaction isolation level when you define a natively compiled stored procedure.</span></span> <span data-ttu-id="9026d-112">해석된 [!INCLUDE[tsql](../includes/tsql-md.md)]의 사용자 트랜잭션에서 메모리 최적화 테이블에 액세스할 때는 테이블 힌트에서 격리 수준을 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-112">You must specify the isolation level in table hints when accessing memory-optimized tables from user transactions in interpreted [!INCLUDE[tsql](../includes/tsql-md.md)].</span></span> <span data-ttu-id="9026d-113">자세한 내용은 [메모리 최적화 테이블을 사용 하는 트랜잭션 격리 수준에 대 한 지침](../relational-databases/in-memory-oltp/memory-optimized-tables.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="9026d-113">For more information, see [Guidelines for Transaction Isolation Levels with Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).</span></span>  
  
 <span data-ttu-id="9026d-114">자동 커밋 트랜잭션이 있는 메모리 최적화 테이블에는 격리 수준 READ COMMITTED가 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-114">The isolation level READ COMMITTED is supported for memory-optimized tables with autocommit transactions.</span></span> <span data-ttu-id="9026d-115">READ COMMITTED는 사용자 트랜잭션 또는 원자 블록에서 유효하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-115">READ COMMITTED is not valid in user transactions or in an atomic block.</span></span> <span data-ttu-id="9026d-116">READ COMMITTED는 명시적 또는 암시적 사용자 트랜잭션에서 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-116">READ COMMITTED is not supported with explicit or implicit user transactions.</span></span> <span data-ttu-id="9026d-117">격리 수준 READ_COMMITTED_SNAPSHOT은 자동 커밋 트랜잭션 기능이 있는 메모리 최적화 테이블의 경우 및 쿼리가 디스크 기반 테이블에 액세스하지 않는 경우에만 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-117">Isolation level READ_COMMITTED_SNAPSHOT is supported for memory-optimized tables with autocommit transactions and only if the query does not access any disk-based tables.</span></span> <span data-ttu-id="9026d-118">뿐만 아니라 SNAPSHOT 격리로 해석된 [!INCLUDE[tsql](../includes/tsql-md.md)]을 사용하여 시작된 트랜잭션은 메모리 최적화 테이블에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-118">In addition, transactions that are started using interpreted [!INCLUDE[tsql](../includes/tsql-md.md)] with SNAPSHOT isolation cannot access memory-optimized tables.</span></span> <span data-ttu-id="9026d-119">REPEATABLE READ 또는 SERIALIZABLE 격리와 함께 해석된 [!INCLUDE[tsql](../includes/tsql-md.md)]을 사용하는 트랜잭션은 SNAPSHOT 격리를 사용하여 메모리 최적화 테이블에 액세스해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-119">Transactions that are use interpreted [!INCLUDE[tsql](../includes/tsql-md.md)] with either REPEATABLE READ or SERIALIZABLE isolation must access memory-optimized tables using SNAPSHOT isolation.</span></span> <span data-ttu-id="9026d-120">이 시나리오에 대 한 자세한 내용은 [크로스 컨테이너 트랜잭션](cross-container-transactions.md)을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="9026d-120">For more information about this scenario, see [Cross-Container Transactions](cross-container-transactions.md).</span></span>  
  
 <span data-ttu-id="9026d-121">READ COMMITTED는 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]의 기본 격리 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-121">READ COMMITTED is the default isolation level in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="9026d-122">세션의 격리 수준이 READ COMMITED 이하인 경우 다음 작업 중 하나를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-122">When the isolation level of the session is READ COMMITED (or lower), you can do one of the following:</span></span>  
  
-   <span data-ttu-id="9026d-123">메모리 최적화 테이블에 액세스하는 데 보다 높은 격리 수준 힌트를 명시적으로 사용합니다(예: WITH (SNAPSHOT)).</span><span class="sxs-lookup"><span data-stu-id="9026d-123">Explicitly use a higher isolation level hint for accessing the memory-optimized table (for example, WITH (SNAPSHOT)).</span></span>  
  
-   <span data-ttu-id="9026d-124">메모리 최적화 테이블에 대한 격리 수준을 SNAPSHOT(메모리 최적화 모든 테이블에 대한 WITH(SNAPSHOT) 힌트를 포함한 것)으로 설정할 `MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT` 설정 옵션을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-124">Specify the `MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT` set option, which will set the isolation level for memory-optimized tables to SNAPSHOT (as if you included WITH(SNAPSHOT) hints to every memory-optimized table).</span></span> <span data-ttu-id="9026d-125">에 대 한 자세한 내용은 `MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT` [ALTER Database SET Options &#40;transact-sql&#41;](/sql/t-sql/statements/alter-database-transact-sql-set-options)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="9026d-125">For more information about `MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT`, see [ALTER DATABASE SET Options &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-database-transact-sql-set-options).</span></span>  
  
 <span data-ttu-id="9026d-126">또는 세션의 격리 수준이 READ COMMITTED인 경우 자동 커밋 트랜잭션을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-126">Alternatively, if the isolation level of the session is READ COMMITTED, you can use autocommit transactions.</span></span>  
  
 <span data-ttu-id="9026d-127">해석된 [!INCLUDE[tsql](../includes/tsql-md.md)]에서 시작된 SNAPSHOT 트랜잭션은 메모리 최적화 테이블에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-127">SNAPSHOT transactions started in interpreted [!INCLUDE[tsql](../includes/tsql-md.md)] cannot access memory-optimized tables.</span></span>  
  
 <span data-ttu-id="9026d-128">메모리 최적화 테이블에 지원되는 트랜잭션 격리 수준은 디스크 기반 테이블과 동일한 논리적 보증을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-128">The transaction isolation levels supported for memory-optimized tables provide the same logical guarantees as disk-based tables.</span></span> <span data-ttu-id="9026d-129">격리 수준 보증을 제공하는 데 사용되는 메커니즘은 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-129">The mechanism used for providing isolation level guarantees is different.</span></span>  
  
 <span data-ttu-id="9026d-130">디스크 기반 테이블의 경우 대부분의 격리 수준 보증은 차단을 통해 충돌을 방지하는 잠금을 사용하여 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-130">For disk-based tables, most isolation level guarantees are implemented using locking, which prevent conflicts through blocking.</span></span> <span data-ttu-id="9026d-131">메모리 최적화 테이블의 경우 잠금 필요성을 방지하는 충돌 감지 메커니즘을 사용하여 보장이 시행됩니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-131">For memory-optimized tables, the guarantees are enforced using a conflict detection mechanism, which avoids the need to take locks.</span></span> <span data-ttu-id="9026d-132">예외는 디스크 기반 테이블의 SNAPSHOT 격리입니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-132">The exception is SNAPSHOT isolation on disk-based tables.</span></span> <span data-ttu-id="9026d-133">이는 충돌 감지 메커니즘을 사용하여 메모리 최적화 테이블에서 SNAPSHOT 격리에 유사하게 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-133">This is implemented similarly to SNAPSHOT isolation on memory-optimized tables using a conflict detection mechanism.</span></span>  
  
 <span data-ttu-id="9026d-134">SNAPSHOT</span><span class="sxs-lookup"><span data-stu-id="9026d-134">SNAPSHOT</span></span>  
 <span data-ttu-id="9026d-135">이 격리 수준은 트랜잭션의 문이 읽은 데이터가 트랜잭션 시작 시와 트랜잭션별로 데이터 버전의 일관성이 유지되도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-135">This isolation level specifies that data read by any statement in a transaction will be the transactionally consistent version of the data that existed at the start of the transaction.</span></span> <span data-ttu-id="9026d-136">트랜잭션은 시작되기 전에 커밋된 데이터 수정 내용만 인식할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-136">The transaction can only recognize data modifications that were committed before the start of the transaction.</span></span> <span data-ttu-id="9026d-137">현재 트랜잭션이 시작된 후 다른 트랜잭션에서 수정한 데이터는 현재 트랜잭션에서 실행되는 문에 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-137">Data modifications made by other transactions after the start of the current transaction are not visible to statements executing in the current transaction.</span></span> <span data-ttu-id="9026d-138">트랜잭션의 문이 트랜잭션 시작 당시 커밋된 데이터의 스냅샷을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-138">The statements in a transaction get a snapshot of the committed data as it existed at the start of the transaction.</span></span>  
  
 <span data-ttu-id="9026d-139">쓰기 작업(업데이트, 삽입 및 삭제)은 항상 다른 트랜잭션에서 완전히 격리됩니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-139">Write operations (updates, inserts and deletes) are always fully isolated from other transactions.</span></span> <span data-ttu-id="9026d-140">따라서 SNAPSHOT 트랜잭션의 쓰기 작업은 다른 트랜잭션의 쓰기 작업과 충돌할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-140">Therefore, the write operations in a SNAPSHOT transaction can conflict with write operations by other transactions.</span></span> <span data-ttu-id="9026d-141">현재 트랜잭션이 시작된 후에 커밋된 다른 트랜잭션에 의해 업데이트되거나 삭제된 행을 현재 트랜잭션이 업데이트하거나 삭제하려고 시도하면 트랜잭션은 다음 오류 메시지가 표시되면서 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-141">When the current transaction attempts to update or delete a row that has been updated or deleted by another transaction that committed after the current transaction started, the transaction terminates with the following error message.</span></span>  
  
 <span data-ttu-id="9026d-142">오류 41302.</span><span class="sxs-lookup"><span data-stu-id="9026d-142">Error 41302.</span></span> <span data-ttu-id="9026d-143">현재 트랜잭션에서 이 트랜잭션이 시작된 이후로 업데이트된 레코드를 업데이트하려고 시도했습니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-143">The current transaction attempted to update a record in table X that has been updated since this transaction started.</span></span> <span data-ttu-id="9026d-144">트랜잭션이 중단되었습니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-144">The transaction was aborted.</span></span>  
  
 <span data-ttu-id="9026d-145">현재 트랜잭션 전에 커밋된 다른 트랜잭션에서 삽입한 행과 같은 기본 키 값을 갖는 행을 현재 트랜잭션이 삽입하려고 시도하면 다음 오류 메시지와 함께 커밋이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-145">When the current transaction attempts to insert a row with the same primary key value as a row that was inserted by another transaction that committed before the current transaction, there will be a failure to commit with the following error message.</span></span>  
  
 <span data-ttu-id="9026d-146">오류 41325.</span><span class="sxs-lookup"><span data-stu-id="9026d-146">Error 41325.</span></span> <span data-ttu-id="9026d-147">직렬화 유효성 검사 실패로 인해 현재 트랜잭션을 커밋하지 못했습니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-147">The current transaction failed to commit due to a serializable validation failure.</span></span>  
  
 <span data-ttu-id="9026d-148">트랜잭션이 커밋하기 전에 트랜잭션이 삭제된 테이블에 쓰는 경우 트랜잭션은 다음 오류 메시지와 함께 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-148">If a transaction writes to a table that is dropped before the transaction commits, the transaction terminates with the following error message:</span></span>  
  
 <span data-ttu-id="9026d-149">오류 41305.</span><span class="sxs-lookup"><span data-stu-id="9026d-149">Error 41305.</span></span> <span data-ttu-id="9026d-150">반복 읽기 유효성 검사 실패로 인해 현재 트랜잭션을 커밋하지 못했습니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-150">The current transaction failed to commit due to a repeatable read validation failure.</span></span>  
  
 <span data-ttu-id="9026d-151">REPEATABLE READ</span><span class="sxs-lookup"><span data-stu-id="9026d-151">REPEATABLE READ</span></span>  
 <span data-ttu-id="9026d-152">이 격리 수준은 SNAPSHOT 격리 수준에 의해 지정된 보증을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-152">This isolation level includes the guarantees given by SNAPSHOT isolation level.</span></span> <span data-ttu-id="9026d-153">또한 REPEATABLE READ는 트랜잭션이 읽는 행의 경우 트랜잭션 커밋 당시 행이 다른 트랜잭션에 의해 변경되지 않았음을 보증합니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-153">In addition, REPEATABLE READ guarantees that for any row that is read by the transaction, at the time the transaction commits the row has not been changed by any other transaction.</span></span> <span data-ttu-id="9026d-154">트랜잭션의 모든 읽기 작업은 트랜잭션이 끝날 때가지 반복이 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-154">Every read operation in the transaction is repeatable up to the end of the transaction.</span></span>  
  
 <span data-ttu-id="9026d-155">현재 트랜잭션 이전에 커밋된 다른 트랜잭션에 의해 업데이트된 행을 현재 트랜잭션이 읽은 경우 커밋은 다음 오류 메시지와 함께 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-155">If the current transaction has read any row that has then been updated by another transaction that has committed before the current transaction, the commit fails with the following error message.</span></span>  
  
 <span data-ttu-id="9026d-156">오류 41305.</span><span class="sxs-lookup"><span data-stu-id="9026d-156">Error 41305.</span></span> <span data-ttu-id="9026d-157">반복 읽기 유효성 검사 실패로 인해 현재 트랜잭션을 커밋하지 못했습니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-157">The current transaction failed to commit due to a repeatable read validation failure.</span></span>  
  
 <span data-ttu-id="9026d-158">직렬화 가능</span><span class="sxs-lookup"><span data-stu-id="9026d-158">SERIALIZABLE</span></span>  
 <span data-ttu-id="9026d-159">이 격리 수준은 REPEATABLE READ를 통해 지정된 보증을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-159">This isolation level includes the guarantees given by REPEATABLE READ.</span></span> <span data-ttu-id="9026d-160">스냅샷과 트랜잭션 종료 사이에 가상 행이 나타나지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-160">No phantom rows have appeared between the snapshot and the end of the transaction.</span></span> <span data-ttu-id="9026d-161">가상 행은 선택, 업데이트 또는 삭제의 필터 조건과 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-161">Phantom rows match the filter condition of a select, update, or delete.</span></span>  
  
 <span data-ttu-id="9026d-162">트랜잭션은 동시 트랜잭션이 없는 것처럼 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-162">The transaction is executed as if there are no concurrent transactions.</span></span> <span data-ttu-id="9026d-163">모든 작업은 거의 단일 직렬화 포인트(커밋 시간)에서 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-163">All actions virtually occur at a single serialization point (commit time).</span></span>  
  
 <span data-ttu-id="9026d-164">이러한 보증을 위반하는 경우 트랜잭션은 다음 오류 메시지와 함께 커밋에 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-164">If any of these guarantees is violated, the transaction fails to commit with the following error message:</span></span>  
  
 <span data-ttu-id="9026d-165">오류 41325.</span><span class="sxs-lookup"><span data-stu-id="9026d-165">Error 41325.</span></span> <span data-ttu-id="9026d-166">직렬화 유효성 검사 실패로 인해 현재 트랜잭션을 커밋하지 못했습니다.</span><span class="sxs-lookup"><span data-stu-id="9026d-166">The current transaction failed to commit due to a serializable validation failure.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9026d-167">참고 항목</span><span class="sxs-lookup"><span data-stu-id="9026d-167">See Also</span></span>  
 <span data-ttu-id="9026d-168">[메모리 액세스에 최적화 된 테이블의 트랜잭션 이해](../../2014/database-engine/understanding-transactions-on-memory-optimized-tables.md) </span><span class="sxs-lookup"><span data-stu-id="9026d-168">[Understanding Transactions on Memory-Optimized Tables](../../2014/database-engine/understanding-transactions-on-memory-optimized-tables.md) </span></span>  
 <span data-ttu-id="9026d-169">[메모리 액세스에 최적화 된 테이블이 있는 트랜잭션 격리 수준에 대 한 지침](../relational-databases/in-memory-oltp/memory-optimized-tables.md) </span><span class="sxs-lookup"><span data-stu-id="9026d-169">[Guidelines for Transaction Isolation Levels with Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md) </span></span>  
 [<span data-ttu-id="9026d-170">메모리 액세스에 최적화된 테이블의 트랜잭션에 대한 재시도 논리 지침</span><span class="sxs-lookup"><span data-stu-id="9026d-170">Guidelines for Retry Logic for Transactions on Memory-Optimized Tables</span></span>](../../2014/database-engine/guidelines-for-retry-logic-for-transactions-on-memory-optimized-tables.md)  
  
  
