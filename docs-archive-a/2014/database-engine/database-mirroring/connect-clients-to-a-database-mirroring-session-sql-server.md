---
title: 데이터베이스 미러링 세션에 클라이언트 연결(SQL Server) | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: high-availability
ms.topic: conceptual
helpviewer_keywords:
- partners [SQL Server], connecting clients to
- database mirroring [SQL Server], connecting clients to
- client connections [SQL Server], database mirroring
- connections [SQL Server], database mirroring
ms.assetid: 0d5d2742-2614-43de-9ab9-864addb6299b
author: MikeRayMSFT
ms.author: mikeray
ms.openlocfilehash: 16faa8d02a22fba3e4cfa4cbe0bd6558fc140fdd
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87648573"
---
# <a name="connect-clients-to-a-database-mirroring-session-sql-server"></a><span data-ttu-id="9c8dd-102">데이터베이스 미러링 세션에 클라이언트 연결(SQL Server)</span><span class="sxs-lookup"><span data-stu-id="9c8dd-102">Connect Clients to a Database Mirroring Session (SQL Server)</span></span>
  <span data-ttu-id="9c8dd-103">데이터베이스 미러링 세션에 연결하기 위해 클라이언트는 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client 또는 .NET Framework Data Provider for [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-103">To connect to a database mirroring session, a client can use either [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client or .NET Framework Data Provider for [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="9c8dd-104">[!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] 데이터베이스에 대해 구성하면 두 데이터 액세스 공급자가 모두 데이터베이스 미러링을 완전하게 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-104">When configured for a [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] database, these data access providers both fully support database mirroring.</span></span> <span data-ttu-id="9c8dd-105">미러된 데이터베이스 사용 시 프로그래밍 고려 사항에서 대한 자세한 내용은 [Using Database Mirroring](../../relational-databases/native-client/features/using-database-mirroring.md)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-105">For information about programming considerations for using a mirrored database, see [Using Database Mirroring](../../relational-databases/native-client/features/using-database-mirroring.md).</span></span> <span data-ttu-id="9c8dd-106">또한 현재 주 서버 인스턴스를 사용할 수 있어야 하며 서버 인스턴스에 클라이언트 로그인이 만들어져 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-106">In addition, the current principal server instance must be available and the login of the client must have been created on the server instance.</span></span> <span data-ttu-id="9c8dd-107">자세한 내용은 [분리된 사용자 문제 해결&#40;SQL Server&#41;](../../sql-server/failover-clusters/troubleshoot-orphaned-users-sql-server.md)을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-107">For more information, see [Troubleshoot Orphaned Users &#40;SQL Server&#41;](../../sql-server/failover-clusters/troubleshoot-orphaned-users-sql-server.md).</span></span> <span data-ttu-id="9c8dd-108">클라이언트에서 데이터베이스 미러링 세션에 연결할 때는 미러링 모니터 서버 인스턴스가 있어도 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-108">Client connections to a database mirroring session do not involve the witness server instance, if one exists.</span></span>  
  
 ##  <a name="making-the-initial-connection-to-a-database-mirroring-session"></a><a name="InitialConnection"></a> <span data-ttu-id="9c8dd-109">데이터베이스 미러링 세션에 대한 초기 연결 설정</span><span class="sxs-lookup"><span data-stu-id="9c8dd-109">Making the Initial Connection to a Database Mirroring Session</span></span>  
 <span data-ttu-id="9c8dd-110">미러된 데이터베이스에 대한 초기 연결의 경우 클라이언트에서 최소한 서버 인스턴스의 이름을 제공하는 연결 문자열을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-110">For the initial connection to a mirrored database, a client must supply a connection string that minimally supplies the name of a server instance.</span></span> <span data-ttu-id="9c8dd-111">이 필수 서버 이름은 현재 주 서버 인스턴스를 식별하며 *초기 파트너 이름*이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-111">This required server name should identify the current principal server instance and is known as the *initial partner name*.</span></span>  
  
 <span data-ttu-id="9c8dd-112">필요에 따라 연결 문자열에서 다른 서버 인스턴스의 이름을 제공할 수도 있습니다. 이 이름은 첫 번째 연결 시도 중에 초기 파트너를 사용할 수 없는 경우 사용되는 현재 미러 서버 인스턴스를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-112">Optionally, the connection string can also supply the name of another server instance, which should identify the current mirror server instance, for use if the initial partner is unavailable during the first connection attempt.</span></span> <span data-ttu-id="9c8dd-113">두 번째 이름을 *장애 조치(failover) 파트너 이름*이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-113">The second name is known as the *failover partner name*.</span></span>  
  
 <span data-ttu-id="9c8dd-114">또한 연결 문자열에서 데이터베이스 이름을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-114">The connection string must also supply a database name.</span></span> <span data-ttu-id="9c8dd-115">데이터베이스 이름은 데이터 액세스 공급자의 장애 조치(Failover) 시도를 지원하는 데 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-115">This is necessary to enable failover attempts by the data access provider.</span></span>  
  
 <span data-ttu-id="9c8dd-116">연결 문자열이 수신되면 데이터 액세스 공급자는 초기 파트너 이름과 장애 조치(failover) 파트너 이름(제공된 경우)을 클라이언트의 휘발성 메모리에 캐시로 저장합니다. 관리 코드의 경우 캐시 범위는 애플리케이션 도메인까지 해당됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-116">On receiving a connection string, the data access provider stores the initial partner name and the failover partner name, if supplied, in a cache in the client's volatile memory (for managed code, the cache is scoped to the application domain).</span></span> <span data-ttu-id="9c8dd-117">초기 파트너 이름이 캐시된 다음에는 데이터 액세스 공급자가 초기 파트너 이름을 업데이트하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-117">Once cached, the initial partner name is never updated by the data access provider.</span></span> <span data-ttu-id="9c8dd-118">클라이언트에서 장애 조치(failover) 파트너 이름을 제공하면 데이터 액세스 공급자는 초기 파트너 이름을 사용하여 연결할 수 없는 경우에 대비하여 이 장애 조치(failover) 파트너 이름도 일시적으로 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-118">When the client supplies the failover partner name, the data access provider also stores this failover partner name temporarily in case the provider cannot connect using the initial partner name.</span></span>  
  
 <span data-ttu-id="9c8dd-119">데이터베이스 미러링 세션에서는 클라이언트 컴퓨터에 네트워크 통신 문제가 있는 경우 등 서버에 액세스하는 클라이언트와 관련된 문제를 방지하지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-119">A database mirroring session does not protect against server-access problems that are specific to clients, such as when a client computer is having a problems communicating with the network.</span></span> <span data-ttu-id="9c8dd-120">데이터 액세스 공급자와 관련되지 않은 여러 가지 이유로 인해 미러된 데이터베이스에 대한 연결 시도가 실패할 수도 있습니다. 예를 들어 데이터베이스가 장애 조치 중이어서 주 서버 인스턴스가 비활성화되거나 네트워크 오류로 인해 연결 시도가 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-120">A connection attempt to a mirrored database can also fail for a variety of reasons that are unrelated to the data-access provider; for example, a connection attempt can fail because the principal server instance is inactive, as occurs when the database is failing over, or because of a network error.</span></span>  
  
 <span data-ttu-id="9c8dd-121">연결을 시도할 때 데이터 액세스 공급자는 최초 파트너 이름부터 사용하기 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-121">When attempting to connect, the data access provider begins by using the initial partner name.</span></span> <span data-ttu-id="9c8dd-122">지정한 서버 인스턴스를 사용할 수 있으며 현재 주 서버 인스턴스이면 일반적으로 연결 시도에 성공합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-122">If the specified server instance is available and is the current principal server instance, the connection attempt typically succeeds.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9c8dd-123">미러링 세션이 일시 중지되면 일반적으로 클라이언트는 주 서버에 연결하여 파트너 이름을 다운로드합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-123">If the mirroring session is paused, the client typically connects to the principal server and the downloads the partner name.</span></span> <span data-ttu-id="9c8dd-124">그러나 미러링이 재개될 때까지 클라이언트에서 데이터베이스를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-124">However, the database is unavailable to the client until mirroring resumes.</span></span>  
  
 <span data-ttu-id="9c8dd-125">이 시도가 실패하면 데이터 액세스 공급자는 장애 조치(failover) 파트너 이름(사용 가능한 경우)을 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-125">If that attempt does not work, the data access provider tries the failover partner name, if available.</span></span> <span data-ttu-id="9c8dd-126">파트너 이름이 현재 주 서버를 올바르게 식별하는 경우 일반적으로 데이터 액세스 공급자가 초기 연결을 여는 데 성공합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-126">If either partner name correctly identifies the current principal server, the data access provider normally succeeds in opening the initial connection.</span></span> <span data-ttu-id="9c8dd-127">이 연결을 완료하면 데이터 액세스 공급자는 현재 미러 서버의 서버 인스턴스 이름을 다운로드합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-127">On completing this connection, the data access provider downloads the server instance name of the current mirror server.</span></span> <span data-ttu-id="9c8dd-128">이 이름은 장애 조치(failover) 파트너 이름으로 캐시에 저장되며 클라이언트에서 제공한 장애 조치(failover) 파트너 이름(있는 경우)을 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-128">This name is stored in the cache as the failover partner name, overwriting the client-supplied failover partner name, if any.</span></span> <span data-ttu-id="9c8dd-129">그런 후에는 .NET Framework Data Provider for [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 에서 장애 조치(failover) 파트너 이름을 업데이트하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-129">Thereafter, the .NET Framework Data Provider for [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] does not update the failover partner name.</span></span> <span data-ttu-id="9c8dd-130">반면 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client는 후속 연결이나 연결 다시 설정에서 다른 파트너 이름이 반환될 때마다 캐시를 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-130">In contrast, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client updates the cache whenever a subsequent connection or connection reset returns a different partner name.</span></span>  
  
 <span data-ttu-id="9c8dd-131">다음 그림에서는 미러된 데이터베이스 **Db_1**에 대한 클라이언트의 초기 파트너 **Partner_A**연결을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-131">The following figure illustrates a client connection to the initial partner, **Partner_A**, for a mirrored database named **Db_1**.</span></span> <span data-ttu-id="9c8dd-132">이 그림은 클라이언트가 제공한 초기 파트너 이름이 현재 주 서버인 **Partner_A**를 올바르게 식별하는 경우를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-132">This figure shows a case in which the initial partner name supplied by the client correctly identifies the current principal server, **Partner_A**.</span></span> <span data-ttu-id="9c8dd-133">초기 연결 시도에 성공하고 데이터 액세스 공급자가 미러 서버의 이름(현재 **Partner_B**)을 장애 조치(failover) 파트너 이름으로 해당 로컬 캐시에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-133">The initial connection attempt succeeds, and the data access provider stores the name of the mirror server (currently **Partner_B**) as the failover partner name in the local cache.</span></span> <span data-ttu-id="9c8dd-134">마지막으로 클라이언트에서 **Db_1** 데이터베이스의 주 복사본에 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-134">Finally, the client connects to the principal copy of the **Db_1** database.</span></span>  
  
 <span data-ttu-id="9c8dd-135">![초기 파트너가 주 서버인 경우의 클라이언트 연결](../media/dbm-initial-connection.gif "초기 파트너가 주 서버인 경우의 클라이언트 연결")</span><span class="sxs-lookup"><span data-stu-id="9c8dd-135">![Client connection if initial partner is principal](../media/dbm-initial-connection.gif "Client connection if initial partner is principal")</span></span>  
  
 <span data-ttu-id="9c8dd-136">예를 들어 네트워크 오류나 비활성 서버 인스턴스로 인해 초기 연결 시도가 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-136">The initial connection attempt may fail, for example, because of a network error or an inactive server instance.</span></span> <span data-ttu-id="9c8dd-137">초기 파트너를 사용할 수 없어 데이터 액세스 공급자가 장애 조치(failover) 파트너에 연결하려면 클라이언트에서 제공한 장애 조치(failover) 파트너 이름이 연결 문자열에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-137">Because the initial partner is unavailable, for the data access provider to attempt to connect to the failover partner, the client must have supplied the failover partner name in the connection string.</span></span>  
  
 <span data-ttu-id="9c8dd-138">이 경우 장애 조치(failover) 파트너 이름을 사용할 수 없으면 미러되지 않은 데이터베이스의 경우처럼 오류가 반환되거나 네트워크 연결 시간이 초과될 때까지 원래 연결 시도가 계속됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-138">In that case, if the failover partner name is unavailable, the original connection attempt continues until the network connection timeout or an error is returned (just as for a non-mirrored database).</span></span>  
  
 <span data-ttu-id="9c8dd-139">장애 조치(failover) 파트너 이름이 연결 문자열에 제공되는 경우 데이터 액세스 공급자의 동작은 클라이언트의 네트워크 프로토콜과 운영 체제에 따라 다음과 같이 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-139">When the failover partner name is supplied in the connection string, the behavior of the data access provider depends on the network protocol and operating system of the client, as follows:</span></span>  
  
-   <span data-ttu-id="9c8dd-140">TCP/IP의 경우 데이터베이스 미러링과 관련된 연결 다시 시도 알고리즘에 의해 연결 시도가 조정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-140">For TCP/IP, the connection attempts are regulated by a connection retry algorithm that is specific to database mirroring.</span></span> <span data-ttu-id="9c8dd-141">*연결 다시 시도 알고리즘* 은 지정된 연결 시도에서 연결을 여는 데 할당되는 최대 시간( *다시 시도 시간*)을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-141">The *connection retry algorithm* determines the maximum time (the *retry time*) allotted for opening a connection in a given connection attempt.</span></span>  
  
-   <span data-ttu-id="9c8dd-142">기타 네트워크 프로토콜의 경우</span><span class="sxs-lookup"><span data-stu-id="9c8dd-142">For other network protocols</span></span>  
  
     <span data-ttu-id="9c8dd-143">오류가 발생하거나 초기 파트너를 사용할 수 없으면 데이터 액세스 공급자에서 네트워크 연결 제한 시간이 만료되거나 로그인 제한 시간이 만료될 때까지 초기 연결 시도가 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-143">If an error occurs or if the initial partner is unavailable, the initial connection attempt waits until the network connection timeout period expires or the login timeout period expires on the data access provider.</span></span> <span data-ttu-id="9c8dd-144">일반적으로 이 대기 시간은 20초에서 30초 정도입니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-144">Typically, this wait is on the order of 20 to 30 seconds.</span></span> <span data-ttu-id="9c8dd-145">그런 후에는 데이터 액세스 공급자가 시간 초과되지 않으면 장애 조치(failover) 파트너에 연결을 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-145">Thereafter, if the data access provider has not timed out, it attempts to connect to the failover partner.</span></span> <span data-ttu-id="9c8dd-146">연결에 성공하기 전에 연결 제한 시간이 만료되거나 장애 조치(failover) 파트너를 사용할 수 없으면 연결 시도가 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-146">If the connection timeout period expires before the connection succeeds or the failover partner is unavailable, the connection attempt fails.</span></span> <span data-ttu-id="9c8dd-147">로그인 제한 시간 내에 장애 조치(failover) 파트너를 사용할 수 있으며 현재 주 서버인 경우 일반적으로 연결 시도에 성공합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-147">If failover partner is available within the login timeout period and is now the principal server, the connection attempt normally succeeds.</span></span>  

  
### <a name="connection-strings-for-a-mirrored-database"></a><span data-ttu-id="9c8dd-148">미러된 데이터베이스에 대한 연결 문자열</span><span class="sxs-lookup"><span data-stu-id="9c8dd-148">Connection Strings for a Mirrored Database</span></span>  
 <span data-ttu-id="9c8dd-149">클라이언트가 제공한 연결 문자열에는 데이터 액세스 공급자가 데이터베이스에 연결하는 데 사용하는 정보가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-149">The connection string supplied by the client contains information that the data access provider uses to connect to the database.</span></span> <span data-ttu-id="9c8dd-150">이 섹션에서는 특히 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC 드라이버 연결을 사용하여 미러된 데이터베이스에 연결하는 경우와 관련된 키워드에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-150">This section discusses the keywords that are specifically relevant for connecting to a mirrored database using a [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC Driver Connection.</span></span>  
  
#### <a name="network-attribute"></a><span data-ttu-id="9c8dd-151">Network 특성</span><span class="sxs-lookup"><span data-stu-id="9c8dd-151">Network Attribute</span></span>  
 <span data-ttu-id="9c8dd-152">연결 문자열에 네트워크 프로토콜을 지정하는 **Network** 특성이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-152">The connection string should contain the **Network** attribute to specify the network protocol.</span></span> <span data-ttu-id="9c8dd-153">이렇게 하면 지정한 네트워크 프로토콜이 여러 파트너에 대한 연결 간에 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-153">This ensures that the specified network protocol persists between connections to different partners.</span></span> <span data-ttu-id="9c8dd-154">미러된 데이터베이스에 대한 연결에 가장 적합한 프로토콜은 TCP/IP입니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-154">The best protocol for connecting to a mirrored database is TCP/IP.</span></span> <span data-ttu-id="9c8dd-155">클라이언트에서 모든 파트너 연결에 대해 TCP/IP를 요청하도록 하기 위해 연결 문자열은 다음 특성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-155">To ensure that the client requests TCP/IP for every connection to the partners, a connection string supplies the following attribute:</span></span>  
  
```  
Network=dbmssocn;   
```  
  
> [!IMPORTANT]  
>  <span data-ttu-id="9c8dd-156">클라이언트의 프로토콜 목록 맨 위에 TCP/IP를 유지하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-156">We recommend keeping TCP/IP at the top of a client's protocol list.</span></span> <span data-ttu-id="9c8dd-157">그러나 연결 문자열에서 **Network** 특성을 지정하면 목록 순서가 재정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-157">However, if the connection string specifies the **Network** attribute, this overrides the list order.</span></span>  
  
 <span data-ttu-id="9c8dd-158">또는 클라이언트에서 모든 파트너 연결에 대해 명명된 파이프를 요청하도록 하기 위해 연결 문자열은 다음 특성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-158">Alternatively, to ensure that the client requests named pipes for every connection to the partners, a connection string supplies the following attribute:</span></span>  
  
```  
Network=dbnmpntw;   
```  
  
> [!IMPORTANT]  
>  <span data-ttu-id="9c8dd-159">명명된 파이프는 TCP/IP 다시 시도 알고리즘을 사용하지 않으므로 미러된 데이터베이스에 연결하기 전에 명명된 파이프 연결 시도가 시간 초과되는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-159">Because named pipes does not use the TCP/IP retry algorithm, in many cases, a named pipes connection attempt may time out before connecting to a mirrored database.</span></span>  
  
#### <a name="server-attribute"></a><span data-ttu-id="9c8dd-160">Server 특성</span><span class="sxs-lookup"><span data-stu-id="9c8dd-160">Server Attribute</span></span>  
 <span data-ttu-id="9c8dd-161">연결 문자열에는 초기 파트너 이름을 제공하는 `Server` 특성이 있어야 합니다. 이 특성은 현재 주 서버 인스턴스를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-161">The connection string must contain a `Server` attribute that supplies the initial partner name, which should identify the current principal server instance.</span></span>  
  
 <span data-ttu-id="9c8dd-162">서버 인스턴스를 식별하는 가장 간단한 방법은 *<server_name>* [ **\\** _<SQL_Server_instance_name>_ ]과 같이 해당 이름을 지정하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-162">The simplest way to identify the server instance is by specifying its name , *<server_name>*[**\\**_<SQL_Server_instance_name>_].</span></span> <span data-ttu-id="9c8dd-163">예를 들면 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-163">For example:</span></span>  
  
 `Server=Partner_A;`  
  
 <span data-ttu-id="9c8dd-164">또는</span><span class="sxs-lookup"><span data-stu-id="9c8dd-164">or</span></span>  
  
 `Server=Partner_A\Instance_2;`  
  
 <span data-ttu-id="9c8dd-165">그러나 시스템 이름을 사용하는 경우 클라이언트에서 DNS 조회를 수행하여 서버의 IP 주소를 가져오고 SQL Server Browser 쿼리를 수행하여 파트너가 있는 서버의 포트 번호를 가져와야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-165">However, when the system name is used, the client must perform a DNS lookup to obtain the IP address of the server and a SQL Server Browser query to obtain the port number of the server on which the partner resides.</span></span> <span data-ttu-id="9c8dd-166">서버 이름을 지정하는 대신 `Server` 특성에 파트너의 IP 주소와 포트 번호를 지정하면 해당 조회와 쿼리를 건너뛸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-166">Those lookups and queries can be bypassed by specifying the IP address and port number of the partner in the `Server` attribute, rather than specifying the server name.</span></span> <span data-ttu-id="9c8dd-167">파트너에 연결하는 동안 외부 지연 가능성을 최소화하려면 이 방법을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-167">This is recommended to minimize the possibility of external delays while connecting to that partner.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9c8dd-168">연결 문자열에서 포트가 아닌 명명된 인스턴스 이름을 지정하는 경우 SQL Server Browser 쿼리가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-168">A SQL Server Browser query is necessary if the connection string specifies the named instance name and not the port.</span></span>  
  
 <span data-ttu-id="9c8dd-169">IP 주소와 포트를 지정 하기 위해 `Server` 특성은 `Server=` *<ip_address>* 형식을 사용 합니다 `,` *\<port>* . 예를 들면 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-169">To specify the IP address and port, the `Server` attribute takes the following form, `Server=`*<ip_address>*`,`*\<port>*, for example:</span></span>  
  
```  
Server=123.34.45.56,4724;   
```  
  
> [!NOTE]  
>  <span data-ttu-id="9c8dd-170">IP 주소는 IP 버전 4(IPv4) 또는 IP 버전 6(IPv6)일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-170">The IP address can be IP Version 4 (IPv4) or IP Version 6 (IPv6).</span></span>  
  
#### <a name="database-attribute"></a><span data-ttu-id="9c8dd-171">Database 특성</span><span class="sxs-lookup"><span data-stu-id="9c8dd-171">Database Attribute</span></span>  
 <span data-ttu-id="9c8dd-172">또한 연결 문자열은 미러된 데이터베이스의 이름을 제공하는 `Database` 특성을 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-172">In addition, the connection string must specify the `Database` attribute to supply the name of the mirrored database.</span></span> <span data-ttu-id="9c8dd-173">클라이언트가 연결을 시도할 때 데이터베이스를 사용할 수 없으면 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-173">If the database is unavailable when the client attempts to connect, an exception is raised.</span></span>  
  
 <span data-ttu-id="9c8dd-174">예를 들어 주 서버 Partner_A의 **AdventureWorks** 데이터베이스에 명시적으로 연결하기 위해 클라이언트는 다음 연결 문자열을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-174">For example, to expressly connect to the **AdventureWorks** database on the principal server Partner_A, a client uses the following connection string:</span></span>  
  
 `" Server=Partner_A; Database=AdventureWorks "`  
  
> [!NOTE]  
>  <span data-ttu-id="9c8dd-175">이 문자열에는 인증 정보가 생략됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-175">This string omits authentication information.</span></span>  
  
> [!IMPORTANT]  
>  <span data-ttu-id="9c8dd-176">`Server`특성 ()이 있는 프로토콜 접두사는 `Server=tcp:` *\<servername>* **Network** 특성과 호환 되지 않으며 두 위치에서 모두 프로토콜을 지정 하면 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-176">Bundling the protocol prefix with the `Server` attribute (`Server=tcp:`*\<servername>*) is incompatible with the **Network** attribute, and specifying the protocol in both places will likely result in an error.</span></span> <span data-ttu-id="9c8dd-177">따라서 연결 문자열에서 **네트워크** 특성을 사용 하 여 프로토콜을 지정 하 고 특성에 서버 이름만 지정 하는 것이 좋습니다 `Server` ( `"Network=dbmssocn; Server=` *\<servername>* `"` ).</span><span class="sxs-lookup"><span data-stu-id="9c8dd-177">Therefore, we recommend that a connection string specify the protocol using the **Network** attribute and specify only the server name in the `Server` attribute (`"Network=dbmssocn; Server=`*\<servername>*`"`).</span></span>  
  
#### <a name="failover-partner-attribute"></a><span data-ttu-id="9c8dd-178">Failover Partner 특성</span><span class="sxs-lookup"><span data-stu-id="9c8dd-178">Failover Partner Attribute</span></span>  
 <span data-ttu-id="9c8dd-179">초기 파트너 이름 외에 클라이언트에서 현재 미러 서버 인스턴스를 식별하는 장애 조치(failover) 파트너 이름을 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-179">In addition to the initial partner name, the client can also specify failover partner name, which should identify the current mirror server instance.</span></span> <span data-ttu-id="9c8dd-180">장애 조치(failover) 파트너는 Failover Partner 특성의 키워드 중 하나에 의해 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-180">The failover partner is specified by one of the keywords for the failover partner attribute.</span></span> <span data-ttu-id="9c8dd-181">이 특성의 키워드는 사용 중인 API에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-181">The keyword for this attribute depends on the API that you are using.</span></span> <span data-ttu-id="9c8dd-182">다음 표에서는 이러한 키워드를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-182">The following table lists these keywords:</span></span>  
  
|<span data-ttu-id="9c8dd-183">API</span><span class="sxs-lookup"><span data-stu-id="9c8dd-183">API</span></span>|<span data-ttu-id="9c8dd-184">Failover Partner 특성의 키워드</span><span class="sxs-lookup"><span data-stu-id="9c8dd-184">Keyword for failover partner attribute</span></span>|  
|---------|--------------------------------------------|  
|<span data-ttu-id="9c8dd-185">OLE DB 공급자</span><span class="sxs-lookup"><span data-stu-id="9c8dd-185">OLE DB Provider</span></span>|`FailoverPartner`|  
|<span data-ttu-id="9c8dd-186">ODBC 드라이버</span><span class="sxs-lookup"><span data-stu-id="9c8dd-186">ODBC Driver</span></span>|`Failover_Partner`|  
|<span data-ttu-id="9c8dd-187">ADO(ActiveX Data Objects)</span><span class="sxs-lookup"><span data-stu-id="9c8dd-187">ActiveX Data Objects (ADO)</span></span>|`Failover Partner`|  
  
 <span data-ttu-id="9c8dd-188">서버 인스턴스를 식별하는 가장 간단한 방법은 *<server_name>* [ **\\** _<SQL_Server_instance_name>_ ]과 같이 시스템 이름을 지정하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-188">The simplest way to identify the server instance is by its system name, *<server_name>*[**\\**_<SQL_Server_instance_name>_].</span></span>  
  
 <span data-ttu-id="9c8dd-189">또는 `Failover Partner` 특성에 IP 주소와 포트 번호를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-189">Alternatively, the IP address and port number can be supplied in the `Failover Partner` attribute.</span></span> <span data-ttu-id="9c8dd-190">데이터베이스에 대한 첫 번째 연결 중에 초기 연결 시도가 실패하면 장애 조치(failover) 파트너에 대한 연결에서 DNS 및 SQL Server Browser를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-190">If the initial connection attempt fails during the first connection to the database, the attempt to connect to the failover partner will be freed from relying on DNS and SQL Server Browser.</span></span> <span data-ttu-id="9c8dd-191">연결이 설정되면 장애 조치(failover) 파트너 이름이 장애 조치(failover) 파트너 이름을 덮어쓰므로 장애 조치가 발생할 경우 리디렉션된 연결에 DNS 및 SQL Server Browser가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-191">Once a connection is established, the failover partner name will be overwritten with the failover partner name, so if a failover occurs, the redirected connections will require DNS and SQL Server Browser.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9c8dd-192">초기 파트너 이름만 제공되면 다시 연결 방법에 대한 경우를 제외하고 애플리케이션 개발자가 다른 동작을 수행하거나 코드를 작성할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-192">When only the initial partner name is provided, application developers do not need to take any action or write any code except about how to reconnect.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9c8dd-193">관리 코드 애플리케이션 개발자는 `ConnectionString` 개체의 `SqlConnection`에 장애 조치(failover) 파트너 이름을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-193">Managed code application developers supply the failover partner name in the `ConnectionString` of the `SqlConnection` object.</span></span> <span data-ttu-id="9c8dd-194">이러한 연결 문자열을 사용하는 방법은 [!INCLUDE[msCoName](../../includes/msconame-md.md)] .NET Framework SDK에 포함된 ADO.NET 설명서에서 "Database Mirroring Support in the .NET Framework Data Provider for SQL Server"를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-194">For information on using this connection string, see "Database Mirroring Support in the .NET Framework Data Provider for SQL Server" in the ADO.NET documentation, which is part of the [!INCLUDE[msCoName](../../includes/msconame-md.md)] .NET Framework SDK.</span></span>  
  
#### <a name="example-connection-string"></a><span data-ttu-id="9c8dd-195">연결 문자열 예</span><span class="sxs-lookup"><span data-stu-id="9c8dd-195">Example Connection String</span></span>  
 <span data-ttu-id="9c8dd-196">예를 들어 TCP/IP를 사용하여 Prtner_A 또는 Partner_B의 **AdventureWorks** 데이터베이스에 명시적으로 연결하기 위해 ODBC 드라이버를 사용하는 클라이언트 애플리케이션에서 다음 연결 문자열을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-196">For example, to explicitly connect using TCP/IP to the **AdventureWorks** database on either Partner_A or Partner_B, a client application that uses the ODBC Driver could supply the following connection string:</span></span>  
  
```  
"Server=Partner_A; Failover_Partner=Partner_B; Database=AdventureWorks; Network=dbmssocn"  
```  
  
 <span data-ttu-id="9c8dd-197">또는 클라이언트에서 IP 주소와 포트 번호를 사용하여 초기 파트너 Partner_A를 식별할 수 있습니다. 예를 들어 IP 주소가 250.65.43.21이고 포트 번호가 4734이면 연결 문자열은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-197">Alternatively, the client could use the IP address and port number to identify the initial partner, Partner_A; for example, if the IP address is 250.65.43.21 and the port number is 4734, the connection string would be:</span></span>  
  
```  
"Server=250.65.43.21,4734; Failover_Partner=Partner_B; Database=AdventureWorks; Network=dbmssocn"  
```  
  
##  <a name="connection-retry-algorithm-for-tcpip-connections"></a><a name="RetryAlgorithm"></a> <span data-ttu-id="9c8dd-198">연결 다시 시도 알고리즘(TCP/IP 연결용)</span><span class="sxs-lookup"><span data-stu-id="9c8dd-198">Connection Retry Algorithm (for TCP/IP Connections)</span></span>  
 <span data-ttu-id="9c8dd-199">TCP/IP 연결의 경우 두 파트너 이름이 캐시에 있을 때 데이터 액세스 공급자가 연결 다시 시도 알고리즘을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-199">For a TCP/IP connection, when both partner names are in the cache, the data access provider adheres to a connection retry algorithm.</span></span> <span data-ttu-id="9c8dd-200">이는 세션에 대한 초기 연결을 설정하는 경우와 설정된 연결이 끊어진 후 다시 연결하는 경우에 모두 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-200">This is true both for making the initial connection to the session and for reconnecting after losing an established connection.</span></span> <span data-ttu-id="9c8dd-201">연결이 열려 있으면 사전 로그인 및 로그인 단계를 완료하는 데 추가 시간이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-201">Once a connection has been opened, completing the pre-login and login steps takes additional time.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9c8dd-202">느린 DNS 조회, 느린 도메인 컨트롤러/Kerberos KDC(키 배포 센터), SQL Server Browser 연결 시간, 많은 네트워크 사용량 등의 외부 요소로 인해 연결에 소요되는 시간이 다시 시도 시간을 초과할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-202">The time spent in opening a connection can exceed the retry time because of external factors, such as slow DNS lookups, slow domain controller/Kerberos Key Distribution Center (KDC), time spent contacting SQL Server Browser, network congestion, and so forth.</span></span> <span data-ttu-id="9c8dd-203">이러한 외부 요소 때문에 클라이언트가 미러된 데이터베이스에 연결하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-203">Such external factors can prevent a client from connecting to a mirrored database.</span></span> <span data-ttu-id="9c8dd-204">또한 외부 요소로 인해 연결을 여는 데 걸리는 시간이 할당된 다시 시도 시간을 초과할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-204">Also, external factors can cause a connection to take longer to open than the allotted retry time.</span></span> <span data-ttu-id="9c8dd-205">초기 파트너에 대한 연결 시도에서 DNS 및 SQL Server Browser를 무시하는 방법은 이 항목의 앞부분에 나오는 [데이터베이스 미러링 세션에 대한 초기 연결 설정](#InitialConnection)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-205">For information on bypassing DNS and SQL Server Browser for connection attempt to the initial partner, see [Making the Initial Connection to a Database Mirroring Session](#InitialConnection), earlier in this topic.</span></span>  
  
 <span data-ttu-id="9c8dd-206">연결 시도가 실패하거나 성공하기 전에 다시 시도 시간이 만료하면 데이터 액세스 공급자는 다른 파트너에 연결을 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-206">If a connection attempt fails or the retry time expires before it succeeds, the data access provider tries the other partner.</span></span> <span data-ttu-id="9c8dd-207">이때 연결이 열려 있지 않으면 공급자는 연결이 열리거나 로그인 기간이 시간 초과될 때까지 초기 및 장애 조치(Failover) 파트너 이름에 연결을 시도합니다. 기본 로그인 제한 시간은 15초입니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-207">If a connection is not opened by this point, the provider alternately tries the initial and failover partner names, until a connection is opened or the login period times out. The default login time-out period is 15 seconds.</span></span> <span data-ttu-id="9c8dd-208">로그인 제한 시간을 5초 이상으로 설정하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-208">We recommend that the login time-out period be at least 5 seconds.</span></span> <span data-ttu-id="9c8dd-209">너무 짧은 제한 시간을 지정하면 연결 시도가 하나도 성공하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-209">Specifying a smaller time-out period might prevent any of the connection attempts from succeeding.</span></span>  
  
 <span data-ttu-id="9c8dd-210">다시 시도 시간은 로그인 기간의 백분율입니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-210">The retry time is a percentage of the login period.</span></span> <span data-ttu-id="9c8dd-211">연결 시도의 다시 시도 시간은 연속 라운드가 진행됨에 따라 더 커집니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-211">The retry time for a connection attempt is larger in each successive round.</span></span> <span data-ttu-id="9c8dd-212">첫 번째 라운드에서 두 시도 중 각각의 다시 시도 시간은 총 로그인 기간의 8%입니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-212">In the first round, the retry time for each of the two attempts is 8 percent of the total login period.</span></span> <span data-ttu-id="9c8dd-213">다시 시도 알고리즘은 각 연속 라운드에서 최대 다시 시도 시간을 동일한 양만큼 늘립니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-213">In each successive round, the retry algorithm increases the maximum retry time by the same amount.</span></span> <span data-ttu-id="9c8dd-214">따라서 처음 8개 연결 시도의 다시 시도 시간은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-214">Thus, the retry times for the first eight connection attempts is as follows:</span></span>  
  
 <span data-ttu-id="9c8dd-215">8%, 8%, 16%, 16%, 24%, 24%, 32%, 32%</span><span class="sxs-lookup"><span data-stu-id="9c8dd-215">8%, 8%, 16%, 16%, 24%, 24%, 32%, 32%</span></span>  
  
 <span data-ttu-id="9c8dd-216">다시 시도 시간은 다음 수식을 사용하여 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-216">The retry time is calculated using the following formula:</span></span>  
  
 <span data-ttu-id="9c8dd-217">_RetryTime_ **=** _PreviousRetryTime_ **+(** 0.08 **&#42;** _LoginTimeout_ **)**</span><span class="sxs-lookup"><span data-stu-id="9c8dd-217">_RetryTime_ **=** _PreviousRetryTime_ **+(** 0.08 **&#42;**_LoginTimeout_**)**</span></span>  
  
 <span data-ttu-id="9c8dd-218">여기서 *PreviousRetryTime* 의 초기값은 0입니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-218">Where *PreviousRetryTime* is initially 0.</span></span>  
  
 <span data-ttu-id="9c8dd-219">예를 들어 기본 로그인 제한 시간이 15초이면 *LoginTimeout* *= 15*입니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-219">For example, if using the default login time-out period of 15 seconds, *LoginTimeout* *= 15*.</span></span> <span data-ttu-id="9c8dd-220">이 경우 처음 세 라운드에 할당되는 다시 시도 시간은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-220">In this case, the retry times allotted in the first three rounds are as follows:</span></span>  
  
|<span data-ttu-id="9c8dd-221">Round</span><span class="sxs-lookup"><span data-stu-id="9c8dd-221">Round</span></span>|<span data-ttu-id="9c8dd-222">*RetryTime* 계산</span><span class="sxs-lookup"><span data-stu-id="9c8dd-222">*RetryTime* calculation</span></span>|<span data-ttu-id="9c8dd-223">시도당 다시 시도 시간</span><span class="sxs-lookup"><span data-stu-id="9c8dd-223">Retry time per attempt</span></span>|  
|-----------|-----------------------------|----------------------------|  
|<span data-ttu-id="9c8dd-224">1</span><span class="sxs-lookup"><span data-stu-id="9c8dd-224">1</span></span>|<span data-ttu-id="9c8dd-225">0 **+(** 0.08 **&#42;** 15 **)**</span><span class="sxs-lookup"><span data-stu-id="9c8dd-225">0 **+(** 0.08 **&#42;** 15 **)**</span></span>|<span data-ttu-id="9c8dd-226">1.2초</span><span class="sxs-lookup"><span data-stu-id="9c8dd-226">1.2 seconds</span></span>|  
|<span data-ttu-id="9c8dd-227">2</span><span class="sxs-lookup"><span data-stu-id="9c8dd-227">2</span></span>|<span data-ttu-id="9c8dd-228">1.2 **+(** 0.08 **&#42;** 15 **)**</span><span class="sxs-lookup"><span data-stu-id="9c8dd-228">1.2 **+(** 0.08 **&#42;** 15 **)**</span></span>|<span data-ttu-id="9c8dd-229">2.4초</span><span class="sxs-lookup"><span data-stu-id="9c8dd-229">2.4 seconds</span></span>|  
|<span data-ttu-id="9c8dd-230">3</span><span class="sxs-lookup"><span data-stu-id="9c8dd-230">3</span></span>|<span data-ttu-id="9c8dd-231">2.4 **+(** 0.08 **&#42;** 15 **)**</span><span class="sxs-lookup"><span data-stu-id="9c8dd-231">2.4 **+(** 0.08 **&#42;** 15 **)**</span></span>|<span data-ttu-id="9c8dd-232">3.6초</span><span class="sxs-lookup"><span data-stu-id="9c8dd-232">3.6 seconds</span></span>|  
|<span data-ttu-id="9c8dd-233">4</span><span class="sxs-lookup"><span data-stu-id="9c8dd-233">4</span></span>|<span data-ttu-id="9c8dd-234">3.6 **+(** 0.08 **&#42;** 15 **)**</span><span class="sxs-lookup"><span data-stu-id="9c8dd-234">3.6 **+(** 0.08 **&#42;** 15 **)**</span></span>|<span data-ttu-id="9c8dd-235">4.8초</span><span class="sxs-lookup"><span data-stu-id="9c8dd-235">4.8 seconds</span></span>|   
  
 <span data-ttu-id="9c8dd-236">다음 그림에서는 각각 시간 초과되는 연속 연결 시도의 다시 시도 시간을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-236">The following figure illustrates these retry times for successive connection attempts, each of which times out.</span></span>  
  
 <span data-ttu-id="9c8dd-237">![15초 로그인 제한 시간의 최대 다시 시도 지연](../media/dbm-retry-algorithm.gif "15초 로그인 제한 시간의 최대 다시 시도 지연")</span><span class="sxs-lookup"><span data-stu-id="9c8dd-237">![Maximum retry delays for 15 second login timeout](../media/dbm-retry-algorithm.gif "Maximum retry delays for 15 second login timeout")</span></span>  
  
 <span data-ttu-id="9c8dd-238">기본 로그인 제한 시간 동안 처음 세 라운드의 연결 시도에 할당되는 최대 시간은 14.4초입니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-238">For the default login time-out period, the maximum time allotted to the first three rounds of connection attempts is 14.4 seconds.</span></span> <span data-ttu-id="9c8dd-239">각 시도에서 할당된 시간을 모두 사용하는 경우 로그인 기간이 시간 초과되기까지 0.6초의 시간만 남습니다. 이 경우 네 번째 라운드는 단축되어 초기 파트너 이름을 사용하여 빨리 연결할 수 있는 최종 시도만 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-239">If every attempt were to use all of its allotted time, only 0.6 seconds of time would remain before the login period times out. In that case, the fourth round would be curtailed, allowing only a final quick attempt to connect using the initial partner name.</span></span> <span data-ttu-id="9c8dd-240">그러나 특히 이후 라운드에서 연결 시도가 할당된 다시 시도 시간보다 먼저 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-240">However, a connection attempt may fail in less than its allotted retry time, particularly in later rounds.</span></span> <span data-ttu-id="9c8dd-241">예를 들어 네트워크 오류가 발생하면 다시 시도 시간이 만료되기 전에 시도가 종료될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-241">For example, receiving a network error can cause an attempt to end before the retry time expires.</span></span> <span data-ttu-id="9c8dd-242">네트워크 오류로 인해 이전 시도가 실패하면 네 번째 라운드 및 추가 라운드에 더 많은 시간을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-242">If earlier attempts fail due to a network error, additional time would be available for the fourth round and, perhaps, additional rounds.</span></span>  
  
 <span data-ttu-id="9c8dd-243">연결 시도에 실패하는 또 다른 원인에는 서버 인스턴스가 데이터베이스 장애 조치를 수행할 때 발생하는 비활성 서버 인스턴스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-243">Another cause of a failed attempt is an inactive server instance, as occurs when a server instance is engaged in failing over its database.</span></span> <span data-ttu-id="9c8dd-244">이 경우 다시 시도가 지연되어 클라이언트가 연결 시도를 빨리 연속하여 파트너를 오버로드하지 않도록 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-244">In this case, a retry delay is imposed to prevent clients from overloading the partners with a rapid succession of connection attempts.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9c8dd-245">두 파트너 이름을 모두 사용할 수 있을 경우 로그인 제한 시간이 정해져 있지 않으면 클라이언트는 초기 파트너 이름과 장애 조치(failover) 파트너 이름을 교대로 사용하여 무제한으로 서버에 다시 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-245">When both partner names are available, if the login time-out period is infinite, the client attempts to reconnect to the servers indefinitely, alternating between the initial partner name and the failover partner name.</span></span>  
<span data-ttu-id="9c8dd-246">)</span><span class="sxs-lookup"><span data-stu-id="9c8dd-246">)</span></span>  
  
### <a name="retry-delays-during-failover"></a><span data-ttu-id="9c8dd-247">장애 조치 중 다시 시도 지연</span><span class="sxs-lookup"><span data-stu-id="9c8dd-247">Retry Delays During Failover</span></span>  
 <span data-ttu-id="9c8dd-248">클라이언트가 장애 조치 중인 파트너에 연결하면 해당 파트너가 비활성 상태라고 즉시 응답합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-248">If a client attempts to connect to a partner that is failing over, the partner immediately responds that it is inactive.</span></span> <span data-ttu-id="9c8dd-249">이 경우 각 라운드의 연결 시도가 할당된 다시 시도 시간보다 훨씬 짧습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-249">In this case, each round of connection attempts are much briefer than the allotted retry time.</span></span> <span data-ttu-id="9c8dd-250">즉, 로그인 기간이 시간 초과되기 전에 많은 라운드의 연결 시도가 수행될 수 있습니다. 장애 조치 중에 연결 시도를 빨리 연속하여 파트너를 오버로드하지 않도록 방지하기 위해 데이터 액세스 공급자는 각 다시 시도 주기 후에 짧은 다시 시도 지연을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-250">This means that many rounds of connection attempts could happen before the login period times out. To avoid overloading the partners with a rapid series of connection attempts during a failover, the data access provider adds a brief retry delay after each retry cycle.</span></span> <span data-ttu-id="9c8dd-251">지정된 다시 시도 지연의 길이는 다시 시도 지연 알고리즘에 의해 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-251">The length of a given retry delay is determined by the retry-delay algorithm.</span></span> <span data-ttu-id="9c8dd-252">첫 번째 라운드 후의 지연은 100밀리초입니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-252">After the first round, the delay is 100 milliseconds.</span></span> <span data-ttu-id="9c8dd-253">다음 세 라운드 후에는 각각 다시 시도 지연이 각각 두 배씩 증가하여 200, 400, 800이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-253">After each of the next three rounds, the retry delay doubles-to 200, 400, and 800.</span></span> <span data-ttu-id="9c8dd-254">이후의 모든 라운드에서 다시 시도 지연은 연결 시도가 성공하거나 시간이 초과될 때까지 1초입니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-254">For all later rounds, the retry delay is 1 second until the connection attempt succeeds or times out.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9c8dd-255">서버 인스턴스가 중지되면 연결 요청이 즉시 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-255">If the server instance is stopped, then the connection request fails immediately.</span></span>  
  
 <span data-ttu-id="9c8dd-256">다음 그림에서는 파트너가 서로 역할을 전환하는 수동 장애 조치 중에 다시 시도 지연이 연결 시도에 미치는 영향을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-256">The following figure illustrates how the retry delay affects connection attempts during a manual failover, in which the partners switch their roles.</span></span> <span data-ttu-id="9c8dd-257">로그인 제한 시간은 15초입니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-257">The login time-out period is 15 seconds.</span></span>  
  
 <span data-ttu-id="9c8dd-258">![다시 시도 지연 알고리즘](../media/dbm-retry-delay-algorithm.gif "다시 시도 지연 알고리즘")</span><span class="sxs-lookup"><span data-stu-id="9c8dd-258">![Retry-delay algorithm](../media/dbm-retry-delay-algorithm.gif "Retry-delay algorithm")</span></span>  
  
##  <a name="reconnecting-to-a-database-mirroring-session"></a><a name="Reconnecting"></a> <span data-ttu-id="9c8dd-259">데이터베이스 미러링 세션에 다시 연결</span><span class="sxs-lookup"><span data-stu-id="9c8dd-259">Reconnecting to a Database Mirroring Session</span></span>  
 <span data-ttu-id="9c8dd-260">데이터베이스 미러링 장애 조치(Failover) 등의 이유로 데이터베이스 미러링 세션에 대해 설정된 연결이 실패하고 애플리케이션이 초기 서버에 다시 연결하는 경우 데이터 액세스 공급자는 클라이언트 캐시에 저장된 장애 조치(failover) 파트너 이름을 사용하여 다시 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-260">If an established connection to a database mirroring session fails for any reason, for example, due to a database mirroring failover, and the application attempts to reconnect to the initial server, the data access provider can attempt to reconnect using the failover partner name stored in the client's cache.</span></span> <span data-ttu-id="9c8dd-261">그러나 다시 연결은 자동으로 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-261">Reconnecting is not automatic, however.</span></span> <span data-ttu-id="9c8dd-262">애플리케이션에서 오류를 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-262">The application must become aware of the error.</span></span> <span data-ttu-id="9c8dd-263">그런 다음 애플리케이션은 실패한 연결을 닫고 동일한 연결 문자열 특성을 사용하여 새 연결을 열어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-263">Then, the application needs to close the failed connection and open a new connection using the same connection string attributes.</span></span> <span data-ttu-id="9c8dd-264">이때 데이터 액세스 공급자는 장애 조치(failover) 파트너로 연결을 리디렉션합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-264">At this point, the data access provider redirects the connection to the failover partner.</span></span> <span data-ttu-id="9c8dd-265">이 이름으로 식별된 서버 인스턴스가 현재 주 서버이면 일반적으로 연결 시도에 성공합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-265">If the server instance identified by this name is currently the principal server, the connection attempt usually succeeds.</span></span> <span data-ttu-id="9c8dd-266">트랜잭션이 커밋 또는 롤백되었는지가 확실하지 않으면 애플리케이션에서 독립 실행형 서버 인스턴스에 다시 연결할 때와 같은 방식으로 트랜잭션 상태를 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-266">If it is unclear whether a transaction was committed or rolled back, the application must check on the state of the transaction, in the same way as when reconnecting to a stand-alone server instance.</span></span>  
  
 <span data-ttu-id="9c8dd-267">다시 연결은 연결 문자열이 장애 조치(failover) 파트너 이름을 제공한 초기 연결과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-267">Reconnecting resembles an initial connection for which the connection string supplied a failover partner name.</span></span> <span data-ttu-id="9c8dd-268">첫 번째 연결 시도가 실패하면 클라이언트가 주 서버에 연결하거나 데이터 액세스 공급자가 시간 초과될 때까지 연결 시도에서 초기 파트너 이름과 장애 조치(failover) 파트너 이름을 교대로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-268">If the first connection attempt fails, connection attempts alternate back and forth between the initial partner name and failover partner name until either the client connects to the  principal server or the data access provider times out.</span></span>  
  
> [!NOTE]  
>  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="9c8dd-269">Native Client는 주 서버 인스턴스에 연결하는지 확인하지만, 이 인스턴스가 연결 문자열의 초기 파트너 이름에 지정된 서버 인스턴스의 파트너인지 여부는 확인하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-269">Native Client verifies that it connects to a principal server instance but not whether this instance is the partner of server instance specified in the initial partner name of the connection string.</span></span>  
  
 <span data-ttu-id="9c8dd-270">연결에서 TCP/IP를 사용하는 경우 연결 다시 시도 알고리즘에 의해 각 라운드의 연결 시도에 할당되는 시간이 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-270">If the connections use TCP/IP, the connection retry algorithm determines the amount of time allotted to the connection attempts in each round.</span></span>  
  
> [!IMPORTANT]  
>  <span data-ttu-id="9c8dd-271">데이터베이스에서 클라이언트의 연결이 끊어지는 경우 데이터 액세스 공급자는 다시 연결을 시도하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-271">If the client gets disconnected from the database, the data access provider does not attempt to reconnect.</span></span> <span data-ttu-id="9c8dd-272">클라이언트는 새 연결 요청을 실행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-272">The client must issue a new connection request.</span></span> <span data-ttu-id="9c8dd-273">또한 연결 손실 시 애플리케이션이 종료되면 캐시된 파트너 이름도 손실됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-273">Also, if an application shuts down on losing the connection, it will lose the cached partner names.</span></span> <span data-ttu-id="9c8dd-274">주 서버를 사용할 수 없어 연결이 손실된 경우 연결 문자열의 장애 조치(failover) 파트너 이름을 제공해야만 애플리케이션이 미러 서버에 다시 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-274">If the connection was lost because the principal server became unavailable, the only way that the application can reconnect to the mirror server is by supplying the failover partner name in its connection string.</span></span>  
  
  
### <a name="impact-of-redirection-on-a-client-application"></a><span data-ttu-id="9c8dd-275">리디렉션이 클라이언트 애플리케이션에 미치는 영향</span><span class="sxs-lookup"><span data-stu-id="9c8dd-275">Impact of Redirection on a Client Application</span></span>  
 <span data-ttu-id="9c8dd-276">장애 조치 후에 데이터 액세스 공급자는 현재 주 서버 인스턴스로 연결을 리디렉션합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-276">After a failover, the data access provider redirects the connection to the current principal server instance.</span></span> <span data-ttu-id="9c8dd-277">그러나 클라이언트에서 리디렉션을 인식하지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-277">However, the redirection is transparent to clients.</span></span> <span data-ttu-id="9c8dd-278">리디렉션된 연결은 초기 파트너 이름으로 식별된 서버 인스턴스에 대한 연결인 것처럼 클라이언트에 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-278">To a client, a redirected connection appears to be a connection to the server instance identified by the initial partner name.</span></span> <span data-ttu-id="9c8dd-279">초기 파트너가 현재 미러 서버인 경우 클라이언트가 미러 서버에 연결되어 있으며 미러 데이터베이스를 업데이트하는 것처럼 보일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-279">When the initial partner is currently the mirror server, the client can appear to be connected to the mirror server and updating the mirror database.</span></span> <span data-ttu-id="9c8dd-280">그러나 클라이언트는 실제로 현재 주 데이터베이스인 장애 조치(failover) 파트너로 리디렉션되었으며 새로운 주 데이터베이스를 업데이트하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-280">Actually, however, the client has been redirected to the failover partner, which is the current principal database, and the client is updating the new principal database.</span></span>  
  
 <span data-ttu-id="9c8dd-281">장애 조치(failover) 파트너로 리디렉션된 후에 클라이언트에서 다른 데이터베이스를 사용하기 위해 [!INCLUDE[tsql](../../includes/tsql-md.md)] USE 문을 사용하면 예기치 않은 결과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-281">After being redirected to the failover partner, a client can experience unexpected results when using a [!INCLUDE[tsql](../../includes/tsql-md.md)] USE statement to use a different database.</span></span> <span data-ttu-id="9c8dd-282">현재 주 서버 인스턴스(장애 조치(failover) 파트너)에 원래 주 서버(초기 파트너)와 다른 데이터베이스 집합이 있을 경우 이런 문제가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-282">This can happen if the current principal server instance (the failover partner) has a different set of databases than the original principal server (the initial partner).</span></span>  
  
##  <a name="the-impact-of-a-stale-failover-partner-name"></a><a name="StalePartnerName"></a> <span data-ttu-id="9c8dd-283">유효하지 않은 장애 조치(Failover) 파트너 이름의 영향</span><span class="sxs-lookup"><span data-stu-id="9c8dd-283">The Impact of a Stale Failover Partner Name</span></span>  
 <span data-ttu-id="9c8dd-284">데이터베이스 관리자는 언제라도 장애 조치(Failover) 파트너를 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-284">The database administrator can change the failover partner at any time.</span></span> <span data-ttu-id="9c8dd-285">그러므로 클라이언트에서 제공한 장애 조치(failover) 파트너 이름이 최신이 아니거나 *부실*할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-285">Therefore, a client-supplied failover partner name might be out of date, or *stale*.</span></span> <span data-ttu-id="9c8dd-286">예를 들어 Partner_B라는 장애 조치(failover) 파트너가 다른 서버 인스턴스인 Partner_C로 바뀔 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-286">For example, consider a failover partner named Partner_B that is replaced by another server instance, Partner_C.</span></span> <span data-ttu-id="9c8dd-287">이 경우 클라이언트에서는 장애 조치(failover) 파트너 이름으로 Partner_B를 제공하지만 이 이름은 유효하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-287">Now, if a client supplies Partner_B as the failover partner name, that name is stale.</span></span> <span data-ttu-id="9c8dd-288">클라이언트가 제공한 장애 조치(failover) 파트너 이름이 지난 데이터인 경우 데이터 액세스 공급자의 동작은 클라이언트에서 장애 조치(failover) 파트너 이름을 제공하지 않은 경우와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-288">When the client-supplied failover partner name is stale, the behavior of the data access provider equates to the case in which a failover partner name is not supplied by the client.</span></span>  
  
 <span data-ttu-id="9c8dd-289">예를 들어 클라이언트가 하나의 연결 문자열을 사용하여 4회 연속으로 연결 시도를 하는 경우를 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-289">For example, consider situation in which a client uses one connection string for a series of four connection attempts.</span></span> <span data-ttu-id="9c8dd-290">연결 문자열에서 초기 파트너 이름은 Partner_A이고 장애 조치(failover) 파트너 이름은 Partner_B입니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-290">In the connection string, the initial partner name is Partner_A, and the failover partner name is Partner_B:</span></span>  
  
```  
"Server=Partner_A; Failover Partner=Partner_B; Database=AdventureWorks"  
```  
  
 <span data-ttu-id="9c8dd-291">다음 표에서는 4가지 파트너 구성을 보여 주고 각 구성에 대해 이 연결 문자열이 클라이언트를 처음 연결하는 데 사용되는지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-291">The following table shows four partner configurations and indicates for each whether this connection string works for connecting the client for the first time.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9c8dd-292">애플리케이션에서 구성 변경 내용을 추적하고 연결 문자열을 적절하게 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-292">An application can track configuration changes and change its connection string accordingly.</span></span> <span data-ttu-id="9c8dd-293">이렇게 하려면 추가 코드가 필요하지만 관리 작업이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-293">This requires extra code but reduces the administrative burden.</span></span>  
  
|<span data-ttu-id="9c8dd-294">구성</span><span class="sxs-lookup"><span data-stu-id="9c8dd-294">Configuration</span></span>|<span data-ttu-id="9c8dd-295">주 서버</span><span class="sxs-lookup"><span data-stu-id="9c8dd-295">Principal server</span></span>|<span data-ttu-id="9c8dd-296">미러 서버</span><span class="sxs-lookup"><span data-stu-id="9c8dd-296">Mirror server</span></span>|<span data-ttu-id="9c8dd-297">Partner_A 및 Partner_B를 지정하여 연결을 시도할 때의 동작</span><span class="sxs-lookup"><span data-stu-id="9c8dd-297">Behavior when attempting to connect specifying Partner_A and Partner_B</span></span>|  
|-------------------|----------------------|-------------------|------------------------------------------------------------------------------|  
|<span data-ttu-id="9c8dd-298">초기 미러링 구성 단계입니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-298">Original mirroring configuration.</span></span>|<span data-ttu-id="9c8dd-299">Db_1</span><span class="sxs-lookup"><span data-stu-id="9c8dd-299">Partner_A</span></span>|<span data-ttu-id="9c8dd-300">Partner_B</span><span class="sxs-lookup"><span data-stu-id="9c8dd-300">Partner_B</span></span>|<span data-ttu-id="9c8dd-301">Partner_A가 초기 파트너 이름으로 캐시됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-301">Partner_A is cached as the initial partner name.</span></span> <span data-ttu-id="9c8dd-302">클라이언트가 Partner_A에 대한 연결에 성공합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-302">The client succeeds in connecting to Partner_A.</span></span> <span data-ttu-id="9c8dd-303">클라이언트는 미러 서버 이름인 Partner_B를 다운로드하고 이를 캐시합니다. 이때 클라이언트가 제공한 장애 조치(failover) 파트너 이름은 무시합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-303">The client downloads the name of mirror server, Partner_B, and caches it, ignoring the client-supplied failover partner name.</span></span>|  
|<span data-ttu-id="9c8dd-304">Partner_A에 하드웨어 오류가 발생하고 장애 조치가 수행됩니다(클라이언트 연결 끊기).</span><span class="sxs-lookup"><span data-stu-id="9c8dd-304">Partner_A experiences a hardware failure, and failover occurs (disconnecting clients).</span></span>|<span data-ttu-id="9c8dd-305">Partner_B</span><span class="sxs-lookup"><span data-stu-id="9c8dd-305">Partner_B</span></span>|<span data-ttu-id="9c8dd-306">none</span><span class="sxs-lookup"><span data-stu-id="9c8dd-306">none</span></span>|<span data-ttu-id="9c8dd-307">Partner_A가 초기 파트너 이름으로 계속 캐시되지만 클라이언트가 제공한 장애 조치(failover) 파트너 이름인 Partner_B를 사용하여 클라이언트는 현재 주 서버에 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-307">The Partner_A is still cached as the initial partner name, but the client-supplied failover partner name, Partner_B, permits the client to connect to the current principal server.</span></span>|  
|<span data-ttu-id="9c8dd-308">데이터베이스 관리자는 미러링을 중지(클라이언트 연결 끊기)하고 Partner_A를 Partner_C로 바꾼 다음 미러링을 다시 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-308">The database administrator stops mirroring (disconnecting clients), replaces Partner_A with Partner_C, and restarts mirroring.</span></span>|<span data-ttu-id="9c8dd-309">Partner_B</span><span class="sxs-lookup"><span data-stu-id="9c8dd-309">Partner_B</span></span>|<span data-ttu-id="9c8dd-310">Partner_C</span><span class="sxs-lookup"><span data-stu-id="9c8dd-310">Partner_C</span></span>|<span data-ttu-id="9c8dd-311">클라이언트가 Partner_A에 연결을 시도하지만 실패합니다. 그런 다음 클라이언트가 Partner_B(현재 주 서버)에 연결을 시도하여 성공합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-311">The client attempts to connect to Partner_A and fails; then the client tries Partner_B (the current principal server) and succeeds.</span></span> <span data-ttu-id="9c8dd-312">데이터 액세스 공급자는 현재 미러 서버 이름인 Partner_C를 다운로드하고 이를 현재 장애 조치(failover) 파트너 이름으로 캐시합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-312">The data access provider downloads the name of the current mirror server, Partner_C, and caches it as the current failover partner name.</span></span>|  
|<span data-ttu-id="9c8dd-313">서비스가 Partner_C로 수동으로 장애 조치가 수행됩니다(클라이언트 연결 끊기).</span><span class="sxs-lookup"><span data-stu-id="9c8dd-313">Service is manually failed over to Partner_C (disconnecting clients).</span></span>|<span data-ttu-id="9c8dd-314">Partner_C</span><span class="sxs-lookup"><span data-stu-id="9c8dd-314">Partner_C</span></span>|<span data-ttu-id="9c8dd-315">Partner_B</span><span class="sxs-lookup"><span data-stu-id="9c8dd-315">Partner_B</span></span>|<span data-ttu-id="9c8dd-316">클라이언트가 처음에는 Partner_A로 연결을 시도한 다음 Partner_B로 연결을 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-316">Client attempts to connect to Partner_A initially, and then to Partner_B.</span></span> <span data-ttu-id="9c8dd-317">두 이름이 모두 유효하지 않으면 연결 요청 시간이 초과되고 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="9c8dd-317">Both names fail, and eventually the connection request times out and fails.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="9c8dd-318">참고 항목</span><span class="sxs-lookup"><span data-stu-id="9c8dd-318">See Also</span></span>  
 <span data-ttu-id="9c8dd-319">[데이터베이스 미러링&#40;SQL Server&#41;](database-mirroring-sql-server.md) </span><span class="sxs-lookup"><span data-stu-id="9c8dd-319">[Database Mirroring &#40;SQL Server&#41;](database-mirroring-sql-server.md) </span></span>  
 [<span data-ttu-id="9c8dd-320">데이터베이스 미러링 중에 발생 가능한 오류</span><span class="sxs-lookup"><span data-stu-id="9c8dd-320">Possible Failures During Database Mirroring</span></span>](possible-failures-during-database-mirroring.md)  
  
  
