---
title: Integration Services 패키지의 MERGE | Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: integration-services
ms.topic: conceptual
helpviewer_keywords:
- MERGE statement [SQL Server]
ms.assetid: 7e44a5c2-e6d6-4fe2-a079-4f95ccdb147b
author: chugugrace
ms.author: chugu
ms.openlocfilehash: cc6de738d44b91a9e2a4885978ba4a46dfede8cf
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87649612"
---
# <a name="merge-in-integration-services-packages"></a><span data-ttu-id="606ec-102">Integration Services 패키지의 MERGE</span><span class="sxs-lookup"><span data-stu-id="606ec-102">MERGE in Integration Services Packages</span></span>
  <span data-ttu-id="606ec-103">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)][!INCLUDE[ssISnoversion](../../includes/ssisnoversion-md.md)]의 현재 릴리스에서 SQL 실행 태스크의 SQL 문은 MERGE 문을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-103">In the current release of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)][!INCLUDE[ssISnoversion](../../includes/ssisnoversion-md.md)], the SQL statement in an Execute SQL task can contain a MERGE statement.</span></span> <span data-ttu-id="606ec-104">이 MERGE 문을 사용하면 하나의 문에서 여러 INSERT, UPDATE 및 DELETE 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-104">This MERGE statement enables you to accomplish multiple INSERT, UPDATE, and DELETE operations in a single statement.</span></span>  
  
 <span data-ttu-id="606ec-105">패키지에서 MERGE 문을 사용하려면 다음 단계를 따르세요.</span><span class="sxs-lookup"><span data-stu-id="606ec-105">To use the MERGE statement in a package, follow these steps:</span></span>  
  
-   <span data-ttu-id="606ec-106">원본 데이터를 로드하고 변환하여 임시 또는 준비 테이블에 저장하는 데이터 흐름 태스크를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-106">Create a Data Flow task that loads, transforms, and saves the source data to a temporary or staging table.</span></span>  
  
-   <span data-ttu-id="606ec-107">MERGE 문을 포함하는 SQL 실행 태스크를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-107">Create an Execute SQL task that contains the MERGE statement.</span></span>  
  
-   <span data-ttu-id="606ec-108">데이터 흐름 태스크를 SQL 실행 태스크에 연결하고 준비 테이블의 데이터를 MERGE 문의 입력으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-108">Connect the Data Flow task to the Execute SQL task, and use the data in the staging table as the input for the MERGE statement.</span></span>  
  
    > [!NOTE]  
    >  <span data-ttu-id="606ec-109">이 시나리오의 MERGE 문에는 일반적으로 준비 테이블이 필요하지만 MERGE 문의 성능은 대개 조회 변환에 의해 수행되는 행 단위 조회보다 뛰어납니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-109">Although a MERGE statement typically requires a staging table in this scenario, the performance of the MERGE statement usually exceeds that of the row-by-row lookup performed by the Lookup transformation.</span></span> <span data-ttu-id="606ec-110">또한 MERGE는 대용량 조회 테이블이 조회 변환에서 참조 테이블을 캐시하는 데 사용할 수 있는 메모리를 테스트하는 경우 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-110">MERGE is also useful when the large size of a lookup table would test the memory that is available to the Lookup transformation for caching its reference table.</span></span>  
  
 <span data-ttu-id="606ec-111">이 항목의 나머지 부분에서는 MERGE 문의 몇 가지 다른 사용 방식에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-111">The remainder of this topic discusses some additional uses for the MERGE statement.</span></span>  
  
 <span data-ttu-id="606ec-112">MERGE 문 사용을 지원하는 예제 대상 구성 요소는 CodePlex 커뮤니티 예제 [MERGE 대상(MERGE Destination)](https://go.microsoft.com/fwlink/?LinkId=141215)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="606ec-112">For a sample destination component that supports the use of the MERGE statement, see the CodePlex community sample, [MERGE Destination](https://go.microsoft.com/fwlink/?LinkId=141215).</span></span>  
  
## <a name="using-merge"></a><span data-ttu-id="606ec-113">MERGE 사용</span><span class="sxs-lookup"><span data-stu-id="606ec-113">Using MERGE</span></span>  
 <span data-ttu-id="606ec-114">일반적으로 삽입, 업데이트 및 삭제가 포함된 한 테이블의 변경을 다른 테이블에 적용하려는 경우 MERGE 문을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-114">Typically, you use the MERGE statement when you want to apply changes that include inserts, updates, and deletions from one table to another table.</span></span> <span data-ttu-id="606ec-115">[!INCLUDE[ssKatmai](../../includes/sskatmai-md.md)]전에는 이 프로세스에 조회 변환과 여러 OLE DB 명령 변환이 모두 필요했습니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-115">Prior to [!INCLUDE[ssKatmai](../../includes/sskatmai-md.md)], this process required both a Lookup transformation and multiple OLE DB Command transformations.</span></span> <span data-ttu-id="606ec-116">조회 변환은 행 단위로 조회를 수행하여 각 행이 새로운 행인지 변경된 행인지를 판단했습니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-116">The Lookup transformation performed a row-by-row lookup to determine whether each row was new or changed.</span></span> <span data-ttu-id="606ec-117">그러면 OLE DB 명령 변환이 필요한 INSERT, UPDATE 및 DELETE 작업을 수행했습니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-117">The OLE DB Command transformations then performed the necessary INSERT, UPDATE, and DELETE operations.</span></span> <span data-ttu-id="606ec-118">[!INCLUDE[ssKatmai](../../includes/sskatmai-md.md)]이상에서는 하나의 MERGE 문이 조회 변환과 이에 해당하는 OLE DB 명령 변환을 대체합니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-118">Beginning in [!INCLUDE[ssKatmai](../../includes/sskatmai-md.md)], a single MERGE statement can replace both the Lookup transformation and the corresponding OLE DB Command transformations.</span></span>  
  
### <a name="merge-with-incremental-loads"></a><span data-ttu-id="606ec-119">증분 로드와의 MERGE</span><span class="sxs-lookup"><span data-stu-id="606ec-119">MERGE with Incremental Loads</span></span>  
 <span data-ttu-id="606ec-120">[!INCLUDE[ssKatmai](../../includes/sskatmai-md.md)] 의 새로운 변경 데이터 캡처 기능을 사용하면 데이터 웨어하우스로 증분 로드를 보다 쉽게, 안정적으로 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-120">The change data capture functionality that is new in [!INCLUDE[ssKatmai](../../includes/sskatmai-md.md)] makes it easier to perform incremental loads reliably to a data warehouse.</span></span> <span data-ttu-id="606ec-121">삽입과 업데이트를 수행하기 위해 매개 변수가 있는 OLE DB 명령 변환을 사용하는 대신 MERGE 문을 사용하여 두 작업을 결합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-121">As an alternative to using parameterized OLE DB Command transformations to perform the inserts and the updates, you can use the MERGE statement to combine both operations.</span></span>  
  
 <span data-ttu-id="606ec-122">자세한 내용은 [대상에 변경 내용 적용](../change-data-capture/apply-the-changes-to-the-destination.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="606ec-122">For more information, see [Apply the Changes to the Destination](../change-data-capture/apply-the-changes-to-the-destination.md).</span></span>  
  
#### <a name="merge-in-other-scenarios"></a><span data-ttu-id="606ec-123">다른 시나리오에서의 MERGE</span><span class="sxs-lookup"><span data-stu-id="606ec-123">MERGE in Other Scenarios</span></span>  
 <span data-ttu-id="606ec-124">다음 시나리오에서는 [!INCLUDE[ssISnoversion](../../includes/ssisnoversion-md.md)] 패키지 외부 또는 내부에서 MERGE 문을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-124">In the following scenarios, you can use the MERGE statement either outside or inside an [!INCLUDE[ssISnoversion](../../includes/ssisnoversion-md.md)] package.</span></span> <span data-ttu-id="606ec-125">그러나 대부분의 경우 [!INCLUDE[ssISnoversion](../../includes/ssisnoversion-md.md)] 패키지는 다른 유형의 여러 원본에서 이 데이터를 로드한 후 결합하고 정리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-125">However, an [!INCLUDE[ssISnoversion](../../includes/ssisnoversion-md.md)] package is often required to load this data from multiple heterogeneous sources, and then to combine and cleanse the data.</span></span> <span data-ttu-id="606ec-126">따라서 쉽고 간단한 유지 관리를 위해 패키지에서 MERGE 문을 사용하는 방법을 고려할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-126">Therefore, you might consider using the MERGE statement in a package for convenience and ease of maintenance.</span></span>  
  
##### <a name="track-buying-habits"></a><span data-ttu-id="606ec-127">구매 습관 추적</span><span class="sxs-lookup"><span data-stu-id="606ec-127">Track Buying Habits</span></span>  
 <span data-ttu-id="606ec-128">데이터 웨어하우스의 FactBuyingHabits 테이블은 고객이 특정 제품을 구매한 마지막 날짜를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-128">The FactBuyingHabits table in the data warehouse tracks the last date on which a customer bought a given product.</span></span> <span data-ttu-id="606ec-129">테이블은 ProductID, CustomerID 및 PurchaseDate 열로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-129">The table consists of ProductID, CustomerID and PurchaseDate columns.</span></span> <span data-ttu-id="606ec-130">매주 트랜잭션 데이터베이스는 해당 주 동안 이루어진 구매를 포함하는 PurchaseRecords 테이블을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-130">Every week, the transactional database generates a PurchaseRecords table that includes the purchases made during that week.</span></span> <span data-ttu-id="606ec-131">목표는 하나의 MERGE 문을 사용하여 PurchaseRecords 테이블의 정보를 FactBuyingHabits 테이블로 병합하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-131">The objective is to use a single MERGE statement to merge the information in the PurchaseRecords table into the FactBuyingHabits table.</span></span> <span data-ttu-id="606ec-132">MERGE 문은 존재하지 않는 제품-고객 쌍에 대해 새 행을 삽입하고,</span><span class="sxs-lookup"><span data-stu-id="606ec-132">For product-customer pairs that do not exist, the MERGE statement inserts new rows.</span></span> <span data-ttu-id="606ec-133">존재하는 제품-고객 쌍에 대한 최근 구매 날짜를 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-133">For product-customer pairs that exist, the MERGE statement updates the most recent date-of-purchase.</span></span>  
  
###### <a name="track-price-history"></a><span data-ttu-id="606ec-134">가격 기록 추적</span><span class="sxs-lookup"><span data-stu-id="606ec-134">Track Price History</span></span>  
 <span data-ttu-id="606ec-135">DimBook 테이블은 서점에 재고가 있는 책 목록을 나타내고 각 책의 가격 기록을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-135">The DimBook table represents the list of books in the inventory of a book seller and identifies the price history of each book.</span></span> <span data-ttu-id="606ec-136">이 테이블에는 ISBN, ProductID, Price, Shelf 및 IsCurrent 열이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-136">This table has these columns: ISBN, ProductID, Price, Shelf, and IsCurrent.</span></span> <span data-ttu-id="606ec-137">또한 이 테이블에는 책의 각 가격에 대한 행이 하나씩 있습니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-137">This table also has one row for each price the book has had.</span></span> <span data-ttu-id="606ec-138">이러한 여러 행 중 하나에 현재 가격이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-138">One of these rows contains the current price.</span></span> <span data-ttu-id="606ec-139">현재 가격이 포함된 행을 나타내기 위해 해당 행에 대한 IsCurrent 열의 값이 1로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-139">To indicate which row contains the current price, the value of the IsCurrent column for that row is set to 1.</span></span>  
  
 <span data-ttu-id="606ec-140">매주 데이터베이스는 해당 주의 가격 변동과 주 동안 추가된 새 책을 포함하는 WeeklyChanges 테이블을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-140">Every week, the database generates a WeeklyChanges table that contains price changes for the week and new books that were added during the week.</span></span> <span data-ttu-id="606ec-141">하나의 MERGE 문을 사용하여 WeeklyChanges 테이블의 변경 사항을 DimBook 테이블에 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-141">By using a single MERGE statement, you can apply the changes in the WeeklyChanges table to the DimBook table.</span></span> <span data-ttu-id="606ec-142">MERGE 문은 새로 추가된 책에 대해 새 행을 삽입하고, 가격이 변경된 기존 책의 행에 대한 IsCurrent 열을 0으로 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-142">The MERGE statement inserts new rows for newly-added books, and updates the IsCurrent column to 0 for rows of existing books whose prices have changed.</span></span> <span data-ttu-id="606ec-143">또한 MERGE 문은 가격이 변경된 책에 대해 새 행을 삽입하고, 삽입된 새 행에 대해 IsCurrent 열의 값을 1로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-143">The MERGE statement also inserts new rows for books whose prices have changed, and for these new rows, sets the value of the IsCurrent column to 1.</span></span>  
  
### <a name="merge-a-table-with-new-data-against-the-old-table"></a><span data-ttu-id="606ec-144">새 데이터가 있는 테이블을 기존 테이블에 병합</span><span class="sxs-lookup"><span data-stu-id="606ec-144">Merge a Table with New Data Against the Old Table</span></span>  
 <span data-ttu-id="606ec-145">데이터베이스는 "개방형 스키마", 즉 각 속성에 대한 이름-값 쌍을 포함하는 테이블을 사용하여 개체의 속성을 모델링합니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-145">The database models the properties of an object by using an "open schema," that is, a table contains name-value pairs for each property.</span></span> <span data-ttu-id="606ec-146">속성 테이블에는 EntityID, PropertyID 및 Value의 3개 열이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-146">The Properties table has three columns: EntityID, PropertyID, and Value.</span></span> <span data-ttu-id="606ec-147">이 테이블의 새로운 버전인 NewProperties 테이블은 Properties 테이블과 동기화되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-147">A NewProperties table that is a newer version of the table has to be synchronized with the Properties table.</span></span> <span data-ttu-id="606ec-148">이 두 테이블을 동기화하려면 하나의 MERGE 문을 사용하여 다음 작업을 수행하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-148">To synchronize these two tables, you can use a single MERGE statement to perform the following operations:</span></span>  
  
-   <span data-ttu-id="606ec-149">NewProperties 테이블에 없는 속성을 Properties 테이블에서 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-149">Delete properties from the Properties table if they are absent from the NewProperties table.</span></span>  
  
-   <span data-ttu-id="606ec-150">Properties 테이블의 속성 값을 NewProperties 테이블의 새 값으로 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-150">Update values for properties that are in the Properties table with new values found in the NewProperties table.</span></span>  
  
-   <span data-ttu-id="606ec-151">NewProperties 테이블에는 있지만 Properties 테이블에는 없는 속성에 대한 새 속성을 삽입합니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-151">Insert new properties for properties that are in the NewProperties table but are not found in the Properties table.</span></span>  
  
 <span data-ttu-id="606ec-152">이 방식은 서버 두 대에 있는 두 테이블의 데이터를 동기화된 상태로 유지하는 것이 목적인 복제 시나리오와 비슷한 시나리오에서 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-152">This approach is useful in scenarios that resemble replication scenarios, where the objective is to keep data in two tables on two servers synchronized.</span></span>  
  
### <a name="track-inventory"></a><span data-ttu-id="606ec-153">재고 추적</span><span class="sxs-lookup"><span data-stu-id="606ec-153">Track Inventory</span></span>  
 <span data-ttu-id="606ec-154">Inventory 데이터베이스의 ProductsInventory 테이블에는 ProductID와 StockOnHand 열이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-154">The Inventory database has a ProductsInventory table that has ProductID and StockOnHand columns.</span></span> <span data-ttu-id="606ec-155">ProductID, CustomerID 및 Quantity 열이 있는 Shipments 테이블은 고객에게 보내는 제품 배송을 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-155">A Shipments table with ProductID, CustomerID, and Quantity columns tracks shipments of products to customers.</span></span> <span data-ttu-id="606ec-156">ProductInventory 테이블은 Shipments 테이블의 정보를 바탕으로 매일 업데이트되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-156">The ProductInventory table has to be updated daily based on information in the Shipments table.</span></span> <span data-ttu-id="606ec-157">하나의 MERGE 문은 배송을 기준으로 ProductInventory 테이블의 재고를 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-157">A single MERGE statement can reduce the inventory in the ProductInventory table based on the shipments made.</span></span> <span data-ttu-id="606ec-158">또한 제품에 대한 재고가 0이 되면 이 MERGE 문은 ProductInventory 테이블에서 해당 제품 행을 삭제할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="606ec-158">If the inventory for a product has been reduced to 0, that MERGE statement can also delete that product row from the ProductInventory table.</span></span>  
  
  
