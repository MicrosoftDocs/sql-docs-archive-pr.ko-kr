---
title: 식에서의 Integration Services 데이터 형식 | Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: integration-services
ms.topic: conceptual
helpviewer_keywords:
- expressions [Integration Services], data types
- data types [Integration Services], expressions
ms.assetid: c296ad10-4080-4988-8c2c-2c250f7a1884
author: chugugrace
ms.author: chugu
ms.openlocfilehash: 5b2921da7322c7511facacf3918368d8cd8f2fe6
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87732840"
---
# <a name="integration-services-data-types-in-expressions"></a><span data-ttu-id="919e8-102">식에서의 Integration Services 데이터 형식</span><span class="sxs-lookup"><span data-stu-id="919e8-102">Integration Services Data Types in Expressions</span></span>
  <span data-ttu-id="919e8-103">식 계산기는 [!INCLUDE[ssISnoversion](../../../includes/ssisnoversion-md.md)] 데이터 형식을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-103">The expression evaluator uses [!INCLUDE[ssISnoversion](../../../includes/ssisnoversion-md.md)] data types.</span></span> <span data-ttu-id="919e8-104">데이터가 [!INCLUDE[ssISnoversion](../../../includes/ssisnoversion-md.md)] 패키지의 데이터 흐름에 처음 포함될 때 데이터 흐름 엔진이 모든 열 데이터를 [!INCLUDE[ssISnoversion](../../../includes/ssisnoversion-md.md)] 데이터 형식으로 변환하므로 식에 사용되는 열 데이터는 이미 [!INCLUDE[ssISnoversion](../../../includes/ssisnoversion-md.md)] 데이터 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-104">When data first enters a data flow in an [!INCLUDE[ssISnoversion](../../../includes/ssisnoversion-md.md)] package, the data flow engine converts all column data to an [!INCLUDE[ssISnoversion](../../../includes/ssisnoversion-md.md)] data type, and the column data that an expression uses already has an [!INCLUDE[ssISnoversion](../../../includes/ssisnoversion-md.md)] data type.</span></span> <span data-ttu-id="919e8-105">조건부 분할 및 파생 열 변환에 사용된 식은 열 데이터가 포함된 데이터 흐름에 속해 있으므로 열을 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-105">Expressions used in the Conditional Split and the Derived Column transformations can reference columns because they are part of a data flow that includes column data.</span></span>

## <a name="variables"></a><span data-ttu-id="919e8-106">variables</span><span class="sxs-lookup"><span data-stu-id="919e8-106">Variables</span></span>
 <span data-ttu-id="919e8-107">식에 변수를 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-107">Expressions can also use variables.</span></span> <span data-ttu-id="919e8-108">변수는 Variant 데이터 형식으로, 식 계산기는 식을 계산하기 전에 변수의 데이터 형식을 Variant 하위 형식에서 [!INCLUDE[ssISnoversion](../../../includes/ssisnoversion-md.md)] 데이터 형식으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-108">Variables have a Variant data type and the expression evaluator converts the data type of a variable from a Variant subtype to an [!INCLUDE[ssISnoversion](../../../includes/ssisnoversion-md.md)] data type before it evaluates the expression.</span></span> <span data-ttu-id="919e8-109">변수는 [!INCLUDE[ssISnoversion](../../../includes/ssisnoversion-md.md)] 데이터 형식의 하위 집합만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-109">Variables can use only a subset of the [!INCLUDE[ssISnoversion](../../../includes/ssisnoversion-md.md)] data types.</span></span> <span data-ttu-id="919e8-110">예를 들어 변수는 BLOB(Binary Large Object Block) 데이터 형식을 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-110">For example, a variable cannot use a Binary Large Object Block (BLOB) data type.</span></span>

 <span data-ttu-id="919e8-111">Variant 데이터 형식을 [!INCLUDE[ssISnoversion](../../../includes/ssisnoversion-md.md)] 데이터 형식으로 매핑하는 방법과 [!INCLUDE[ssISnoversion](../../../includes/ssisnoversion-md.md)] 데이터 형식에 대한 자세한 내용은 [Integration Services 데이터 형식](../data-flow/integration-services-data-types.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="919e8-111">For more information about [!INCLUDE[ssISnoversion](../../../includes/ssisnoversion-md.md)] data types and the mapping of Variant data types to [!INCLUDE[ssISnoversion](../../../includes/ssisnoversion-md.md)] data types, see [Integration Services Data Types](../data-flow/integration-services-data-types.md).</span></span>

## <a name="literals"></a><span data-ttu-id="919e8-112">리터럴</span><span class="sxs-lookup"><span data-stu-id="919e8-112">Literals</span></span>
 <span data-ttu-id="919e8-113">또한 식은 문자열, 부울 및 숫자 리터럴을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-113">In addition, expressions can include string, Boolean, and numeric literals.</span></span> <span data-ttu-id="919e8-114">숫자 리터럴을 [!INCLUDE[ssISnoversion](../../../includes/ssisnoversion-md.md)] 숫자 데이터 형식으로 변환하는 방법은 [리터럴&#40;SSIS&#41;](numeric-string-and-boolean-literals.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="919e8-114">For more information about converting numeric literals to numeric [!INCLUDE[ssISnoversion](../../../includes/ssisnoversion-md.md)] data types, see [Literals &#40;SSIS&#41;](numeric-string-and-boolean-literals.md).</span></span>

## <a name="implicit-data-conversion"></a><span data-ttu-id="919e8-115">암시적 데이터 변환</span><span class="sxs-lookup"><span data-stu-id="919e8-115">Implicit Data Conversion</span></span>
 <span data-ttu-id="919e8-116">데이터 형식의 암시적 변환은 식 계산기가 자동으로 데이터를 한 데이터 형식에서 다른 데이터 형식으로 변환할 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-116">An implicit conversion of a data type occurs when the expression evaluator automatically converts the data from one data type to another.</span></span> <span data-ttu-id="919e8-117">예를 들어 `smallint`를 `int`와 비교하는 경우 `smallint`는 비교되기 전에 암시적으로 `int`로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-117">For example, if a `smallint` is compared to an `int`, the `smallint` is implicitly converted to `int` before the comparison is performed.</span></span>

 <span data-ttu-id="919e8-118">인수와 피연산자의 데이터 형식이 호환되지 않는 경우 식 계산기는 암시적 데이터 변환을 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-118">The expression evaluator cannot perform implicit data conversion when the arguments and operands have incompatible data types.</span></span> <span data-ttu-id="919e8-119">또한 식 계산기는 암시적으로 임의의 값을 부울로 변환할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-119">In addition, the expression evaluator cannot implicitly convert any value to a Boolean.</span></span> <span data-ttu-id="919e8-120">대신 인수 및 피연산자는 캐스트 연산자를 사용하여 명시적으로 변환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-120">Instead, the arguments and operands must be explicitly converted by using the cast operator.</span></span> <span data-ttu-id="919e8-121">자세한 내용은 [캐스트&#40;SSIS 식&#41;](cast-ssis-expression.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="919e8-121">For more information, see [Cast &#40;SSIS Expression&#41;](cast-ssis-expression.md).</span></span>

 <span data-ttu-id="919e8-122">다음 다이어그램에서는 BINARY 연산의 암시적 변환의 결과 유형을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-122">The following diagram shows the result type of implicit conversions of BINARY operations.</span></span> <span data-ttu-id="919e8-123">이 테이블에서 열과 행의 교집합은 왼쪽(원본) 및 오른쪽(대상) 유형의 피연산자가 있는 이진 연산의 결과 유형입니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-123">The intersection of column and row in this table is the result type of a binary operation with operands of the left (From) and right (To) types.</span></span>

 <span data-ttu-id="919e8-124">![데이터 형식 간 암시적 데이터 형식 전환](../media/mw-dts-impl-conver-02.gif "데이터 형식 간 암시적 데이터 형식 전환")</span><span class="sxs-lookup"><span data-stu-id="919e8-124">![Implicit data type conversion between data types](../media/mw-dts-impl-conver-02.gif "Implicit data type conversion between data types")</span></span>

 <span data-ttu-id="919e8-125">부호 있는 정수와 부호 없는 정수의 교집합은 두 인수 중 하나보다 클 수도 있는 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-125">The intersection of a signed and an unsigned integer is a signed integer that is potentially larger than either argument.</span></span>

 <span data-ttu-id="919e8-126">연산자는 문자열, 날짜, 부울 및 기타 데이터 형식을 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-126">Operators compare strings, dates, Booleans, and other data types.</span></span> <span data-ttu-id="919e8-127">연산자가 두 값을 비교하기 전에 식 계산기는 특정 암시적 변환을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-127">Before an operator compares two values, the expression evaluator performs certain implicit conversions.</span></span> <span data-ttu-id="919e8-128">식 계산기는 항상 문자열 리터럴을 DT_WSTR 데이터 형식으로 변환하고 부울 리터럴을 DT_BOOL 데이터 형식으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-128">The expression evaluator always converts string literals to the DT_WSTR data type and converts Boolean literals to the DT_BOOL data type.</span></span> <span data-ttu-id="919e8-129">식 계산기는 따옴표로 묶인 모든 값을 문자열로 해석합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-129">The expression evaluator interprets all values enclosed in quotation marks as strings.</span></span> <span data-ttu-id="919e8-130">숫자 리터럴은 [!INCLUDE[ssISnoversion](../../../includes/ssisnoversion-md.md)] 숫자 데이터 형식 중 하나로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-130">Numeric literals are converted to one of the numeric [!INCLUDE[ssISnoversion](../../../includes/ssisnoversion-md.md)] data types.</span></span>

> [!NOTE]
>  <span data-ttu-id="919e8-131">부울 값은 숫자가 아니라 논리 값입니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-131">Boolean values are logical values, not numbers.</span></span> <span data-ttu-id="919e8-132">일부 환경에서는 부울 값이 숫자로 표시될 수 있지만 숫자로 저장되지는 않으며, 다양한 프로그래밍 언어에서는 부울 값을 .NET Framework 메서드와는 다른 숫자 값으로 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-132">Although Boolean values may be displayed as numbers in some environments, they are not stored as numbers, and various programming languages represent Boolean values as numeric values differently, as do the .NET Framework methods.</span></span>
> 
>  <span data-ttu-id="919e8-133">예를 들어 Visual Basic에서 사용할 수 있는 변환 함수는 `True`를 -1로 변환하지만 .NET Framework의 `System.Convert.ToInt32` 메서드는 `True`를 +1로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-133">For example, the conversion functions available in Visual Basic convert `True` to -1; however, the `System.Convert.ToInt32` method in the .NET Framework converts `True` to +1.</span></span> <span data-ttu-id="919e8-134">[!INCLUDE[ssISnoversion](../../../includes/ssisnoversion-md.md)] 식 언어는 `True`를 -1로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-134">The [!INCLUDE[ssISnoversion](../../../includes/ssisnoversion-md.md)] Expression Language converts `True` to -1.</span></span>
> 
>  <span data-ttu-id="919e8-135">오류나 예기치 않은 결과를 방지하려면 `True` 및 `False`에 특정 숫자 값을 사용하는 코드를 작성하지 말아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-135">To avoid errors or unexpected results, you should not write code that relies on particular numeric values for `True` and `False`.</span></span> <span data-ttu-id="919e8-136">가능하면 부울 변수는 부울 변수용으로 설계된 논리 값으로만 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-136">Wherever possible, you should restrict usage of Boolean variables to the logical values for which they are designed.</span></span>

 <span data-ttu-id="919e8-137">자세한 내용은 다음 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="919e8-137">For more information, see the following topics:</span></span>

-   [<span data-ttu-id="919e8-138">== &#40;같음&#41;&#40;SSIS 식&#41;</span><span class="sxs-lookup"><span data-stu-id="919e8-138">== &#40;Equal&#41; &#40;SSIS Expression&#41;</span></span>](equal-ssis-expression.md)

-   [<span data-ttu-id="919e8-139">\!= &#40;같지 않음&#41;&#40;SSIS 식&#41;</span><span class="sxs-lookup"><span data-stu-id="919e8-139">!= &#40;Unequal&#41; &#40;SSIS Expression&#41;</span></span>](unequal-ssis-expression.md)

-   [<span data-ttu-id="919e8-140">&#62;&#40;보다 큼&#41;&#40;SSIS 식&#41;</span><span class="sxs-lookup"><span data-stu-id="919e8-140">&#62; &#40;Greater Than&#41; &#40;SSIS Expression&#41;</span></span>](greater-than-ssis-expression.md)

-   [<span data-ttu-id="919e8-141">&#60;&#40;보다 작음&#41;&#40;SSIS 식&#41;</span><span class="sxs-lookup"><span data-stu-id="919e8-141">&#60; &#40;Less Than&#41; &#40;SSIS Expression&#41;</span></span>](less-than-ssis-expression.md)

-   [<span data-ttu-id="919e8-142">&#62;=&#40;크거나 같음&#41;&#40;SSIS 식&#41;</span><span class="sxs-lookup"><span data-stu-id="919e8-142">&#62;= &#40;Greater Than or Equal To&#41; &#40;SSIS Expression&#41;</span></span>](greater-than-or-equal-to-ssis-expression.md)

-   [<span data-ttu-id="919e8-143">&#60;=&#40;작거나 같음&#41;&#40;SSIS 식&#41;</span><span class="sxs-lookup"><span data-stu-id="919e8-143">&#60;= &#40;Less Than or Equal To&#41; &#40;SSIS Expression&#41;</span></span>](less-than-or-equal-to-ssis-expression.md)

 <span data-ttu-id="919e8-144">인수가 하나인 함수는 다음과 같은 경우를 제외하고 해당 인수의 데이터 형식으로 결과를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-144">A function that uses a single argument returns a result with the same data type as the argument, with the following exceptions:</span></span>

-   <span data-ttu-id="919e8-145">DAY, MONTH 및 YEAR는 날짜를 받아서 정수(DT_I4) 결과를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-145">DAY, MONTH, and YEAR accept a date and return an integer (DT_I4) result.</span></span>

-   <span data-ttu-id="919e8-146">ISNULL은 모든 [!INCLUDE[ssIS](../../includes/ssis-md.md)] 데이터 형식의 식을 받아서 부울(DT_BOOL) 결과를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-146">ISNULL accepts an expression of any [!INCLUDE[ssIS](../../includes/ssis-md.md)] data type and returns a Boolean (DT_BOOL) result.</span></span>

-   <span data-ttu-id="919e8-147">SQUARE 및 SQRT는 숫자 식을 받아서 비정수 숫자(DT_R8) 결과를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-147">SQUARE and SQRT accept a numeric expression and return a non-integral numeric (DT_R8) result.</span></span>

 <span data-ttu-id="919e8-148">인수의 데이터 형식이 같으면 결과도 해당 형식이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-148">If the arguments have the same data type, the result is of that type.</span></span> <span data-ttu-id="919e8-149">단, DT_DECIMAL 데이터 형식의 두 값에 대한 이진 연산의 반환 결과는 DT_NUMERIC 데이터 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-149">The only exception is the result of a binary operation on two values with the DT_DECIMAL data type, which returns a result with the DT_NUMERIC data type.</span></span>

## <a name="requirements-for-data-used-in-expressions"></a><span data-ttu-id="919e8-150">식에 사용되는 데이터에 대한 요구 사항</span><span class="sxs-lookup"><span data-stu-id="919e8-150">Requirements for Data Used in Expressions</span></span>
 <span data-ttu-id="919e8-151">식 계산기는 모든 [!INCLUDE[ssISnoversion](../../../includes/ssisnoversion-md.md)] 데이터 형식을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-151">The expression evaluator supports all [!INCLUDE[ssISnoversion](../../../includes/ssisnoversion-md.md)] data types.</span></span> <span data-ttu-id="919e8-152">그러나 연산이나 함수에 따라 피연산자와 인수에 특정 데이터 형식이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-152">However, depending on the operation or the function, the operands and arguments require certain data types.</span></span> <span data-ttu-id="919e8-153">식 계산기는 식에 사용된 데이터에 대해 다음 데이터 형식 요구 사항을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-153">The expression evaluator imposes the following data type requirements on data used in expressions:</span></span>

-   <span data-ttu-id="919e8-154">**논리** 연산에 사용된 피연산자는 부울 값이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-154">Operands used in **logical** operations must evaluate to a Boolean.</span></span> <span data-ttu-id="919e8-155">예를 들어 ColumnA > 1&&ColumnB < 2가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-155">For example, ColumnA > 1&&ColumnB < 2.</span></span>

-   <span data-ttu-id="919e8-156">**수치** 연산에 사용된 피연산자는 숫자 값이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-156">Operands used in **mathematical** operations must evaluate to a numeric value.</span></span> <span data-ttu-id="919e8-157">예를 들어 23.75 \* 4와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-157">For example, 23.75 \* 4.</span></span>

-   <span data-ttu-id="919e8-158">논리 및 등가 연산과 같은 비교 연산에 사용된 피연산자는 호환 가능한 데이터 형식이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-158">Operands used in comparison operations, such as logical and equality operations, must evaluate to compatible data types.</span></span>

     <span data-ttu-id="919e8-159">예를 들어 다음 예의 식 중 하나는 DT_DBTIMESTAMPOFFSET 데이터 형식을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-159">For example, one of the expressions in the following example uses the DT_DBTIMESTAMPOFFSET data type:</span></span>

     `(DT_DBTIMESTAMPOFFSET,3) "1999-10-11 20:34:52.123 -3:30" != (DT_DBDATE)"1999-10-12"`

     <span data-ttu-id="919e8-160">시스템은 `(DT_DBDATE)"1999-10-12"`식을 DT_DBTIMESTAMPOFFSET으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-160">The system converts the expression, `(DT_DBDATE)"1999-10-12"`, to DT_DBTIMESTAMPOFFSET.</span></span> <span data-ttu-id="919e8-161">변환된 식은 "1999-10-12 00:00:00.000 +00:00"이 되고, 이는 다른 식인 `(DT_DBTIMESTAMPOFFSET,3) "1999-10-11 20:34:52.123 -3:30"`과 같지 않으므로 예는 TRUE로 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-161">The example evaluates to TRUE because the converted expression becomes "1999-10-12 00:00:00.000 +00:00", which is not equal to the value of the other expression, `(DT_DBTIMESTAMPOFFSET,3) "1999-10-11 20:34:52.123 -3:30"`.</span></span>

-   <span data-ttu-id="919e8-162">수치 연산 함수에 전달된 인수는 숫자 데이터 형식이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-162">Arguments passed to mathematical functions must evaluate to a numeric data type.</span></span> <span data-ttu-id="919e8-163">함수나 연산에 따라 특정 숫자 데이터 형식이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-163">Depending on the function or operation, a specific numeric data type may be required.</span></span> <span data-ttu-id="919e8-164">예를 들어 HEX 함수는 부호 있는 정수나 부호 없는 정수가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-164">For example, the HEX function requires a signed or unsigned integer.</span></span>

-   <span data-ttu-id="919e8-165">문자열 함수에 전달된 인수는 DT_STR 또는 DT_WSTR과 같은 문자 데이터 형식이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-165">Arguments passed to string functions must evaluate to a character data type: DT_STR or DT_WSTR.</span></span> <span data-ttu-id="919e8-166">예를 들어 UPPER("flower")와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-166">For example, UPPER("flower").</span></span> <span data-ttu-id="919e8-167">SUBSTRING과 같은 일부 문자열 함수는 시작 위치와 문자열 길이를 나타내는 추가 정수 인수가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-167">Some string functions, such as SUBSTRING, require additional integer arguments for the start position and the length of the string.</span></span>

-   <span data-ttu-id="919e8-168">날짜 및 시간 함수에 전달된 인수는 유효한 날짜여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-168">Arguments passed to date and time functions must evaluate to a valid date.</span></span> <span data-ttu-id="919e8-169">예를 들어 DAY(GETDATE())와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-169">For example, DAY(GETDATE()).</span></span> <span data-ttu-id="919e8-170">DATEADD와 같은 일부 함수는 날짜에 추가할 일 수를 나타내는 추가 정수 인수가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-170">Some functions, such as DATEADD, require an additional integer argument for the number of days the function adds to a date.</span></span>

 <span data-ttu-id="919e8-171">부호 없는 8바이트 정수와 부호 있는 정수를 결합하는 연산에서 결과 형식을 명확히 하려면 명시적 캐스트가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-171">Operations that combine an unsigned eight-byte integer and a signed integer require an explicit cast to clarify the result format.</span></span> <span data-ttu-id="919e8-172">자세한 내용은 [캐스트&#40;SSIS 식&#41;](cast-ssis-expression.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="919e8-172">For more information, see [Cast &#40;SSIS Expression&#41;](cast-ssis-expression.md).</span></span>

 <span data-ttu-id="919e8-173">많은 연산 및 함수 결과에는 미리 결정된 데이터 형식이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-173">Results of many operations and functions have predetermined data types.</span></span> <span data-ttu-id="919e8-174">인수의 데이터 형식이거나 식 계산기가 결과를 캐스팅하는 데이터 형식일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-174">This can be the data type of the argument or the data type to which the expression evaluator casts the result.</span></span> <span data-ttu-id="919e8-175">예를 들어 논리적 OR 연산자(||)의 결과는 항상 부울이고 ABS 함수의 결과는 인수의 숫자 데이터 형식이며 곱하기의 결과는 손실 없이 결과를 유지할 수 있는 가장 작은 숫자 데이터 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="919e8-175">For example, the result of a logical OR operator (||) is always a Boolean, the result of the ABS function is the numeric data type of the argument, and the result of multiplication is the smallest numeric data type that can hold the result without loss.</span></span> <span data-ttu-id="919e8-176">결과의 데이터 형식에 대한 자세한 내용은 [연산자&#40;SSIS 식&#41;](operators-ssis-expression.md) 및 [함수&#40;SSIS 식&#41;](functions-ssis-expression.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="919e8-176">For more information about the data types of results, see [Operators &#40;SSIS Expression&#41;](operators-ssis-expression.md) and [Functions &#40;SSIS Expression&#41;](functions-ssis-expression.md).</span></span>

## <a name="related-tasks"></a><span data-ttu-id="919e8-177">관련 작업</span><span class="sxs-lookup"><span data-stu-id="919e8-177">Related Tasks</span></span>
 [<span data-ttu-id="919e8-178">데이터 흐름 구성 요소에서 식 사용</span><span class="sxs-lookup"><span data-stu-id="919e8-178">Use an Expression in a Data Flow Component</span></span>](../use-an-expression-in-a-data-flow-component.md)

## <a name="related-content"></a><span data-ttu-id="919e8-179">관련 내용</span><span class="sxs-lookup"><span data-stu-id="919e8-179">Related Content</span></span>

-   <span data-ttu-id="919e8-180">pragmaticworks.com의 기술 문서 - [SSIS 식 치트 시트](https://pragmaticworks.com/Resources/Cheat-Sheets/SSIS-Expression-Cheat-Sheet3)</span><span class="sxs-lookup"><span data-stu-id="919e8-180">Technical article, [SSIS Expression Cheat Sheet](https://pragmaticworks.com/Resources/Cheat-Sheets/SSIS-Expression-Cheat-Sheet3), on pragmaticworks.com</span></span>

-   <span data-ttu-id="919e8-181">social.technet.microsoft.com의 기술 문서 - [SSIS 식 예](https://go.microsoft.com/fwlink/?LinkId=220761)</span><span class="sxs-lookup"><span data-stu-id="919e8-181">Technical article, [SSIS Expression Examples](https://go.microsoft.com/fwlink/?LinkId=220761), on social.technet.microsoft.com</span></span>


