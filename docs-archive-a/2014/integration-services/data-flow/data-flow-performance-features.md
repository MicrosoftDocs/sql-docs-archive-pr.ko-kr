---
title: 데이터 흐름 성능 기능 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: integration-services
ms.topic: conceptual
helpviewer_keywords:
- Aggregate transformation [Integration Services]
- Integration Services packages, performance
- performance [Integration Services]
- data flow [Integration Services], troubleshooting
- SQL Server Integration Services packages, performance
- loading data
- control flow [Integration Services], troubleshooting
- SSIS packages, performance
- packages [Integration Services], performance
- queries [Integration Services], troubleshooting
- sorting data [Integration Services]
- aggregations [Integration Services]
ms.assetid: c4bbefa6-172b-4547-99a1-a0b38e3e2b05
author: chugugrace
ms.author: chugu
ms.openlocfilehash: 9fb1e5052469421ea2ac9b04627d16d1e2e78771
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87732879"
---
# <a name="data-flow-performance-features"></a><span data-ttu-id="9b10f-102">데이터 흐름 성능 기능</span><span class="sxs-lookup"><span data-stu-id="9b10f-102">Data Flow Performance Features</span></span>
  <span data-ttu-id="9b10f-103">이 항목에서는 일반적인 성능 문제를 방지할 수 있도록 [!INCLUDE[ssISnoversion](../../includes/ssisnoversion-md.md)] 패키지를 디자인하는 방법에 대한 제안 사항을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-103">This topic provides suggestions about how to design [!INCLUDE[ssISnoversion](../../includes/ssisnoversion-md.md)] packages to avoid common performance issues.</span></span> <span data-ttu-id="9b10f-104">또한 이 항목에서는 패키지의 성능 문제를 해결하기 위해 사용할 수 있는 기능 및 도구에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-104">This topic also provides information about features and tools that you can use to troubleshoot the performance of packages.</span></span>  
  
## <a name="configuring-the-data-flow"></a><span data-ttu-id="9b10f-105">데이터 흐름 구성</span><span class="sxs-lookup"><span data-stu-id="9b10f-105">Configuring the Data Flow</span></span>  
 <span data-ttu-id="9b10f-106">성능 향상을 위해 데이터 흐름 태스크를 구성하려면 태스크의 속성을 구성하고 버퍼 크기를 조정하며 패키지에 대해 병렬 실행을 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-106">To configure the Data Flow task for better performance, you can configure the task's properties, adjust buffer size, and configure the package for parallel execution.</span></span>  
  
### <a name="configure-the-properties-of-the-data-flow-task"></a><span data-ttu-id="9b10f-107">데이터 흐름 태스크의 속성 구성</span><span class="sxs-lookup"><span data-stu-id="9b10f-107">Configure the Properties of the Data Flow Task</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9b10f-108">이 섹션에 설명된 속성은 패키지의 각 데이터 흐름 태스크에 대해 개별적으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-108">The properties discussed in this section must be set separately for each Data Flow task in a package.</span></span>  
  
 <span data-ttu-id="9b10f-109">성능에 영향을 주는 다음 데이터 흐름 태스크 속성을 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-109">You can configure the following properties of the Data Flow task, all of which affect performance:</span></span>  
  
-   <span data-ttu-id="9b10f-110">버퍼 데이터의 임시 스토리지 위치(BufferTempStoragePath 속성)와 BLOB(Binary Large Object) 데이터가 들어 있는 열의 임시 스토리지 위치(BLOBTempStoragePath 속성)를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-110">Specify the locations for temporary storage of buffer data (BufferTempStoragePath property) and of columns that contain binary large object (BLOB) data (BLOBTempStoragePath property).</span></span> <span data-ttu-id="9b10f-111">기본적으로 이러한 속성에는 TEMP 및 TMP 환경 변수의 값이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-111">By default, these properties contain the values of the TEMP and TMP environment variables.</span></span> <span data-ttu-id="9b10f-112">다른 폴더를 지정하여 임시 파일을 다른 하드 디스크 드라이브 또는 보다 빠른 하드 디스크 드라이브에 넣거나 해당 파일을 여러 드라이브로 분산할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-112">You might want to specify other folders to put the temporary files on a different or faster hard disk drive, or to spread them across multiple drives.</span></span> <span data-ttu-id="9b10f-113">디렉터리 이름을 세미콜론으로 구분하여 여러 디렉터리를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-113">You can specify multiple directories by delimiting the directory names with semicolons.</span></span>  
  
-   <span data-ttu-id="9b10f-114">DefaultBufferSize 속성을 설정하여 태스크에서 사용되는 버퍼의 기본 크기를 정의하고, DefaultBufferMaxRows 속성을 설정하여 각 버퍼의 최대 행 개수를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-114">Define the default size of the buffer that the task uses, by setting the DefaultBufferSize property, and define the maximum number of rows in each buffer, by setting the DefaultBufferMaxRows property.</span></span> <span data-ttu-id="9b10f-115">기본 버퍼 크기는 10MB이고 최대 버퍼 크기는 100MB입니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-115">The default buffer size is 10 megabytes, with a maximum buffer size of 100 megabytes.</span></span> <span data-ttu-id="9b10f-116">기본 최대 행 개수는 10,000개입니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-116">The default maximum number of rows is 10,000.</span></span>  
  
-   <span data-ttu-id="9b10f-117">EngineThreads 속성을 설정하여 실행 중에 태스크에서 사용할 수 있는 스레드 수를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-117">Set the number of threads that the task can use during execution, by setting the EngineThreads property.</span></span> <span data-ttu-id="9b10f-118">이 속성은 데이터 흐름 엔진에 사용할 스레드 수에 대한 제안 사항을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-118">This property provides a suggestion to the data flow engine about the number of threads to use.</span></span> <span data-ttu-id="9b10f-119">기본값은 10이고 최소값은 3입니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-119">The default is 10, with a minimum value of 3.</span></span> <span data-ttu-id="9b10f-120">그러나 데이터 흐름 엔진은 이 속성 값에 관계없이 필요한 만큼의 스레드만 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-120">However, the engine will not use more threads than it needs, regardless of the value of this property.</span></span> <span data-ttu-id="9b10f-121">동시성 문제를 방지하기 위해 필요한 경우에는 엔진에서 이 속성에 지정된 것보다 많은 수의 스레드를 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-121">The engine may also use more threads than specified in this property, if necessary to avoid concurrency issues.</span></span>  
  
-   <span data-ttu-id="9b10f-122">데이터 흐름 태스크가 최적 모드에서 실행되는지 여부(RunInOptimizedMode 속성)를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-122">Indicate whether the Data Flow task runs in optimized mode (RunInOptimizedMode property).</span></span> <span data-ttu-id="9b10f-123">최적화된 모드는 데이터 흐름에서 사용되지 않은 열, 출력 및 구성 요소를 제거하여 성능을 향상합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-123">Optimized mode improves performance by removing unused columns, outputs, and components from the data flow.</span></span>  
  
    > [!NOTE]  
    >  <span data-ttu-id="9b10f-124">같은 이름의 속성인 RunInOptimizedMode를 [!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)] 의 프로젝트 수준에서 설정하여 데이터 흐름 태스크가 디버깅 중에 최적화된 모드에서 실행되도록 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-124">A property with the same name, RunInOptimizedMode, can be set at the project level in [!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)] to indicate that the Data Flow task runs in optimized mode during debugging.</span></span> <span data-ttu-id="9b10f-125">이 프로젝트 속성은 디자인 타임에 데이터 흐름 태스크의 RunInOptimizedMode 속성보다 우선합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-125">This project property overrides the RunInOptimizedMode property of Data Flow tasks at design time.</span></span>  
  
### <a name="adjust-the-sizing-of-buffers"></a><span data-ttu-id="9b10f-126">버퍼 크기 조정</span><span class="sxs-lookup"><span data-stu-id="9b10f-126">Adjust the Sizing of Buffers</span></span>  
 <span data-ttu-id="9b10f-127">데이터 흐름 엔진은 단일 데이터 행의 예상 크기를 계산하여 버퍼 크기 조정 태스크를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-127">The data flow engine begins the task of sizing its buffers by calculating the estimated size of a single row of data.</span></span> <span data-ttu-id="9b10f-128">그런 다음 예상 행 크기를 DefaultBufferMaxRows 값으로 곱하여 버퍼 크기의 예비 작업 값을 구합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-128">Then it multiplies the estimated size of a row by the value of DefaultBufferMaxRows to obtain a preliminary working value for the buffer size.</span></span>  
  
-   <span data-ttu-id="9b10f-129">결과가 DefaultBufferSize 값보다 크면 엔진은 행 개수를 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-129">If the result is more than the value of DefaultBufferSize, the engine reduces the number of rows.</span></span>  
  
-   <span data-ttu-id="9b10f-130">결과가 내부적으로 계산된 최소 버퍼 크기보다 작으면 엔진은 행 개수를 늘립니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-130">If the result is less than the internally-calculated minimum buffer size, the engine increases the number of rows.</span></span>  
  
-   <span data-ttu-id="9b10f-131">결과가 최소 버퍼 크기와 DefaultBufferSize 값 사이에 있으면 엔진은 예상 행 크기에 DefaultBufferMaxRows 값을 곱한 값에 가능한 한 근접하게 버퍼 크기를 조정합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-131">If the result falls between the minimum buffer size and the value of DefaultBufferSize, the engine sizes the buffer as close as possible to the estimated row size times the value of DefaultBufferMaxRows.</span></span>  
  
 <span data-ttu-id="9b10f-132">데이터 흐름 태스크의 성능 테스트를 시작할 때는 DefaultBufferSize 및 DefaultBufferMaxRows의 기본값을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-132">When you begin testing the performance of your data flow tasks, use the default values for DefaultBufferSize and DefaultBufferMaxRows.</span></span> <span data-ttu-id="9b10f-133">데이터 흐름 태스크에 대한 로깅을 설정하고 BufferSizeTuning 이벤트를 선택하여 각 버퍼에 포함된 행 개수를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-133">Enable logging on the data flow task, and select the BufferSizeTuning event to see how many rows are contained in each buffer.</span></span>  
  
 <span data-ttu-id="9b10f-134">버퍼의 크기를 조정하기 전에 불필요한 열을 제거하고 데이터 형식을 적절하게 구성하여 각 데이터 행의 크기를 줄이는 방식으로 성능을 향상시켜 보는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-134">Before you begin adjusting the sizing of the buffers, the most important improvement that you can make is to reduce the size of each row of data by removing unneeded columns and by configuring data types appropriately.</span></span>  
  
 <span data-ttu-id="9b10f-135">최적의 버퍼 수와 버퍼 크기를 확인하려면 DefaultBufferSize 및 DefaultBufferMaxRows 값으로 시험하면서 BufferSizeTuning 이벤트에서 보고된 정보와 성능을 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-135">To determine the optimum number of buffers and their size, experiment with the values of DefaultBufferSize and DefaultBufferMaxRows while monitoring performance and the information reported by the BufferSizeTuning event.</span></span>  
  
 <span data-ttu-id="9b10f-136">디스크에 대한 페이징이 발생하는 수준까지 버퍼 크기를 늘리지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="9b10f-136">Do not increase buffer size to the point where paging to disk starts to occur.</span></span> <span data-ttu-id="9b10f-137">디스크에 대한 페이징은 최적화되지 않은 버퍼 크기 이상으로 성능을 저하시킵니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-137">Paging to disk hinders performance more than a buffer size that has not been optimized.</span></span> <span data-ttu-id="9b10f-138">페이징의 발생 여부를 확인하려면 MMC( [!INCLUDE[msCoName](../../includes/msconame-md.md)] Management Console)의 성능 스냅인에서 "Buffers spooled" 성능 카운터를 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-138">To determine whether paging is occurring, monitor the "Buffers spooled" performance counter in the Performance snap-in of the [!INCLUDE[msCoName](../../includes/msconame-md.md)] Management Console (MMC).</span></span>  
  
### <a name="configure-the-package-for-parallel-execution"></a><span data-ttu-id="9b10f-139">패키지에 대해 병렬 실행 구성</span><span class="sxs-lookup"><span data-stu-id="9b10f-139">Configure the Package for Parallel Execution</span></span>  
 <span data-ttu-id="9b10f-140">병렬 실행은 실제 프로세서나 논리적 프로세서가 여러 개 있는 컴퓨터에서 성능을 향상시킵니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-140">Parallel execution improves performance on computers that have multiple physical or logical processors.</span></span> <span data-ttu-id="9b10f-141">패키지에 있는 다른 태스크의 병렬 실행을 지원하기 위해 [!INCLUDE[ssISnoversion](../../includes/ssisnoversion-md.md)]에서는 `MaxConcurrentExecutables`와 `EngineThreads`라는 두 속성을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-141">To support parallel execution of different tasks in the package, [!INCLUDE[ssISnoversion](../../includes/ssisnoversion-md.md)] uses two properties: `MaxConcurrentExecutables` and `EngineThreads`.</span></span>  
  
#### <a name="the-maxconcurrentexcecutables-property"></a><span data-ttu-id="9b10f-142">MaxConcurrentExcecutables 속성</span><span class="sxs-lookup"><span data-stu-id="9b10f-142">The MaxConcurrentExcecutables Property</span></span>  
 <span data-ttu-id="9b10f-143">`MaxConcurrentExecutables` 속성은 패키지 자체의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-143">The `MaxConcurrentExecutables` property is a property of the package itself.</span></span> <span data-ttu-id="9b10f-144">이 속성은 동시에 실행할 수 있는 태스크 수를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-144">This property defines how many tasks can run simultaneously.</span></span> <span data-ttu-id="9b10f-145">기본값인 -1은 논리적 프로세서나 실제 프로세서 수에서 2를 더한 수를 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-145">The default value is -1, which means the number of physical or logical processors plus 2.</span></span>  
  
 <span data-ttu-id="9b10f-146">이 속성이 작동하는 방식을 이해하기 위해 세 개의 데이터 흐름 태스크가 있는 샘플 패키지를 살펴 봅니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-146">To understand how this property works, consider a sample package that has three Data Flow tasks.</span></span> <span data-ttu-id="9b10f-147">`MaxConcurrentExecutables`를 3으로 설정하면 세 개의 데이터 흐름 태스크가 모두 동시에 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-147">If you set `MaxConcurrentExecutables` to 3, all three Data Flow tasks can run simultaneously.</span></span> <span data-ttu-id="9b10f-148">그러나 각 데이터 흐름 태스크에 원본에서 대상으로의 실행 트리가 10개 있다고 가정할 때</span><span class="sxs-lookup"><span data-stu-id="9b10f-148">However, assume that each Data Flow task has 10 source-to-destination execution trees.</span></span> <span data-ttu-id="9b10f-149">`MaxConcurrentExecutables`를 3으로 설정하면 각 데이터 흐름 태스크 내에서 실행 트리가 병렬로 실행되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-149">Setting `MaxConcurrentExecutables` to 3 does not ensure that the execution trees inside each Data Flow task run in parallel.</span></span>  
  
#### <a name="the-enginethreads-property"></a><span data-ttu-id="9b10f-150">EngineThreads 속성</span><span class="sxs-lookup"><span data-stu-id="9b10f-150">The EngineThreads Property</span></span>  
 <span data-ttu-id="9b10f-151">`EngineThreads` 속성은 각 데이터 흐름 태스크의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-151">The `EngineThreads` property is a property of each Data Flow task.</span></span> <span data-ttu-id="9b10f-152">이 속성은 데이터 흐름 엔진에서 만들어 병렬로 실행할 수 있는 스레드 수를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-152">This property defines how many threads the data flow engine can create and run in parallel.</span></span> <span data-ttu-id="9b10f-153">`EngineThreads` 속성은 데이터 흐름 엔진에서 원본에 대해 만드는 원본 스레드와 해당 엔진에서 변환 및 대상에 대해 만드는 작업자 스레드 모두에 동일하게 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-153">The `EngineThreads` property applies equally to both the source threads that the data flow engine creates for sources and the worker threads that the engine creates for transformations and destinations.</span></span> <span data-ttu-id="9b10f-154">따라서 `EngineThreads`를 10으로 설정하면 엔진에서 원본 스레드와 작업자 스레드를 각각 10개까지 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-154">Therefore, setting `EngineThreads` to 10 means that the engine can create up to ten source threads and up to ten worker threads.</span></span>  
  
 <span data-ttu-id="9b10f-155">이 속성이 작동하는 방식을 이해하기 위해 세 개의 데이터 흐름 태스크가 있는 샘플 패키지를 살펴 봅니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-155">To understand how this property works, consider the sample package with three Data Flow tasks.</span></span> <span data-ttu-id="9b10f-156">각 데이터 흐름 태스크에 10개의 원본에서 대상으로의 실행 트리가 포함되어 있을 때</span><span class="sxs-lookup"><span data-stu-id="9b10f-156">Each of Data Flow task contains ten source-to-destination execution trees.</span></span> <span data-ttu-id="9b10f-157">각 데이터 흐름 태스크에서 EngineThreads를 10으로 설정하면 30개의 실행 트리가 모두 동시에 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-157">If you set EngineThreads to 10 on each Data Flow task, all 30 execution trees can potentially run simultaneously.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9b10f-158">스레딩에 대한 설명은 이 항목의 범위를 벗어납니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-158">A discussion of threading is beyond the scope of this topic.</span></span> <span data-ttu-id="9b10f-159">그러나 사용 가능한 프로세서 수보다 많은 스레드를 병렬로 실행하지 않는 것이 일반적인 규칙입니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-159">However, the general rule is not to run more threads in parallel than the number of available processors.</span></span> <span data-ttu-id="9b10f-160">사용 가능한 프로세서 수보다 많은 스레드를 실행하면 스레드 간 컨텍스트 전환이 빈번하게 발생하므로 성능이 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-160">Running more threads than the number of available processors can hinder performance because of the frequent context-switching between threads.</span></span>  
  
## <a name="configuring-individual-data-flow-components"></a><span data-ttu-id="9b10f-161">개별 데이터 흐름 구성 요소 구성</span><span class="sxs-lookup"><span data-stu-id="9b10f-161">Configuring Individual Data Flow Components</span></span>  
 <span data-ttu-id="9b10f-162">성능 향상을 위해 개별 데이터 흐름 구성 요소를 구성하려면 몇 가지 일반적인 지침을 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-162">To configure individual data flow components for better performance, there are some general guidelines that you can follow.</span></span> <span data-ttu-id="9b10f-163">데이터 흐름 구성 요소의 각 유형(원본, 변환 및 대상)과 관련된 지침도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-163">There are also specific guidelines for each type of data flow component: source, transformation, and destination.</span></span>  
  
### <a name="general-guidelines"></a><span data-ttu-id="9b10f-164">일반 지침</span><span class="sxs-lookup"><span data-stu-id="9b10f-164">General Guidelines</span></span>  
 <span data-ttu-id="9b10f-165">데이터 흐름 구성 요소와 상관없이 성능 향상을 위해서는 쿼리를 최적화하고 불필요한 정렬을 사용하지 않는다는 두 가지 일반적인 지침을 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-165">Regardless of the data flow component, there are two general guidelines that you should follow to improve performance: optimize queries and avoid unnecessary strings.</span></span>  
  
#### <a name="optimize-queries"></a><span data-ttu-id="9b10f-166">쿼리 최적화</span><span class="sxs-lookup"><span data-stu-id="9b10f-166">Optimize Queries</span></span>  
 <span data-ttu-id="9b10f-167">많은 데이터 흐름 구성 요소가 원본에서 데이터를 추출할 때나 참조 테이블을 만들기 위해 조회 작업에서 쿼리를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-167">A number of data flow components use queries, either when they extract data from sources, or in lookup operations to create reference tables.</span></span> <span data-ttu-id="9b10f-168">기본 쿼리는 SELECT \* FROM \<tableName> 구문을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-168">The default query uses the SELECT \* FROM \<tableName> syntax.</span></span> <span data-ttu-id="9b10f-169">이 유형의 쿼리는 원본 테이블의 모든 열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-169">This type of query returns all the columns in the source table.</span></span> <span data-ttu-id="9b10f-170">디자인 타임에 모든 열을 사용할 수 있도록 만들면 모든 열을 조회, 통과 또는 원본 열로 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-170">Having all the columns available at design time makes it possible to choose any column as a lookup, pass-through, or source column.</span></span> <span data-ttu-id="9b10f-171">그러나 사용할 열을 선택한 후에는 선택한 열만 포함되도록 쿼리를 수정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-171">However, after you have selected the columns to be used, you should revise the query to include only those selected columns.</span></span> <span data-ttu-id="9b10f-172">열 수가 적을수록 더 작은 행이 만들어지므로 여분의 열을 제거하면 패키지의 데이터 흐름이 보다 효율적으로 개선됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-172">Removing superfluous columns makes the data flow in a package more efficient because fewer columns create a smaller row.</span></span> <span data-ttu-id="9b10f-173">행이 작을수록 하나의 버퍼에 더 많은 행을 넣을 수 있으며 데이터 세트의 모든 행을 보다 적은 작업으로 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-173">A smaller row means that more rows can fit into one buffer, and the less work it is to process all the rows in the dataset.</span></span>  
  
 <span data-ttu-id="9b10f-174">쿼리를 생성하려면 쿼리를 직접 입력하거나 쿼리 작성기를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-174">To construct a query, you can type the query or use Query Builder.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="9b10f-175">[!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)]에서 패키지를 실행하면 [!INCLUDE[ssIS](../../includes/ssis-md.md)] 디자이너의 진행률 탭에 경고가 나열됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-175">When you run a package in [!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)], the Progress tab of [!INCLUDE[ssIS](../../includes/ssis-md.md)] Designer lists warnings.</span></span> <span data-ttu-id="9b10f-176">이러한 경고에는 원본에서 데이터 흐름에 제공되지만 나중에 다운스트림 데이터 흐름 구성 요소에 사용되지 않는 데이터 열이 식별되어 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-176">These warnings include identifying any data column that a source makes available to the data flow, but is not subsequently used by downstream data flow components.</span></span> <span data-ttu-id="9b10f-177">`RunInOptimizedMode` 속성을 사용하여 이러한 열을 자동으로 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-177">You can use the `RunInOptimizedMode` property to remove these columns automatically.</span></span>  
  
#### <a name="avoid-unnecessary-sorting"></a><span data-ttu-id="9b10f-178">불필요한 정렬 방지</span><span class="sxs-lookup"><span data-stu-id="9b10f-178">Avoid Unnecessary Sorting</span></span>  
 <span data-ttu-id="9b10f-179">정렬은 근본적으로 느린 작업이므로 불필요한 정렬을 방지하면 패키지 데이터 흐름의 성능을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-179">Sorting is inherently a slow operation, and avoiding unnecessary sorting can enhance the performance of the package data flow.</span></span>  
  
 <span data-ttu-id="9b10f-180">원본 데이터가 다운스트림 구성 요소에 의해 사용되기 전에 이미 정렬되어 있는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-180">Sometimes the source data has already been sorted before being used by a downstream component.</span></span> <span data-ttu-id="9b10f-181">SELECT 쿼리에 ORDER BY 절이 사용되거나 데이터가 원본에 정렬된 순서대로 삽입되면 이러한 사전 정렬이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-181">Such pre-sorting can occur when the SELECT query used an ORDER BY clause or when the data was inserted into the source in sorted order.</span></span> <span data-ttu-id="9b10f-182">이렇게 사전 정렬된 원본 데이터의 경우 데이터가 정렬되어 있음을 나타내는 힌트를 제공하여 특정 다운스트림 변환의 정렬 요구 사항을 만족시키기 위해 정렬 변환을 사용하는 것을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-182">For such pre-sorted source data, you can provide a hint that the data is sorted, and thereby avoid the use of a Sort transformation to satisfy the sorting requirements of certain downstream transformations.</span></span> <span data-ttu-id="9b10f-183">예를 들어 병합 및 병합 조인 변환에는 정렬된 입력이 필요합니다. 데이터가 정렬되어 있음을 나타내는 힌트를 제공하려면 다음 태스크를 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-183">(For example, the Merge and Merge Join transformations require sorted inputs.) To provide a hint that the data is sorted, you have to do the following tasks:</span></span>  
  
-   <span data-ttu-id="9b10f-184">업스트림 데이터 흐름 구성 요소의 출력에 있는 `IsSorted` 속성을 `True`로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-184">Set the `IsSorted` property on the output of an upstream data flow component to `True`.</span></span>  
  
-   <span data-ttu-id="9b10f-185">데이터가 정렬되는 정렬 키 열을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-185">Specify the sort key columns on which the data is sorted.</span></span>  
  
 <span data-ttu-id="9b10f-186">자세한 내용은 [병합 및 병합 조인 변환을 위한 데이터 정렬](transformations/sort-data-for-the-merge-and-merge-join-transformations.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9b10f-186">For more information, see [Sort Data for the Merge and Merge Join Transformations](transformations/sort-data-for-the-merge-and-merge-join-transformations.md).</span></span>  
  
 <span data-ttu-id="9b10f-187">데이터 흐름에서 데이터를 정렬해야 하는 경우 정렬 연산을 가능한 한 적게 사용하도록 데이터 흐름을 디자인하여 성능을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-187">If you have to sort the data in the data flow, you can improve performance by designing the data flow to use as few sort operations as possible.</span></span> <span data-ttu-id="9b10f-188">예를 들어 데이터 흐름에서 멀티캐스트 변환을 사용하여 데이터 세트를 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-188">For example, the data flow uses a Multicast transformation to copy the dataset.</span></span> <span data-ttu-id="9b10f-189">변환 후 여러 출력을 정렬하는 대신 멀티캐스트 변환을 실행하기 전에 데이터 세트를 한 번 정렬합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-189">Sort the dataset once before the Multicast transformation runs, instead of sorting multiple outputs after the transformation.</span></span>  
  
 <span data-ttu-id="9b10f-190">자세한 내용은 [Sort Transformation](transformations/sort-transformation.md), [Merge Transformation](transformations/merge-transformation.md), [Merge Join Transformation](transformations/merge-join-transformation.md)및 [Multicast Transformation](transformations/multicast-transformation.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9b10f-190">For more information, see [Sort Transformation](transformations/sort-transformation.md), [Merge Transformation](transformations/merge-transformation.md), [Merge Join Transformation](transformations/merge-join-transformation.md), and [Multicast Transformation](transformations/multicast-transformation.md).</span></span>  
  
### <a name="sources"></a><span data-ttu-id="9b10f-191">원본</span><span class="sxs-lookup"><span data-stu-id="9b10f-191">Sources</span></span>  
  
#### <a name="ole-db-source"></a><span data-ttu-id="9b10f-192">OLE DB 원본</span><span class="sxs-lookup"><span data-stu-id="9b10f-192">OLE DB Source</span></span>  
 <span data-ttu-id="9b10f-193">OLE DB 원본을 사용하여 뷰에서 데이터를 검색할 때는 "SQL 명령"을 데이터 액세스 모드로 선택하고 SELECT 문을 입력합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-193">When you use an OLE DB source to retrieve data from a view, select "SQL command" as the data access mode and enter a SELECT statement.</span></span> <span data-ttu-id="9b10f-194">SELECT 문을 사용하여 데이터에 액세스하면 "테이블 또는 뷰"를 데이터 액세스 모드로 선택하는 것보다 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-194">Accessing data by using a SELECT statement performs better than selecting "Table or view" as the data access mode.</span></span>  
  
### <a name="transformations"></a><span data-ttu-id="9b10f-195">변환</span><span class="sxs-lookup"><span data-stu-id="9b10f-195">Transformations</span></span>  
 <span data-ttu-id="9b10f-196">집계, 유사 항목 조회, 유사 항목 그룹화, 조회, 병합 조인 및 느린 변경 차원 변환의 성능을 향상시키려면 이 섹션의 제안 사항을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-196">Use the suggestions in this section to improve the performance of the Aggregate, Fuzzy Lookup, Fuzzy Grouping, Lookup, Merge Join, and Slowly Changing Dimension transformations.</span></span>  
  
#### <a name="aggregate-transformation"></a><span data-ttu-id="9b10f-197">집계 변환</span><span class="sxs-lookup"><span data-stu-id="9b10f-197">Aggregate Transformation</span></span>  
 <span data-ttu-id="9b10f-198">집계 변환에는 `Keys`, `KeysScale`, `CountDistinctKeys` 및 `CountDistinctScale` 속성이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-198">The Aggregate transformation includes the `Keys`, `KeysScale`, `CountDistinctKeys`, and `CountDistinctScale` properties.</span></span> <span data-ttu-id="9b10f-199">이 속성은 변환이 캐시하는 데이터에 필요한 메모리 양을 미리 할당할 수 있도록 하여 성능을 향상시킵니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-199">These properties improve performance by enabling the transformation to preallocate the amount of memory that the transformation needs for the data that the transformation caches.</span></span> <span data-ttu-id="9b10f-200">**Group by** 연산의 결과로 반환 될 그룹의 정확한 수 또는 대략적인 수를 아는 경우 `Keys` `KeysScale` 각각 및 속성을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-200">If you know the exact or approximate number of groups that are expected to result from a **Group by** operation, set the `Keys` and `KeysScale` properties, respectively.</span></span> <span data-ttu-id="9b10f-201">**고유 카운트** 연산의 결과로 반환 될 고유 값의 정확한 수 또는 대략적인 수를 아는 경우 `CountDistinctKeys` `CountDistinctScale` 각각 및 속성을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-201">If you know the exact or approximate number of distinct values that are expected to result from a **Distinct count** operation, set the `CountDistinctKeys` and `CountDistinctScale` properties, respectively.</span></span>  
  
 <span data-ttu-id="9b10f-202">한 데이터 흐름에 여러 집계를 만들어야 하는 경우 여러 변환을 만드는 대신 하나의 집계 변환을 사용하는 여러 집계를 만드십시오.</span><span class="sxs-lookup"><span data-stu-id="9b10f-202">If you have to create multiple aggregations in a data flow, consider creating multiple aggregations that use one Aggregate transformation instead of creating multiple transformations.</span></span> <span data-ttu-id="9b10f-203">이 방법을 사용하면 한 집계가 다른 집계의 하위 집합인 경우 성능이 향상됩니다. 이는 변환이 한 번만 들어오는 데이터를 검색하고 내부 스토리지를 최적화할 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-203">This approach improves performance when one aggregation is a subset of another aggregation because the transformation can optimize internal storage and scan incoming data only once.</span></span> <span data-ttu-id="9b10f-204">예를 들어 집계에서 GROUP BY 절 및 AVG 집계를 사용하는 경우 이를 하나의 변환으로 조합하면 성능을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-204">For example, if an aggregation uses a GROUP BY clause and an AVG aggregation, combining them into one transformation can improve performance.</span></span> <span data-ttu-id="9b10f-205">그러나 하나의 집계 변환 내에서 여러 집계를 수행하면 집계 작업이 직렬화되므로 여러 집계가 독립적으로 계산되어야 하는 경우 성능이 향상되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-205">However, performing multiple aggregations within one Aggregate transformation serializes the aggregation operations, and therefore might not improve performance when multiple aggregations must be computed independently.</span></span>  
  
#### <a name="fuzzy-lookup-and-fuzzy-grouping-transformations"></a><span data-ttu-id="9b10f-206">유사 항목 조회 및 유사 항목 그룹화 변환</span><span class="sxs-lookup"><span data-stu-id="9b10f-206">Fuzzy Lookup and Fuzzy Grouping Transformations</span></span>  
 <span data-ttu-id="9b10f-207">유사 항목 조회 및 유사 항목 그룹화 변환의 성능 최적화에 대한 자세한 내용은 백서 [SQL Server 2005 데이터 변환 서비스의 퍼지 조회 및 퍼지 그룹화](https://go.microsoft.com/fwlink/?LinkId=96604)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="9b10f-207">For information about optimizing the performance of the Fuzzy Lookup and Fuzzy Grouping transformations, see the white paper, [Fuzzy Lookup and Fuzzy Grouping in SQL Server Integration Services 2005](https://go.microsoft.com/fwlink/?LinkId=96604).</span></span>  
  
#### <a name="lookup-transformation"></a><span data-ttu-id="9b10f-208">조회 변환</span><span class="sxs-lookup"><span data-stu-id="9b10f-208">Lookup Transformation</span></span>  
 <span data-ttu-id="9b10f-209">필요한 열만 조회하는 SELECT 문을 입력하여 메모리에서 참조 데이터의 크기를 최소화합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-209">Minimize the size of the reference data in memory by entering a SELECT statement that looks up only the columns that you need.</span></span> <span data-ttu-id="9b10f-210">이 옵션은 불필요한 데이터를 대량 반환하는 전체 테이블 또는 뷰 선택 작업보다 성능을 향상시킵니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-210">This option performs better than selecting an entire table or view, which returns a large amount of unnecessary data.</span></span>  
  
#### <a name="merge-join-transformation"></a><span data-ttu-id="9b10f-211">Merge Join Transformation</span><span class="sxs-lookup"><span data-stu-id="9b10f-211">Merge Join Transformation</span></span>  
 <span data-ttu-id="9b10f-212">병합 조인 변환에서 과도한 메모리를 사용할 위험을 줄이기 위해 Microsoft에서 필요한 변경을 수행했기 때문에 더 이상 `MaxBuffersPerInput` 속성 값을 구성할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-212">You no longer have to configure the value of the `MaxBuffersPerInput` property because Microsoft has made changes that reduce the risk that the Merge Join transformation will consume excessive memory.</span></span> <span data-ttu-id="9b10f-213">과도한 메모리가 사용되는 문제는 여러 병합 조인 입력에서 균일하지 않은 속도로 데이터를 생성하는 경우에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-213">This problem sometimes occurred when the multiple inputs of the Merge Join produced data at uneven rates.</span></span>  
  
#### <a name="slowly-changing-dimension-transformation"></a><span data-ttu-id="9b10f-214">느린 변경 차원 변환</span><span class="sxs-lookup"><span data-stu-id="9b10f-214">Slowly Changing Dimension Transformation</span></span>  
 <span data-ttu-id="9b10f-215">느린 변경 차원 마법사 및 느린 변경 차원 변형은 사용자 대부분의 요구를 충족하는 일반적인 용도의 도구입니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-215">The Slowly Changing Dimension Wizard and the Slowly Changing Dimension transformation are general-purpose tools that meet the needs of most users.</span></span> <span data-ttu-id="9b10f-216">그러나 마법사에서 생성하는 데이터 흐름은 성능을 위해 최적화되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-216">However, the data flow that the wizard generates is not optimized for performance.</span></span>  
  
 <span data-ttu-id="9b10f-217">일반적으로 느린 변경 차원 변환에서 가장 느린 구성 요소는 한 번에 하나의 행에 대해 UPDATE를 수행하는 OLE DB 명령 변환입니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-217">Typically, the slowest components in the Slowly Changing Dimension transformation are the OLE DB Command transformations that perform UPDATEs against a single row at a time.</span></span> <span data-ttu-id="9b10f-218">따라서 느린 변경 차원 변환의 성능을 향상시키는 가장 효과적인 방법은 OLE DB 명령 변환을 바꾸는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-218">Therefore, the most effective way to improve the performance of the Slowly Changing Dimension transformation is to replace the OLE DB Command transformations.</span></span> <span data-ttu-id="9b10f-219">업데이트할 모든 행을 준비 테이블에 저장하는 대상 구성 요소로 이러한 변환을 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-219">You can replace these transformations with destination components that save all rows to be updated to a staging table.</span></span> <span data-ttu-id="9b10f-220">그런 다음 모든 행에 대해 동시에 단일 집합 기반 Transact-SQL UPDATE를 수행하는 SQL 실행 태스크를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-220">Then, you can add an Execute SQL task that performs a single set-based Transact-SQL UPDATE against all rows at the same time.</span></span>  
  
 <span data-ttu-id="9b10f-221">고급 사용자는 느린 변경 차원 처리를 위해 대규모 차원에 대해 최적화된 사용자 지정 데이터 흐름을 디자인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-221">Advanced users can design a custom data flow for slowly changing dimension processing that is optimized for large dimensions.</span></span> <span data-ttu-id="9b10f-222">이 방법에 대한 설명 및 예는 백서 [Project REAL: 비즈니스 인텔리전스 ETL 디자인 방법](https://www.microsoft.com/download/details.aspx?id=14582)의 "고유 차원 시나리오" 섹션을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="9b10f-222">For a discussion and example of this approach, see the section, "Unique dimension scenario," in the white paper, [Project REAL: Business Intelligence ETL Design Practices](https://www.microsoft.com/download/details.aspx?id=14582).</span></span>  
  
### <a name="destinations"></a><span data-ttu-id="9b10f-223">Destinations</span><span class="sxs-lookup"><span data-stu-id="9b10f-223">Destinations</span></span>  
 <span data-ttu-id="9b10f-224">대상에서 성능을 향상시키려면 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 대상을 사용하고 대상의 성능을 테스트하십시오.</span><span class="sxs-lookup"><span data-stu-id="9b10f-224">To achieve better performance with destinations, consider using a [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] destination and testing the destination's performance.</span></span>  
  
#### <a name="sql-server-destination"></a><span data-ttu-id="9b10f-225">SQL Server 대상</span><span class="sxs-lookup"><span data-stu-id="9b10f-225">SQL Server Destination</span></span>  
 <span data-ttu-id="9b10f-226">패키지가 같은 컴퓨터에 있는 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 인스턴스에 데이터를 로드하면 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 대상을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-226">When a package loads data to an instance of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] on the same computer, use a [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] destination.</span></span> <span data-ttu-id="9b10f-227">이 대상은 고속 대량 로드를 위해 최적화되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-227">This destination is optimized for high-speed bulk loads.</span></span>  
  
#### <a name="testing-the-performance-of-destinations"></a><span data-ttu-id="9b10f-228">대상 성능 테스트</span><span class="sxs-lookup"><span data-stu-id="9b10f-228">Testing the Performance of Destinations</span></span>  
 <span data-ttu-id="9b10f-229">대상에 데이터를 저장하는 데는 예상보다 많은 시간이 소모됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-229">You may find that saving data to destinations takes more time than expected.</span></span> <span data-ttu-id="9b10f-230">대상의 낮은 데이터 처리 능력으로 인해 속도 저하가 일어났는지 여부를 식별하려면 임시로 대상을 행 개수 변환으로 대체하십시오.</span><span class="sxs-lookup"><span data-stu-id="9b10f-230">To identify whether the slowness is caused by the inability of the destination to process data quickly enough, you can temporarily replace the destination with a Row Count transformation.</span></span> <span data-ttu-id="9b10f-231">처리량이 크게 향상되면 데이터를 로드하는 대상에서 속도 저하가 일어난 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-231">If the throughput improves significantly, it is likely that the destination that is loading the data is causing the slowdown.</span></span>  
  
### <a name="review-the-information-on-the-progress-tab"></a><span data-ttu-id="9b10f-232">진행률 탭의 정보 검토</span><span class="sxs-lookup"><span data-stu-id="9b10f-232">Review the Information on the Progress Tab</span></span>  
 [!INCLUDE[ssIS](../../includes/ssis-md.md)] <span data-ttu-id="9b10f-233">디자이너는 [!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)]에서 패키지를 실행할 때 제어 흐름과 데이터 흐름 모두에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-233">Designer provides information about both control flow and data flow when you run a package in [!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)].</span></span> <span data-ttu-id="9b10f-234">**진행률** 탭에는 태스크와 컨테이너가 실행 순서대로 나열되며 패키지 자체를 포함하여 각 태스크 및 컨테이너에 대한 시작 및 종료 시간, 경고 및 오류 메시지가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-234">The **Progress** tab lists tasks and containers in order of execution and includes start and finish times, warnings, and error messages for each task and container, including the package itself.</span></span> <span data-ttu-id="9b10f-235">또한 데이터 흐름 구성 요소가 실행 순서대로 표시되고, 진행률(완료율로 표시)과 처리된 행 개수에 대한 정보가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-235">It also lists data flow components in order of execution and includes information about progress, displayed as percentage complete, and the number of rows processed.</span></span>  
  
 <span data-ttu-id="9b10f-236">**진행률** 탭에 메시지를 표시할지 여부는 **SSIS** 메뉴의 **디버그 진행률 보고** 옵션을 선택 또는 선택 취소하여 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-236">To enable or disable the display of messages on the **Progress** tab, toggle the **Debug Progress Reporting** option on the **SSIS** menu.</span></span> <span data-ttu-id="9b10f-237">진행률 보고를 사용하지 않으면 [!INCLUDE[ssBIDevStudio](../../includes/ssbidevstudio-md.md)]에서 복잡한 패키지를 실행하는 동안 성능을 높일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9b10f-237">Disabling progress reporting can help improve performance while running a complex package in [!INCLUDE[ssBIDevStudio](../../includes/ssbidevstudio-md.md)].</span></span>  
  
## <a name="related-tasks"></a><span data-ttu-id="9b10f-238">관련 작업</span><span class="sxs-lookup"><span data-stu-id="9b10f-238">Related Tasks</span></span>  
  
-   [<span data-ttu-id="9b10f-239">병합 및 병합 조인 변환을 위한 데이터 정렬</span><span class="sxs-lookup"><span data-stu-id="9b10f-239">Sort Data for the Merge and Merge Join Transformations</span></span>](transformations/sort-data-for-the-merge-and-merge-join-transformations.md)  
  
## <a name="related-content"></a><span data-ttu-id="9b10f-240">관련 내용</span><span class="sxs-lookup"><span data-stu-id="9b10f-240">Related Content</span></span>  
 <span data-ttu-id="9b10f-241">**기사와 블로그 게시물**</span><span class="sxs-lookup"><span data-stu-id="9b10f-241">**Articles and Blog Posts**</span></span>  
  
-   <span data-ttu-id="9b10f-242">technet.microsoft.com의 기술 문서 [SQL Server 2005 Integration Services: 성능에 대한 전략](https://go.microsoft.com/fwlink/?LinkId=98899)</span><span class="sxs-lookup"><span data-stu-id="9b10f-242">Technical article, [SQL Server 2005 Integration Services: A Strategy for Performance](https://go.microsoft.com/fwlink/?LinkId=98899), on technet.microsoft.com</span></span>  
  
-   <span data-ttu-id="9b10f-243">technet.microsoft.com의 기술 문서 [Integration Services: 성능 튜닝 기술](https://go.microsoft.com/fwlink/?LinkId=98900)</span><span class="sxs-lookup"><span data-stu-id="9b10f-243">Technical article, [Integration Services: Performance Tuning Techniques](https://go.microsoft.com/fwlink/?LinkId=98900), on technet.microsoft.com</span></span>  
  
-   <span data-ttu-id="9b10f-244">sqlcat.com의 기술 문서 - [동기 변환을 여러 태스크로 분할하여 파이프라인의 처리량 증가](http://sqlcat.com/technicalnotes/archive/2010/08/18/increasing-throughput-of-pipelines-by-splitting-synchronous-transformations-into-multiple-tasks.aspx)</span><span class="sxs-lookup"><span data-stu-id="9b10f-244">Technical article, [Increasing Throughput of Pipelines by Splitting Synchronous Transformations into Multiple Tasks](http://sqlcat.com/technicalnotes/archive/2010/08/18/increasing-throughput-of-pipelines-by-splitting-synchronous-transformations-into-multiple-tasks.aspx), on sqlcat.com</span></span>  
  
-   <span data-ttu-id="9b10f-245">msdn.microsoft.com의 기술 문서 - [데이터 로드 성능 가이드](https://go.microsoft.com/fwlink/?LinkId=220816)</span><span class="sxs-lookup"><span data-stu-id="9b10f-245">Technical article, [The Data Loading Performance Guide](https://go.microsoft.com/fwlink/?LinkId=220816), on msdn.microsoft.com.</span></span>  
  
-   <span data-ttu-id="9b10f-246">msdn.microsoft.com의 기술 문서 - [SSIS를 사용하여 30분 이내에 1TB 로드](https://go.microsoft.com/fwlink/?LinkId=220817)</span><span class="sxs-lookup"><span data-stu-id="9b10f-246">Technical article, [We Loaded 1TB in 30 Minutes with SSIS, and So Can You](https://go.microsoft.com/fwlink/?LinkId=220817), on msdn.microsoft.com.</span></span>  
  
-   <span data-ttu-id="9b10f-247">sqlcat.com의 기술 문서 - [SQL Server Integration Services의 상위 10가지 모범 사례](https://go.microsoft.com/fwlink/?LinkId=220818)</span><span class="sxs-lookup"><span data-stu-id="9b10f-247">Technical article, [Top 10 SQL Server Integration Services Best Practices](https://go.microsoft.com/fwlink/?LinkId=220818), on sqlcat.com.</span></span>  
  
-   <span data-ttu-id="9b10f-248">sqlcat.com의 기술 문서 및 예제 - [SSIS용 "Balanced Data Distributor"](https://go.microsoft.com/fwlink/?LinkId=220822)</span><span class="sxs-lookup"><span data-stu-id="9b10f-248">Technical article and sample, [The "Balanced Data Distributor" for SSIS](https://go.microsoft.com/fwlink/?LinkId=220822), on sqlcat.com.</span></span>  
  
-   <span data-ttu-id="9b10f-249">blogs.msdn.com의 블로그 게시물 - [SSIS 패키지 성능 문제 해결](https://go.microsoft.com/fwlink/?LinkId=238156)</span><span class="sxs-lookup"><span data-stu-id="9b10f-249">Blog post, [Troubleshooting SSIS Package Performance Issues](https://go.microsoft.com/fwlink/?LinkId=238156), on blogs.msdn.com</span></span>  
  
 <span data-ttu-id="9b10f-250">**비디오**</span><span class="sxs-lookup"><span data-stu-id="9b10f-250">**Videos**</span></span>  
  
-   <span data-ttu-id="9b10f-251">비디오 시리즈, [엔터프라이즈에서 SSIS 패키지의 성능 설계 및 조정(SQL 비디오 시리즈)](https://go.microsoft.com/fwlink/?LinkId=400878)</span><span class="sxs-lookup"><span data-stu-id="9b10f-251">Video series, [Designing and Tuning for Performance your SSIS packages in the Enterprise (SQL Video Series)](https://go.microsoft.com/fwlink/?LinkId=400878)</span></span>  
  
-   <span data-ttu-id="9b10f-252">technet.microsoft.com의 비디오, [엔터프라이즈에서 SSIS 패키지 데이터 흐름 튜닝(SQL Server 비디오)](https://technet.microsoft.com/sqlserver/ff686901.aspx)</span><span class="sxs-lookup"><span data-stu-id="9b10f-252">Video, [Tuning Your SSIS Package Data Flow in the Enterprise (SQL Server Video)](https://technet.microsoft.com/sqlserver/ff686901.aspx), on technet.microsoft.com</span></span>  
  
-   <span data-ttu-id="9b10f-253">technet.microsoft.com의 비디오, [SSIS 데이터 흐름 버퍼 이해(SQL Server 비디오)](https://technet.microsoft.com/sqlserver/ff686905.aspx)</span><span class="sxs-lookup"><span data-stu-id="9b10f-253">Video, [Understanding SSIS Data Flow Buffers (SQL Server Video)](https://technet.microsoft.com/sqlserver/ff686905.aspx), on technet.microsoft.com</span></span>  
  
-   <span data-ttu-id="9b10f-254">channel9.msdn.com의 비디오 - [Microsoft SQL Server Integration Services 성능 디자인 패턴](https://go.microsoft.com/fwlink/?LinkID=233698&clcid=0x409)</span><span class="sxs-lookup"><span data-stu-id="9b10f-254">Video, [Microsoft SQL Server Integration Services Performance Design Patterns](https://go.microsoft.com/fwlink/?LinkID=233698&clcid=0x409), on channel9.msdn.com.</span></span>  
  
-   <span data-ttu-id="9b10f-255">sqlcat.com의 프레젠테이션 - [Microsoft IT의 SQL Server 2008 SSIS 데이터 흐름 엔진 향상 기능 활용 방법](https://go.microsoft.com/fwlink/?LinkId=217660)</span><span class="sxs-lookup"><span data-stu-id="9b10f-255">Presentation, [How Microsoft IT Leverages SQL Server 2008 SSIS Dataflow Engine Enhancements](https://go.microsoft.com/fwlink/?LinkId=217660), on sqlcat.com.</span></span>  
  
-   <span data-ttu-id="9b10f-256">technet.microsoft.com의 비디오 - [Balanced Data Distributor](https://go.microsoft.com/fwlink/?LinkID=226278&clcid=0x409)</span><span class="sxs-lookup"><span data-stu-id="9b10f-256">Video, [Balanced Data Distributor](https://go.microsoft.com/fwlink/?LinkID=226278&clcid=0x409), on technet.microsoft.com.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9b10f-257">참고 항목</span><span class="sxs-lookup"><span data-stu-id="9b10f-257">See Also</span></span>  
 <span data-ttu-id="9b10f-258">[패키지 배포 문제 해결 도구](../troubleshooting/troubleshooting-tools-for-package-development.md) </span><span class="sxs-lookup"><span data-stu-id="9b10f-258">[Troubleshooting Tools for Package Development](../troubleshooting/troubleshooting-tools-for-package-development.md) </span></span>  
 [<span data-ttu-id="9b10f-259">패키지 실행 문제 해결 도구</span><span class="sxs-lookup"><span data-stu-id="9b10f-259">Troubleshooting Tools for Package Execution</span></span>](../troubleshooting/troubleshooting-tools-for-package-execution.md)  
  
  
