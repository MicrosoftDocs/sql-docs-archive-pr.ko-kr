---
title: 중첩 테이블 (Analysis Services 데이터 마이닝) | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: analysis-services
ms.topic: conceptual
helpviewer_keywords:
- data mining [Analysis Services], nested tables
- tables [Analysis Services], nested
- nested tables
ms.assetid: cb192aa2-597e-4d4f-ac34-3556d037fed4
author: minewiskan
ms.author: owend
ms.openlocfilehash: 78b1022751ae6d381b86512f45f7232bebe7fcd0
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87728963"
---
# <a name="nested-tables-analysis-services---data-mining"></a><span data-ttu-id="fdb02-102">중첩 테이블(Analysis Services - 데이터 마이닝)</span><span class="sxs-lookup"><span data-stu-id="fdb02-102">Nested Tables (Analysis Services - Data Mining)</span></span>
  <span data-ttu-id="fdb02-103">에서 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 데이터는 사례 테이블에 포함 된 일련의 사례로 데이터 마이닝 알고리즘에 공급 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-103">In [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)], data must be fed to a data mining algorithm as a series of cases that are contained within a case table.</span></span> <span data-ttu-id="fdb02-104">그러나 한 개의 데이터 행으로 설명할 수 없는 사례도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-104">However, not all cases can be described by a single row of data.</span></span> <span data-ttu-id="fdb02-105">예를 들어 한 사례가 두 테이블, 즉 고객 정보가 포함된 한 테이블과 고객 구매 내용이 포함된 다른 테이블에서 파생될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-105">For example, a case might be derived from two tables: one table that contains customer information, and another table that contains customer purchases.</span></span> <span data-ttu-id="fdb02-106">고객 정보 테이블의 단일 고객이 고객 구매 테이블에서 여러 항목을 가질 수 있으므로 단일 행을 사용하여 데이터를 설명하기 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-106">A single customer in the customer information table might have multiple items in the customer purchases table, which makes it difficult to describe the data by using a single row.</span></span> [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] <span data-ttu-id="fdb02-107">에서는 *중첩 테이블*을 사용하여 이러한 사례를 처리하는 고유한 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-107">provides a unique method for handling these cases, by using *nested tables*.</span></span> <span data-ttu-id="fdb02-108">다음 그림에서는 중첩 테이블의 개념을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-108">The concept of a nested table is demonstrated in the following illustration.</span></span>  
  
 <span data-ttu-id="fdb02-109">![중첩 테이블을 사용하여 결합한 두 테이블](../media/nested-tables.gif "중첩 테이블을 사용하여 결합한 두 테이블")</span><span class="sxs-lookup"><span data-stu-id="fdb02-109">![Two tables combined by using a nested table](../media/nested-tables.gif "Two tables combined by using a nested table")</span></span>  
  
 <span data-ttu-id="fdb02-110">이 다이어그램에서 부모 테이블인 첫 번째 테이블에는 고객 정보가 들어 있으며 각 고객의 고유 식별자와 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-110">In this diagram, the first table, which is the parent table, contains information about customers, and associates a unique identifier for each customer.</span></span> <span data-ttu-id="fdb02-111">자식 테이블인 두 번째 테이블에는 각 고객의 구매 내용이 들어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-111">The second table, the child table, contains the purchases for each customer.</span></span> <span data-ttu-id="fdb02-112">자식 테이블의 구매 내용은 고유 식별자인 **CustomerKey** 열에 의해 부모 테이블에 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-112">The purchases in the child table are related to the parent table by the unique identifier, the **CustomerKey** column.</span></span> <span data-ttu-id="fdb02-113">다이어그램의 세 번째 테이블은 결합된 두 테이블을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-113">The third table in the diagram shows the two tables combined.</span></span>  
  
 <span data-ttu-id="fdb02-114">중첩 테이블은 **TABLE**데이터 형식을 갖는 특수 열로 사례 테이블에 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-114">A nested table is represented in the case table as a special column that has a data type of **TABLE**.</span></span> <span data-ttu-id="fdb02-115">이러한 종류의 열은 특정 사례 행에 대해 부모 테이블과 관련된 자식 테이블에서 선택한 행을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-115">For any particular case row, this kind of column contains selected rows from the child table that pertain to the parent table.</span></span>  
  
 <span data-ttu-id="fdb02-116">중첩된 테이블의 데이터는 예측이나 입력 또는 둘 다에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-116">The data in a nested table can be used for prediction or for input, or for both.</span></span> <span data-ttu-id="fdb02-117">예를 들어 모델에 두 개의 중첩된 테이블 열이 있을 수 있으며 이 중 하나의 중첩된 테이블 열에는 고객이 구매한 제품의 목록이 포함되어 있고 다른 하나의 중첩된 테이블 열에는 설문 조사를 통해 얻은 고객의 취미와 관심사에 대한 정보가 포함되어 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-117">For example, you might have two nested table columns in a model: one nested table column might contain a list of the products that a customer has purchased, while the other nested table column contains information about the customer's hobbies and interests, possibly obtained from a survey.</span></span> <span data-ttu-id="fdb02-118">이 시나리오에서 고객의 취미와 관심사를 입력으로 사용하여 구매 행동을 분석하고 구매할 가능성이 높은 제품을 예측할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-118">In this scenario, you could use the customer's hobbies and interests as an input for analyzing purchasing behavior, and predicting likely purchases.</span></span>  
  
## <a name="joining-case-tables-and-nested-tables"></a><span data-ttu-id="fdb02-119">사례 테이블 및 중첩 테이블 조인</span><span class="sxs-lookup"><span data-stu-id="fdb02-119">Joining Case Tables and Nested Tables</span></span>  
 <span data-ttu-id="fdb02-120">중첩 테이블을 만들려면 한 테이블의 항목이 다른 테이블에 연결될 수 있도록 두 원본 테이블이 정의된 관계를 포함해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-120">In order to create a nested table, the two source tables must contain a defined relationship so that the items in one table can be related to the other table.</span></span> <span data-ttu-id="fdb02-121">[!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)]에서는 데이터 원본 뷰에서 이러한 관계를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-121">In [!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)], you can define this relationship in the data source view.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="fdb02-122">**CustomerKey** 필드는 데이터 원본 뷰 정의 내에서 사례 테이블과 중첩 테이블을 연결하고 마이닝 구조 내에서 열의 관계를 설정하는 데 사용되는 관계형 키입니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-122">The **CustomerKey** field is the relational key that is used to link the case table and the nested table within the data source view definition, and to establish the relationship of the columns within the mining structure.</span></span> <span data-ttu-id="fdb02-123">그러나 일반적으로 해당 구조에서 만들어진 마이닝 모델에는 이 관계형 키를 사용해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-123">However, typically you should not use this relational key in mining models built on that structure.</span></span> <span data-ttu-id="fdb02-124">관계형 키 열이 테이블 조인을 위한 목적으로만 사용되어 분석에 유용한 정보를 제공하지 않는 경우 마이닝 모델에서 관계형 키 열을 생략하는 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-124">Usually it is best to omit the relational key column from the mining model if it serves only to join the tables and does not provide information that is interesting for analysis.</span></span>  
  
 <span data-ttu-id="fdb02-125">DMX(Data Mining Extensions) 또는 AMO(Analysis Management Objects)를 사용하여 프로그래밍 방식으로 중첩 테이블을 만들거나 [!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)]에서 데이터 마이닝 마법사 및 데이터 마이닝 디자이너를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-125">You can create nested tables programmatically by either using Data Mining Extensions (DMX) or Analysis Management Objects (AMO), or you can use the Data Mining Wizard and Data Mining Designer in [!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)].</span></span>  
  
## <a name="using-nested-table-columns-in-a-mining-model"></a><span data-ttu-id="fdb02-126">마이닝 모델에서 중첩 테이블 열 사용</span><span class="sxs-lookup"><span data-stu-id="fdb02-126">Using Nested Table Columns in a Mining Model</span></span>  
 <span data-ttu-id="fdb02-127">사례 테이블에서 키는 종종 고객 ID, 제품 이름 또는 계열의 날짜와 같이 테이블의 행을 고유하게 식별하는 데이터를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-127">In the case table, the key is often a customer ID, a product name, or date in a series: data that uniquely identifies a row in the table.</span></span> <span data-ttu-id="fdb02-128">.</span><span class="sxs-lookup"><span data-stu-id="fdb02-128">.</span></span> <span data-ttu-id="fdb02-129">그러나 중첩 테이블에서 키는 일반적으로 관계형 키(외래 키)가 아니라 모델링하고 있는 특성을 나타내는 열입니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-129">However, in nested tables, the key is typically not the relational key (or foreign key) but rather the column that represents the attribute that you are modeling.</span></span>  
  
 <span data-ttu-id="fdb02-130">예를 들어 사례 테이블에 주문이 포함되어 있고 중첩 테이블에 주문 항목이 포함되어 있는 경우 사례 테이블에 저장되어 있는 여러 개의 주문에서 중첩 테이블에 저장된 항목 간의 관계를 모델링하고자 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-130">For example, if the case table contains orders, and the nested table contains items in the order, you would be interested in modeling the relationship between items stored in the nested table across multiple orders, which are stored in the case table.</span></span> <span data-ttu-id="fdb02-131">따라서 관계형 키 **OrderID** 에 의해 **Items** 중첩 테이블이 **Orders**사례 테이블에 조인되었더라도 **OrderID** 를 중첩 테이블 키로 사용해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-131">Therefore, although the **Items** nested table is joined to the **Orders** case table by the relational key **OrderID**, you should not use **OrderID** as the nested table key.</span></span> <span data-ttu-id="fdb02-132">대신 **Items** 열을 중첩 테이블 키로 선택해야 합니다. 왜냐하면 이 열에는 모델링하려는 데이터가 포함되어 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-132">Instead, you would select the **Items** column as the nested table key, because that column contains the data that you want to model.</span></span> <span data-ttu-id="fdb02-133">대부분의 경우 사례 테이블과 중첩 테이블 간의 관계가 데이터 원본 뷰 정의에 의해 이미 설정되어 있으므로 마이닝 모델에서 **OrderID** 를 무시해도 괜찮습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-133">In most cases, you can safely ignore **OrderID** in the mining model, because the relationship between the case table and the nested table has already been established by the data source view definition.</span></span>  
  
 <span data-ttu-id="fdb02-134">중첩 테이블 키로 사용할 열을 선택할 때 해당 열의 값은 각 사례에 대해 고유해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-134">When you choose a column to use as the nested table key, you must ensure that the values in that column are unique for each case.</span></span> <span data-ttu-id="fdb02-135">예를 들어 사례 테이블은 고객을 나타내고 중첩 테이블은 고객이 구매한 항목을 나타낼 경우 고객 한 명당 항목이 한 번만 나열되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-135">For example, if the case table represents customers and the nested table represents items purchased by the customer, you must ensure that no item is listed more than one time per customer.</span></span> <span data-ttu-id="fdb02-136">한 고객이 같은 항목을 두 번 이상 구매한 경우 각 제품에 대한 구매 수를 집계하는 열이 포함된 다른 뷰를 만들 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-136">If a customer has purchased the same item more than one time, you might want to create a different view that has a column that aggregates the count of purchases for each unique product.</span></span>  
  
 <span data-ttu-id="fdb02-137">중첩 테이블에서 중복 값을 처리하는 방법은 만들고 있는 마이닝 모델과 해결 중인 비즈니스 문제에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-137">How you decide to handle duplicate values in a nested table depends on the mining model that you are creating and the business problem that you are solving.</span></span> <span data-ttu-id="fdb02-138">일부 시나리오에서는 고객이 특정 제품을 구매한 횟수보다는 한 번 이상의 구매가 있었는지만 확인하고자 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-138">In some scenarios you might not care how many times a customer has purchased a particular product, but want to check for the existence of at least one purchase.</span></span> <span data-ttu-id="fdb02-139">다른 시나리오에서는 구매 수량과 순서가 매우 중요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-139">In other scenarios, the quantity and sequence of purchases might be very important.</span></span>  
  
 <span data-ttu-id="fdb02-140">항목 순서가 중요한 경우 순서를 나타내는 열이 추가로 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-140">If the order of items is important, you might need an additional column that indicates the sequence.</span></span> <span data-ttu-id="fdb02-141">시퀀스 클러스터링 알고리즘을 사용하여 모델을 만드는 경우 항목의 순서를 나타내는 *KEY SEQUENCE* 열을 추가로 선택해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-141">When you use the sequence clustering algorithm to create a model, you must choose an additional *key sequence* column to represent the order of the items.</span></span> <span data-ttu-id="fdb02-142">KEY SEQUENCE 열은 시퀀스 클러스터링 모델에만 사용되는 특별한 종류의 중첩 키로 고유한 숫자 데이터 형식을 필요로 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-142">The key sequence column is a special kind of nested key that is used only in sequence clustering models, and requires a unique numeric data type.</span></span> <span data-ttu-id="fdb02-143">예를 들어 정수와 날짜 모두 KEY SEQUENCE 열로 사용할 수 있지만 모든 시퀀스 값은 고유해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-143">For example, integers and dates can both be used as a key sequence column, but all sequence values must be unique.</span></span> <span data-ttu-id="fdb02-144">KEY SEQUENCE 열 이외에도 시퀀스 클러스터링 모델에는 구매한 제품과 같이 모델링되고 있는 특성을 나타내는 중첩 테이블 키도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-144">In addition to the key sequence column, a sequence clustering model also has a nested table key that represents the attribute that is being modeled, such as the products that have been purchased.</span></span>  
  
### <a name="using-non-key-nested-columns-from-a-nested-table"></a><span data-ttu-id="fdb02-145">중첩 테이블에서 키가 아닌 중첩 열 사용</span><span class="sxs-lookup"><span data-stu-id="fdb02-145">Using Non-Key Nested Columns from a Nested Table</span></span>  
 <span data-ttu-id="fdb02-146">사례 테이블과 중첩 테이블 간의 조인을 정의하고 중첩 테이블 키로 사용할 관심 있는 고유 특성이 포함된 열을 선택한 후에는 중첩 테이블의 다른 열을 포함시켜 모델에 대한 입력으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-146">After you have defined the join between the case table and the nested table, and you have chosen a column that contains interesting and unique attributes to use as the nested table key, you can include other columns from the nested table to use as input to the model.</span></span> <span data-ttu-id="fdb02-147">중첩 테이블의 모든 열은 입력, 예측 및 입력 또는 예측용으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-147">All columns from the nested table can be used for input, prediction and input, or for prediction only.</span></span>  
  
 <span data-ttu-id="fdb02-148">예를 들어 중첩 테이블에 **Product**, **ProductQuantity**및 **ProductPrice**열이 포함되어 있는 경우 **Product** 는 중첩 테이블 키로 선택하고 **ProductQuantity** 는 마이닝 구조에 추가하여 입력으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-148">For example, if the nested table contains the columns **Product**, **ProductQuantity**, and **ProductPrice**, you might choose **Product** as the nested table key, but add **ProductQuantity** to the mining structure to use as input.</span></span>  
  
## <a name="filtering-nested-table-data"></a><span data-ttu-id="fdb02-149">중첩 테이블 데이터 필터링</span><span class="sxs-lookup"><span data-stu-id="fdb02-149">Filtering Nested Table Data</span></span>  
 <span data-ttu-id="fdb02-150">[!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)]에서는 데이터 마이닝 모델 학습 또는 테스트에 사용되는 데이터에 대한 필터를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-150">In [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)], you can create filters on the data that is used to train or test a data mining model.</span></span> <span data-ttu-id="fdb02-151">필터를 사용하여 모델 컴퍼지션에 영향을 주거나 사례 하위 집합에서 모델을 테스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-151">A filer can be used to affect the composition of the model, or to test the model on a subset of cases.</span></span> <span data-ttu-id="fdb02-152">필터를 중첩 테이블에 적용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-152">Filters can also be applied to nested tables.</span></span> <span data-ttu-id="fdb02-153">그러나 중첩 테이블에서 사용할 수 있는 구문에는 제한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-153">However, there are limitations on the syntax that can be used with nested tables.</span></span>  
  
 <span data-ttu-id="fdb02-154">대개 특성의 존재 여부를 테스트할 때 필터를 중첩 테이블에 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-154">Often when you apply a filter to a nested table you are testing for the existence or nonexistence of an attribute.</span></span> <span data-ttu-id="fdb02-155">예를 들어 모델에 사용된 사례를 중첩 테이블에 지정된 값을 갖는 사례로 제한하는 필터를 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-155">For example, you can apply a filter that restricts the cases used in the model to only those cases that have a specified value in the nested table.</span></span> <span data-ttu-id="fdb02-156">또는 모델에 사용된 사례를 특정 항목을 구매하지 않은 고객으로 제한할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-156">Or, you could restrict the cases used in the model to customers who have not purchased a particular item.</span></span>  
  
 <span data-ttu-id="fdb02-157">중첩 테이블에 필터를 만들 때 보다 큼 또는 보다 작음과 같은 연산자를 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-157">When you create filters on a nested table, you can also use operators such as greater than or less than.</span></span> <span data-ttu-id="fdb02-158">예를 들어 모델에 사용된 사례를 대상 제품을 n개 이상 구매한 고객으로 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-158">For example, you could restrict the cases used in the model to customers who had purchased at least n units of the target product.</span></span> <span data-ttu-id="fdb02-159">중첩 테이블 특성 필터링 기능을 사용하면 모델을 보다 유연하게 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fdb02-159">The ability to filter on nested table attributes provides great flexibility for customizing models.</span></span>  
  
 <span data-ttu-id="fdb02-160">모델 필터를 만들고 사용하는 방법은 [마이닝 모델에 대한 필터&#40;Analysis Services - 데이터 마이닝&#41;](mining-models-analysis-services-data-mining.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="fdb02-160">For more information about how to create and use model filters, see [Filters for Mining Models &#40;Analysis Services - Data Mining&#41;](mining-models-analysis-services-data-mining.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="fdb02-161">참고 항목</span><span class="sxs-lookup"><span data-stu-id="fdb02-161">See Also</span></span>  
 <span data-ttu-id="fdb02-162">[데이터 마이닝 알고리즘 &#40;Analysis Services 데이터 마이닝&#41;](data-mining-algorithms-analysis-services-data-mining.md) </span><span class="sxs-lookup"><span data-stu-id="fdb02-162">[Data Mining Algorithms &#40;Analysis Services - Data Mining&#41;](data-mining-algorithms-analysis-services-data-mining.md) </span></span>  
 [<span data-ttu-id="fdb02-163">마이닝 구조&#40;Analysis Services - 데이터 마이닝&#41;</span><span class="sxs-lookup"><span data-stu-id="fdb02-163">Mining Structures &#40;Analysis Services - Data Mining&#41;</span></span>](mining-structures-analysis-services-data-mining.md)  
  
  
