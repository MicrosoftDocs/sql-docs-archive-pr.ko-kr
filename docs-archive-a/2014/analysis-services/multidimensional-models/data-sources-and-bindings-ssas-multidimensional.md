---
title: 데이터 원본 및 바인딩 (SSAS 다차원) | Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: analysis-services
ms.topic: conceptual
helpviewer_keywords:
- data source views [Analysis Services], bindings
- DSO, bindings
- Analysis Services Scripting Language, data sources
- cubes [Analysis Services], bindings
- OLAP mining models [Analysis Services Scripting Language]
- bindings [Analysis Services Scripting Language]
- rebindings [Analysis Services Scripting Language]
- ASSL, bindings
- relational mining models [ASSL]
- data sources [Analysis Services Scripting Language]
- ASSL, data sources
- dimensions [Analysis Services], bindings
- measures [Analysis Services], bindings
- relational data sources [Analysis Services Scripting Language]
- Analysis Services Scripting Language, bindings
- chaptered rowsets
- granularity
- mining models [Analysis Services], data sources
- inline bindings [ASSL]
- out-of-line bindings
- measure groups [Analysis Services], bindings
- partitions [Analysis Services], bindings
ms.assetid: bc028030-dda2-4660-b818-c3160d79fd6d
author: minewiskan
ms.author: owend
ms.openlocfilehash: 260425bcd0e0741ffe5ab71dd0cbad77f2cbe3d3
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87653619"
---
# <a name="data-sources-and-bindings-ssas-multidimensional"></a><span data-ttu-id="81419-102">데이터 원본 및 바인딩(SSAS 다차원)</span><span class="sxs-lookup"><span data-stu-id="81419-102">Data Sources and Bindings (SSAS Multidimensional)</span></span>
  <span data-ttu-id="81419-103">큐브, 차원 및 기타 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 개체는 데이터 원본에 바인딩될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-103">Cubes, dimensions, and other [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] objects can be bound to a data source.</span></span> <span data-ttu-id="81419-104">데이터 원본은 다음 개체 중 하나일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-104">A data source can be one of the following objects:</span></span>  
  
-   <span data-ttu-id="81419-105">관계형 데이터 원본.</span><span class="sxs-lookup"><span data-stu-id="81419-105">A relational data source.</span></span>  
  
-   <span data-ttu-id="81419-106">행 집합(또는 장으로 구성된 행 집합)을 출력하는 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 파이프라인.</span><span class="sxs-lookup"><span data-stu-id="81419-106">An [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] pipeline that outputs a rowset (or chaptered rowsets).</span></span>  
  
 <span data-ttu-id="81419-107">데이터 원본의 표현 방법은 데이터 원본의 형식에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="81419-107">The means of expressing the data source varies by the type of data source.</span></span> <span data-ttu-id="81419-108">예를 들어 관계형 데이터 원본은 연결 문자열로 구분됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-108">For example, a relational data source is distinguished by the connection string.</span></span> <span data-ttu-id="81419-109">데이터 원본에 대한 자세한 내용은 [Data Sources in Multidimensional Models](data-sources-in-multidimensional-models.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="81419-109">For more information about data sources, see [Data Sources in Multidimensional Models](data-sources-in-multidimensional-models.md).</span></span>  
  
 <span data-ttu-id="81419-110">사용되는 데이터 원본에 관계없이 DSC(데이터 원본 뷰)에는 데이터 원본에 대한 메타데이터가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-110">Regardless of the data source used, the data source view (DSV) contains the metadata for the data source.</span></span> <span data-ttu-id="81419-111">따라서 큐브 또는 다른 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 개체에 대한 바인딩은 DSV에 대한 바인딩으로 표현됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-111">Thus, the bindings for a cube or other [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] objects are expressed as bindings to the DSV.</span></span> <span data-ttu-id="81419-112">이러한 바인딩에는 논리적 개체에 대 한 바인딩 (뷰, 계산 열, 데이터 원본에 물리적으로 존재 하지 않는 관계 등)이 포함 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-112">These bindings can include bindings to logical objects-objects such as views, calculated columns, and relationships that do not physically exist in the data source.</span></span> [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] <span data-ttu-id="81419-113">에서는 식을 DSV로 캡슐화하는 계산 열을 추가한 다음 해당 OLAP 측정값을 DSV의 이 열에 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-113">adds a calculated column that encapsulates the expression to the DSV, and then binds the corresponding OLAP measure to that column in the DSV.</span></span> <span data-ttu-id="81419-114">DSV에 대한 자세한 내용은 [Data Source Views in Multidimensional Models](data-source-views-in-multidimensional-models.md)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="81419-114">For more information about DSVs, see [Data Source Views in Multidimensional Models](data-source-views-in-multidimensional-models.md).</span></span>  
  
 <span data-ttu-id="81419-115">각 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 개체는 자체적인 방식으로 데이터 원본에 바인딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-115">Each [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] object binds to the data source in its own way.</span></span> <span data-ttu-id="81419-116">또한 이러한 개체에 대한 데이터 바인딩과 데이터 원본 정의는 데이터 바인딩된 개체(예: 차원)의 정의와 인라인으로 제공되거나 별도의 정의 집합으로 아웃오브 라인으로 제공될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-116">In addition, the data bindings for these objects and the definition of the data source can be provided inline with the definition of the databound object (for example, the dimension), or out-of-line as a separate set of definitions.</span></span>  
  
## <a name="analysis-services-data-types"></a><span data-ttu-id="81419-117">Analysis Services 데이터 형식</span><span class="sxs-lookup"><span data-stu-id="81419-117">Analysis Services Data Types</span></span>  
 <span data-ttu-id="81419-118">바인딩에 사용되는 데이터 형식은 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)]에서 지원하는 데이터 형식과 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-118">The data types that are used in bindings must match the data types supported by [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)].</span></span> <span data-ttu-id="81419-119">[!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)]에 정의되어 있는 데이터 형식은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-119">The following data types are defined in [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)]:</span></span>  
  
|<span data-ttu-id="81419-120">Analysis Services 데이터 형식</span><span class="sxs-lookup"><span data-stu-id="81419-120">Analysis Services Data Type</span></span>|<span data-ttu-id="81419-121">Description</span><span class="sxs-lookup"><span data-stu-id="81419-121">Description</span></span>|  
|---------------------------------|-----------------|  
|<span data-ttu-id="81419-122">BigInt</span><span class="sxs-lookup"><span data-stu-id="81419-122">BigInt</span></span>|<span data-ttu-id="81419-123">64비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-123">A 64-bit signed integer.</span></span> <span data-ttu-id="81419-124">이 데이터 형식은 Microsoft [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] 의 Int64 데이터 형식 및 OLE DB의 DBTYPE_I8 데이터 형식에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-124">This data type maps to the Int64 data type inside Microsoft [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] and the DBTYPE_I8 data type inside OLE DB.</span></span>|  
|<span data-ttu-id="81419-125">Bool</span><span class="sxs-lookup"><span data-stu-id="81419-125">Bool</span></span>|<span data-ttu-id="81419-126">부울 값입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-126">A Boolean value.</span></span> <span data-ttu-id="81419-127">이 데이터 형식은 [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] 의 Boolean 데이터 형식 및 OLE DB의 DBTYPE_BOOL 데이터 형식에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-127">This data type maps to the Boolean data type inside the [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] and the DBTYPE_BOOL data type inside OLE DB.</span></span>|  
|<span data-ttu-id="81419-128">Currency</span><span class="sxs-lookup"><span data-stu-id="81419-128">Currency</span></span>|<span data-ttu-id="81419-129">정확성이 통화 단위의 10/1,000인 -263(또는 -922,337,203,685,477.5808)에서 263-1(또는 +922,337,203,685,477.5807)까지의 통화 값입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-129">A currency value ranging from -263 (or -922,337,203,685,477.5808) to 263-1 (or +922,337,203,685,477.5807) with an accuracy to a ten-thousandth of a currency unit.</span></span> <span data-ttu-id="81419-130">이 데이터 형식은 [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] 의 Decimal 데이터 형식 및 OLE DB의 DBTYPE_CY 데이터 형식에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-130">This data type maps to the Decimal data type inside the [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] and the DBTYPE_CY data type inside OLE DB.</span></span>|  
|<span data-ttu-id="81419-131">Date</span><span class="sxs-lookup"><span data-stu-id="81419-131">Date</span></span>|<span data-ttu-id="81419-132">배정밀도 부동 소수점 숫자로 저장되는 날짜 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-132">Date data, stored as a double-precision floating-point number.</span></span> <span data-ttu-id="81419-133">정수 부분은 1899년 12월 30일 이후의 날짜 수이고, 소수 부분은 하루를 분수로 표시한 수입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-133">The whole portion is the number of days since December 30, 1899, while the fractional portion is a fraction of a day.</span></span> <span data-ttu-id="81419-134">이 데이터 형식은 [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] 의 DateTime 데이터 형식 및 OLE DB의 DBTYPE_DATE 데이터 형식에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-134">This data type maps to the DateTime data type inside the [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] and the DBTYPE_DATE data type inside OLE DB.</span></span>|  
|<span data-ttu-id="81419-135">Double</span><span class="sxs-lookup"><span data-stu-id="81419-135">Double</span></span>|<span data-ttu-id="81419-136">-1.79E+308부터 1.79E+308 사이의 배정밀도 부동 소수점 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-136">A double-precision floating-point number within the range of -1.79E +308 through 1.79E +308.</span></span> <span data-ttu-id="81419-137">이 데이터 형식은 [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] 의 Double 데이터 형식 및 OLE DB의 DBTYPE_R8 데이터 형식에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-137">This data type maps to the Double data type inside the [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] and the DBTYPE_R8 data type inside OLE DB.</span></span>|  
|<span data-ttu-id="81419-138">정수</span><span class="sxs-lookup"><span data-stu-id="81419-138">Integer</span></span>|<span data-ttu-id="81419-139">32비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-139">A 32-bit signed integer.</span></span> <span data-ttu-id="81419-140">이 데이터 형식은 [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] 의 Int32 데이터 형식 및 OLE DB의 DBTYPE_I4 데이터 형식에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-140">This data type maps to the Int32 data type inside the [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] and the DBTYPE_I4 data type inside OLE DB.</span></span>|  
|<span data-ttu-id="81419-141">Single</span><span class="sxs-lookup"><span data-stu-id="81419-141">Single</span></span>|<span data-ttu-id="81419-142">-3.40E+38부터 3.40E+38 사이의 단정밀도 부동 소수점 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-142">A single-precision floating-point number within the range of -3.40E +38 through 3.40E +38.</span></span> <span data-ttu-id="81419-143">이 데이터 형식은 [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] 의 Single 데이터 형식 및 OLE DB의 DBTYPE_R4 데이터 형식에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-143">This data type maps to the Single data type inside [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] and the DBTYPE_R4 data type inside OLE DB.</span></span>|  
|<span data-ttu-id="81419-144">SmallInt</span><span class="sxs-lookup"><span data-stu-id="81419-144">SmallInt</span></span>|<span data-ttu-id="81419-145">16비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-145">A 16-bit signed integer.</span></span> <span data-ttu-id="81419-146">이 데이터 형식은 [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] 의 Int16 데이터 형식 및 OLE DB의 DBTYPE_I2 데이터 형식에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-146">This data type maps to the Int16 data type inside the [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] and the DBTYPE_I2 data type inside OLE DB.</span></span>|  
|<span data-ttu-id="81419-147">TinyInt</span><span class="sxs-lookup"><span data-stu-id="81419-147">TinyInt</span></span>|<span data-ttu-id="81419-148">8비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-148">An 8-bit signed integer.</span></span> <span data-ttu-id="81419-149">이 데이터 형식은 [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] 의 SByte 데이터 형식 및 OLE DB의 DBTYPE_I1 데이터 형식에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-149">This data type maps to the SByte data type inside the [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] and the DBTYPE_I1 data type inside OLE DB.</span></span><br /><br /> <span data-ttu-id="81419-150">참고: 데이터 원본에서 데이터 형식이 tinyint인 필드가 포함되어 있고, AutoIncrement 속성이 True로 설정되어 있는 경우 이러한 필드는 데이터 원본 뷰에서 정수로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-150">Note: If a data source contains fields that are of the tinyint datatype and the AutoIncrement property is set to True, then they will be converted to integers in the data source view.</span></span>|  
|<span data-ttu-id="81419-151">UnsignedBigInt</span><span class="sxs-lookup"><span data-stu-id="81419-151">UnsignedBigInt</span></span>|<span data-ttu-id="81419-152">64비트 부호 없는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-152">A 64-bit unsigned integer.</span></span> <span data-ttu-id="81419-153">이 데이터 형식은 [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] 의 UInt64 데이터 형식 및 OLE DB의 DBTYPE_UI8 데이터 형식에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-153">This data type maps to the UInt64 data type inside [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] and the DBTYPE_UI8 data type inside OLE DB.</span></span>|  
|<span data-ttu-id="81419-154">UnsignedInt</span><span class="sxs-lookup"><span data-stu-id="81419-154">UnsignedInt</span></span>|<span data-ttu-id="81419-155">32비트 부호 없는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-155">A 32-bit unsigned integer.</span></span> <span data-ttu-id="81419-156">이 데이터 형식은 [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] 의 UInt32 데이터 형식 및 OLE DB의 DBTYPE_UI4 데이터 형식에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-156">This data type maps to the UInt32 data type inside the [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] and the DBTYPE_UI4 data type inside OLE DB.</span></span>|  
|<span data-ttu-id="81419-157">UnsignedSmallInt</span><span class="sxs-lookup"><span data-stu-id="81419-157">UnsignedSmallInt</span></span>|<span data-ttu-id="81419-158">16비트 부호 없는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-158">A 16-bit unsigned integer.</span></span> <span data-ttu-id="81419-159">이 데이터 형식은 [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] 의 UInt16 데이터 형식 및 OLE DB의 DBTYPE_UI2 데이터 형식에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-159">This data type maps to the UInt16 data type inside the [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] and the DBTYPE_UI2 data type inside OLE DB.</span></span>|  
|<span data-ttu-id="81419-160">WChar</span><span class="sxs-lookup"><span data-stu-id="81419-160">WChar</span></span>|<span data-ttu-id="81419-161">유니코드 문자의 Null로 끝나는 스트림입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-161">A null-terminated stream of Unicode characters.</span></span> <span data-ttu-id="81419-162">이 데이터 형식은 [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] 의 String 데이터 형식 및 OLE DB의 DBTYPE_WSTR 데이터 형식에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-162">This data type maps to the String data type inside the [!INCLUDE[dnprdnshort](../../includes/dnprdnshort-md.md)] and the DBTYPE_WSTR data type inside OLE DB.</span></span>|  
  
 <span data-ttu-id="81419-163">데이터 원본으로부터 받은 모든 데이터는 대개 처리 중에 바인딩에 지정된 [!INCLUDE[ssAS](../../includes/ssas-md.md)] 형식으로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-163">All data that is received from the data source is converted to the [!INCLUDE[ssAS](../../includes/ssas-md.md)] type specified in the binding (usually during processing).</span></span> <span data-ttu-id="81419-164">String을 Int로 변환할 때와 같이 변환을 수행할 수 없는 경우 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-164">An error is raised if the conversion cannot be performed (for example, String to Int).</span></span> [!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)] <span data-ttu-id="81419-165">에서는 일반적으로 바인딩의 데이터 형식을 데이터 원본의 유형에 가장 일치하는 형식으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-165">usually sets the data type in the binding to the one that best matches the source type in the data source.</span></span> <span data-ttu-id="81419-166">예를 들어 SQL 유형의 Date, DateTime, SmallDateTime, DateTime2, DateTimeOffset은 [!INCLUDE[ssAS](../../includes/ssas-md.md)] Date에 매핑되고 SQL 유형의 Time은 String에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-166">For example, the SQL types Date, DateTime, SmallDateTime, DateTime2, DateTimeOffset are mapped to [!INCLUDE[ssAS](../../includes/ssas-md.md)] Date, and the SQL type Time is mapped to String.</span></span>  
  
## <a name="bindings-for-dimensions"></a><span data-ttu-id="81419-167">차원에 대한 바인딩</span><span class="sxs-lookup"><span data-stu-id="81419-167">Bindings for Dimensions</span></span>  
 <span data-ttu-id="81419-168">차원의 각 특성은 DSV의 열에 바인딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-168">Each attribute of a dimension is bound to a column in a DSV.</span></span> <span data-ttu-id="81419-169">차원의 모든 특성은 하나의 데이터 원본에서 가져와야 합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-169">All the attributes of a dimension must come from a single data source.</span></span> <span data-ttu-id="81419-170">그러나 특성은 다른 테이블의 열에 바인딩될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-170">However, the attributes can be bound to columns in different tables.</span></span> <span data-ttu-id="81419-171">테이블 간의 관계는 DSV에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-171">The relationships between the tables are defined in the DSV.</span></span> <span data-ttu-id="81419-172">동일한 테이블에 두 개 이상의 관계 집합이 존재 하는 경우 DSV에 명명 된 쿼리를 도입 하 여 ' 별칭 ' 테이블 역할을 수행 해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-172">In the case where more than one set of relationships exists to the same table, it might be necessary to introduce a named query in the DSV to act as an 'alias' table.</span></span> <span data-ttu-id="81419-173">DSV에서 식과 필터는 명명된 계산 및 명명된 쿼리를 사용하여 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-173">Expressions and filters are defined in the DSV by using named calculations and named queries.</span></span>  
  
## <a name="bindings-for-measuregroups-measures-and-partitions"></a><span data-ttu-id="81419-174">MeasureGroups, Measures 및 Partitions에 대한 바인딩</span><span class="sxs-lookup"><span data-stu-id="81419-174">Bindings for MeasureGroups, Measures, and Partitions</span></span>  
 <span data-ttu-id="81419-175">각 측정값 그룹에는 다음과 같은 기본 바인딩이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-175">Each measure group has the following default bindings:</span></span>  
  
-   <span data-ttu-id="81419-176">측정값 그룹은 DSV의 테이블에 바인딩됩니다(예: `MeasureGroup.Source`).</span><span class="sxs-lookup"><span data-stu-id="81419-176">The measure group is bound to a table in a DSV (for example, `MeasureGroup.Source`).</span></span>  
  
-   <span data-ttu-id="81419-177">각 측정값은 이 테이블의 열에 바인딩됩니다(예: `Measure.ValueColumn.Source`).</span><span class="sxs-lookup"><span data-stu-id="81419-177">Each measure is bound to a column in that table (for example, `Measure.ValueColumn.Source`).</span></span>  
  
-   <span data-ttu-id="81419-178">각 측정값 그룹 차원에는 측정값 그룹의 세분성을 정의하는 *세분성 특성* 집합이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-178">Each measure group dimension has a set of *granularity attributes* that define the granularity of the measure group.</span></span> <span data-ttu-id="81419-179">이러한 각 특성은 특성 키를 포함하는 팩트 테이블의 열에 바인딩되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-179">Each of these attributes must be bound to the column or columns in the fact table that contain the attribute key.</span></span> <span data-ttu-id="81419-180">세분성 특성에 대한 자세한 내용은 이 항목의 뒷부분에 있는 MeasureGroup 세분성 특성을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="81419-180">(For more information about granularity attributes, see MeasureGroup Granularity Attributes later in this topic.)</span></span>  
  
 <span data-ttu-id="81419-181">이러한 기본 바인딩은 파티션별로 선택적으로 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-181">These default bindings can be selectively overridden per partition.</span></span> <span data-ttu-id="81419-182">각 파티션은 다른 데이터 원본, 테이블이나 쿼리 이름, 또는 필터 식을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-182">Each partition can specify a different data source, table or query name, or filter expression.</span></span> <span data-ttu-id="81419-183">가장 일반적인 분할 전략은 동일한 데이터 원본을 사용하여 파티션별로 테이블을 재정의하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-183">The most common partitioning strategy is to override the table per partition, by using the same data source.</span></span> <span data-ttu-id="81419-184">대안으로는 파티션별로 다른 필터를 적용하거나 데이터 원본을 바꾸는 것이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-184">Alternatives include applying a different filter per partition or changing the data source.</span></span>  
  
 <span data-ttu-id="81419-185">기본 데이터 원본은 DSV에 정의되어 관계의 세부 정보를 포함한 스키마 정보를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-185">The default data source must be defined in the DSV, thereby providing the schema information, including the details of relationships.</span></span> <span data-ttu-id="81419-186">파티션 수준에서 정의되는 추가 테이블 또는 쿼리는 DSV에 나열되지 않아도 되지만 측정값 그룹에 대해 정의된 기본 테이블과 같은 스키마를 갖거나 최소한 측정값 또는 세분성 특성에 사용된 모든 열을 포함해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-186">Any additional tables or queries specified at the partition level do not need to be listed in the DSV, but they must have the same schema as the default table defined for the measure group, or at least they must contain all the columns used by the measures or granularity attributes.</span></span> <span data-ttu-id="81419-187">측정값 및 세분성 특성별로 세분화된 바인딩은 파티션 수준에서 재정의할 수 없으며 측정값 그룹에 대해 정의된 것과 동일한 열에 있는 것으로 가정됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-187">The detailed bindings per measure and granularity attribute cannot be overridden at the partition level, and they are assumed to be to the same columns as defined for the measure group.</span></span> <span data-ttu-id="81419-188">따라서 파티션에서 실제로 다른 스키마를 가진 데이터 원본을 사용하는 경우 파티션에 대해 정의된 `TableDefinition` 쿼리의 결과는 측정값 그룹에 의해 사용된 스키마와 동일한 스키마여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-188">Therefore, if the partition uses a data source that does in fact have a different schema, the `TableDefinition` query defined for the partition must result in the same schema as the schema used by the measure group.</span></span>  
  
### <a name="measuregroup-granularity-attributes"></a><span data-ttu-id="81419-189">MeasureGroup 세분성 특성</span><span class="sxs-lookup"><span data-stu-id="81419-189">MeasureGroup Granularity Attributes</span></span>  
 <span data-ttu-id="81419-190">측정값 그룹의 세분성이 데이터베이스에 알려진 세분성에 일치하고 팩트 테이블에서 차원 테이블로 직접적인 관계가 있는 경우 세분성 특성은 적절한 외래 키 열 또는 팩트 테이블의 열에만 바인딩되면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-190">When the granularity of a measure group matches the granularity known in the database, and there is a direct relationship from the fact table to the dimension table, the granularity attribute only needs to be bound to the appropriate foreign key column or columns on the fact table.</span></span> <span data-ttu-id="81419-191">예를 들어 다음 팩트 테이블 및 차원 테이블을 살펴보십시오.</span><span class="sxs-lookup"><span data-stu-id="81419-191">For example, consider the following fact and dimension tables:</span></span>  
  
 `Sales(RequestedDate, OrderedProductID, ReplacementProductID, Qty)`  
  
 `Product(ProductID, ProductName,Category)`  
  
 ``  
  
 `Relation: Sales.OrderedProductID -> Product.ProductID`  
  
 `Relation: Sales.ReplacementProductID -> Product.ProductID`  
  
 ``  
  
 <span data-ttu-id="81419-192">주문된 제품별로 분석해 보면 Sales 차원 역할의 Ordered Product의 경우 Product 세분성 특성은 Sales.OrderedProductID에 바인딩될 것입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-192">If you analyze by the ordered product, for the Ordered Product on Sales dimension role, the Product granularity attribute would be bound to Sales.OrderedProductID.</span></span>  
  
 <span data-ttu-id="81419-193">한편 `GranularityAttributes`가 팩트 테이블의 열로 존재하지 않는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-193">However, there may be times when the `GranularityAttributes` might not exist as columns on the fact table.</span></span> <span data-ttu-id="81419-194">예를 들어 `GranularityAttributes`는 다음과 같은 경우에는 열로 존재하지 않을 것입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-194">For example, the `GranularityAttributes` might not exist as columns in the following circumstances:</span></span>  
  
-   <span data-ttu-id="81419-195">OLAP 세분성이 원본의 세분성보다 성긴 경우.</span><span class="sxs-lookup"><span data-stu-id="81419-195">The OLAP granularity is coarser than the granularity in the source.</span></span>  
  
-   <span data-ttu-id="81419-196">중간 테이블이 팩트 테이블과 차원 테이블 사이에 개입하는 경우.</span><span class="sxs-lookup"><span data-stu-id="81419-196">An intermediate table interposes between the fact table and the dimension table.</span></span>  
  
-   <span data-ttu-id="81419-197">차원 키가 차원 테이블의 기본 키와 다른 경우.</span><span class="sxs-lookup"><span data-stu-id="81419-197">The dimension key is not the same as the primary key in the dimension table.</span></span>  
  
 <span data-ttu-id="81419-198">이러한 경우에는 모두 GranularityAttributes가 팩트 테이블에 존재하도록 DSV가 정의되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-198">In all such cases, the DSV must be defined so that the GranularityAttributes exist on the fact table.</span></span> <span data-ttu-id="81419-199">예를 들어 명명된 쿼리 또는 계산 열을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-199">For example, a named query or calculated column can be introduced.</span></span>  
  
 <span data-ttu-id="81419-200">예를 들어 위와 같은 테이블에서 세분성이 Category별이라면 Sales의 뷰는 다음과 같이 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-200">For example, in the same example tables as above, if the granularity were by Category, then a view of the Sales could be introduced:</span></span>  
  
 `SalesWithCategory(RequestedDate, OrderedProductID, ReplacementProductID, Qty, OrderedProductCategory)`  
  
 `SELECT Sales.*, Product.Category AS OrderedProductCategory`  
  
 `FROM Sales INNER JOIN Product`  
  
 `ON Sales.OrderedProductID = Product.ProductID`  
  
 ``  
  
 <span data-ttu-id="81419-201">이 경우 GranularityAttribute Category는 SalesWithCategory.OrderedProductCategory에 바인딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-201">In this case, the GranularityAttribute Category is bound to SalesWithCategory.OrderedProductCategory.</span></span>  
  
### <a name="migrating-from-decision-support-objects"></a><span data-ttu-id="81419-202">의사 결정 지원 개체에서 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="81419-202">Migrating from Decision Support Objects</span></span>  
 <span data-ttu-id="81419-203">DSO(의사 결정 지원 개체) 8.0을 사용하면 `PartitionMeasures`를 다시 바인딩할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-203">Decision Support Objects (DSO) 8.0 allows `PartitionMeasures` to be rebound.</span></span> <span data-ttu-id="81419-204">따라서 이러한 경우 마이그레이션 전략은 적절한 쿼리를 작성하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-204">Therefore, the migration strategy in these cases is to construct the appropriate query.</span></span>  
  
 <span data-ttu-id="81419-205">마찬가지로 DSO 8.0에서 허용하긴 하지만 파티션 내에서 차원 특성은 다시 바인딩할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-205">Similarly, it is not possible to rebind the dimension attributes within a partition, although DSO 8.0 allows this rebinding also.</span></span> <span data-ttu-id="81419-206">이러한 경우 마이그레이션 전략은 DSV에서 필요한 명명된 쿼리를 정의하여 차원에 사용된 테이블 및 열과 동일한 테이블 및 열이 파티션에 대한 DSV에 있도록 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-206">The migration strategy in these cases is to define the necessary named queries in the DSV so that the same tables and columns exist in the DSV for the partition as the tables and columns that are used for the dimension.</span></span> <span data-ttu-id="81419-207">이와 같은 경우에는 From/Join/Filter 절이 관련 테이블의 구조화된 집합이 아닌 하나의 명명된 쿼리에 매핑되는 간단한 마이그레이션을 채택해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-207">These cases may require the adoption of the simple migration, in which the From/Join/Filter clause is mapped to a single named query rather than to a structured set of related tables.</span></span> <span data-ttu-id="81419-208">DSO 8.0은 파티션이 동일한 데이터 원본을 사용하는 경우에도 PartitionDimensions의 재바인딩을 허용하므로 마이그레이션 시 동일한 데이터 원본에 대해 여러 DSV가 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-208">As DSO 8.0 allows PartitionDimensions to be rebound even when the partition is using the same data source, migration may also require multiple DSVs for the same data source.</span></span>  
  
 <span data-ttu-id="81419-209">DSO 8.0에서 해당 바인딩은 최적화된 스키마가 사용되는지 여부에 따라 차원 테이블의 기본 키 또는 팩트 테이블의 외래 키 중 하나에 바인딩되어 두 가지 방법으로 표현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-209">In DSO 8.0, the corresponding bindings can be expressed in two different ways, depending on whether optimized schemas are employed, by binding to either the primary key on the dimension table or the foreign key on the fact table.</span></span> <span data-ttu-id="81419-210">ASSL에서는 이 두 가지 다른 형식이 구분되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-210">In ASSL, the two different forms are not distinguished.</span></span>  
  
 <span data-ttu-id="81419-211">차원 테이블을 포함하지 않는 데이터 원본을 사용하는 파티션에 대해서도 동일한 바인딩 접근 방식이 적용됩니다. 바인딩이 차원 테이블의 기본 키 열이 아니라 팩트 테이블의 외래 키 열에 대해 수행되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-211">The same approach to bindings applies even for a partition using a data source that does not contain the dimension tables, because the binding is made to the foreign key column in the fact table, not to the primary key column in the dimension table.</span></span>  
  
## <a name="bindings-for-mining-models"></a><span data-ttu-id="81419-212">마이닝 모델에 대한 바인딩</span><span class="sxs-lookup"><span data-stu-id="81419-212">Bindings for Mining Models</span></span>  
 <span data-ttu-id="81419-213">마이닝 모델은 관계형 또는 OLAP입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-213">A mining model is either relational or OLAP.</span></span> <span data-ttu-id="81419-214">관계형 마이닝 모델에 대한 데이터 바인딩은 OLAP 마이닝 모델에 대한 바인딩과 상당히 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="81419-214">The data bindings for a relational mining model are considerably different than the bindings for an OLAP mining model.</span></span>  
  
### <a name="bindings-for-a-relational-mining-model"></a><span data-ttu-id="81419-215">관계형 마이닝 모델에 대한 바인딩</span><span class="sxs-lookup"><span data-stu-id="81419-215">Bindings for a Relational Mining Model</span></span>  
 <span data-ttu-id="81419-216">관계형 마이닝 모델은 DSV에 정의된 관계를 기반으로 어느 열이 어느 데이터 원본에 바인딩되는지에 대한 모호함을 해결합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-216">A relational mining model relies on the relationships defined in the DSV to resolve any ambiguity regarding which columns are bound to which data sources.</span></span> <span data-ttu-id="81419-217">관계형 마이닝 모델에서 데이터 바인딩은 다음과 같은 규칙을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="81419-217">In a relational mining model, the data bindings follow these rules:</span></span>  
  
-   <span data-ttu-id="81419-218">각 비중첩 테이블 열은 사례 테이블 또는 사례 테이블과 관련된 테이블의 열에 바인딩됩니다(다 대 일 또는 일 대 일 관계에 따름).</span><span class="sxs-lookup"><span data-stu-id="81419-218">Each non-nested table column is bound to a column either on the case table or a table related to the case table (following a many-to-one or one-to-one relationship).</span></span> <span data-ttu-id="81419-219">DSV는 테이블 간의 관계를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-219">The DSV defines the relationships between the tables.</span></span>  
  
-   <span data-ttu-id="81419-220">각 중첩 테이블 열은 원본 테이블에 바인딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-220">Each nested-table column is bound to a source table.</span></span> <span data-ttu-id="81419-221">그러면 중첩 테이블 열이 소유한 열은 원본 테이블 또는 이 원본 테이블과 관련된 테이블의 열에 바인딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-221">The columns owned by the nested-table column are then bound to columns on that source table or a table related to the source table.</span></span> <span data-ttu-id="81419-222">이 경우에도 바인딩은 다 대 일 또는 일 대 일 관계를 따릅니다. 마이닝 모델 바인딩은 중첩 테이블에 조인 경로를 제공하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-222">(Again, the binding follows a many-to-one or one-to-one relationship.) The mining model bindings do not provide the join path to the nested table.</span></span> <span data-ttu-id="81419-223">대신 이 정보는 DSV에 정의된 관계가 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-223">Instead, the relationships defined in the DSV provide this information.</span></span>  
  
### <a name="bindings-for-an-olap-mining-model"></a><span data-ttu-id="81419-224">OLAP 마이닝 모델에 대한 바인딩</span><span class="sxs-lookup"><span data-stu-id="81419-224">Bindings for an OLAP Mining Model</span></span>  
 <span data-ttu-id="81419-225">OLAP 마이닝 모델에는 DSV에 해당하는 요소가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-225">OLAP mining models do not have the equivalent of a DSV.</span></span> <span data-ttu-id="81419-226">따라서 데이터 바인딩은 열과 데이터 원본 사이에 모호함이 없도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-226">Therefore, the data bindings must provide any disambiguation between columns and data sources.</span></span> <span data-ttu-id="81419-227">예를 들어 마이닝 모델은 Sales 큐브를 기반으로 하고 열은 Qty, Amount 및 Product Name을 기반으로 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-227">For example, a mining model can be based on the Sales cube, and columns can be based on Qty, Amount, and Product Name.</span></span> <span data-ttu-id="81419-228">또는 마이닝 모델은 Product를 기반으로 하고 열은 Product Name, Product Color 및 Sales Qty가 있는 중첩 테이블을 기반으로 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-228">Alternatively, a mining model can be based on Product, and columns can be based on Product Name, Product Color, and a nested table with Sales Qty.</span></span>  
  
 <span data-ttu-id="81419-229">OLAP 마이닝 모델에서 데이터 바인딩은 다음과 같은 규칙을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="81419-229">In an OLAP mining model, the data bindings follow these rules:</span></span>  
  
-   <span data-ttu-id="81419-230">각 비중첩 테이블 열은 큐브의 측정값, 해당 큐브의 차원의 특성(차원 역할의 경우 모호함을 없애기 위해 `CubeDimension` 지정), 또는 차원의 특성에 바인딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-230">Each non-nested table column is bound to a measure on a cube, to an attribute on a dimension of that cube (specifying the `CubeDimension` to disambiguate in the case of dimension roles), or to an attribute on a dimension.</span></span>  
  
-   <span data-ttu-id="81419-231">각 중첩 테이블 열은 `CubeDimension`에 바인딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-231">Each nested table column is bound to a `CubeDimension`.</span></span> <span data-ttu-id="81419-232">즉 차원에서 관련된 큐브로, 또는 드물지만 중첩 테이블의 경우 큐브에서 차원 중 하나로 이동하는 방법을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-232">That is, it defines how to navigate from a dimension to a related cube or (in the less common case of nested tables) from a cube to one of its dimensions.</span></span>  
  
## <a name="out-of-line-bindings"></a><span data-ttu-id="81419-233">아웃오브 라인 바인딩</span><span class="sxs-lookup"><span data-stu-id="81419-233">Out-of-Line Bindings</span></span>  
 <span data-ttu-id="81419-234">아웃오브 라인 바인딩을 사용하여 명령을 실행하는 동안 일시적으로 기존 데이터 바인딩을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-234">Out-of-Line bindings enable you to temporarily change the existing data bindings for the duration of a command.</span></span> <span data-ttu-id="81419-235">아웃오브 라인 바인딩은 명령에 포함되며 지속되지 않는 바인딩을 지칭합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-235">Out-of-line bindings refer to bindings that are included in a command and are not persisted.</span></span> <span data-ttu-id="81419-236">아웃오브 라인 바인딩은 이러한 특정 명령이 실행되는 동안에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-236">Out-of-line bindings apply only while that particular command executes.</span></span> <span data-ttu-id="81419-237">반면 인라인 바인딩은 ASSL 개체 정의에 포함되며 서버 메타데이터 내에서 개체 정의와 함께 지속됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-237">In contrast, inline bindings are contained in the ASSL object definition, and persist with the object definition within server metadata.</span></span>  
  
 <span data-ttu-id="81419-238">ASSL에서는 `Process` 명령, 또는 일괄 처리에 포함되지 않은 경우 `Batch` 명령에서 아웃오브 라인 바인딩 지정이 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-238">ASSL allows out-of-line bindings to be specified on either a `Process` command, if it is not in a batch, or on a `Batch` command.</span></span> <span data-ttu-id="81419-239">아웃오브 라인 바인딩이 `Batch` 명령에 지정되는 경우 `Batch` 명령에 지정되는 모든 바인딩은 일괄 처리의 모든 `Process` 명령이 실행되는 새 바인딩 컨텍스트를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-239">If out-of-line bindings are specified on the `Batch` command, all bindings specified in the `Batch` command create a new binding context in which all `Process` commands of the batch run.</span></span> <span data-ttu-id="81419-240">이 새 바인딩 컨텍스트에는 `Process` 명령으로 인해 간접적으로 처리되는 개체가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-240">This new binding context includes objects that are indirectly processed because of the `Process` command.</span></span>  
  
 <span data-ttu-id="81419-241">명령에 아웃오브 라인 바인딩이 지정되면 이러한 바인딩은 지정된 개체에 대한 지속형 DDL에 포함된 인라인 바인딩을 다시 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-241">When out-of-line bindings are specified on a command, they override the inline bindings contained in the persisted DDL for the specified objects.</span></span> <span data-ttu-id="81419-242">이렇게 처리되는 개체에는 `Process` 명령에서 직접 명명된 개체 또는, 처리의 일부로 자동으로 처리 작업이 시작되는 기타 개체가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-242">These processed objects may include the object directly named in the `Process` command, or they may include other objects whose processing is automatically initiated as a part of the processing.</span></span>  
  
 <span data-ttu-id="81419-243">아웃오브 라인 바인딩은 옵션인 `Bindings` 컬렉션 개체를 처리 명령으로 포함하여 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-243">Out-of-line bindings are specified by including the optional `Bindings` collection object with the processing command.</span></span> <span data-ttu-id="81419-244">옵션인 `Bindings` 컬렉션에는 다음 요소가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-244">The optional `Bindings` collection contains the following elements.</span></span>  
  
|<span data-ttu-id="81419-245">속성</span><span class="sxs-lookup"><span data-stu-id="81419-245">Property</span></span>|<span data-ttu-id="81419-246">카디널리티</span><span class="sxs-lookup"><span data-stu-id="81419-246">Cardinality</span></span>|<span data-ttu-id="81419-247">Type</span><span class="sxs-lookup"><span data-stu-id="81419-247">Type</span></span>|<span data-ttu-id="81419-248">Description</span><span class="sxs-lookup"><span data-stu-id="81419-248">Description</span></span>|  
|--------------|-----------------|----------|-----------------|  
|`Binding`|<span data-ttu-id="81419-249">0-n</span><span class="sxs-lookup"><span data-stu-id="81419-249">0-n</span></span>|`Binding`|<span data-ttu-id="81419-250">새 바인딩의 컬렉션을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-250">Provides a collection of new bindings.</span></span>|  
|`DataSource`|<span data-ttu-id="81419-251">0-1</span><span class="sxs-lookup"><span data-stu-id="81419-251">0-1</span></span>|`DataSource`|<span data-ttu-id="81419-252">사용되었을 수 있는 서버의 `DataSource`를 대체합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-252">Replaces `DataSource` from server that would have been used.</span></span>|  
|`DataSourceView`|<span data-ttu-id="81419-253">0-1</span><span class="sxs-lookup"><span data-stu-id="81419-253">0-1</span></span>|`DataSourceView`|<span data-ttu-id="81419-254">사용되었을 수 있는 서버의 `DataSourceView`를</span><span class="sxs-lookup"><span data-stu-id="81419-254">Replaces the `DataSourceView` from the</span></span><br /><br /> <span data-ttu-id="81419-255">대체합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-255">server that would have been used.</span></span>|  
  
 <span data-ttu-id="81419-256">아웃오브 라인 바인딩과 관련된 모든 요소는 선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-256">All elements that relate to out-of-line bindings are optional.</span></span> <span data-ttu-id="81419-257">지정되지 않은 요소에 대해 ASSL은 지속형 개체의 DDL에 포함된 사양을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-257">For any elements not specified, ASSL uses the specification contained in the DDL of the persisted object.</span></span> <span data-ttu-id="81419-258">`DataSource` 명령에서 `DataSourceView` 또는 `Process` 지정은 선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-258">Specification of `DataSource` or `DataSourceView` in the `Process` command is optional.</span></span> <span data-ttu-id="81419-259">`DataSource` 또는 `DataSourceView`가 지정된 경우 이는 인스턴스화되지 않으며 `Process` 명령이 완료된 후 지속되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-259">If `DataSource` or `DataSourceView` are specified, they are not instantiated and do not persist after the `Process` command has completed.</span></span>  
  
### <a name="definition-of-the-out-of-line-binding-type"></a><span data-ttu-id="81419-260">아웃오브 라인 바인딩 유형 정의</span><span class="sxs-lookup"><span data-stu-id="81419-260">Definition of the Out-of-line Binding Type</span></span>  
 <span data-ttu-id="81419-261">아웃오브 라인 `Bindings` 컬렉션 내에서 ASSL은 각 `Binding`당 여러 개체에 대한 바인딩 컬렉션을 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-261">Inside the out-of-line `Bindings` collection, ASSL allows a collection of bindings for multiple objects, each a `Binding`.</span></span> <span data-ttu-id="81419-262">각 `Binding`에는 확장 개체 참조가 있습니다. 확장 개체 참조는 개체 참조와 비슷하지만 보조 개체(예: 차원 특성 및 측정값 그룹 특성)도 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="81419-262">Each `Binding` has an extended object reference, which is similar to the object reference, but it can refer to minor objects as well (for example, dimension attributes and measure group attributes).</span></span> <span data-ttu-id="81419-263">이 개체는 `Object` 태그가 없다는 점을 제외 하면 명령의 요소에 일반적인 플랫 형식을 취합니다 `Process` \<*Object*> \<*/Object*> .</span><span class="sxs-lookup"><span data-stu-id="81419-263">This object takes the flat form typical of the `Object` element in `Process` commands, except that the \<*Object*>\<*/Object*> tags are not present.</span></span>  
  
 <span data-ttu-id="81419-264">바인딩이 지정 되는 각 개체는 폼 ID의 XML 요소로 식별 됩니다 \<*object*> (예: `DimensionID` ).</span><span class="sxs-lookup"><span data-stu-id="81419-264">Each object for which the binding is specified is identified by an XML element of the form \<*object*>ID (for example, `DimensionID`).</span></span> <span data-ttu-id="81419-265">개체를 폼 ID를 사용 하 여 가능한 한 명확 하 게 식별 한 후 \<*object*> 에는 바인딩이 지정 되는 요소를 식별 합니다 .이는 일반적으로 `Source` 입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-265">After you have identified the object as specifically as possible with the form \<*object*>ID, then you identify the element for which the binding is being specified, which is usually `Source`.</span></span> <span data-ttu-id="81419-266">한 가지 일반적인 경우는 `Source`가 `DataItem`의 속성인 경우로, 특성의 열 바인딩이 이에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-266">A common case to note is that in which `Source` is a property on the `DataItem`, which is the case for column bindings in an attribute.</span></span> <span data-ttu-id="81419-267">이 경우에는 `DataItem` 태그를 지정하지 않고 바인딩할 열에 바로 있는 것처럼 `Source` 속성만 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-267">In this case, you do not specify the `DataItem` tag; instead, you simply specify the `Source` property, as if it were directly on the column to be bound.</span></span>  
  
 <span data-ttu-id="81419-268">`KeyColumns`는 `KeyColumns` 컬렉션 내의 순서에 의해 식별됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-268">`KeyColumns` are identified by their ordering inside the `KeyColumns` collection.</span></span> <span data-ttu-id="81419-269">여기에서는 예를 들어 특성의 첫 번째와 세 번째 키 열만 지정할 수는 없습니다. 두 번째 키 열을 건너뛴다는 점을 나타낼 방법이 없기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="81419-269">There it is not possible to specify, for example, only the first and third key columns of an attribute, because there is no way to indicate that the second key column is to be skipped.</span></span> <span data-ttu-id="81419-270">모든 키 열은 차원 특성에 대한 아웃오브 라인 바인딩에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-270">All of the key columns must be present in the out-of-line binding for a dimension attribute.</span></span>  
  
 <span data-ttu-id="81419-271">`Translations`는 ID가 없지만 언어에 의해 의미상으로 식별됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-271">`Translations`, although they have no ID, are semantically identified by their language.</span></span> <span data-ttu-id="81419-272">따라서 `Translations` 내의 `Binding`는 언어 식별자를 포함해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-272">Therefore, the `Translations` inside a `Binding` need to include their language identifier.</span></span>  
  
 <span data-ttu-id="81419-273">`Binding`내에 허용되는, DDL에 직접 존재하지 않는 한 가지 추가 요소는 `ParentColumnID`로, 이 요소는 데이터 마이닝을 위한 중첩 테이블에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="81419-273">One additional element allowed within a `Binding` that does not exist directly in the DDL is `ParentColumnID`, which is used for nested tables for data mining.</span></span> <span data-ttu-id="81419-274">이 경우 바인딩이 제공되는 중첩 테이블에 있는 부모 열을 식별해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="81419-274">In this case, it is necessary to identify the parent column in the nested table for which the binding is being provided.</span></span>  
  
  
