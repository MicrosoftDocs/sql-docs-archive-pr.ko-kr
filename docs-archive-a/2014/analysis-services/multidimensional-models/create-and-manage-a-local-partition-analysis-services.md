---
title: 로컬 파티션 만들기 및 관리 (Analysis Services) | Microsoft Docs
ms.custom: ''
ms.date: 05/24/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: analysis-services
ms.topic: conceptual
helpviewer_keywords:
- local partitions [Analysis Services]
- partitions [Analysis Services], local
- partitions [Analysis Services], creating
ms.assetid: eaa95278-9ce9-47d5-a6b6-1046e7076599
author: minewiskan
ms.author: owend
ms.openlocfilehash: 7251f9e9422a79c214d27d913112a28ff43d56b1
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87639029"
---
# <a name="create-and-manage-a-local-partition-analysis-services"></a><span data-ttu-id="2539b-102">로컬 파티션 만들기 및 관리(Analysis Services)</span><span class="sxs-lookup"><span data-stu-id="2539b-102">Create and Manage a Local Partition (Analysis Services)</span></span>
  <span data-ttu-id="2539b-103">처리 성능 향상을 위해 측정값 그룹에 대한 추가 파티션을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-103">You can create additional partitions for a measure group to improve processing performance.</span></span> <span data-ttu-id="2539b-104">여러 개의 파티션이 있으면 로컬 서버뿐만 아니라 원격 서버의 해당하는 개수의 실제 데이터 파일에 팩트 데이터를 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-104">Having multiple partitions allows you to allocate fact data across a corresponding number of physical data files on local as well as remote servers.</span></span> <span data-ttu-id="2539b-105">Analysis Services에서는 파티션을 독립적으로 병렬 처리할 수 있어 서버에서 작업을 처리할 때 더 세부적으로 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-105">In Analysis Services, partitions can be processed independently and in parallel, giving you more control over processing workloads on the server.</span></span>

 <span data-ttu-id="2539b-106">모델을 디자인할 때 또는 [!INCLUDE[ssBIDevStudio](../../includes/ssbidevstudio-md.md)] 나 XMLA를 사용하여 솔루션을 배포한 후 [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)] 에서 파티션을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-106">Partitions can be created in [!INCLUDE[ssBIDevStudio](../../includes/ssbidevstudio-md.md)] during model design, or after the solution is deployed using [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)] or XMLA.</span></span> <span data-ttu-id="2539b-107">한 가지 방법만 선택하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-107">We recommend that you choose one approach only.</span></span> <span data-ttu-id="2539b-108">도구를 번갈아 사용하면 이후에 [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)] 에서 솔루션을 다시 배포할 때 [!INCLUDE[ssBIDevStudio](../../includes/ssbidevstudio-md.md)]에서 배포된 데이터베이스에 대한 변경 내용이 덮어쓰기될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-108">If you alternate between tools, you might find that changes made to a deployed database in [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)] are overwritten when you subsequently redeploy the solution from [!INCLUDE[ssBIDevStudio](../../includes/ssbidevstudio-md.md)].</span></span>

## <a name="before-you-start"></a><span data-ttu-id="2539b-109">시작하기 전에</span><span class="sxs-lookup"><span data-stu-id="2539b-109">Before you start</span></span>
 <span data-ttu-id="2539b-110">가지고 있는 버전이 비즈니스 인텔리전스 버전인지 엔터프라이즈 버전인지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-110">Check whether you have either the business intelligence edition or enterprise edition.</span></span> <span data-ttu-id="2539b-111">스탠더드 버전에서는 여러 파티션을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-111">Standard edition does not support multiple partitions.</span></span> <span data-ttu-id="2539b-112">버전을 확인 하려면에서 서버 노드를 마우스 오른쪽 단추로 클릭 [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)] 하 고 **보고서**  |  **일반**을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-112">To check the edition, right-click the server node in [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)] and choose **Reports** | **General**.</span></span> <span data-ttu-id="2539b-113">기능 가용성에 대 한 자세한 내용은 [SQL Server 2014 버전에서 지 원하는 기능](../../getting-started/features-supported-by-the-editions-of-sql-server-2014.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2539b-113">For more information about feature availability, see [Features Supported by the Editions of SQL Server 2014](../../getting-started/features-supported-by-the-editions-of-sql-server-2014.md).</span></span>

 <span data-ttu-id="2539b-114">나중에 파티션을 병합하려는 경우 처음부터 해당 파티션이 같은 집계 디자인을 공유해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-114">From the outset, it's important to understand that partitions must share the same aggregation design if you want to merge them later.</span></span> <span data-ttu-id="2539b-115">파티션은 집계 디자인과 스토리지 모드가 동일한 경우에만 병합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-115">Partitions can be merged only if they have identical aggregation designs and storage modes.</span></span>

> [!TIP]
>  <span data-ttu-id="2539b-116">DSV(데이터 원본 뷰)를 탐색하여 분할할 데이터의 범위와 깊이를 파악합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-116">Explore the data in Data Source View (DSV) to understand the range and depth of the data you are partitioning.</span></span> <span data-ttu-id="2539b-117">예를 들어 날짜별로 분할하는 경우 날짜 열을 기준으로 정렬하여 각 파티션의 상한과 하한을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-117">For example, if partitioning by date, you can sort on a date column to determine the upper and lower bounds of each partition.</span></span>

## <a name="choose-an-approach"></a><span data-ttu-id="2539b-118">방법 선택</span><span class="sxs-lookup"><span data-stu-id="2539b-118">Choose an approach</span></span>
 <span data-ttu-id="2539b-119">파티션을 만들 때 가장 중요한 고려 사항은 중복 행이 없도록 데이터를 분할하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-119">The most important consideration when creating partitions is to segment the data so that there are no duplicate rows.</span></span> <span data-ttu-id="2539b-120">데이터를 한 파티션에만 저장하여 행이 두 번 계산되지 않도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-120">Data must be stored in one, and only one, partition to avoid double counting any rows.</span></span> <span data-ttu-id="2539b-121">따라서 각 파티션 간에 명확한 경계를 정의할 수 있도록 날짜별로 분할하는 것이 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-121">As such, it's common to partition by DATE so that you can define clear boundaries between each partition.</span></span>

 <span data-ttu-id="2539b-122">팩트 데이터를 여러 파티션에 배포하는 기술을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-122">You can use either technique to distribute the fact data across multiple partitions.</span></span> <span data-ttu-id="2539b-123">다음 방법을 사용하여 데이터를 분할할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-123">The following techniques can be used to segment the data.</span></span>

|<span data-ttu-id="2539b-124">방법</span><span class="sxs-lookup"><span data-stu-id="2539b-124">Technique</span></span>|<span data-ttu-id="2539b-125">권장 사항</span><span class="sxs-lookup"><span data-stu-id="2539b-125">Recommendations</span></span>|
|---------------|---------------------|
|<span data-ttu-id="2539b-126">SQL 쿼리를 사용하여 팩트 데이터 분할</span><span class="sxs-lookup"><span data-stu-id="2539b-126">Use SQL queries to segment fact data</span></span>|<span data-ttu-id="2539b-127">파티션은 SQL 쿼리를 기반으로 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-127">Partitions can be sourced from SQL queries.</span></span> <span data-ttu-id="2539b-128">처리하는 동안 SQL 쿼리가 데이터를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-128">During processing, the SQL query is to retrieve the data.</span></span> <span data-ttu-id="2539b-129">쿼리의 WHERE 절은 각 파티션의 데이터를 분할하는 필터를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-129">The query's WHERE clause provides the filter that segments the data for each partition.</span></span> <span data-ttu-id="2539b-130">Analysis Services에서 자동으로 쿼리가 생성되지만 데이터가 제대로 분할되도록 사용자가 WHERE 절을 채워야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-130">Analysis Services generates the query for you, but you must fill in the WHERE clause to properly segment the data.</span></span><br /><br /> <span data-ttu-id="2539b-131">이 방법의 주요 이점은 단일 원본 테이블에서 데이터를 분할할 수 있는 편의성입니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-131">The primary advantage of this approach is the ease with which you can partition data from a single source table.</span></span> <span data-ttu-id="2539b-132">모든 원본 데이터를 큰 팩트 테이블에서 가져오는 경우 DSV(데이터 원본 뷰)에 추가 데이터 구조를 만들 필요 없이 불연속 파티션으로 데이터를 필터링하는 쿼리를 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-132">If all of the source data originates from a large fact table, you can build queries that filter that data into discrete partitions, without having to create additional data structures in the Data Source View (DSV).</span></span><br /><br /> <span data-ttu-id="2539b-133">쿼리를 사용하면 파티션과 DSV 간에 바인딩이 끊긴다는 점이 한 가지 단점입니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-133">One disadvantage is that using queries will break the binding between the partition and the DSV.</span></span> <span data-ttu-id="2539b-134">나중에 팩트 테이블에 열을 추가하는 등 Analysis Services 프로젝트에서 DSV를 업데이트하는 경우 새 열을 포함하도록 각 파티션에 대한 쿼리를 수동으로 편집해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-134">If you later update the DSV in the Analysis Services project, such as adding columns to the fact table, you must manually edit the queries for each partition to include the new column.</span></span> <span data-ttu-id="2539b-135">다음에 설명하는 두 번째 방법을 사용할 때는 이러한 단점이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-135">The second approach, discussed next, does not have this disadvantage.</span></span>|
|<span data-ttu-id="2539b-136">DSV의 테이블을 사용하여 팩트 데이터 분할</span><span class="sxs-lookup"><span data-stu-id="2539b-136">Use tables in the DSV to segment fact data</span></span>|<span data-ttu-id="2539b-137">DSV의 뷰, 테이블 및 명명된 쿼리에 파티션을 바인딩할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-137">You can bind a partition to a table, named query, or view in the DSV.</span></span> <span data-ttu-id="2539b-138">파티션의 기반으로 이 세 개는 모두 동일한 기능을 합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-138">As the basis of a partition, all three are functionally equivalent.</span></span> <span data-ttu-id="2539b-139">전체 테이블, 명명된 쿼리 또는 뷰는 모든 데이터를 단일 파티션에 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-139">The entire table, named query, or view provides all of the data to a single partition.</span></span><br /><br /> <span data-ttu-id="2539b-140">테이블, 뷰 또는 명명된 쿼리를 사용하면 DSV에 모든 데이터 선택 논리가 배치되어 시간이 지남에 따라 관리하기가 더 쉬워질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-140">Using a table, view, or named query places all of the data selection logic in the DSV, which can be easier to manage and maintain over time.</span></span> <span data-ttu-id="2539b-141">이 방법의 중요 이점은 테이블 바인딩이 유지된다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-141">An important advantage to this approach is that table bindings are preserved.</span></span> <span data-ttu-id="2539b-142">나중에 원본 테이블을 업데이트하는 경우 해당 테이블을 사용하는 파티션을 수정할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-142">If you update the source table later, you do not have to modify the partitions that use it.</span></span> <span data-ttu-id="2539b-143">두 번째로, 모든 테이블, 명명된 쿼리 및 뷰가 공통 작업 공간에 있어 파티션 쿼리를 개별적으로 열고 편집해야 할 때보다 편리하게 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-143">Secondly, all of the tables, named queries and views exist in a common work space, making updates more convenient than having to open and edit partition queries individually.</span></span>|

## <a name="option-1-filter-a-fact-table-for-multiple-partitions"></a><span data-ttu-id="2539b-144">옵션 1: 여러 파티션의 팩트 테이블 필터링</span><span class="sxs-lookup"><span data-stu-id="2539b-144">Option 1: Filter a Fact Table for Multiple Partitions</span></span>
 <span data-ttu-id="2539b-145">여러 개의 파티션을 만들려면 기본 파티션의 **원본** 속성을 수정하는 작업으로 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-145">To create multiple partitions, you begin by modifying the **Source** property of the default partition.</span></span> <span data-ttu-id="2539b-146">기본적으로 측정값 그룹은 DSV의 단일 테이블에 바인딩된 단일 파티션을 사용하여 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-146">By default, a measure group is created using a single partition that is bound to a single table in the DSV.</span></span> <span data-ttu-id="2539b-147">파티션을 추가하기 전에 먼저 팩트 데이터의 일부만 포함하도록 원래 파티션을 수정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-147">Before you can add more partitions, you must first modify the original partition to contain just a portion of the fact data.</span></span> <span data-ttu-id="2539b-148">그러면 나머지 데이터를 저장하기 위한 추가 파티션을 계속해서 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-148">You can then proceed to create additional partitions for storing the remainder of the data.</span></span>

 <span data-ttu-id="2539b-149">해당 데이터가 파티션 간에 중복되지 않도록 필터를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-149">Construct your filters such that data is not duplicated among the partitions.</span></span> <span data-ttu-id="2539b-150">파티션의 필터는 파티션에서 사용할 팩트 테이블의 데이터를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-150">A partition's filter specifies which data in the fact table is used in the partition.</span></span> <span data-ttu-id="2539b-151">큐브의 모든 파티션에 대한 필터가 팩트 테이블에서 상호 배타적인 데이터 세트를 추출하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-151">It is important that the filters for all partitions in a cube extract mutually exclusive datasets from the fact table.</span></span> <span data-ttu-id="2539b-152">같은 팩트 데이터가 여러 파티션에 나타나는 경우 두 번 계산될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-152">The same fact data might be double-counted if it appears in multiple partitions.</span></span>

1.  <span data-ttu-id="2539b-153">[!INCLUDE[ssBIDevStudio](../../includes/ssbidevstudio-md.md)]의 솔루션 탐색기에서 큐브를 두 번 클릭하여 큐브 디자이너에서 큐브를 연 다음 **파티션** 탭을 클릭합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-153">In [!INCLUDE[ssBIDevStudio](../../includes/ssbidevstudio-md.md)], in Solution Explorer, double-click the cube to open it in Cube Designer, and then click the **Partitions** tab.</span></span>

2.  <span data-ttu-id="2539b-154">파티션을 추가할 측정값 그룹을 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-154">Expand the measure group for which are adding partitions.</span></span> <span data-ttu-id="2539b-155">기본적으로 각 측정값 그룹에는 DSV의 팩트 테이블에 바인딩된 하나의 파티션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-155">By default, each measure group has one partition, bound to a fact table in the DSV.</span></span>

3.  <span data-ttu-id="2539b-156">원본 열에서 찾아보기(.</span><span class="sxs-lookup"><span data-stu-id="2539b-156">In the Source column, click the browse (.</span></span> <span data-ttu-id="2539b-157">.) 단추를 클릭하여 파티션 원본 대화 상자를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-157">.) button to open the Partition Source dialog box.</span></span>

     <span data-ttu-id="2539b-158">![파티션 창의 원본 열](../media/ssas-partitionsource.png "파티션 창의 원본 열")</span><span class="sxs-lookup"><span data-stu-id="2539b-158">![Source column in Partition pane](../media/ssas-partitionsource.png "Source column in Partition pane")</span></span>

4.  <span data-ttu-id="2539b-159">바인딩 유형에서 **쿼리 바인딩**을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-159">In Binding Type, select **Query Binding**.</span></span> <span data-ttu-id="2539b-160">데이터를 선택하는 SQL 쿼리가 자동으로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-160">The SQL query that selects the data appears automatically.</span></span>

5.  <span data-ttu-id="2539b-161">아래쪽의 WHERE 절에서 이 파티션에 대한 데이터를 분할하는 필터를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-161">In the WHERE clause at the bottom, add a filter that segments data for this partition.</span></span>

     <span data-ttu-id="2539b-162">WHERE 절 구문의 예로는 `WHERE OrderDateKey >= '20060101'` 또는 `WHERE OrderDateKey BETWEEN '20051001' AND '20051201'`이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-162">Examples of WHERE clause syntax include `WHERE OrderDateKey >= '20060101'` or `WHERE OrderDateKey BETWEEN '20051001' AND '20051201'`.</span></span> <span data-ttu-id="2539b-163">다른 예제를 보려면 [WHERE&#40;Transact-SQL&#41;](/sql/t-sql/queries/where-transact-sql)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2539b-163">For other examples, see [WHERE &#40;Transact-SQL&#41;](/sql/t-sql/queries/where-transact-sql).</span></span>

     <span data-ttu-id="2539b-164">다음 필터는 각 집합 내에서 함께 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-164">Notice that the following filters are mutually exclusive within each set:</span></span>

    |||
    |-|-|
    |<span data-ttu-id="2539b-165">설정 1:</span><span class="sxs-lookup"><span data-stu-id="2539b-165">Set 1:</span></span>|<span data-ttu-id="2539b-166">"SaleYear" = 2012</span><span class="sxs-lookup"><span data-stu-id="2539b-166">"SaleYear" = 2012</span></span><br /><br /> <span data-ttu-id="2539b-167">"SaleYear" = 2013</span><span class="sxs-lookup"><span data-stu-id="2539b-167">"SaleYear" = 2013</span></span>|
    |<span data-ttu-id="2539b-168">설정 2</span><span class="sxs-lookup"><span data-stu-id="2539b-168">Set 2:</span></span>|<span data-ttu-id="2539b-169">"Continent" = 'NorthAmerica'</span><span class="sxs-lookup"><span data-stu-id="2539b-169">"Continent" = 'NorthAmerica'</span></span><br /><br /> <span data-ttu-id="2539b-170">"Continent" = 'Europe'</span><span class="sxs-lookup"><span data-stu-id="2539b-170">"Continent" = 'Europe'</span></span><br /><br /> <span data-ttu-id="2539b-171">"Continent" = 'SouthAmerica'</span><span class="sxs-lookup"><span data-stu-id="2539b-171">"Continent" = 'SouthAmerica'</span></span>|
    |<span data-ttu-id="2539b-172">설정 3:</span><span class="sxs-lookup"><span data-stu-id="2539b-172">Set 3:</span></span>|<span data-ttu-id="2539b-173">"Country" = 'USA'</span><span class="sxs-lookup"><span data-stu-id="2539b-173">"Country" = 'USA'</span></span><br /><br /> <span data-ttu-id="2539b-174">"Country" = 'Mexico'</span><span class="sxs-lookup"><span data-stu-id="2539b-174">"Country" = 'Mexico'</span></span><br /><br /> <span data-ttu-id="2539b-175">("Country" <> 'USA' AND "Country" <> 'Mexico')</span><span class="sxs-lookup"><span data-stu-id="2539b-175">("Country" <> 'USA' AND "Country" <> 'Mexico')</span></span>|

6.  <span data-ttu-id="2539b-176">**검사** 를 클릭하여 구문 오류를 검사한 다음 **확인**을 클릭합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-176">Click **Check** to check for syntax errors, and then click **OK**.</span></span>

7.  <span data-ttu-id="2539b-177">다음 데이터 조각을 선택할 때마다 WHERE 절을 수정하여 이전 단계를 반복해서 나머지 파티션을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-177">Repeat the previous steps to create the remaining partitions, modifying the WHERE clause each time to select the next data slice.</span></span>

8.  <span data-ttu-id="2539b-178">솔루션을 배포하거나 파티션을 처리하여 데이터를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-178">Deploy the solution or process the partition to load the data.</span></span> <span data-ttu-id="2539b-179">모든 파티션을 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-179">Be sure to process all partitions.</span></span>

9. <span data-ttu-id="2539b-180">큐브를 검색하여 올바른 데이터가 반환되었는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-180">Browse the cube to verify the correct data is returned.</span></span>

 <span data-ttu-id="2539b-181">여러 측정값 그룹을 사용하는 측정값 그룹이 있으면 [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)]에서 추가 파티션을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-181">After you have a measure group that uses multiple measure groups, you can create additional partitions in [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)].</span></span> <span data-ttu-id="2539b-182">측정값 그룹에서 파티션 폴더를 마우스 오른쪽 단추로 클릭하고 **새 파티션** 을 선택하여 마법사를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-182">Under a measure group, right-click the Partitions folder and select **New Partitions** to start the wizard.</span></span>

> [!NOTE]
>  <span data-ttu-id="2539b-183">파티션에서 데이터를 필터링하지 않고 같은 쿼리를 사용하여 DSV에 이름 쿼리를 만든 다음 명명된 쿼리를 기준으로 파티션을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-183">Instead of filtering data in a partition, you can use the same query to create a name query in the DSV, and then base the partition on the named query.</span></span>

## <a name="option-2-use-tables-views-or-named-queries"></a><span data-ttu-id="2539b-184">옵션 2: 테이블, 뷰 또는 명명된 쿼리 사용</span><span class="sxs-lookup"><span data-stu-id="2539b-184">Option 2: Use Tables, Views, or Named Queries</span></span>
 <span data-ttu-id="2539b-185">이미 DSV가 팩트를 개별 테이블(예: 연도 또는 분기별)로 구성하는 경우 각 파티션에 자체 데이터 원본 테이블이 있는 개별 테이블을 기반으로 파티션을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-185">If the DSV already organizes facts into individual tables (for example, by year or quarter), you can create partitions based on an individual table, where each partition has its own data source table.</span></span> <span data-ttu-id="2539b-186">이것은 기본적으로 측정값 그룹이 분할되는 방식이지만 여러 파티션의 경우에는 원래 파티션을 여러 파티션으로 나누고 각각의 새 파티션을 데이터를 제공하는 데이터 원본 테이블에 매핑하십시오.</span><span class="sxs-lookup"><span data-stu-id="2539b-186">This is essentially how measure groups are partitioned by default but in the case of multiple partitions, you break the original partition into multiple partitions, and map each new partition to the data source table providing the data.</span></span>

 <span data-ttu-id="2539b-187">세 개체 모두 DSV에 정의되고 파티션 원본 대화 상자의 테이블 바인딩 옵션을 사용하여 파티션에 바인딩된다는 점에서 뷰와 명명된 쿼리는 테이블과 기능적으로 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-187">Views and named queries are functional equivalent to tables, in that all three objects are defined in the DSV and bound to a partition using the Table Binding option in the Partition Source dialog box.</span></span> <span data-ttu-id="2539b-188">뷰 또는 명명된 쿼리를 만들어 각 파티션에 필요한 데이터 세그먼트를 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-188">You can create a view or named query to generate the data segment needed for each partition.</span></span> <span data-ttu-id="2539b-189">자세한 내용은 [데이터 원본 뷰에서 명명된 쿼리 정의&#40;Analysis Services&#41;](define-named-queries-in-a-data-source-view-analysis-services.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2539b-189">For more information, see [Define Named Queries in a Data Source View &#40;Analysis Services&#41;](define-named-queries-in-a-data-source-view-analysis-services.md).</span></span>

> [!IMPORTANT]
>  <span data-ttu-id="2539b-190">DSV의 파티션에 대해 함께 사용할 수 없는 명명된 쿼리를 만드는 경우 파티션에 대해 결합된 데이터가 큐브에 포함할 측정값 그룹의 모든 데이터를 포함하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-190">When you create mutually exclusive named queries for partitions in a DSV, ensure that the combined data for the partitions includes all data from a measure group that you want to include in the cube.</span></span> <span data-ttu-id="2539b-191">이때 기본 파티션이 측정값 그룹에 대한 전체 테이블을 기반으로 하지 않도록 합니다. 그렇게 하지 않으면 쿼리 기반 파티션이 전체 테이블을 기반으로 하는 쿼리와 중복됩니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-191">Make sure that you do not leave a default partition based on the entire table for the measure group, or else the query based partitions will overlap the query based on the complete table.</span></span>

1.  <span data-ttu-id="2539b-192">파티션 원본으로 사용할 명명된 쿼리를 하나 이상 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-192">Create one or more named queries to use as the partition source.</span></span> <span data-ttu-id="2539b-193">자세한 내용은 [데이터 원본 뷰에서 명명된 쿼리 정의&#40;Analysis Services&#41;](define-named-queries-in-a-data-source-view-analysis-services.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2539b-193">For more information, see [Define Named Queries in a Data Source View &#40;Analysis Services&#41;](define-named-queries-in-a-data-source-view-analysis-services.md).</span></span>

     <span data-ttu-id="2539b-194">명명된 쿼리는 측정값 그룹과 연결된 팩트 테이블을 기반으로 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-194">The named query must be based on the fact table associated with the measure group.</span></span> <span data-ttu-id="2539b-195">예를 들어 FactInternetSales 측정값 그룹을 분할하는 경우 DSV의 명명된 쿼리는 FROM 문에 FactInternetSales 테이블을 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-195">For example, if you are partitioning the FactInternetSales measure group, the named queries in the DSV must specify the FactInternetSales table in the FROM statement.</span></span>

2.  <span data-ttu-id="2539b-196">[!INCLUDE[ssBIDevStudio](../../includes/ssbidevstudio-md.md)]의 솔루션 탐색기에서 큐브를 두 번 클릭하여 큐브 디자이너에서 큐브를 연 다음 **파티션** 탭을 클릭합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-196">In [!INCLUDE[ssBIDevStudio](../../includes/ssbidevstudio-md.md)], in Solution Explorer, double-click the cube to open it in Cube Designer, and then click the **Partitions** tab.</span></span>

3.  <span data-ttu-id="2539b-197">파티션을 추가할 측정값 그룹을 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-197">Expand the measure group for which are adding partitions.</span></span>

4.  <span data-ttu-id="2539b-198">**새 파티션** 을 클릭하여 파티션 마법사를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-198">Click **New Partition** to start the Partition Wizard.</span></span> <span data-ttu-id="2539b-199">측정값 그룹에 바인딩된 팩트 테이블을 사용하여 명명된 쿼리를 만든 경우 이전 단계에서 만든 명명된 쿼리가 각각 표시되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-199">If you created the named queries using the fact table bound to the measure group, you should see each of the named queries you created in the previous step.</span></span>

5.  <span data-ttu-id="2539b-200">원본 정보 지정에서 이전 단계에서 만든 명명된 쿼리 중 하나를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-200">In Specify Source Information, choose one of the named queries you created in a previous step.</span></span> <span data-ttu-id="2539b-201">표시되지 않는 명명된 쿼리가 있으면 DSV로 돌아가서 FROM 문을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-201">If you do not see any named queries, go back to the DSV and check the FROM statement.</span></span>

6.  <span data-ttu-id="2539b-202">**다음** 을 클릭하여 각 후속 페이지에 대한 기본값을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-202">Click **Next** to accept the default values for each subsequent page.</span></span>

7.  <span data-ttu-id="2539b-203">마법사를 완료하는 마지막 페이지에서 파티션을 설명하는 이름을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-203">On the last page, Completing the Wizard, give the partition a descriptive name.</span></span>

8.  <span data-ttu-id="2539b-204">**Finish**를 클릭합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-204">Click **Finish**.</span></span>

9. <span data-ttu-id="2539b-205">다음 데이터 조각을 선택할 때마다 다른 명명된 쿼리를 선택하여 이전 단계를 반복해서 나머지 파티션을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-205">Repeat the previous steps to create the remaining partitions, choosing a different named query each time to select the next data slice.</span></span>

10. <span data-ttu-id="2539b-206">솔루션을 배포하거나 파티션을 처리하여 데이터를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-206">Deploy the solution or process the partition to load the data.</span></span> <span data-ttu-id="2539b-207">모든 파티션을 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-207">Be sure to process all partitions.</span></span>

11. <span data-ttu-id="2539b-208">큐브를 검색하여 올바른 데이터가 반환되었는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-208">Browse the cube to verify the correct data is returned.</span></span>

## <a name="next-step"></a><span data-ttu-id="2539b-209">다음 단계</span><span class="sxs-lookup"><span data-stu-id="2539b-209">Next Step</span></span>
 <span data-ttu-id="2539b-210">파티션에 대해 상호 배타적인 쿼리를 작성할 때는 큐브에 포함시킬 데이터가 결합된 파티션 데이터에 모두 포함되게 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-210">When you create mutually exclusive queries for partitions, ensure that the combined partition data includes all data you want to include in the cube.</span></span>

 <span data-ttu-id="2539b-211">마지막 단계로, 일반적으로 테이블 자체(아직 있는 경우)를 기반으로 하는 기본 파티션을 제거합니다. 제거하지 않으면 쿼리 기반 파티션이 전체 테이블을 기반으로 하는 쿼리와 겹치게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2539b-211">As a final step, you normally want to remove the default partition that was based on the table itself (if it still exists), or else the query based partitions will overlap the query based on the complete table.</span></span>

## <a name="see-also"></a><span data-ttu-id="2539b-212">참고 항목</span><span class="sxs-lookup"><span data-stu-id="2539b-212">See Also</span></span>
 <span data-ttu-id="2539b-213">[파티션 &#40;Analysis Services-다차원 데이터&#41;](../multidimensional-models-olap-logical-cube-objects/partitions-analysis-services-multidimensional-data.md) [원격 파티션](../multidimensional-models-olap-logical-cube-objects/partitions-remote-partitions.md) [Analysis Services &#40;SSAS-다차원&#41;](merge-partitions-in-analysis-services-ssas-multidimensional.md)</span><span class="sxs-lookup"><span data-stu-id="2539b-213">[Partitions &#40;Analysis Services - Multidimensional Data&#41;](../multidimensional-models-olap-logical-cube-objects/partitions-analysis-services-multidimensional-data.md) [Remote Partitions](../multidimensional-models-olap-logical-cube-objects/partitions-remote-partitions.md) [Merge Partitions in Analysis Services &#40;SSAS - Multidimensional&#41;](merge-partitions-in-analysis-services-ssas-multidimensional.md)</span></span>


