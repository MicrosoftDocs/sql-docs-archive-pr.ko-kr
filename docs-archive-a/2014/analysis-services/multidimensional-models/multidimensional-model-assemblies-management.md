---
title: 다차원 모델 어셈블리 관리 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: analysis-services
ms.topic: conceptual
helpviewer_keywords:
- permissions [Analysis Services], assemblies
- calling user-defined functions
- user impersonation [Analysis Services]
- impersonation [Analysis Services]
- Data Mining Extensions [Analysis Services], assemblies
- MDX [Analysis Services], assemblies
- user-defined functions [Analysis Services]
- Analysis Services objects, assemblies
- assemblies [Analysis Services]
- application domains [Analysis Services]
ms.assetid: b2645d10-6d17-444e-9289-f111ec48bbfb
author: minewiskan
ms.author: owend
ms.openlocfilehash: b95a3171b3b194e84f10809f71eb72fefb07172b
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87728875"
---
# <a name="multidimensional-model-assemblies-management"></a><span data-ttu-id="c2a9e-102">다차원 모델 어셈블리 관리</span><span class="sxs-lookup"><span data-stu-id="c2a9e-102">Multidimensional Model Assemblies Management</span></span>
  [!INCLUDE[msCoName](../../includes/msconame-md.md)]<span data-ttu-id="c2a9e-103">는 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] MDX (Multidimensional Expressions) 및 DMX (Data 마이닝 확장) 언어와 함께 사용할 수 있는 다양 한 내장 함수를 제공 하 여 표준 통계 계산에서 계층의 멤버를 트래버스하는 모든 작업을 수행 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-103">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] supplies lots of intrinsic functions for use with the Multidimensional Expressions (MDX) and Data Mining Extensions (DMX) languages, designed to accomplish everything from standard statistical calculations to traversing members in a hierarchy.</span></span> <span data-ttu-id="c2a9e-104">그러나 복잡하고 강력한 다른 제품에서도 그렇듯이 제품의 기능을 더 확장할 필요성은 언제나 있기 마련입니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-104">But, as with any other complex and robust product, there is always the need to extend the functionality of such a product further.</span></span>  
  
 <span data-ttu-id="c2a9e-105">따라서 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 에서는 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 인스턴스 또는 데이터베이스에 어셈블리를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-105">Therefore, [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] lets you add assemblies to an [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] instance or database.</span></span> <span data-ttu-id="c2a9e-106">어셈블리를 사용하면 Microsoft Visual Basic .NET 또는 Microsoft Visual C#과 같은 CLR(공용 언어 런타임) 언어를 사용하여 사용자 정의 외부 함수를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-106">Assemblies let you create external, user-defined functions using any common language runtime (CLR) language, such as Microsoft Visual Basic .NET or Microsoft Visual C#.</span></span> <span data-ttu-id="c2a9e-107">또한 Microsoft Visual Basic 또는 Microsoft Visual C++와 같은 COM(구성 요소 개체 모델) 자동화 언어도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-107">You can also use Component Object Model (COM) Automation languages such as Microsoft Visual Basic or Microsoft Visual C++.</span></span>  
  
> [!IMPORTANT]  
>  <span data-ttu-id="c2a9e-108">COM 어셈블리는 보안 위험을 내포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-108">COM assemblies might pose a security risk.</span></span> <span data-ttu-id="c2a9e-109">이러한 위험 및 기타 고려 사항으로 인해 COM 어셈블리는 [!INCLUDE[ssASversion10](../../includes/ssasversion10-md.md)]에서 더 이상 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-109">Due to this risk and other considerations, COM assemblies were deprecated in [!INCLUDE[ssASversion10](../../includes/ssasversion10-md.md)].</span></span> <span data-ttu-id="c2a9e-110">COM 어셈블리는 후속 릴리스에서 지원되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-110">COM assemblies might not be supported in future releases.</span></span>  
  
 <span data-ttu-id="c2a9e-111">어셈블리를 사용하면 MDX와 DMX의 비즈니스 기능을 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-111">Assemblies let you extend the business functionality of MDX and DMX.</span></span> <span data-ttu-id="c2a9e-112">원하는 기능을 작성하여 DLL(동적 링크 라이브러리)과 같은 라이브러리에 추가한 후 이 라이브러리를 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 인스턴스 또는 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 데이터베이스에 어셈블리로 추가하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-112">You build the functionality that you want into a library, such as a dynamic link library (DLL) and add the library as an assembly to an instance of [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] or to an [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] database.</span></span> <span data-ttu-id="c2a9e-113">그런 다음 MDX 및 DMX 식, 프로시저, 계산, 동작 및 클라이언트 애플리케이션에서 라이브러리의 공용 메서드를 사용자 정의 함수로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-113">The public methods in the library are then exposed as user-defined functions to MDX and DMX expressions, procedures, calculations, actions, and client applications.</span></span>  
  
 <span data-ttu-id="c2a9e-114">새 프로시저와 함수가 포함된 어셈블리는 서버에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-114">An assembly with new procedures and functions can be added to the server.</span></span> <span data-ttu-id="c2a9e-115">어셈블리를 사용하여 서버에서 제공하지 않는 사용자 지정 기능을 향상시키거나 추가할 수 있으며,</span><span class="sxs-lookup"><span data-stu-id="c2a9e-115">You can use assemblies to enhance or add custom functionality that is not provided by the server.</span></span> <span data-ttu-id="c2a9e-116">MDX(Multidimensional Expressions), DMX(Data Mining Extensions) 또는 저장 프로시저에 새 함수를 추가할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-116">By using assemblies, you can add new functions to Multidimensional Expressions (MDX), Data Mining Extensions (DMX), or stored procedures.</span></span> <span data-ttu-id="c2a9e-117">어셈블리는 사용자 지정 애플리케이션이 실행되는 위치에서 로드되며 어셈블리 이진 파일의 복사본은 서버에 데이터베이스 데이터와 함께 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-117">Assemblies are loaded from the location where the custom application is run, and a copy of the assembly binary file is saved along with the database data in the server.</span></span> <span data-ttu-id="c2a9e-118">어셈블리가 제거되면 복사된 어셈블리도 서버에서 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-118">When an assembly is removed, the copied assembly is also removed from the server.</span></span>  
  
 <span data-ttu-id="c2a9e-119">어셈블리는 COM 또는 CLR 유형일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-119">Assemblies can be of two different types: COM and CLR.</span></span> <span data-ttu-id="c2a9e-120">CLR 어셈블리는 C#, Visual Basic .NET, Managed C++ 등의 .NET Framework 프로그래밍 언어로 개발됩니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-120">CLR assemblies are assemblies developed in .NET Framework programming languages such as C#, Visual Basic .NET, managed C++.</span></span> <span data-ttu-id="c2a9e-121">COM 어셈블리는 서버에 등록해야 하는 COM 라이브러리입니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-121">COM assemblies are COM libraries that must be registered in the server</span></span>  
  
 <span data-ttu-id="c2a9e-122">어셈블리는 <xref:Microsoft.AnalysisServices.Server> 또는 <xref:Microsoft.AnalysisServices.Database> 개체에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-122">Assemblies can be added to <xref:Microsoft.AnalysisServices.Server> or <xref:Microsoft.AnalysisServices.Database> objects.</span></span> <span data-ttu-id="c2a9e-123">서버 어셈블리는 서버에 연결된 사용자나 서버에 있는 개체가 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-123">Server assemblies can be called by any user connected to the server or any object in the server.</span></span> <span data-ttu-id="c2a9e-124">데이터베이스 어셈블리는 데이터베이스에 연결된 <xref:Microsoft.AnalysisServices.Database> 개체 또는 사용자만 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-124">Database assemblies can be called only by <xref:Microsoft.AnalysisServices.Database> objects or users connected to the database.</span></span>  
  
 <span data-ttu-id="c2a9e-125">단순 <xref:Microsoft.AnalysisServices.Assembly> 개체는 기본 정보(이름 및 ID), 파일 컬렉션 및 보안 사양으로 구성되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-125">A simple <xref:Microsoft.AnalysisServices.Assembly> object is composed of basic information (Name and Id), file collection, and security specifications.</span></span>  
  
 <span data-ttu-id="c2a9e-126">파일 컬렉션은 디버깅 파일이 어셈블리 파일을 통해 로드된 경우 로드된 어셈블리 파일과 해당 디버깅 파일(.pdb)을 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-126">The file collection refers to the loaded assembly files and their corresponding debugging (.pdb) files, if the debugging files were loaded with the assembly files.</span></span> <span data-ttu-id="c2a9e-127">어셈블리 파일은 애플리케이션이 해당 파일을 정의한 위치에서 로드되면 복사본은 서버에 데이터와 함께 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-127">Assembly files are loaded from the location where the application defined the files to, and a copy is saved in the server along with the data.</span></span> <span data-ttu-id="c2a9e-128">어셈블리 파일의 복사본은 서버가 시작될 때마다 어셈블리를 로드하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-128">The copy of the assembly file is used to load the assembly every time the service is started.</span></span>  
  
 <span data-ttu-id="c2a9e-129">보안 사양에는 어셈블리를 실행하는 데 사용되는 권한 집합과 가장이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-129">Security specifications include the permission set and the impersonation used to run the assembly.</span></span>  
  
## <a name="calling-user-defined-functions"></a><span data-ttu-id="c2a9e-130">사용자 정의 함수 호출</span><span class="sxs-lookup"><span data-stu-id="c2a9e-130">Calling User-Defined Functions</span></span>  
 <span data-ttu-id="c2a9e-131">어셈블리의 사용자 정의 함수를 호출하는 방법은 전부 정규화된 이름을 사용해야 한다는 것을 제외하고는 내장 함수를 호출하는 방법과 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-131">Calling a user-defined function in an assembly is performed just like calling an intrinsic function, except that you must use a fully qualified name.</span></span> <span data-ttu-id="c2a9e-132">예를 들어 다음과 같이 MDX 쿼리에는 MDX에서 필요한 형식을 반환하는 사용자 정의 함수가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-132">For example, a user-defined function that returns a type expected by MDX is included in an MDX query, as shown in the following example:</span></span>  
  
```  
Select MyAssembly.MyClass.MyStoredProcedure(a, b, c) on 0 from Sales  
```  
  
 <span data-ttu-id="c2a9e-133">사용자 정의 함수는 CALL 키워드를 사용하여 호출할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-133">User-defined functions can also be called using the CALL keyword.</span></span> <span data-ttu-id="c2a9e-134">CALL 키워드는 레코드 집합이나 void 값을 반환하는 사용자 정의 함수에 사용해야 합니다. 현재 큐브 또는 데이터 마이닝 모델과 같이 MDX 또는 DMX 문이나 스크립트의 컨텍스트 내에 있는 개체에 사용자 정의 함수가 종속되어 있는 경우에는 CALL 키워드를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-134">You must use the CALL keyword for user-defined functions which return recordsets or void values, and you cannot use the CALL keyword if the user-defined function depends on an object in the context of the MDX or DMX statement or script, such as the current cube or data mining model.</span></span> <span data-ttu-id="c2a9e-135">MDX 또는 DMX 쿼리 외부에서 호출되는 함수는 대개 관리 기능을 수행하기 위해 AMO 개체 모델을 사용할 때 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-135">A common use for a function called outside an MDX or DMX query is to use the AMO object model to perform administrative functions.</span></span> <span data-ttu-id="c2a9e-136">예를 들어 MDX 문에서 `MyVoidProcedure(a, b, c)` 함수를 사용하려면 다음과 같은 구문을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-136">If, for example, you wanted to use the function `MyVoidProcedure(a, b, c)` in an MDX statement, the following syntax would be employed:</span></span>  
  
```  
Call MyAssembly.MyClass.MyVoidProcedure(a, b, c)  
```  
  
 <span data-ttu-id="c2a9e-137">어셈블리를 사용하면 공통 코드를 개발한 후 이를 단일 위치에 저장하여 재사용할 수 있으므로 데이터베이스 개발이 간편해집니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-137">Assemblies simplify database development by enabling common code to be developed once and stored in a single location.</span></span> <span data-ttu-id="c2a9e-138">클라이언트 소프트웨어 개발자는 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 에 대한 함수 라이브러리를 만들어 해당 애플리케이션과 함께 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-138">Client software developers can create libraries of functions for [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] and distribute them with their applications.</span></span>  
  
 <span data-ttu-id="c2a9e-139">어셈블리와 사용자 정의 함수 이름은 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 함수 라이브러리의 함수 이름 또는 다른 어셈블리의 함수 이름과 중복되게 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-139">Assemblies and user-defined functions can duplicate the function names of the [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] function library or of other assemblies.</span></span> <span data-ttu-id="c2a9e-140">해당 정규화된 이름을 사용하여 사용자 정의 함수를 호출하기만 하면 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 에서 올바른 프로시저를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-140">As long as you call the user-defined function by using its fully qualified name, [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] will use the correct procedure.</span></span> <span data-ttu-id="c2a9e-141">보안을 유지하고 다른 클래스 라이브러리에 있는 중복 이름을 호출하는 것을 방지하기 위해 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 에서는 저장 프로시저에 정규화된 이름만 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-141">For security purposes, and to eliminate the chance of calling a duplicate name in a different class library, [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] requires that you use only fully qualified names for stored procedures.</span></span>  
  
 <span data-ttu-id="c2a9e-142">특정 CLR 어셈블리에서 사용자 정의 함수를 호출하려면 다음과 같이 사용자 정의 함수 앞에 어셈블리 이름, 전체 클래스 이름 및 프로시저 이름이 와야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-142">To call a user-defined function from a specific CLR assembly, the user-defined function is preceded by the assembly name, full class name, and procedure name, as demonstrated here:</span></span>  
  
 <span data-ttu-id="c2a9e-143">*AssemblyName*. *Fullclassname* *E*(*인수 1*, *인수 2*, ...)</span><span class="sxs-lookup"><span data-stu-id="c2a9e-143">*AssemblyName*.*FullClassName*.*ProcedureName*(*Argument1*, *Argument2*, ...)</span></span>  
  
 <span data-ttu-id="c2a9e-144">이전 버전의 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)]와의 호환성을 위해 다음과 같은 구문도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-144">For backward compatibility with earlier versions of [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)], the following syntax is also acceptable:</span></span>  
  
 <span data-ttu-id="c2a9e-145">*AssemblyName*!*FullClassName*!*ProcedureName*(*Argument1*, *Argument2*, ...)</span><span class="sxs-lookup"><span data-stu-id="c2a9e-145">*AssemblyName*!*FullClassName*!*ProcedureName*(*Argument1*, *Argument2*, ...)</span></span>  
  
 <span data-ttu-id="c2a9e-146">COM 라이브러리가 다중 인터페이스를 지원하는 경우에는 다음과 같이 인터페이스 ID를 사용하여 프로시저 이름을 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-146">If a COM library supports multiple interfaces, the interface ID can also be used to resolve the procedure name, as demonstrated here:</span></span>  
  
 <span data-ttu-id="c2a9e-147">*AssemblyName*!*InterfaceID*!*ProcedureName*(*Argument1*, *Argument2*, ...)</span><span class="sxs-lookup"><span data-stu-id="c2a9e-147">*AssemblyName*!*InterfaceID*!*ProcedureName*(*Argument1*, *Argument2*, ...)</span></span>  
  
## <a name="security"></a><span data-ttu-id="c2a9e-148">보안</span><span class="sxs-lookup"><span data-stu-id="c2a9e-148">Security</span></span>  
 <span data-ttu-id="c2a9e-149">어셈블리 보안은 코드 액세스 보안 모델인 .NET Framework 보안 모델에 기반을 둡니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-149">Security for assemblies is based on the .NET Framework security model, which is a code-access security model.</span></span> <span data-ttu-id="c2a9e-150">.NET Framework는 런타임에서 완전히 신뢰할 수 있는 코드와 부분적으로 신뢰할 수 있는 코드를 모두 호스팅할 수 있다고 가정하는 코드 액세스 보안 메커니즘을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-150">.NET Framework supports a code-access security mechanism that assumes that the runtime can host both fully trusted and partially trusted code.</span></span> <span data-ttu-id="c2a9e-151">일반적으로 .NET Framework 코드 액세스 보안을 통해 보호되는 리소스는 액세스를 허용하기 전에 먼저 해당 사용 권한을 요구하는 관리 코드에 의해 래핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-151">The resources that are protected by .NET Framework code access security are typically wrapped by managed code which demands the corresponding permission before enabling access to the resource.</span></span> <span data-ttu-id="c2a9e-152">사용 권한 요청은 호출 스택의 어셈블리 수준에 있는 모든 호출자가 해당 리소스 사용 권한을 가지고 있는 경우에만 충족됩니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-152">The demand for the permission is satisfied only if all the callers (at the assembly level) in the call stack have the corresponding resource permission.</span></span>  
  
 <span data-ttu-id="c2a9e-153">어셈블리의 경우 `PermissionSet` 개체에 `Assembly` 속성이 설정된 상태로 실행 권한이 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-153">For assemblies, permission for execution is passed with the `PermissionSet` property on the `Assembly` object.</span></span> <span data-ttu-id="c2a9e-154">관리 코드가 받게 되는 사용 권한은 적용된 보안 정책에 따라 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-154">The permissions that managed code receives are determined by the security policy in effect.</span></span> <span data-ttu-id="c2a9e-155">[!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 를 호스팅하지 않는 환경에는 엔터프라이즈, 컴퓨터 및 사용자라는 3가지 수준의 보안 정책이 이미 적용되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-155">There are already three levels of policy in effect in a non-[!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] hosted environment: enterprise, computer and user.</span></span> <span data-ttu-id="c2a9e-156">코드가 받게 되는 유효한 사용 권한 목록은 이 3가지 수준에서 확보하는 사용 권한의 공통 사항에 따라 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-156">The effective list of permissions that code receives is determined by the intersection of the permissions obtained by these three levels.</span></span>  
  
 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] <span data-ttu-id="c2a9e-157">에서는 CLR을 호스트하면서 호스트 수준 보안 정책을 CLR에 제공합니다. 이 정책은 항상 적용되는 위의 3가지 정책 수준 아래에 있는 추가 정책 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-157">supplies a host-level security policy level to the CLR while hosting it; this policy is an additional policy level below the three policy levels that are always in effect.</span></span> <span data-ttu-id="c2a9e-158">이 정책은 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)]에서 만든 모든 애플리케이션 도메인에 대해 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-158">This policy is set for every application domain that is created by [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)].</span></span>  
  
 <span data-ttu-id="c2a9e-159">[!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 호스트 수준 정책은 시스템 어셈블리에 대한 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 고정 정책과 사용자 어셈블리에 대한 사용자 지정 정책을 조합한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-159">The [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] host-level policy is a combination of [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] fixed policy for system assemblies and user-specified policy for user assemblies.</span></span> <span data-ttu-id="c2a9e-160">[!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 호스트 정책에서 사용자 지정 부분은 어셈블리 소유자가 각 어셈블리에 대한 3가지 권한 집합 중 어떤 것을 지정하는지에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-160">The user-specified piece of the [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] host policy is based on the assembly owner specifying one of three permission buckets for each assembly:</span></span>  
  
|<span data-ttu-id="c2a9e-161">권한 설정</span><span class="sxs-lookup"><span data-stu-id="c2a9e-161">Permission Setting</span></span>|<span data-ttu-id="c2a9e-162">Description</span><span class="sxs-lookup"><span data-stu-id="c2a9e-162">Description</span></span>|  
|------------------------|-----------------|  
|`Safe`|<span data-ttu-id="c2a9e-163">내부 계산 권한을 부여합니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-163">Provides internal computation permission.</span></span> <span data-ttu-id="c2a9e-164">이 권한 집합은 .NET Framework의 보호된 리소스에 대해서는 액세스 권한을 할당하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-164">This permission bucket does not assign permissions to access any of the protected resources in the .NET Framework.</span></span> <span data-ttu-id="c2a9e-165">`PermissionSet` 속성에 아무 것도 지정되지 않은 경우 어셈블리의 기본 권한 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-165">This is the default permission bucket for an assembly if none is specified with the `PermissionSet` property.</span></span>|  
|`ExternalAccess`|<span data-ttu-id="c2a9e-166">`Safe` 설정과 동일한 액세스 권한을 부여하며 외부 시스템 리소스에 액세스할 수 있는 권한을 추가로 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-166">Provides the same access as the `Safe` setting, with the additional ability to access external system resources.</span></span> <span data-ttu-id="c2a9e-167">이 권한 집합은 이 시나리오상에서 유효한 것이며 보안을 보장하지는 않습니다. 그러나 안정성은 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-167">This permission bucket does not offer security guarantees (although it is possible to secure this scenario), but it does give reliability guarantees.</span></span>|  
|`Unsafe`|<span data-ttu-id="c2a9e-168">제한을 두지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-168">Provides no restrictions.</span></span> <span data-ttu-id="c2a9e-169">이 권한 집합으로 실행되는 관리 코드에 대해서는 어떠한 보안이나 안정성도 보장되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-169">No security or reliability guarantees can be made for managed code running under this permission set.</span></span> <span data-ttu-id="c2a9e-170">이 신뢰 수준에서 실행되는 코드에는 관리자가 포함한 사용자 지정 권한을 비롯하여 모든 권한이 부여됩니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-170">Any permission, even a custom permission included by the administrator, is granted to code running at this level of trust.</span></span>|  
  
 <span data-ttu-id="c2a9e-171">[!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)]에서 CLR를 호스팅하는 경우에는 스택 워크(stack-walk) 기반의 권한 확인이 네이티브 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 코드와의 경계에서 중지됩니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-171">When CLR is hosted by [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)], the stack-walk based permission check stops at the boundary with native [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] code.</span></span> <span data-ttu-id="c2a9e-172">[!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 어셈블리의 모든 관리 코드는 항상 위의 3가지 사용 권한 범주 중 하나에 속합니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-172">Any managed code in [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] assemblies always falls into one of the three permission categories listed earlier.</span></span>  
  
 <span data-ttu-id="c2a9e-173">COM 또는 관리되지 않는 어셈블리 루틴은 CLR 보안 모델을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-173">COM (or unmanaged) assembly routines do not support the CLR security model.</span></span>  
  
### <a name="impersonation"></a><span data-ttu-id="c2a9e-174">가장</span><span class="sxs-lookup"><span data-stu-id="c2a9e-174">Impersonation</span></span>  
 <span data-ttu-id="c2a9e-175">관리 코드가 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 외부의 리소스에 액세스할 때마다 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)]는 어셈블리의 `ImpersonationMode` 속성 설정과 관련된 규칙을 따라 적절한 Windows 보안 컨텍스트에서 액세스가 이루어지도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-175">Whenever managed code accesses any resource outside [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)], [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] follows the rules associated with the `ImpersonationMode` property setting of the assembly to make sure that the access occurs in an appropriate Windows security context.</span></span> <span data-ttu-id="c2a9e-176">`Safe` 권한 설정을 사용하는 어셈블리는 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 외부의 리소스에 액세스할 수 없으므로 이러한 규칙은 `ExternalAccess` 및 `Unsafe` 권한 설정을 사용하는 어셈블리에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-176">Because assemblies using the `Safe` permission setting cannot access resources outside [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)], these rules are applicable only for assemblies using the `ExternalAccess` and `Unsafe` permission settings.</span></span>  
  
-   <span data-ttu-id="c2a9e-177">현재의 실행 컨텍스트가 Windows 인증 로그인과 일치하며 원래 호출자의 컨텍스트와 동일한 경우(즉, 중간에 EXECUTE AS가 없는 경우) [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 는 리소스에 액세스하기 전에 먼저 Windows 인증 로그인을 가장합니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-177">If the current execution context corresponds to Windows Authenticated login and is the same as the context of the original caller (that is, there is no EXECUTE AS in the middle), [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] will impersonate the Windows Authenticated login before accessing the resource.</span></span>  
  
-   <span data-ttu-id="c2a9e-178">중간에 EXECUTE AS가 있어서 컨텍스트가 원래 호출자의 컨텍스트와 다르게 변경된 경우에는 외부 리소스에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-178">If there is an intermediate EXECUTE AS that changed the context from that of the original caller), the attempt to access external resource will fail.</span></span>  
  
 <span data-ttu-id="c2a9e-179">`ImpersonationMode` 속성은 `ImpersonateCurrentUser` 또는 `ImpersonateAnonymous`로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-179">The `ImpersonationMode` property can be set to `ImpersonateCurrentUser` or `ImpersonateAnonymous`.</span></span> <span data-ttu-id="c2a9e-180">기본 설정 `ImpersonateCurrentUser`는 현재 사용자의 네트워크 로그인 계정으로 어셈블리를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-180">The default setting, `ImpersonateCurrentUser`, runs an assembly under the current user's network login account.</span></span> <span data-ttu-id="c2a9e-181">설정이 사용 되는 경우 `ImpersonateAnonymous` 실행 컨텍스트는 서버의*Servername* IUSER_ Windows 로그인 사용자 계정에 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-181">If the `ImpersonateAnonymous` setting is used, the execution context is corresponds to the Windows login user account IUSER_*servername* on the server.</span></span> <span data-ttu-id="c2a9e-182">이 계정은 서버에 대해 제한된 권한을 갖는 인터넷 게스트 계정입니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-182">This is the Internet guest account, which has limited privileges on the server.</span></span> <span data-ttu-id="c2a9e-183">이 컨텍스트에서 실행되는 어셈블리는 로컬 서버의 제한된 리소스에만 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-183">An assembly running in this context can only access limited resources on the local server.</span></span>  
  
### <a name="application-domains"></a><span data-ttu-id="c2a9e-184">애플리케이션 도메인</span><span class="sxs-lookup"><span data-stu-id="c2a9e-184">Application Domains</span></span>  
 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] <span data-ttu-id="c2a9e-185">에서는 애플리케이션 도메인을 직접 노출시키지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-185">does not expose application domains directly.</span></span> <span data-ttu-id="c2a9e-186">동일한 애플리케이션 도메인에서 실행되는 어셈블리 집합으로 인해 애플리케이션 도메인은 .NET Framework의 `System.Reflection` 네임스페이스를 사용하거나 다른 방법으로 실행 시 서로를 검색할 수 있으며 런타임에 바인딩된 방식으로 애플리케이션을 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-186">Because of a set of assemblies running in the same application domain, application domains can discover each other at execution time by using the `System.Reflection` namespace in the .NET Framework or in some other way, and can call into them in late-bound manner.</span></span> <span data-ttu-id="c2a9e-187">이러한 호출에 대해서는 [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] 권한 부여 기반의 보안 방식에서 사용되는 권한 확인이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-187">Such calls will be subject to the permission checks used by [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] authorization-based security.</span></span>  
  
 <span data-ttu-id="c2a9e-188">애플리케이션 도메인 경계와 각 도메인에 속하는 어셈블리는 구현에 따라 달라지므로 동일한 애플리케이션 도메인 내에서 어셈블리를 찾는 방법에만 의존해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c2a9e-188">You should not rely on finding assemblies in the same application domain, because the application domain boundary and the assemblies that go into each domain are defined by the implementation.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c2a9e-189">참고 항목</span><span class="sxs-lookup"><span data-stu-id="c2a9e-189">See Also</span></span>  
 <span data-ttu-id="c2a9e-190">[저장 프로시저에 대 한 보안 설정](../multidimensional-models-extending-olap-stored-procedures/setting-security-for-stored-procedures.md) </span><span class="sxs-lookup"><span data-stu-id="c2a9e-190">[Setting Security for Stored Procedures](../multidimensional-models-extending-olap-stored-procedures/setting-security-for-stored-procedures.md) </span></span>  
 [<span data-ttu-id="c2a9e-191">저장 프로시저 정의</span><span class="sxs-lookup"><span data-stu-id="c2a9e-191">Defining Stored Procedures</span></span>](../multidimensional-models-extending-olap-stored-procedures/defining-stored-procedures.md)  
  
  
