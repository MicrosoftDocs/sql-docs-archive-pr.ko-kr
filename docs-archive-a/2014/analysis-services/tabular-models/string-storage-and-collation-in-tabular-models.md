---
title: 테이블 형식 모델의 문자열 저장소 및 데이터 정렬 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: analysis-services
ms.topic: conceptual
ms.assetid: 8516f0ad-32ee-4688-a304-e705143642ca
author: minewiskan
ms.author: owend
ms.openlocfilehash: 3aad4cf16c39897bc0796f4fb161eaf39abdb5fd
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87738818"
---
# <a name="string-storage-and-collation-in-tabular-models"></a><span data-ttu-id="65f6a-102">테이블 형식 모델의 문자열 스토리지 및 데이터 정렬</span><span class="sxs-lookup"><span data-stu-id="65f6a-102">String Storage and Collation in Tabular Models</span></span>
  <span data-ttu-id="65f6a-103">테이블 형식 모델에서 문자열(텍스트 값)은 고도로 압축된 형식으로 저장되며, 이러한 압축으로 인해 전체 또는 부분 문자열을 검색할 때 예기치 않은 결과를 얻게 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-103">Strings (text values) are stored in a highly compressed format in tabular models; because of this compression, you can get unexpected results when you retrieve entire or partial strings.</span></span> <span data-ttu-id="65f6a-104">또한 문자열 로캘 및 데이터 정렬은 가장 가까운 부모 개체에서 계층적으로 상속되므로 문자열 언어가 명시적으로 정의되어 있지 않은 경우 각 문자열이 저장되는 방식과 문자열이 고유한지 아니면 부모 데이터 정렬에 의해 정의된 유사 문자열과 혼합되는지는 부모의 로캘 및 데이터 정렬에 따라 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-104">Also, because string locale and collations are inherited hierarchically from the closest parent object, if the string language is not explicitly defined, the locale and collation of the parent can affect how each string is stored and whether the string is unique or conflated with similar strings as defined by the parent collation.</span></span>  
  
 <span data-ttu-id="65f6a-105">이 항목에서는 문자열 압축 및 저장 메커니즘에 대해 설명하고 테이블 형식 모델에서 데이터 정렬 및 언어가 텍스트 수식 결과에 미치는 영향을 보여 주는 예를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-105">This topic describes the mechanism by which strings are compressed and stored, and provides examples of how collation and language affect the results of text formulas in tabular models.</span></span>  
  
## <a name="storage"></a><span data-ttu-id="65f6a-106">스토리지</span><span class="sxs-lookup"><span data-stu-id="65f6a-106">Storage</span></span>  
 <span data-ttu-id="65f6a-107">테이블 형식 모델에서는 모든 데이터가 메모리 사용을 최적화할 수 있도록 고도로 압축됩니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-107">In tabular models all data is highly compressed to better fit in memory.</span></span> <span data-ttu-id="65f6a-108">따라서 어휘적으로 동일한 것으로 간주될 수 있는 모든 문자열이 한 번만 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-108">As a consequence, all strings that can be considered lexically equivalent are stored only once.</span></span> <span data-ttu-id="65f6a-109">문자열의 첫 번째 인스턴스는 정식 표현으로 사용되며 이후 해당하는 각 문자열은 첫 번째 발생한 인스턴스와 동일한 압축된 값으로 인덱싱됩니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-109">The first instance of the string is used as the canonical representation and thereafter each equivalent string is indexed to the same compressed value as the first occurrence.</span></span>  
  
 <span data-ttu-id="65f6a-110">중요한 점은 어휘적으로 동일한 문자열을 구성하는 요소가 무엇이냐는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-110">The key question is: what constitutes a lexically equivalent string?</span></span> <span data-ttu-id="65f6a-111">동일한 단어로 간주할 수 있는 두 문자열은 어휘적으로 동일한 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-111">Two strings are considered lexically equivalent if they can be considered as the same word.</span></span> <span data-ttu-id="65f6a-112">예를 들어 영어로 **violin** 이라는 단어를 사전에서 검색할 경우 사전의 편집 정책에 따라 **Violin** 또는 **violin**항목을 찾을 수 있지만, 일반적으로 두 단어는 모두 동일한 것으로 간주되며 대/소문자 차이는 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-112">For example, in English when you search for the word **violin** in a dictionary, you might find the entry **Violin** or **violin**, depending on the editorial policy of the dictionary, but generally you consider both words equivalent, and disregard the difference in capitalization.</span></span> <span data-ttu-id="65f6a-113">테이블 형식 모델에서 두 문자열이 어휘적으로 동일한지 여부를 결정하는 요소는 편집 정책이나 사용자 선호도가 아니라 해당 열에 할당된 로캘 및 데이터 정렬 순서입니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-113">In a tabular model, the factor that determines whether two strings are lexically equivalent is not editorial policy or even user preference, but the locale and collation order assigned to the column.</span></span>  
  
 <span data-ttu-id="65f6a-114">따라서 대문자와 소문자를 동일하게 처리할지 다르게 처리할지는 데이터 정렬과 로캘에 따라 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-114">Therefore, the decision of whether uppercase and lowercase letters should be handled as the same or different depends on the collation and locale.</span></span> <span data-ttu-id="65f6a-115">해당 로캘 내의 특정 단어에 대해 특정 열에서 첫 번째로 발생하는 단어가 해당 단어의 정식 표현으로 처리되고 해당 문자열은 압축되지 않은 형식으로 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-115">For any particular word within that locale, the first occurrence of the word that is found within a particular column therefore serves as the canonical representation of that word and that string is stored in uncompressed format.</span></span>  <span data-ttu-id="65f6a-116">다른 모든 문자열은 첫 번째 발생한 단어를 기준으로 테스트되며, 동일성 테스트 조건을 충족하는 문자열은 첫 번째 발생한 단어의 압축된 값에 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-116">All other strings are tested against the first occurrence, and if they match the equivalence test, they are assigned to the compressed value of the first occurrence.</span></span> <span data-ttu-id="65f6a-117">나중에 압축된 값이 검색될 때 이 값은 첫 번째 발생한 문자열의 압축되지 않은 값을 사용하여 표현됩니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-117">Later, when the compressed values are retrieved they are represented using the uncompressed value of the first occurrence of the string.</span></span>  
  
 <span data-ttu-id="65f6a-118">예를 통해 이 과정을 명확하게 이해할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-118">An example will help to clarify how this works.</span></span> <span data-ttu-id="65f6a-119">다음의 "Classification - English" 열은 식물과 나무에 대한 정보를 포함하는 테이블에서 추출한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-119">The following column "Classification - English" was extracted from a table that contains information about plants and trees.</span></span> <span data-ttu-id="65f6a-120">분류 열에서는 각 식물(식물 이름은 여기에 표시되지 않음)에 대한 일반 범주를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-120">For each plant (the names of the plants are not shown here) the classification column shows the general category of plant.</span></span>  
  
|<span data-ttu-id="65f6a-121">Classification - English</span><span class="sxs-lookup"><span data-stu-id="65f6a-121">Classification - English</span></span>|  
|-------------------------------|  
|<span data-ttu-id="65f6a-122">trEE</span><span class="sxs-lookup"><span data-stu-id="65f6a-122">trEE</span></span>|  
|<span data-ttu-id="65f6a-123">PlAnT</span><span class="sxs-lookup"><span data-stu-id="65f6a-123">PlAnT</span></span>|  
|<span data-ttu-id="65f6a-124">trEE</span><span class="sxs-lookup"><span data-stu-id="65f6a-124">TREE</span></span>|  
|<span data-ttu-id="65f6a-125">PlAnT</span><span class="sxs-lookup"><span data-stu-id="65f6a-125">PLANT</span></span>|  
|<span data-ttu-id="65f6a-126">PlAnT</span><span class="sxs-lookup"><span data-stu-id="65f6a-126">Plant</span></span>|  
|<span data-ttu-id="65f6a-127">트리</span><span class="sxs-lookup"><span data-stu-id="65f6a-127">Tree</span></span>|  
|<span data-ttu-id="65f6a-128">PlAnT</span><span class="sxs-lookup"><span data-stu-id="65f6a-128">plant</span></span>|  
|<span data-ttu-id="65f6a-129">trEE</span><span class="sxs-lookup"><span data-stu-id="65f6a-129">tReE</span></span>|  
|<span data-ttu-id="65f6a-130">tree</span><span class="sxs-lookup"><span data-stu-id="65f6a-130">tree</span></span>|  
|<span data-ttu-id="65f6a-131">PlAnT</span><span class="sxs-lookup"><span data-stu-id="65f6a-131">pLaNt</span></span>|  
|<span data-ttu-id="65f6a-132">trEE</span><span class="sxs-lookup"><span data-stu-id="65f6a-132">tREE</span></span>|  
  
 <span data-ttu-id="65f6a-133">대/소문자와 악센트 사용이 일관되지 않은 것은 데이터의 원본이 다양하기 때문일 수 있으며 관계형 데이터베이스에서는 이러한 차이가 있는 그대로 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-133">Perhaps the data came from many different sources, and so the casing and use of accents was inconsistent, and the relational database stored those differences as is.</span></span> <span data-ttu-id="65f6a-134">그러나 이러한 값은 대/소문자만 다를 뿐 대체적으로는 **Plant** 또는 **Tree**중 하나에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-134">But in general the values are either **Plant** or **Tree**, just with different casing.</span></span>  
  
 <span data-ttu-id="65f6a-135">이러한 값이 영어 (미국)에 대 한 기본 데이터 정렬과 정렬 순서를 사용 하는 테이블 형식 모델로 로드 되는 경우 대/소문자는 중요 하지 않으므로 전체 열에 대해 두 개의 값만 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-135">When these values are loaded into a tabular model that uses the default collation and sorting order for English (United States), case is not important, so only two values would be stored for the entire column:</span></span>  
  
|<span data-ttu-id="65f6a-136">Classification - English</span><span class="sxs-lookup"><span data-stu-id="65f6a-136">Classification - English</span></span>|  
|-------------------------------|  
|<span data-ttu-id="65f6a-137">trEE</span><span class="sxs-lookup"><span data-stu-id="65f6a-137">trEE</span></span>|  
|<span data-ttu-id="65f6a-138">PlAnT</span><span class="sxs-lookup"><span data-stu-id="65f6a-138">PlAnT</span></span>|  
  
 <span data-ttu-id="65f6a-139">모델에서 **등급-영어**열을 사용 하는 경우 공장 분류를 표시 하는 경우에는 대/소문자를 다양 하 게 사용 하 고 첫 번째 인스턴스만 사용 하 여 원래 값이 아니라는 것을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-139">If you use the column, **Classification - English**, in your model, wherever you display plant classification you will see not the original values, with their various uses of upper and lower case, but only the first instance.</span></span> <span data-ttu-id="65f6a-140">이 데이터 정렬 및 로캘에서는 **tree** 의 대문자 및 소문자 변형이 모두 동일한 것으로 간주되기 때문입니다. 따라서 한 문자열만 보관되며 시스템에서 발견한 첫 번째 문자열 인스턴스가 저장 인스턴스가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-140">The reason is that all the uppercase and lowercase variants of **tree** are considered equivalent in this collation and locale; therefore, only one string was preserved and the first instance of that string that is encountered by the system is the one that is saved.</span></span>  
  
> [!WARNING]  
>  <span data-ttu-id="65f6a-141">사용자가 판단하는 올바른 형태에 따라 첫 번째로 저장할 문자열을 정의할 수도 있지만 이 과정은 매우 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-141">You might decide that you want to define which string will be the first to store, according to what you consider correct, but this could be very hard to so.</span></span> <span data-ttu-id="65f6a-142">모든 값이 동일한 것으로 간주될 경우 엔진에서 처음 처리될 행을 미리 결정할 수 있는 간단한 방법은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-142">There is no simple way to determine in advance which row should be processed first by the engine, given that all values are considered to be the same.</span></span> <span data-ttu-id="65f6a-143">대신 표준 값을 설정해야 하는 경우에는 모델을 로드하기 전에 모든 문자열을 정리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-143">Instead, if you need to set the standard value, you should cleanse all your strings before loading the model.</span></span>  
  
## <a name="locale-and-collation-order"></a><span data-ttu-id="65f6a-144">로캘 및 데이터 정렬 순서</span><span class="sxs-lookup"><span data-stu-id="65f6a-144">Locale and Collation Order</span></span>  
 <span data-ttu-id="65f6a-145">문자열(텍스트 값)을 비교할 때 동일성을 정의하는 요소는 일반적으로 해당 문자열이 해석되는 방식에 대한 culture 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-145">When comparing strings (text values), what defines equivalence is normally the cultural aspect of how such strings are interpreted.</span></span> <span data-ttu-id="65f6a-146">일부 culture에서는 문자의 악센트나 대/소문자에 따라 문자열의 의미가 완전히 달라질 수 있으므로, 특정 언어 또는 영역에서 동일성을 결정할 때는 대개 이러한 차이가 고려됩니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-146">In some cultures an accent or the capitalization of a character can completely change the meaning of the string; therefore, typically such differences are considered when determining equivalency for any particular language or region.</span></span>  
  
 <span data-ttu-id="65f6a-147">일반적으로 사용 중인 컴퓨터는 이미 사용자에게 필요한 culture 및 언어 동작에 맞게 구성되어 있으므로 텍스트 값 정렬 및 비교와 같은 문자열 작업이 예상대로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-147">Usually, when you use your computer it is already configured to match your own cultural expectations and linguistic behavior, and string operations such as sorting and comparing text values behaves as you would expect.</span></span> <span data-ttu-id="65f6a-148">언어별 동작을 제어하는 설정은 Windows의 **국가 및 언어** 설정을 통해 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-148">The settings that control language-specific behavior are defined through the **Locale and Regional** settings in Windows.</span></span> <span data-ttu-id="65f6a-149">애플리케이션에서는 이 설정을 읽고 그에 따라 동작을 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-149">Applications read those settings and change their behavior accordingly.</span></span> <span data-ttu-id="65f6a-150">일부 애플리케이션에는 사용자가 애플리케이션의 culture 동작이나 문자열 비교 방식을 변경할 수 있는 기능이 있는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-150">In some cases, an application might have a feature that allows you to change the cultural behavior of the application or the way in which strings are compared.</span></span>  
  
 <span data-ttu-id="65f6a-151">테이블 형식 model 데이터베이스를 만들 때 데이터베이스는 기본적으로 이러한 culture 및 언어 설정을 언어 식별자 및 데이터 정렬의 형태로 상속합니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-151">When you are creating a tabular model database, by default the database inherits these cultural and linguistic settings in the form of a language identifier and collation.</span></span>  
  
-   <span data-ttu-id="65f6a-152">언어 식별자는 문자열에 사용할 문자 집합을 해당 culture에 따라 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-152">The language identifier defines the character set you want to use for your strings according to your culture.</span></span>  
  
-   <span data-ttu-id="65f6a-153">데이터 정렬은 문자 순서와 문자 일치성을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-153">The collation defines the ordering of the characters and their equivalence.</span></span>  
  
 <span data-ttu-id="65f6a-154">언어 식별자는 언어를 식별할 뿐 아니라 해당 언어가 사용되는 국가 또는 지역도 식별한다는 점에 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-154">It is important to note that a language identifier not only identifies a language but, also the country or region where the language is used.</span></span> <span data-ttu-id="65f6a-155">각 언어 식별자에는 기본 데이터 정렬도 지정되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-155">Each language identifier also has a default collation specification.</span></span> <span data-ttu-id="65f6a-156">언어 식별자에 자세한 내용은 [Microsoft에서 할당한 로캘 ID](https://msdn.microsoft.com/goglobal/bb964664.aspx)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="65f6a-156">For more information about language identifiers, see [Locale IDs Assigned by Microsoft](https://msdn.microsoft.com/goglobal/bb964664.aspx).</span></span> <span data-ttu-id="65f6a-157">수동으로 값을 삽입할 때는 10진수 LCID 열에서 올바른 ID를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-157">You can use the LCID Dec column to get the correct ID when manually inserting a value.</span></span> <span data-ttu-id="65f6a-158">SQL의 데이터 정렬 개념에 대한 자세한 내용은 [COLLATE&#40;Transact-SQL&#41;](/sql/t-sql/statements/collations)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="65f6a-158">For more information about the SQL concept of collations, see [COLLATE &#40;Transact-SQL&#41;](/sql/t-sql/statements/collations).</span></span> <span data-ttu-id="65f6a-159">데이터 정렬 지정자 및 Windows 데이터 정렬 이름의 비교 스타일에 대한 자세한 내용은 [Windows 데이터 정렬 이름&#40;Transact-SQL&#41;](/sql/t-sql/statements/windows-collation-name-transact-sql)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="65f6a-159">For information about the collation designators and the comparison styles for Windows collation names, see [Windows Collation Name &#40;Transact-SQL&#41;](/sql/t-sql/statements/windows-collation-name-transact-sql).</span></span> <span data-ttu-id="65f6a-160">[SQL Server 데이터 정렬 이름&#40;Transact-SQL&#41;](/sql/t-sql/statements/sql-server-collation-name-transact-sql) 항목에서는 Windows 데이터 정렬 이름을 SQL에 사용되는 이름에 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-160">The topic, [SQL Server Collation Name &#40;Transact-SQL&#41;](/sql/t-sql/statements/sql-server-collation-name-transact-sql), maps the Windows collation names to the names used for SQL.</span></span>  
  
 <span data-ttu-id="65f6a-161">테이블 형식 model 데이터베이스를 만든 후 모델의 모든 새 개체는 데이터베이스 특성에서 언어 및 데이터 정렬 특성을 상속합니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-161">Once your tabular model database has been created, all new objects in the model will inherit the language and collation attributes from the database attributes.</span></span> <span data-ttu-id="65f6a-162">이는 모든 개체에 대해 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-162">This is true for all objects.</span></span> <span data-ttu-id="65f6a-163">상속 경로는 개체에서 시작되어, 부모에서 상속할 언어 및 데이터 정렬 특성을 확인하고, 특성을 찾을 수 없는 경우 최상위 수준까지 계속 진행하여 데이터베이스 수준에서 언어 및 데이터 정렬 특성을 찾는 방식으로 진행됩니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-163">The inheritance path begins at the object, looks at the parent for any language and collation attributes to inherit, and if none are found, continues to the top and finds the language and collation attributes at the database level.</span></span> <span data-ttu-id="65f6a-164">즉, 개체의 언어 및 데이터 정렬 특성을 지정하지 않을 경우 기본적으로 개체는 가장 가까운 부모의 특성을 상속합니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-164">In other words, if you do not specify the language and collation attributes for an object, by default, the object inherits the attributes of its closest parent.</span></span>  
  
 <span data-ttu-id="65f6a-165">열의 경우 생성 시 다음 규칙에 따라 언어 및 데이터 정렬 특성이 상속됩니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-165">For columns, the language and collation attributes are inherited at creation, according to the following rules:</span></span>  
  
1.  <span data-ttu-id="65f6a-166">부모 차원 개체에서 언어 및 데이터 정렬 특성이 검색됩니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-166">The parent dimension object is searched for language and collation attributes.</span></span> <span data-ttu-id="65f6a-167">두 값이 모두 있으면 두 값이 열 특성에 복사되고, 한 값만 있으면 다른 값은 기존 값에서 유추되어 두 값이 모두 할당됩니다. 두 값이 모두 없는 경우에는 다음 단계로 진행합니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-167">If both values exist, they are copied to the column attributes; if only one exists, the other is inferred from the existing one and both are assigned; if none exist, move to next step.</span></span>  
  
2.  <span data-ttu-id="65f6a-168">1단계에 설명된 차원에 대한 프로세스와 동일한 프로세스를 사용하여 데이터베이스 개체가 검색됩니다. 특성을 찾지 못하면 다음 단계로 진행합니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-168">The database object is searched using the same process described in Step 1 for dimensions; if no attributes are found, move to the next step.</span></span>  
  
3.  <span data-ttu-id="65f6a-169">1단계에 설명된 차원에 대한 프로세스와 동일한 프로세스를 사용하여 서버 개체가 검색됩니다. 특성을 찾지 못하면 열에서는 Windows 언어 식별자를 사용하고 해당 값에서 데이터 정렬 특성을 유추합니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-169">The server object is searched using the same process described in Step 1 for dimensions; if no attributes are found, the column uses the Windows language identifier and infers the collation attribute from that value.</span></span>  
  
 <span data-ttu-id="65f6a-170">일반적으로 원본 데이터베이스의 언어 식별자 및 데이터 정렬 순서는 테이블 형식 모델 열에서 값이 저장되는 방식에 거의 영향을 주지 않는다는 점을 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-170">It is important to note that typically the language identifier and collation order in the source database has little to no effect on how values are stored in the tabular model column.</span></span> <span data-ttu-id="65f6a-171">원본 데이터베이스에서 요청된 값을 변환하거나 필터링하는 경우는 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="65f6a-171">The exception is if the source database transforms or filters the requested values.</span></span>  
  
  
