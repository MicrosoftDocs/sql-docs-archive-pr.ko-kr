---
title: 관계 (SSAS 테이블 형식) | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: analysis-services
ms.topic: conceptual
ms.assetid: 21e0144a-3cfd-4bc7-87ff-bb7d1800ed2f
author: minewiskan
ms.author: owend
ms.openlocfilehash: eac90102e4595bf19cbeb7eefc22e975ecf53610
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87738823"
---
# <a name="relationships-ssas-tabular"></a><span data-ttu-id="9fb12-102">관계(SSAS 테이블 형식)</span><span class="sxs-lookup"><span data-stu-id="9fb12-102">Relationships (SSAS Tabular)</span></span>
  <span data-ttu-id="9fb12-103">테이블 형식 모델에서 관계는 두 데이터 테이블 간의 연결입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-103">In tabular models, a relationship is a connection between two tables of data.</span></span> <span data-ttu-id="9fb12-104">관계는 두 테이블의 데이터 간에 상관 관계를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-104">The relationship establishes how the data in the two tables should be correlated.</span></span> <span data-ttu-id="9fb12-105">예를 들어 Customers 테이블과 Orders 테이블을 연결하여 각 주문에 연결된 고객 이름을 표시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-105">For example, a Customers table and an Orders table can be related in order to show the customer name that is associated with each order.</span></span>  
  
 <span data-ttu-id="9fb12-106">테이블 가져오기 마법사를 사용하여 동일한 데이터 원본에서 가져오기를 수행할 경우 가져오기로 선택한 테이블(데이터 원본에서)에 이미 있는 관계가 모델에 다시 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-106">When using the Table Import Wizard to import from the same data source, relationships that already exist in tables (at the data source) that you choose to import will be re-created in the model.</span></span> <span data-ttu-id="9fb12-107">다이어그램 뷰의 모델 디자이너 또는 관계 관리 대화 상자를 사용하여 자동으로 검색된 관계와 다시 만들어진 관계를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-107">You can view relationships that were detected and re-created automatically by using the model designer in Diagram View or by using the Manage Relationships dialog box.</span></span> <span data-ttu-id="9fb12-108">또한 다이어그램 뷰의 모델 디자이너나 관계 만들기 또는 관계 관리 대화 상자를 사용하여 수동으로 테이블 간에 새로운 관계를 만들 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-108">You can also create new relationships between tables manually by using the model designer in Diagram View or by using the Create Relationship or Manage Relationships dialog box.</span></span>  
  
 <span data-ttu-id="9fb12-109">가져오는 동안 자동으로 만들어졌거나 수동으로 만든 테이블 간에 관계를 정의하면 관련 열을 사용하여 데이터를 필터링하고 관련 테이블의 값을 조회할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-109">After relationships between tables have been defined, either automatically during import or created manually, you will be able to filter data by using related columns and look up values in related tables.</span></span>  
  
> [!TIP]  
>  <span data-ttu-id="9fb12-110">모델에 여러 관계가 포함된 경우 다이어그램 뷰를 사용하면 테이블 간의 새 관계를 만들고 시각화하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-110">If your model contains many relationships, Diagram View can better help you better visualize and create new relationships between tables.</span></span>  
  
 <span data-ttu-id="9fb12-111">이 항목의 섹션:</span><span class="sxs-lookup"><span data-stu-id="9fb12-111">Sections in this topic:</span></span>  
  
-   [<span data-ttu-id="9fb12-112">이점</span><span class="sxs-lookup"><span data-stu-id="9fb12-112">Benefits</span></span>](#what)  
  
-   [<span data-ttu-id="9fb12-113">관계에 대 한 요구 사항</span><span class="sxs-lookup"><span data-stu-id="9fb12-113">Requirements for Relationships</span></span>](#requirements)  
  
-   [<span data-ttu-id="9fb12-114">관계 유추</span><span class="sxs-lookup"><span data-stu-id="9fb12-114">Inference of Relationships</span></span>](#detection)  
  
-   [<span data-ttu-id="9fb12-115">데이터를 가져올 때 관계 검색</span><span class="sxs-lookup"><span data-stu-id="9fb12-115">Detection of Relationships When Importing Data</span></span>](#bkmk_detection)  
  
-   [<span data-ttu-id="9fb12-116">수동으로 관계 만들기</span><span class="sxs-lookup"><span data-stu-id="9fb12-116">Manually Create Relationships</span></span>](#bkmk_manually_create)  
  
-   [<span data-ttu-id="9fb12-117">중복 값 및 기타 오류</span><span class="sxs-lookup"><span data-stu-id="9fb12-117">Duplicate Values and Other Errors</span></span>](#bkmk_dupl_errors)  
  
-   [<span data-ttu-id="9fb12-118">관련 작업</span><span class="sxs-lookup"><span data-stu-id="9fb12-118">Related Tasks</span></span>](#bkmk_related_tasks)  
  
##  <a name="benefits"></a><a name="what"></a> <span data-ttu-id="9fb12-119">이점</span><span class="sxs-lookup"><span data-stu-id="9fb12-119">Benefits</span></span>  
 <span data-ttu-id="9fb12-120">관계는 각 테이블에 있는 하나 이상의 열에 기반을 둔 두 데이터 테이블 간의 연결입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-120">A relationship is a connection between two tables of data, based on one or more columns in each table.</span></span> <span data-ttu-id="9fb12-121">관계가 어떤 점에서 유용한지 궁금하다면 여러분이 기업에서 고객 주문 데이터를 추적하는 업무를 담당하고 있다고 가정해 보십시오.</span><span class="sxs-lookup"><span data-stu-id="9fb12-121">To see why relationships are useful, imagine that you track data for customer orders in your business.</span></span> <span data-ttu-id="9fb12-122">관계를 사용하면 다음과 같은 구조를 지닌 단일 테이블에서 모든 데이터를 추적할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-122">You could track all the data in a single table that has a structure like the following:</span></span>  
  
|<span data-ttu-id="9fb12-123">CustomerID</span><span class="sxs-lookup"><span data-stu-id="9fb12-123">CustomerID</span></span>|<span data-ttu-id="9fb12-124">이름</span><span class="sxs-lookup"><span data-stu-id="9fb12-124">Name</span></span>|<span data-ttu-id="9fb12-125">EMail</span><span class="sxs-lookup"><span data-stu-id="9fb12-125">EMail</span></span>|<span data-ttu-id="9fb12-126">DiscountRate</span><span class="sxs-lookup"><span data-stu-id="9fb12-126">DiscountRate</span></span>|<span data-ttu-id="9fb12-127">OrderID</span><span class="sxs-lookup"><span data-stu-id="9fb12-127">OrderID</span></span>|<span data-ttu-id="9fb12-128">OrderDate</span><span class="sxs-lookup"><span data-stu-id="9fb12-128">OrderDate</span></span>|<span data-ttu-id="9fb12-129">제품</span><span class="sxs-lookup"><span data-stu-id="9fb12-129">Product</span></span>|<span data-ttu-id="9fb12-130">수량</span><span class="sxs-lookup"><span data-stu-id="9fb12-130">Quantity</span></span>|  
|----------------|----------|-----------|------------------|-------------|---------------|-------------|--------------|  
|<span data-ttu-id="9fb12-131">1</span><span class="sxs-lookup"><span data-stu-id="9fb12-131">1</span></span>|<span data-ttu-id="9fb12-132">Ashton</span><span class="sxs-lookup"><span data-stu-id="9fb12-132">Ashton</span></span>|chris.ashton@contoso.com|<span data-ttu-id="9fb12-133">.05</span><span class="sxs-lookup"><span data-stu-id="9fb12-133">.05</span></span>|<span data-ttu-id="9fb12-134">256</span><span class="sxs-lookup"><span data-stu-id="9fb12-134">256</span></span>|<span data-ttu-id="9fb12-135">2010-01-07</span><span class="sxs-lookup"><span data-stu-id="9fb12-135">2010-01-07</span></span>|<span data-ttu-id="9fb12-136">Compact Digital</span><span class="sxs-lookup"><span data-stu-id="9fb12-136">Compact Digital</span></span>|<span data-ttu-id="9fb12-137">11</span><span class="sxs-lookup"><span data-stu-id="9fb12-137">11</span></span>|  
|<span data-ttu-id="9fb12-138">1</span><span class="sxs-lookup"><span data-stu-id="9fb12-138">1</span></span>|<span data-ttu-id="9fb12-139">Ashton</span><span class="sxs-lookup"><span data-stu-id="9fb12-139">Ashton</span></span>|chris.ashton@contoso.com|<span data-ttu-id="9fb12-140">.05</span><span class="sxs-lookup"><span data-stu-id="9fb12-140">.05</span></span>|<span data-ttu-id="9fb12-141">255</span><span class="sxs-lookup"><span data-stu-id="9fb12-141">255</span></span>|<span data-ttu-id="9fb12-142">2010-01-03</span><span class="sxs-lookup"><span data-stu-id="9fb12-142">2010-01-03</span></span>|<span data-ttu-id="9fb12-143">SLR Camera</span><span class="sxs-lookup"><span data-stu-id="9fb12-143">SLR Camera</span></span>|<span data-ttu-id="9fb12-144">15</span><span class="sxs-lookup"><span data-stu-id="9fb12-144">15</span></span>|  
|<span data-ttu-id="9fb12-145">2</span><span class="sxs-lookup"><span data-stu-id="9fb12-145">2</span></span>|<span data-ttu-id="9fb12-146">Jaworski</span><span class="sxs-lookup"><span data-stu-id="9fb12-146">Jaworski</span></span>|michal.jaworski@contoso.com|<span data-ttu-id="9fb12-147">.10</span><span class="sxs-lookup"><span data-stu-id="9fb12-147">.10</span></span>|<span data-ttu-id="9fb12-148">254</span><span class="sxs-lookup"><span data-stu-id="9fb12-148">254</span></span>|<span data-ttu-id="9fb12-149">2010-01-03</span><span class="sxs-lookup"><span data-stu-id="9fb12-149">2010-01-03</span></span>|<span data-ttu-id="9fb12-150">Budget Movie-Maker</span><span class="sxs-lookup"><span data-stu-id="9fb12-150">Budget Movie-Maker</span></span>|<span data-ttu-id="9fb12-151">27</span><span class="sxs-lookup"><span data-stu-id="9fb12-151">27</span></span>|  
  
 <span data-ttu-id="9fb12-152">이 접근 방법도 나쁘지 않지만 이 경우 각 주문에 대해 고객의 전자 메일 주소와 같은 중복 데이터가 다량 저장될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-152">This approach can work, but it involves storing a lot of redundant data, such as the customer e-mail address for every order.</span></span> <span data-ttu-id="9fb12-153">스토리지 비용은 저렴하지만 전자 메일 주소가 변경될 경우 해당 고객에 대한 모든 행을 업데이트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-153">Storage is cheap, but you have to make sure you update every row for that customer if the e-mail address changes.</span></span> <span data-ttu-id="9fb12-154">데이터를 여러 테이블로 분할하고 해당 테이블 간에 관계를 정의하면 이러한 문제를 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-154">One solution to this problem is to split the data into multiple tables and define relationships between those tables.</span></span> <span data-ttu-id="9fb12-155">이것이 바로 *와 같은* 관계형 데이터베이스 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]에서 사용하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-155">This is the approach used in *relational databases* like [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="9fb12-156">예를 들어 모델로 가져온 데이터베이스에서 다음과 같은 세 개의 관련 테이블을 사용하여 주문 데이터를 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-156">For example, a database that you import into a model might represent order data by using three related tables:</span></span>  
  
### <a name="customers"></a><span data-ttu-id="9fb12-157">고객</span><span class="sxs-lookup"><span data-stu-id="9fb12-157">Customers</span></span>  
  
|<span data-ttu-id="9fb12-158">[CustomerID]</span><span class="sxs-lookup"><span data-stu-id="9fb12-158">[CustomerID]</span></span>|<span data-ttu-id="9fb12-159">속성</span><span class="sxs-lookup"><span data-stu-id="9fb12-159">Name</span></span>|<span data-ttu-id="9fb12-160">Email</span><span class="sxs-lookup"><span data-stu-id="9fb12-160">Email</span></span>|  
|--------------------|----------|-----------|  
|<span data-ttu-id="9fb12-161">1</span><span class="sxs-lookup"><span data-stu-id="9fb12-161">1</span></span>|<span data-ttu-id="9fb12-162">Ashton</span><span class="sxs-lookup"><span data-stu-id="9fb12-162">Ashton</span></span>|chris.ashton@contoso.com|  
|<span data-ttu-id="9fb12-163">2</span><span class="sxs-lookup"><span data-stu-id="9fb12-163">2</span></span>|<span data-ttu-id="9fb12-164">Jaworski</span><span class="sxs-lookup"><span data-stu-id="9fb12-164">Jaworski</span></span>|michal.jaworski@contoso.com|  
  
### <a name="customerdiscounts"></a><span data-ttu-id="9fb12-165">CustomerDiscounts</span><span class="sxs-lookup"><span data-stu-id="9fb12-165">CustomerDiscounts</span></span>  
  
|<span data-ttu-id="9fb12-166">[CustomerID]</span><span class="sxs-lookup"><span data-stu-id="9fb12-166">[CustomerID]</span></span>|<span data-ttu-id="9fb12-167">DiscountRate</span><span class="sxs-lookup"><span data-stu-id="9fb12-167">DiscountRate</span></span>|  
|--------------------|------------------|  
|<span data-ttu-id="9fb12-168">1</span><span class="sxs-lookup"><span data-stu-id="9fb12-168">1</span></span>|<span data-ttu-id="9fb12-169">.05</span><span class="sxs-lookup"><span data-stu-id="9fb12-169">.05</span></span>|  
|<span data-ttu-id="9fb12-170">2</span><span class="sxs-lookup"><span data-stu-id="9fb12-170">2</span></span>|<span data-ttu-id="9fb12-171">.10</span><span class="sxs-lookup"><span data-stu-id="9fb12-171">.10</span></span>|  
  
### <a name="orders"></a><span data-ttu-id="9fb12-172">Orders</span><span class="sxs-lookup"><span data-stu-id="9fb12-172">Orders</span></span>  
  
|<span data-ttu-id="9fb12-173">[CustomerID]</span><span class="sxs-lookup"><span data-stu-id="9fb12-173">[CustomerID]</span></span>|<span data-ttu-id="9fb12-174">OrderID</span><span class="sxs-lookup"><span data-stu-id="9fb12-174">OrderID</span></span>|<span data-ttu-id="9fb12-175">OrderDate</span><span class="sxs-lookup"><span data-stu-id="9fb12-175">OrderDate</span></span>|<span data-ttu-id="9fb12-176">제품</span><span class="sxs-lookup"><span data-stu-id="9fb12-176">Product</span></span>|<span data-ttu-id="9fb12-177">수량</span><span class="sxs-lookup"><span data-stu-id="9fb12-177">Quantity</span></span>|  
|--------------------|-------------|---------------|-------------|--------------|  
|<span data-ttu-id="9fb12-178">1</span><span class="sxs-lookup"><span data-stu-id="9fb12-178">1</span></span>|<span data-ttu-id="9fb12-179">256</span><span class="sxs-lookup"><span data-stu-id="9fb12-179">256</span></span>|<span data-ttu-id="9fb12-180">2010-01-07</span><span class="sxs-lookup"><span data-stu-id="9fb12-180">2010-01-07</span></span>|<span data-ttu-id="9fb12-181">Compact Digital</span><span class="sxs-lookup"><span data-stu-id="9fb12-181">Compact Digital</span></span>|<span data-ttu-id="9fb12-182">11</span><span class="sxs-lookup"><span data-stu-id="9fb12-182">11</span></span>|  
|<span data-ttu-id="9fb12-183">1</span><span class="sxs-lookup"><span data-stu-id="9fb12-183">1</span></span>|<span data-ttu-id="9fb12-184">255</span><span class="sxs-lookup"><span data-stu-id="9fb12-184">255</span></span>|<span data-ttu-id="9fb12-185">2010-01-03</span><span class="sxs-lookup"><span data-stu-id="9fb12-185">2010-01-03</span></span>|<span data-ttu-id="9fb12-186">SLR Camera</span><span class="sxs-lookup"><span data-stu-id="9fb12-186">SLR Camera</span></span>|<span data-ttu-id="9fb12-187">15</span><span class="sxs-lookup"><span data-stu-id="9fb12-187">15</span></span>|  
|<span data-ttu-id="9fb12-188">2</span><span class="sxs-lookup"><span data-stu-id="9fb12-188">2</span></span>|<span data-ttu-id="9fb12-189">254</span><span class="sxs-lookup"><span data-stu-id="9fb12-189">254</span></span>|<span data-ttu-id="9fb12-190">2010-01-03</span><span class="sxs-lookup"><span data-stu-id="9fb12-190">2010-01-03</span></span>|<span data-ttu-id="9fb12-191">Budget Movie-Maker</span><span class="sxs-lookup"><span data-stu-id="9fb12-191">Budget Movie-Maker</span></span>|<span data-ttu-id="9fb12-192">27</span><span class="sxs-lookup"><span data-stu-id="9fb12-192">27</span></span>|  
  
 <span data-ttu-id="9fb12-193">이러한 테이블을 동일한 데이터베이스에서 가져오는 경우, 테이블 가져오기 마법사에서는 [대괄호] 안에 있는 열을 기준으로 테이블 간의 관계를 검색하여 모델 디자이너에서 이러한 관계를 재현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-193">If you import these tables from the same database, the Table Import Wizard can detect the relationships between the tables based on the columns that are in [brackets], and can reproduce these relationships in the model designer.</span></span> <span data-ttu-id="9fb12-194">자세한 내용은 이 항목의 [관계 자동 검색 및 유추](#detection) 를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="9fb12-194">For more information, see [Automatic Detection and Inference of Relationships](#detection) in this topic.</span></span> <span data-ttu-id="9fb12-195">테이블을 여러 원본에서 가져오는 경우 [두 테이블 간에 관계 만들기&#40;SSAS 테이블 형식&#41;](create-a-relationship-between-two-tables-ssas-tabular.md)에서 사용하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-195">If you import tables from multiple sources, you can manually create relationships as described in [Create a Relationship Between Two Tables &#40;SSAS Tabular&#41;](create-a-relationship-between-two-tables-ssas-tabular.md).</span></span>  
  
### <a name="columns-and-keys"></a><span data-ttu-id="9fb12-196">열 및 키</span><span class="sxs-lookup"><span data-stu-id="9fb12-196">Columns and Keys</span></span>  
 <span data-ttu-id="9fb12-197">관계는 동일한 데이터가 포함된 각 테이블의 열에 기반을 둡니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-197">Relationships are based on columns in each table that contain the same data.</span></span> <span data-ttu-id="9fb12-198">예를 들어 Customers 테이블과 Orders 테이블은 둘 모두 고객 ID가 저장된 열을 포함하기 때문에 서로 관련시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-198">For example, the Customers and Orders tables can be related to each other because they both contain a column that stores a customer ID.</span></span> <span data-ttu-id="9fb12-199">이 항목의 예에서는 열 이름이 같지만 반드시 같아야 할 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-199">In the example, the column names are the same, but this is not a requirement.</span></span> <span data-ttu-id="9fb12-200">한 열은 이름이 CustomerID이고 다른 열은 이름이 CustomerNumber일 수 있습니다. Orders 테이블의 모든 행에 Customers 테이블에 저장되어 있는 ID만 있으면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-200">One could be CustomerID and another CustomerNumber, as long as all of the rows in the Orders table contain an ID that is also stored in the Customers table.</span></span>  
  
 <span data-ttu-id="9fb12-201">관계형 데이터베이스에는 일반적으로 특수 속성을 가진 열로 나타나는 여러 가지 유형의 *키*가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-201">In a relational database, there are several types of *keys*, which are typically just columns with special properties.</span></span> <span data-ttu-id="9fb12-202">관계형 데이터베이스에는 다음 네 가지 유형의 키를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-202">The following four types of keys can be used in relational databases:</span></span>  
  
-   <span data-ttu-id="9fb12-203">*기본 키*: 테이블의 행을 고유하게 식별합니다(예: Customers 테이블의 CustomerID).</span><span class="sxs-lookup"><span data-stu-id="9fb12-203">*Primary key*: uniquely identifies a row in a table, such as CustomerID in the Customers table.</span></span>  
  
-   <span data-ttu-id="9fb12-204">*대체 키* (또는 *후보 키*): 기본 키가 아닌 고유 열입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-204">*Alternate key* (or *candidate key*): a column other than the primary key that is unique.</span></span> <span data-ttu-id="9fb12-205">예를 들어 Employees 테이블에 직원 ID와 주민 등록 번호가 저장될 수 있으며 둘 모두 고유합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-205">For example, an Employees table might store an employee ID and a social security number, both of which are unique.</span></span>  
  
-   <span data-ttu-id="9fb12-206">*외래 키*: 다른 테이블의 고유 열을 참조하는 열입니다(예: Customers 테이블의 CustomerID를 참조하는 Orders 테이블의 CustomerID).</span><span class="sxs-lookup"><span data-stu-id="9fb12-206">*Foreign key*: a column that refers to a unique column in another table, such as CustomerID in the Orders table, which refers to CustomerID in the Customers table.</span></span>  
  
-   <span data-ttu-id="9fb12-207">*복합 키*: 두 개 이상의 열로 구성된 키입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-207">*Composite key*: a key that is composed of more than one column.</span></span> <span data-ttu-id="9fb12-208">테이블 형식 모델에서는 복합 키가 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-208">Composite keys are not supported in tabular models.</span></span> <span data-ttu-id="9fb12-209">자세한 내용은 이 항목의 "복합 키 및 조회 열"을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="9fb12-209">For more information, see "Composite Keys and Lookup Columns" in this topic.</span></span>  
  
 <span data-ttu-id="9fb12-210">테이블 형식 모델에서는 기본 키 또는 대체 키를 *관련 조회 열*또는 그냥 *조회 열*이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-210">In tabular models, the primary key or alternate key is referred to as the *related lookup column*, or just *lookup column*.</span></span> <span data-ttu-id="9fb12-211">테이블에 기본 키와 대체 키가 둘 다 있으면 둘 중 하나를 조회 열로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-211">If a table has both a primary and alternate key, you can use either as the lookup column.</span></span> <span data-ttu-id="9fb12-212">외래 키는 *원본 열* 또는 그냥 *열*이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-212">The foreign key is referred to as the *source column* or just *column*.</span></span> <span data-ttu-id="9fb12-213">이 항목의 예에서는 Orders 테이블의 CustomerID(열)와 Customers 테이블의 CustomerID(조회 열) 간에 관계가 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-213">In our example, a relationship would be defined between CustomerID in the Orders table (the column) and CustomerID (the lookup column) in the Customers table.</span></span> <span data-ttu-id="9fb12-214">관계형 데이터베이스에서 데이터를 가져오는 경우 기본적으로 모델 디자이너에서는 한 테이블에서 외래 키를 선택하고 다른 테이블에서 해당되는 기본 키를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-214">If you import data from a relational database, by default the model designer chooses the foreign key from one table and the corresponding primary key from the other table.</span></span> <span data-ttu-id="9fb12-215">그러나 조회 열에 대한 고유 값을 가지는 열이면 모두 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-215">However, you can use any column that has unique values for the lookup column.</span></span>  
  
### <a name="types-of-relationships"></a><span data-ttu-id="9fb12-216">관계 유형</span><span class="sxs-lookup"><span data-stu-id="9fb12-216">Types of Relationships</span></span>  
 <span data-ttu-id="9fb12-217">Customers와 Orders 간의 관계는 *일 대 다 관계*입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-217">The relationship between Customers and Orders is a *one-to-many relationship*.</span></span> <span data-ttu-id="9fb12-218">모든 고객은 여러 개의 주문을 가질 수 있지만 각 주문은 여러 고객을 가질 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-218">Every customer can have multiple orders, but an order cannot have multiple customers.</span></span> <span data-ttu-id="9fb12-219">관계의 유형에는 *일 대 일* 과 *다 대 다*가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-219">The other types of relationships are *one-to-one* and *many-to-many*.</span></span> <span data-ttu-id="9fb12-220">각 고객에 대해 단일 할인율을 정의하는 CustomerDiscounts 테이블은 Customers 테이블과 일 대 일 관계에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-220">The CustomerDiscounts table, which defines a single discount rate for each customer, is in a one-to-one relationship with the Customers table.</span></span> <span data-ttu-id="9fb12-221">다 대 다 관계의 예로는 Products 및 Customers 간의 직접적인 관계를 들 수 있습니다. 이 관계에서 고객은 여러 개의 제품을 구입할 수 있고 한 제품을 여러 명의 고객이 구입할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-221">An example of a many-to-many relationship is a direct relationship between Products and Customers, in which a customer can buy many products and the same product can be bought by many customers.</span></span> <span data-ttu-id="9fb12-222">모델 디자이너는 사용자 인터페이스에서 다 대 다 관계를 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-222">The model designer does not support many-to-many relationships in the user interface.</span></span> <span data-ttu-id="9fb12-223">자세한 내용은 이 항목에 있는 "[다 대 다 관계](#bkmk_many_to_many)"를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="9fb12-223">For more information, see "[Many-to-Many Relationships](#bkmk_many_to_many)" in this topic.</span></span>  
  
 <span data-ttu-id="9fb12-224">다음 표에서는 세 테이블 간의 관계를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-224">The following table shows the relationships between the three tables:</span></span>  
  
|<span data-ttu-id="9fb12-225">관계</span><span class="sxs-lookup"><span data-stu-id="9fb12-225">Relationship</span></span>|<span data-ttu-id="9fb12-226">Type</span><span class="sxs-lookup"><span data-stu-id="9fb12-226">Type</span></span>|<span data-ttu-id="9fb12-227">조회 열</span><span class="sxs-lookup"><span data-stu-id="9fb12-227">Lookup Column</span></span>|<span data-ttu-id="9fb12-228">열</span><span class="sxs-lookup"><span data-stu-id="9fb12-228">Column</span></span>|  
|------------------|----------|-------------------|------------|  
|<span data-ttu-id="9fb12-229">Customers-CustomerDiscounts</span><span class="sxs-lookup"><span data-stu-id="9fb12-229">Customers-CustomerDiscounts</span></span>|<span data-ttu-id="9fb12-230">일 대 일</span><span class="sxs-lookup"><span data-stu-id="9fb12-230">one-to-one</span></span>|<span data-ttu-id="9fb12-231">Customers.CustomerID</span><span class="sxs-lookup"><span data-stu-id="9fb12-231">Customers.CustomerID</span></span>|<span data-ttu-id="9fb12-232">CustomerDiscounts.CustomerID</span><span class="sxs-lookup"><span data-stu-id="9fb12-232">CustomerDiscounts.CustomerID</span></span>|  
|<span data-ttu-id="9fb12-233">Customers-Orders</span><span class="sxs-lookup"><span data-stu-id="9fb12-233">Customers-Orders</span></span>|<span data-ttu-id="9fb12-234">일 대 다</span><span class="sxs-lookup"><span data-stu-id="9fb12-234">one-to-many</span></span>|<span data-ttu-id="9fb12-235">Customers.CustomerID</span><span class="sxs-lookup"><span data-stu-id="9fb12-235">Customers.CustomerID</span></span>|<span data-ttu-id="9fb12-236">Orders.CustomerID</span><span class="sxs-lookup"><span data-stu-id="9fb12-236">Orders.CustomerID</span></span>|  
  
### <a name="relationships-and-performance"></a><span data-ttu-id="9fb12-237">관계와 성능</span><span class="sxs-lookup"><span data-stu-id="9fb12-237">Relationships and Performance</span></span>  
 <span data-ttu-id="9fb12-238">관계를 만든 후에 모델 디자이너에서는 일반적으로 새로 만든 관계의 테이블에 있는 열을 사용하는 모든 수식을 다시 계산해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-238">After any relationship has been created, the model designer typically must recalculate any formulas that use columns from tables in the newly created relationship.</span></span> <span data-ttu-id="9fb12-239">데이터의 양이 많거나 관계가 복잡하면 처리에 시간이 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-239">Processing can take some time depending on the amount of data and the complexity of the relationships.</span></span>  
  
##  <a name="requirements-for-relationships"></a><a name="requirements"></a> <span data-ttu-id="9fb12-240">관계를 정의하기 위한 요구 사항</span><span class="sxs-lookup"><span data-stu-id="9fb12-240">Requirements for Relationships</span></span>  
 <span data-ttu-id="9fb12-241">모델 디자이너에서 관계를 만들 때 따라야 할 몇 가지 요구 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-241">The model designer has several requirements that must be followed when creating relationships:</span></span>  
  
### <a name="single-active-relationship-between-tables"></a><span data-ttu-id="9fb12-242">테이블 간 단일 활성 관계</span><span class="sxs-lookup"><span data-stu-id="9fb12-242">Single Active Relationship between Tables</span></span>  
 <span data-ttu-id="9fb12-243">관계가 여러 개 있으면 테이블 간의 종속성이 모호해질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-243">Multiple relationships could result in ambiguous dependencies between tables.</span></span> <span data-ttu-id="9fb12-244">정확한 계산을 만들려면 한 테이블에서 다음 테이블로 연결되는 단일 경로가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-244">To create accurate calculations, you need a single path from one table to the next.</span></span> <span data-ttu-id="9fb12-245">따라서 각 테이블 쌍 사이에는 하나의 활성 관계만 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-245">Therefore, there can be only one active relationship between each pair of tables.</span></span> <span data-ttu-id="9fb12-246">예를 들어 AdventureWorks DW 2012에서 DimDate 테이블에는 FactInternetSales 테이블의 세 가지 다른 열인 OrderDate, DueDate 및 ShipDate와 관련된 DateKey 열이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-246">For example, in AdventureWorks DW 2012, the table, DimDate, contains a column, DateKey, that is related to three different columns in the table, FactInternetSales: OrderDate, DueDate, and ShipDate.</span></span> <span data-ttu-id="9fb12-247">이러한 테이블을 가져오려는 경우 첫 번째 관계는 성공적으로 만들어지지만 같은 열에 적용되는 연속된 관계에 대해 다음 오류가 나타나게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-247">If you attempt to import these tables, the first relationship is created successfully, but you will receive the following error on successive relationships that involve the same column:</span></span>  
  
 <span data-ttu-id="9fb12-248">\*관계: 테이블 [열 1]-> 테이블 [열 2]-상태: 오류-이유: 테이블과 간의 관계를 만들 수 없습니다 \<table 1> . \<table 2></span><span class="sxs-lookup"><span data-stu-id="9fb12-248">\* Relationship: table[column 1]-> table[column 2]   - Status: error   - Reason: A relationship cannot be created between tables \<table 1> and \<table 2>.</span></span> <span data-ttu-id="9fb12-249">두 테이블 간에는 하나의 직접 또는 간접 관계만 존재합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-249">Only one direct or indirect relationship can exist between two tables.</span></span>  
  
 <span data-ttu-id="9fb12-250">테이블이 두 개 있고 이 테이블 간에 여러 관계가 있는 경우 조회 열을 포함하는 테이블의 여러 복사본을 가져와서 각 테이블 쌍 간에 하나의 관계를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-250">If you have two tables and multiple relationships between them, then you will need to import multiple copies of the table that contains the lookup column, and create one relationship between each pair of tables.</span></span>  
  
 <span data-ttu-id="9fb12-251">테이블 간에 많은 비활성 관계가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-251">There can be many inactive relationships between tables.</span></span> <span data-ttu-id="9fb12-252">테이블 사이에서 사용할 경로는 쿼리 시간에 보고하는 클라이언트에 의해 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-252">The path to use between tables is specified by the reporting client at query time.</span></span>  
  
### <a name="one-relationship-for-each-source-column"></a><span data-ttu-id="9fb12-253">각 원본 열에 하나의 관계 사용</span><span class="sxs-lookup"><span data-stu-id="9fb12-253">One Relationship for Each Source Column</span></span>  
 <span data-ttu-id="9fb12-254">원본 열은 여러 관계에 참여할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-254">A source column cannot participate in multiple relationships.</span></span> <span data-ttu-id="9fb12-255">특정 열을 한 관계의 원본 열로 이미 사용했지만 해당 열을 사용하여 다른 테이블의 다른 관련 조회 열에 연결하려는 경우 열의 복사본을 만든 다음 해당 열을 새 관계에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-255">If you have used a column as a source column in one relationship already, but want to use that column to connect to another related lookup column in a different table, you can create a copy of the column, and use that column for the new relationship.</span></span>  
  
 <span data-ttu-id="9fb12-256">계산 열에 DAX 수식을 사용하면 동일한 값을 가진 열의 복사본을 쉽게 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-256">It is easy to create a copy of a column that has the exact same values, by using a DAX formula in a calculated column.</span></span> <span data-ttu-id="9fb12-257">자세한 내용은 [계산 열 만들기&#40;SSAS 테이블 형식&#41;](ssas-calculated-columns-create-a-calculated-column.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9fb12-257">For more information, see [Create a Calculated Column &#40;SSAS Tabular&#41;](ssas-calculated-columns-create-a-calculated-column.md).</span></span>  
  
### <a name="unique-identifier-for-each-table"></a><span data-ttu-id="9fb12-258">각 테이블의 고유 식별자</span><span class="sxs-lookup"><span data-stu-id="9fb12-258">Unique Identifier for Each Table</span></span>  
 <span data-ttu-id="9fb12-259">각 테이블에는 해당 테이블의 각 행을 고유하게 식별하는 단일 열이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-259">Each table must have a single column that uniquely identifies each row in that table.</span></span> <span data-ttu-id="9fb12-260">이 열을 대개 기본 키라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-260">This column is often referred to as the primary key.</span></span>  
  
### <a name="unique-lookup-columns"></a><span data-ttu-id="9fb12-261">고유 조회 열</span><span class="sxs-lookup"><span data-stu-id="9fb12-261">Unique Lookup Columns</span></span>  
 <span data-ttu-id="9fb12-262">조회 열의 데이터 값은 고유해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-262">The data values in the lookup column must be unique.</span></span> <span data-ttu-id="9fb12-263">즉, 열에 중복된 값이 있으면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-263">In other words, the column cannot contain duplicates.</span></span> <span data-ttu-id="9fb12-264">테이블 형식 모델에서 null 및 빈 문자열은 공백과 동일하며 이는 고유 데이터 값입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-264">In Tabular models, nulls and empty strings are equivalent to a blank, which is a distinct data value.</span></span> <span data-ttu-id="9fb12-265">이는 조회 열에 Null 값을 여러 개 포함할 수 없음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-265">This means that you cannot have multiple nulls in the lookup column.</span></span>  
  
### <a name="compatible-data-types"></a><span data-ttu-id="9fb12-266">호환되는 데이터 형식</span><span class="sxs-lookup"><span data-stu-id="9fb12-266">Compatible Data Types</span></span>  
 <span data-ttu-id="9fb12-267">원본 열과 조회 열의 데이터 형식이 호환되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-267">The data types in the source column and lookup column must be compatible.</span></span> <span data-ttu-id="9fb12-268">데이터 형식에 대한 자세한 내용은 [지원되는 데이터 형식&#40;SSAS 테이블 형식&#41;](data-types-supported-ssas-tabular.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9fb12-268">For more information about data types, see [Data Types Supported &#40;SSAS Tabular&#41;](data-types-supported-ssas-tabular.md).</span></span>  
  
### <a name="composite-keys-and-lookup-columns"></a><span data-ttu-id="9fb12-269">복합 키 및 조회 열</span><span class="sxs-lookup"><span data-stu-id="9fb12-269">Composite Keys and Lookup Columns</span></span>  
 <span data-ttu-id="9fb12-270">테이블 형식 모델에서는 복합 키를 사용할 수 없습니다. 즉, 테이블의 각 행을 고유하게 식별하는 열이 항상 하나여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-270">You cannot use composite keys in a tabular model; you must always have one column that uniquely identifies each row in the table.</span></span> <span data-ttu-id="9fb12-271">복합 키를 기반으로 하는 기존 관계를 가진 테이블을 가져오는 경우 테이블 가져오기 마법사는 해당 관계를 테이블 형식 모델에서 만들 수 없으므로 이 관계를 무시합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-271">If you try to import tables that have an existing relationship based on a composite key, the Table Import Wizard will ignore that relationship because it cannot be created in the tabular model.</span></span>  
  
 <span data-ttu-id="9fb12-272">모델 디자이너에서 두 테이블 간의 관계를 만들려고 하고 기본 키 및 외래 키를 정의하는 열이 여러 개 있는 경우 먼저 이들 값을 결합하여 단일 키 열을 만든 후 관계를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-272">If you want to create a relationship between two tables in the model designer, and there are multiple columns defining the primary and foreign keys, you must combine the values to create a single key column before creating the relationship.</span></span> <span data-ttu-id="9fb12-273">이 작업을 데이터를 가져오기 전에 수행하거나 모델 디자이너에서 계산 열을 만들어 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-273">You can do this before you import the data, or you can do this in the model designer by creating a calculated column.</span></span>  
  
###  <a name="many-to-many-relationships"></a><a name="bkmk_many_to_many"></a><span data-ttu-id="9fb12-274">다 대 다 관계</span><span class="sxs-lookup"><span data-stu-id="9fb12-274">Many-to-Many Relationships</span></span>  
 <span data-ttu-id="9fb12-275">테이블 형식 모델에서는 다 대 다 관계를 지원하지 않으므로 모델 디자이너에서 *접합 테이블* 을 추가할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-275">Tabular models do not support many-to-many relationships, and you cannot add *junction tables* in the model designer.</span></span> <span data-ttu-id="9fb12-276">하지만 DAX 함수를 사용하여 다 대 다 관계를 모델링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-276">However, you can use DAX functions to model many-to-many relationships.</span></span>  
  
### <a name="self-joins-and-loops"></a><span data-ttu-id="9fb12-277">자체 조인 및 루프</span><span class="sxs-lookup"><span data-stu-id="9fb12-277">Self-Joins and Loops</span></span>  
 <span data-ttu-id="9fb12-278">자체 조인은 테이블 형식 모델 테이블에서 허용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-278">Self-joins are not permitted in tabular model tables.</span></span> <span data-ttu-id="9fb12-279">자체 조인은 테이블 자체의 재귀적 관계입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-279">A self-join is a recursive relationship between a table and itself.</span></span> <span data-ttu-id="9fb12-280">자체 조인은 주로 부모-자식 계층을 정의하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-280">Self-joins are often used to define parent-child hierarchies.</span></span> <span data-ttu-id="9fb12-281">예를 들어 Employees 테이블을 자체에 조인하여 기업의 관리 체인을 보여 주는 계층을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-281">For example, you could join an Employees table to itself to produce a hierarchy that shows the management chain at a business.</span></span>  
  
 <span data-ttu-id="9fb12-282">모델 디자이너에서는 모델의 관계 사이에 루프를 만들 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-282">The model designer does not allow loops to be created among relationships in a model.</span></span> <span data-ttu-id="9fb12-283">즉, 다음과 같은 관계 집합은 금지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-283">In other words, the following set of relationships is prohibited.</span></span>  
  
 <span data-ttu-id="9fb12-284">테이블 1, 열 a - 테이블 2, 열 f</span><span class="sxs-lookup"><span data-stu-id="9fb12-284">Table 1, column a   to   Table 2, column f</span></span>  
  
 <span data-ttu-id="9fb12-285">테이블 2, 열 f - 테이블 3, 열 n</span><span class="sxs-lookup"><span data-stu-id="9fb12-285">Table 2, column f   to   Table 3, column n</span></span>  
  
 <span data-ttu-id="9fb12-286">테이블 3, 열 n - 테이블 1, 열 a</span><span class="sxs-lookup"><span data-stu-id="9fb12-286">Table 3, column n   to   Table 1, column a</span></span>  
  
 <span data-ttu-id="9fb12-287">루프를 초래하는 관계를 만들려고 하면 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-287">If you try to create a relationship that would result in a loop being created, an error is generated.</span></span>  
  
##  <a name="inference-of-relationships"></a><a name="detection"></a><span data-ttu-id="9fb12-288">관계 유추</span><span class="sxs-lookup"><span data-stu-id="9fb12-288">Inference of Relationships</span></span>  
 <span data-ttu-id="9fb12-289">경우에 따라 테이블 간의 관계가 자동으로 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-289">In some cases, relationships between tables are automatically chained.</span></span> <span data-ttu-id="9fb12-290">예를 들어 아래에서 처음 두 테이블 집합 간에 관계를 만들면 다른 두 테이블 간에 관계가 존재하는 것으로 유추되어 관계가 자동으로 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-290">For example, if you create a relationship between the first two sets of tables below, a relationship is inferred to exist between the other two tables, and a relationship is automatically established.</span></span>  
  
 <span data-ttu-id="9fb12-291">Products와 Category -- 수동으로 관계 생성</span><span class="sxs-lookup"><span data-stu-id="9fb12-291">Products and Category -- created manually</span></span>  
  
 <span data-ttu-id="9fb12-292">Category와 SubCategory -- 수동으로 관계 생성</span><span class="sxs-lookup"><span data-stu-id="9fb12-292">Category and SubCategory -- created manually</span></span>  
  
 <span data-ttu-id="9fb12-293">Products와 SubCategory -- 관계가 유추됨</span><span class="sxs-lookup"><span data-stu-id="9fb12-293">Products and SubCategory -- relationship is inferred</span></span>  
  
 <span data-ttu-id="9fb12-294">관계가 자동으로 연결되려면 위와 같이 관계가 한 방향으로 형성되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-294">In order for relationships to be automatically chained, the relationships must go in one direction, as shown above.</span></span> <span data-ttu-id="9fb12-295">예를 들어 처음에 Sales와 Products 간에 관계를 만들고 Sales와 Customers 간에 관계를 만들었다면 관계는 유추되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-295">If the initial relationships were between, for example, Sales and Products, and Sales and Customers, a relationship is not inferred.</span></span> <span data-ttu-id="9fb12-296">이는 Products와 Customers 간의 관계가 다 대 다 관계이기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-296">This is because the relationship between Products and Customers is a many-to-many relationship.</span></span>  
  
##  <a name="detection-of-relationships-when-importing-data"></a><a name="bkmk_detection"></a> <span data-ttu-id="9fb12-297">데이터를 가져올 때 관계 검색</span><span class="sxs-lookup"><span data-stu-id="9fb12-297">Detection of Relationships When Importing Data</span></span>  
 <span data-ttu-id="9fb12-298">관계형 데이터 원본 테이블에서 가져오는 경우 테이블 가져오기 마법사는 원본 스키마 데이터를 기반으로 원본 테이블에서 기존 관계를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-298">When you import from a relational data source table, the Table Import Wizard detects existing relationships in those source tables based on the source schema data.</span></span> <span data-ttu-id="9fb12-299">관련 테이블을 가져오는 경우 해당 관계가 모델에서 중복됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-299">If related tables are imported, those relationships will be duplicated in the model.</span></span>  
  
##  <a name="manually-create-relationships"></a><a name="bkmk_manually_create"></a> <span data-ttu-id="9fb12-300">수동으로 관계 만들기</span><span class="sxs-lookup"><span data-stu-id="9fb12-300">Manually Create Relationships</span></span>  
 <span data-ttu-id="9fb12-301">단일 관계형 데이터 원본의 테이블 간 대부분의 관계는 자동으로 검색되고 테이블 형식 모델에 만들어지는 데 반해 모델 테이블 간 관계를 수동으로 만들어야 하는 인스턴스도 많습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-301">While most relationships between tables in a single relational data source will be detected automatically, and created in the tabular model, there are also many instances where you must manually create relationships between model tables.</span></span>  
  
 <span data-ttu-id="9fb12-302">모델에 있는 데이터의 원본이 여러 개인 경우 수동으로 관계를 만들어야 할 가능성이 많습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-302">If your model contains data from multiple sources, you will likely have to manually create relationships.</span></span> <span data-ttu-id="9fb12-303">예를 들어 관계형 데이터 원본에서 Customers, CustomerDiscounts 및 Orders 테이블을 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-303">For example, you may import Customers, CustomerDiscounts, and Orders tables from a relational data source.</span></span> <span data-ttu-id="9fb12-304">원본의 이러한 테이블 간에 있는 관계는 자동으로 모델에 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-304">Relationships existing between those tables at the source are automatically created in the model.</span></span> <span data-ttu-id="9fb12-305">그런 다음 다른 원본의 다른 테이블을 추가할 수 있습니다. 예를 들어 icrosoft Excel 통합 문서의 Geography 테이블에서 영역 데이터를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-305">You may then add another table from a different source, for example, you import region data from a Geography table in a Microsoft Excel workbook.</span></span> <span data-ttu-id="9fb12-306">그런 다음 Customers 테이블의 열과 Geography 테이블 간 관계를 수동으로 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-306">You can then manually create a relationship between a column in the Customers table and a column in the Geography table.</span></span>  
  
 <span data-ttu-id="9fb12-307">다이어그램 뷰의 모델 디자이너나 관계 관리 대화 상자를 사용하여 테이블 형식 모델에 관계를 수동으로 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-307">To manually create relationships in a tabular model, you can use the model designer in Diagram View or by using the Manage Relationships dialog box.</span></span> <span data-ttu-id="9fb12-308">다이어그램 뷰는 테이블을 그래픽 형식의 관계도와 함께 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-308">The diagram view displays tables, with relationships between them, in a graphical format.</span></span> <span data-ttu-id="9fb12-309">한 테이블의 열을 클릭한 다음 다른 테이블로 커서를 끌어 테이블 간에 올바른 순서로 쉽게 관계를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-309">You can click a column in one table and drag the cursor to another table to easily create a relationship, in the correct order, between the tables.</span></span> <span data-ttu-id="9fb12-310">관계 관리 대화 상자에는 간단한 테이블 형식으로 테이블 간의 관계가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-310">The Manage Relationships dialog box displays relationships between tables in a simple table format.</span></span> <span data-ttu-id="9fb12-311">수동으로 관계를 만드는 방법에 대한 자세한 내용은 [두 테이블 간에 관계 만들기&#40;SSAS 테이블 형식&#41;](create-a-relationship-between-two-tables-ssas-tabular.md)에서 사용하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-311">To learn how to manually create relationships, see [Create a Relationship Between Two Tables &#40;SSAS Tabular&#41;](create-a-relationship-between-two-tables-ssas-tabular.md).</span></span>  
  
##  <a name="duplicate-values-and-other-errors"></a><a name="bkmk_dupl_errors"></a><span data-ttu-id="9fb12-312">중복 값 및 기타 오류</span><span class="sxs-lookup"><span data-stu-id="9fb12-312">Duplicate Values and Other Errors</span></span>  
 <span data-ttu-id="9fb12-313">관계에 사용할 수 없는 열을 선택하면 열 옆에 빨간색 X가 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-313">If you choose a column that cannot be used in the relationship, a red X appears next to the column.</span></span> <span data-ttu-id="9fb12-314">오류 아이콘 위에 커서를 두면 문제에 대한 자세한 정보를 제공하는 메시지가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-314">You can pause the cursor over the error icon to view a message that provides more information about the problem.</span></span> <span data-ttu-id="9fb12-315">다음과 같은 문제로 인해 선택된 열 간에 관계를 만들지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-315">Problems that can make it impossible to create a relationship between the selected columns include the following:</span></span>  
  
|<span data-ttu-id="9fb12-316">문제 또는 메시지</span><span class="sxs-lookup"><span data-stu-id="9fb12-316">Problem or message</span></span>|<span data-ttu-id="9fb12-317">해결 방법</span><span class="sxs-lookup"><span data-stu-id="9fb12-317">Resolution</span></span>|  
|------------------------|----------------|  
|<span data-ttu-id="9fb12-318">선택한 두 열 모두에 중복되는 값이 들어 있기 때문에 관계를 만들 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-318">The relationship cannot be created because both columns selected contain duplicate values.</span></span>|<span data-ttu-id="9fb12-319">올바른 관계를 만들려면 선택한 한 쌍의 열 중 최소 하나의 열에 고유 값만 들어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-319">To create a valid relationship, at least one column of the pair that you select must contain only unique values.</span></span><br /><br /> <span data-ttu-id="9fb12-320">열을 편집하여 중복을 제거하거나 고유 값이 들어 있는 열이 **관련 조회 열**로 사용되도록 열의 순서를 반대로 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-320">You can either edit the columns to remove duplicates, or you can reverse the order of the columns so that the column that contains the unique values is used as the **Related Lookup Column**.</span></span>|  
|<span data-ttu-id="9fb12-321">열에 null 또는 빈 값이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-321">The column contains a null or empty value.</span></span>|<span data-ttu-id="9fb12-322">null 값이 있으면 데이터 열을 서로 조인할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-322">Data columns cannot be joined to each other on a null value.</span></span> <span data-ttu-id="9fb12-323">모든 행에 대해 관계에서 사용되는 두 열 모두에 값이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-323">For every row, there must be a value in both of the columns that are used in a relationship.</span></span>|  
  
##  <a name="related-tasks"></a><a name="bkmk_related_tasks"></a> <span data-ttu-id="9fb12-324">관련 작업</span><span class="sxs-lookup"><span data-stu-id="9fb12-324">Related Tasks</span></span>  
  
|<span data-ttu-id="9fb12-325">항목</span><span class="sxs-lookup"><span data-stu-id="9fb12-325">Topic</span></span>|<span data-ttu-id="9fb12-326">설명</span><span class="sxs-lookup"><span data-stu-id="9fb12-326">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="9fb12-327">두 테이블 간에 관계 만들기&#40;SSAS 테이블 형식&#41;</span><span class="sxs-lookup"><span data-stu-id="9fb12-327">Create a Relationship Between Two Tables &#40;SSAS Tabular&#41;</span></span>](create-a-relationship-between-two-tables-ssas-tabular.md)|<span data-ttu-id="9fb12-328">두 테이블 간의 관계를 수동으로 만드는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-328">Describes how to manually create a relationship between two tables.</span></span>|  
|[<span data-ttu-id="9fb12-329">관계 삭제&#40;SSAS 테이블 형식&#41;</span><span class="sxs-lookup"><span data-stu-id="9fb12-329">Delete Relationships &#40;SSAS Tabular&#41;</span></span>](relationships-ssas-tabular.md)|<span data-ttu-id="9fb12-330">관계를 삭제하는 방법과 관계를 삭제할 경우에 발생하는 결과를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb12-330">Describes how to delete a relationship and the ramifications of deleting relationships.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="9fb12-331">참고 항목</span><span class="sxs-lookup"><span data-stu-id="9fb12-331">See Also</span></span>  
 <span data-ttu-id="9fb12-332">[SSAS 테이블 형식&#41;&#40;테이블 및 열](tables-and-columns-ssas-tabular.md) </span><span class="sxs-lookup"><span data-stu-id="9fb12-332">[Tables and Columns &#40;SSAS Tabular&#41;](tables-and-columns-ssas-tabular.md) </span></span>  
 [<span data-ttu-id="9fb12-333">데이터 가져오기&#40;SSAS 테이블 형식&#41;</span><span class="sxs-lookup"><span data-stu-id="9fb12-333">Import Data &#40;SSAS Tabular&#41;</span></span>](../import-data-ssas-tabular.md)  
  
  
